Reading prompt from stdin...
OpenAI Codex v0.72.0 (research preview)
--------
[1mworkdir:[0m /Users/ronaldeddings/ClaudeCodeTS
[1mmodel:[0m gpt-5.2
[1mprovider:[0m openai
[1mapproval:[0m never
[1msandbox:[0m danger-full-access
[1mreasoning effort:[0m high
[1mreasoning summaries:[0m auto
[1msession id:[0m 019b2796-8dc8-7260-8c7a-8608a7f96f9d
--------
[36muser[0m
You are performing ITERATION 5 of 5.

AUTHORITATIVE INPUTS:
- @instruction.md
- @/Users/ronaldeddings/ClaudeCodeTS/changelogs/1-rewrite-plan-20251216-074742/agent-change-log-iteration-4.md

PRIMARY OBJECTIVE:
Design and continuously refine a VERY DEEP, VERY TECHNICAL implementation plan
for a full rewrite of the application described in instruction.md.

THIS IS NOT A SUMMARY.
THIS IS NOT A HIGH-LEVEL OUTLINE.
THIS IS A STAFF-ENGINEER-LEVEL IMPLEMENTATION CHECKLIST.

MANDATORY TECHNICAL REQUIREMENTS:
- The plan MUST be structured into numbered PHASES.
- Each phase MUST contain subsections (e.g., 3.1, 3.2, 3.3).
- Each subsection MUST contain checklist items.
- Checklist items MUST be concrete, testable, and technical.
- Err on the side of TOO MUCH detail.

MANDATORY SUBSYSTEM COVERAGE (do not omit):
- Core async runtime & scheduling model
- Tool execution without subprocesses
- Hooks system redesign (pure async, no shell)
- Permissions & policy engine
- MCP integration (endpoint vs direct, mobile-safe)
- Settings & configuration system
- App/session state model
- Background agents & long-running tasks
- Host capability abstraction (iOS, Web, Desktop)
- Observability, logging, telemetry boundaries
- Testing strategy (unit, integration, cross-platform)
- Migration strategy from existing CLI
- Risk register & deferred decisions
- Completion criteria

ITERATION-SPECIFIC INSTRUCTIONS:
- Read the existing implementation plan on disk.
- Expand, deepen, and refine it.
- Break vague checklist items into smaller ones.
- Add missing phases or subsystems.
- Increase technical specificity.

ABSOLUTE CONSTRAINTS:
- Do NOT write production code.
- Do NOT write full function implementations.
- Small illustrative snippets are allowed ONLY if essential.
- Do NOT assume Node-only APIs.

FILE OUTPUT REQUIREMENT:
- Write or overwrite the implementation plan ON DISK
- Location is defined in instruction.md

STDOUT CONTRACT (CRITICAL):
- DO NOT print the implementation plan.
- Output ONLY an Agent Change Log.
- The change log MUST include:
  - What sections were added or expanded
  - What technical depth was increased
  - What assumptions were made
  - What remains incomplete or risky

Begin now.

[36mmcp:[0m context7 starting
[36mmcp:[0m context7 ready
[36mmcp startup:[0m ready: context7
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,200p' changelogs/1-rewrite-plan-20251216-074742/agent-change-log-iteration-4.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 49ms:[0m
[2mReading prompt from stdin...
OpenAI Codex v0.72.0 (research preview)
--------
[1mworkdir:[0m /Users/ronaldeddings/ClaudeCodeTS
[1mmodel:[0m gpt-5.2
[1mprovider:[0m openai
[1mapproval:[0m never
[1msandbox:[0m danger-full-access
[1mreasoning effort:[0m high
[1mreasoning summaries:[0m auto
[1msession id:[0m 019b278f-4d04-71a0-90a4-6f19e759fcea
--------
[36muser[0m
You are performing ITERATION 4 of 5.

AUTHORITATIVE INPUTS:
- @instruction.md
- @/Users/ronaldeddings/ClaudeCodeTS/changelogs/1-rewrite-plan-20251216-074742/agent-change-log-iteration-3.md

PRIMARY OBJECTIVE:[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'ls -la'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 31ms:[0m
[2mtotal 408
drwxr-xr-x   12 ronaldeddings  staff     384 Dec 16 07:57 .
drwxr-xr-x@ 288 ronaldeddings  staff    9216 Dec 16 08:07 ..
-rw-r--r--@   1 ronaldeddings  staff    6148 Dec 16 07:57 .DS_Store
drwxr-xr-x   10 ronaldeddings  staff     320 Dec 16 08:35 .git
drwxr-xr-x    3 ronaldeddings  staff      96 Dec 16 07:47 changelogs
drwxr-xr-x   17 ronaldeddings  staff     544 Dec 16 07:57 ClaudeAgentSDKCode
drwxr-xr-x   14 ronaldeddings  staff     448 Dec 16 07:57 ClaudeCodeCode
-rw-r--r--    1 ronaldeddings  staff  159739 Dec 15 07:25 CLI_ENCYCLOPEDIA.md
-rw-r--r--    1 ronaldeddings  staff    8625 Dec 15 07:25 CLI_FUNCTION_CLASS_MAP.md
drwxr-xr-x    4 ronaldeddings  staff     128 Dec 16 07:55 implementation
-rw-r--r--    1 ronaldeddings  staff   17620 Dec 16 07:25 instruction.md
-rw-r--r--    1 ronaldeddings  staff    4485 Dec 16 07:47 runner.sh[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,200p' instruction.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 27ms:[0m
[2mNOTE YOU MUST FULLY READ @ClaudeAgentSDKCode/cli.js and @ClaudeCodeCode/cli.js entirely!!!
I want you to stop analyzing and start **designing a full rewrite** of my application. You must also read @CLI_ENCYCLOPEDIA.md

You now have a detailed, subsystem-level understanding of my codebase from **CLI_ENCYCLOPEDIA.md**, which documents the internals of:

* `ClaudeAgentSDKCode/cli.js` (2.0.67)
* `ClaudeCodeCode/cli.js` (2.0.69)

This encyclopedia is the **ground truth**. You should treat it as a reverse-engineered spec of the current system, not something to re-implement verbatim.

### üî¥ Core Goal

Design a **single, clean, TypeScript-first codebase** that fully replaces both CLIs and:

1. **Eliminates all reliance on spawning child processes**

   * No `spawn`, `exec`, `shell: true`, or process-per-task models
   * No ‚Äúshell hooks‚Äù as subprocesses
2. **Uses async-first, event-driven JavaScript**
[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"implementation/|rewrite plan|plan\\.md|IMPLEMENTATION PLAN|output requirement|Write or overwrite\" instruction.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 80ms:[0m
[2m706: store Implementation Plan in: ./implementation/1-[description][0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '680,760p' instruction.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 47ms:[0m
[2m
Write like:

* A senior staff engineer
* Authoring a design execution plan for a multi-platform rewrite
* That will be reviewed, debated, and revised

Be:

* Confident
* Explicit
* Structured
* Conservative about locking in details

---

## 9. Final Instruction

Start immediately.
[0m

[35m[3mthinking[0m[0m
**Evaluating file structure**

I'm considering the file path for the implementation. It seems like I should use something like `./implementation/1-[description]`. I‚Äôm thinking about whether this should be in a folder. Let‚Äôs list the directory for the implementation to see what‚Äôs there. I want to make sure I'm organizing everything properly, so I'll check to ensure I'm on the right track with the structure.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'ls -·Éö·Éê implementation && find implementation -maxdepth 3 -type f -print'[0m in /Users/ronaldeddings/ClaudeCodeTS[31m exited 1 in 52ms:[0m
[2mls: invalid option -- √°
usage: ls [-@ABCFGHILOPRSTUWXabcdefghiklmnopqrstuvwxy1%,] [--color=when] [-D format] [file ...][0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'ls -la implementation && find implementation -maxdepth 3 -type f -print'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 50ms:[0m
[2mtotal 272
drwxr-xr-x   4 ronaldeddings  staff     128 Dec 16 07:55 .
drwxr-xr-x  12 ronaldeddings  staff     384 Dec 16 07:57 ..
-rw-r--r--   1 ronaldeddings  staff  137014 Dec 16 08:34 1-initial-rewrite-implementation-checklist.md
drwxr-xr-x   2 ronaldeddings  staff      64 Dec 16 07:47 1-rewrite-plan-20251216-074742
implementation/1-initial-rewrite-implementation-checklist.md[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'find . -name AGENTS.md -print'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 69ms:[0m
[2m[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,220p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 65ms:[0m
[2m# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)

## Project Overview

This project is a ground-up rewrite of the current Claude Code CLI application (two bundled variants) into a single, TypeScript-first, **platform-agnostic engine** that can run inside iOS (React Native), web, and desktop hosts. The rewrite explicitly removes the current architecture‚Äôs reliance on spawning child processes as an orchestration/concurrency mechanism, replacing it with **async-first, event-driven execution** and explicit cooperative scheduling.

### Why this rewrite exists

- The current system is tightly coupled to Node + filesystem + subprocess execution, which blocks mobile/web support and makes correctness/testing nondeterministic.
- Multiple ‚Äúsystems‚Äù (hooks, permissions, background tasks) exist primarily to manage process boundaries instead of explicit async boundaries.
- The bundled codebase is difficult to reason about and evolve; the rewrite aims for a clean module graph with explicit ownership boundaries.

### High-level goals

- Core ‚Äúengine‚Äù is TypeScript, portable, and deterministic under test.
- UI layers (CLI, React Native, web) are thin adapters over the engine.
- Tool execution, hooks, and background agents are implemented as **async tasks** (no process-per-task model).
- Permissions and policy are explicit, enforceable, and testable across hosts.
- MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
[0m


[35m[3mthinking[0m[0m
**Reviewing implementation plan**

I need to review the plan for any missing specifics as we move from iteration 4 to 5. The goal is to design and refine a very deep, technical implementation plan for a full rewrite. I‚Äôll scan for vague sections and focus on areas marked "TBD," "??," or "define." It‚Äôs essential to ensure coverage on various subsystems, including tool execution, permissions, and testing strategy. The plan outlines phases, but there seems to be a truncation in phase 2 information.
[35m[3mthinking[0m[0m
**Reviewing phase details**

It seems like Phase 2 exists, but the initial snippet didn't include a header for it due to truncation. I need to go over the table of contents or headings to clarify this. I‚Äôll utilize a search to look for specific patterns like "***Phase" and "Phase 2" to locate any relevant sections quickly. This way, I can confirm what‚Äôs included in Phase 2 and make sure I‚Äôm catching everything needed.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"\\*\\*\\*Phase|"'^## Phase|Phase [0-9]+:" implementation/1-initial-rewrite-implementation-checklist.md'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 89ms:[0m
[2m39:***Phase 1: Rewrite Charter, Spec Capture, and Behavioral Baseline***
126:***Phase 2: High-Level Architecture and Canonical Module Graph***
206:***Phase 3: Core Async Runtime and Scheduling Model (Deterministic Kernel)***
355:***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
451:***Phase 5: App and Session State Model (UI-Agnostic, Event-Driven)***
528:***Phase 6: Settings and Configuration System (Layered, Watchable, Portable)***
601:***Phase 7: Permissions and Policy Engine (Rules, Explainability, Persistence)***
699:***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
860:***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
987:***Phase 10: MCP Integration (Endpoint vs Direct, Mobile-Safe, Streamed)***
1088:***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
1198:***Phase 12: Host Adapters and UI Integration (CLI, iOS, Web, Desktop)***
1264:***Phase 13: Observability, Logging, and Telemetry Boundaries***
1321:***Phase 14: Testing Strategy (Unit, Integration, Cross-Platform, Regression)***
1388:***Phase 15: Migration Strategy from Existing CLI (Incremental Replacement)***
1469:***Phase 16: Release Engineering, Packaging, and Distribution (Multi-Host)***
1510:***Phase 17: Security Hardening and Compliance (Defense-in-Depth)***
1549:***Phase 18: Performance, Memory, and UX Responsiveness (Budgeted System)***
1585:***Phase 19: Documentation, DX, and Operational Playbooks (Ship-Ready)***[0m

[35m[3mthinking[0m[0m
**Refining project phases**

I have a plan that spans 19 phases, which is great! However, I realize I need to refine each phase and deepen our iteration 5 further. There's still work to be done in identifying weak spots, so I want to reread sections, especially in the later phases. I'll also need to develop a risk register, deferred decisions, and completion criteria, likely towards the end. Time to gather information on things like "Risk register" and similar topics!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "Risk|Deferred|Completion criteria|Exit criteria|Definition of done|DONE" implementation/1-initial-rewrite-implementation-checklist.md'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 66ms:[0m
[2m43:Risks mitigated: scope creep, accidental Node-only assumptions, and silent behavior regressions vs the legacy CLIs.
130:Risks mitigated: accidental circular dependencies, UI leaking into core, and platform-specific logic contaminating portable modules.
210:Risks mitigated: nondeterministic concurrency bugs, untestable timing behavior, and platform divergence (Node vs RN vs web).
359:Risks mitigated: accidental platform lock-in, security boundary leaks, and undefined behavior when capabilities are missing.
455:Risks mitigated: UI-framework coupling, state inconsistency, and inability to replay/debug decisions.
532:Risks mitigated: silent behavior drift, incorrect precedence, and non-portable IO/watch assumptions.
605:Risks mitigated: unsafe defaults, inconsistent approvals across platforms, and non-auditable policy overrides.
703:Risks mitigated: reintroducing subprocess-as-orchestrator patterns, breaking streaming UX, and inconsistent behavior across platforms.
864:Risks mitigated: security vulnerabilities (arbitrary code execution), non-portability, and untestable hook behavior.
991:Risks mitigated: inconsistent MCP behavior across hosts, double-telemetry, and fragile connection logic.
1092:Risks mitigated: runaway resource usage, unpredictable concurrency, and mobile lifecycle breakage.
1202:Risks mitigated: reintroducing platform coupling and implementing features twice.
1268:Risks mitigated: privacy regressions, untraceable failures, and platform-specific logging hacks.
1325:Risks mitigated: platform-only bugs, nondeterministic flakiness, and missed security regressions.
1392:Risks mitigated: big-bang rewrite failure, prolonged dual-maintenance, and unbounded behavior drift.
1473:Risks mitigated: shipping a Node-only core by accident, breaking upgrades due to schema drift, and platform-specific regressions that only appear post-release.
1514:Risks mitigated: capability escalation, supply-chain compromise, exfiltration via telemetry/logs, and policy bypass through host adapters.
1553:Risks mitigated: UI jank, out-of-memory crashes, runaway background work, and degraded large-repo workflows.
1589:Risks mitigated: misuse of APIs, accidental boundary violations, and high support burden during migration.
1614:***Risk Register & Mitigations (Iteration 4 Draft)***[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1600,1705p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 48ms:[0m
[2m- [ ] Document permission behavior and how policy-managed environments differ (attribution, managed-only constraints).
- [ ] Document feature availability by host (mobile/web limitations; explicit capability gating).

19.3 Operator/enterprise playbooks (policy + telemetry)
- [ ] Document policy deployment models (mobile offline cache, refresh cadence, failure behavior).
- [ ] Document telemetry controls and endpoint-mode dedupe behavior.
- [ ] Document incident response controls (kill switches, feature gates).

19.4 Support playbooks (diagnostics and triage)
- [ ] Document how to generate and interpret diagnostic bundles (Phase 13.5) without leaking sensitive data.
- [ ] Document common failure modes and remediation steps (MCP connectivity, permission denials, hook blocks, workspace trust issues).

---

***Risk Register & Mitigations (Iteration 4 Draft)***

- [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
- [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
- [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
- [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "Agent Change Log" changelogs/1-rewrite-plan-20251216-074742/agent-change-log-iteration-4.md | head'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 76ms:[0m
[2m70:- Output ONLY an Agent Change Log.
84:[2m## Agent Change Log ‚Äî Iteration 3 of 5
7961:## Agent Change Log ‚Äî Iteration 4 of 5
8300:## Agent Change Log ‚Äî Iteration 4 of 5[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '7940,8065p' changelogs/1-rewrite-plan-20251216-074742/agent-change-log-iteration-4.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 75ms:[0m
[2m?? ClaudeCodeCode/
?? changelogs/
?? implementation/
?? instruction.md
?? runner.sh[0m



[35m[3mthinking[0m[0m
**Evaluating Git repo status**

So, the Git repo has no tracked files, which means `git diff` is showing nothing. That‚Äôs okay, we can still move forward. I want to keep track of the plan file being untracked, though. It's important to make sure I‚Äôm writing to the right location, `./implementation/1-[description]`, which looks good. I'm unsure whether a new file name might be needed for each iteration. The current plan is named `1-initial-rewrite-implementation-checklist.md`. I also need to update the change log to reflect any sections added or expanded.
[35m[3mthinking[0m[0m
**Reviewing modifications and assumptions**

I‚Äôm going over a list of modifications across various phases, including header updates, event envelope tweaks, and worker semantics. There are lots of details here, like conflict resolution and auth rotation. I‚Äôve updated the risk register and completion criteria, and even the checklist count is now around 1110! I‚Äôve made some assumptions too, such as no subprocesses in the shipped codebase and some features being deferred. I‚Äôm noting the remaining risks and incomplete tasks. Since the prompt says not to share the implementation plan, I‚Äôll keep it to myself.
[35m[3mthinking[0m[0m
**Preparing change log**

I need to label the change log properly and update the file path. It‚Äôs crucial to ensure we‚Äôre not including any production code‚Äîjust the plan. The final response should be formatted to only include the change log, without any extras. I‚Äôll follow a structure similar to iteration 3, making sure not to be too verbose while still including the necessary details. I‚Äôll cover four sections: what has been expanded, depth increased, assumptions, and any incomplete or risky items. Alright, I‚Äôm ready to deliver this![0m

[35m[3mthinking[0m[0m
**Refining iteration plan**

I see that the iteration 4 log is quite extensive, but we only need to focus on relevant expansions for it. Now for iteration 5, I want to deepen the plan significantly, breaking down any vague items. Maybe I‚Äôll introduce more detailed subsections and add checklists for phases, keeping things more testable. I should inspect mid-sections around phases 3, 4, 8, 9, and 10 to identify any vagueness and make necessary adjustments. I'll ensure careful sampling.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '200,420p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 37ms:[0m
[2m- [ ] Define an ADR template for each ‚Äú‚ö†Ô∏è do not decide yet‚Äù topic (hook action surface, MCP transports, tool packaging, isolation tech).
- [ ] Define a ‚Äúdecision gate checklist‚Äù (data required before deciding: benchmarks, security review, host feasibility matrix).
- [ ] Require that each ADR includes a rollback path and explicit ‚Äúrevisit by‚Äù milestone.

---

***Phase 3: Core Async Runtime and Scheduling Model (Deterministic Kernel)***

Why this phase exists: the new system replaces ‚Äúspawned processes‚Äù with explicit async tasks; this requires a coherent runtime model for scheduling, cancellation, and streaming.

Risks mitigated: nondeterministic concurrency bugs, untestable timing behavior, and platform divergence (Node vs RN vs web).

Dependencies: Phase 2 boundaries and event taxonomy.

3.1 Define the runtime kernel primitives (types + semantics)
- [ ] Define a `Task` model (identity, parent/child relationships, labels, metadata, lifecycle state).
- [ ] Define a task ID strategy that is stable for correlation (string IDs, monotonic counters in tests, host-provided UUIDs in production).
- [ ] Define task result semantics (`success`, `error`, `cancelled`, `timeout`) and how results are surfaced to the store and event bus.
- [ ] Define a supervision model (parent task cancels/awaits children; failure policies: fail-fast vs isolate vs escalate).
- [ ] Define task-local metadata semantics (immutable vs mutable, how to update without hidden global state).[0m





[35m[3mthinking[0m[0m
**Augmenting phases and details**

I'm focusing on augmenting different phases in my plan. For Phase 3, I'll include aspects like deterministic time, IO virtualization, and scheduler integration. In Phase 8, I want to dive deeper into tools by exploring the tool registry and caching methods. For Phase 9, I'm considering more details on hook schemas, including triggers and conditions. Furthermore, in Phase 7, I plan to add a policy evaluation pipeline and improve permission semantics, alongside possibly enhancing the endpoint server in Phase 10.
[35m[3mthinking[0m[0m
**Planning enhancement tasks**

I‚Äôm focusing on planning tasks rather than writing code for now. This includes selecting transports, detailing handshakes, and setting up resume tokens. I want to consider how to bridge direct connections and endpoints, mobile-safe transports, as well as implementing certificate pinning. For Phase 11, I need to add features like concurrency and persistence for background agents. In Phase 4, I‚Äôll work on capability acquisition flows, and for Phase 13, I want to expand observability features. Lastly, I aim to enhance testing methodologies in Phase 14.
[35m[3mthinking[0m[0m
**Planning phases and migration steps**

I'm laying out a cross-platform migration plan and considering continuous integration (CI). In Phase 15, I need to create a new engine library and wrap the existing CLI calls while ensuring compatibility with a new CLI. I'll use shadow mode for output comparison. I'm also pondering if a phase for data model and schema migrations is necessary, particularly concerning persisted states and transcripts. Additionally, I want to incorporate a security hardening phase and address tool execution without subprocesses. I'll also evaluate the feasibility of using WebAssembly for iOS.
[35m[3mthinking[0m[0m
**Confirming RN environment tasks**

I'm working on tasks to confirm the React Native environment. I‚Äôm unsure if Hermes supports WebAssembly (WASM) fully now, so I‚Äôll treat it as a deferred decision for now. The plan includes MCP integration with mobile-safe options and acknowledges that using a "loopback" endpoint may not be possible on iOS due to restrictions. We also need to emphasize observability and logging. Since this is the final iteration, I‚Äôm considering adding explicit exit criteria and deliverables for each phase, as well as expanding checklists for clarity. I'll update the plan file accordingly.
[35m[3mthinking[0m[0m
**Editing the plan file**

I‚Äôm planning to use `wc -l` to examine specific subsections of the plan that we'll modify, and I‚Äôll use `sed -n` for targeted exploration. I want to find "TODO" items using `rg` and also look for phrases like "Define" to break concepts into concrete elements. Identifying vaguer items, I'll explore patterns like "Decide" and "Define," refining them with explicit tests and constraints. Since the plan file isn‚Äôt tracked by git, I‚Äôll focus on editing the markdown directly, starting with sections in phases 8 and 9 from lines 690 to 940.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '660,940p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 61ms:[0m
[2m- [ ] Define enforcement points (tool runner, MCP transport, settings edits, hook actions).
- [ ] Define ‚Äúdefense in depth‚Äù: capability can be present but denied by policy (must fail with attributable error).
- [ ] Define a mandatory enforcement test suite: attempts to bypass permissions via direct capability calls must be impossible from portable modules.

7.5 Policy engine integration (managed settings, enterprise constraints)
- [ ] Define how policy settings can:
  - [ ] enforce managed-only hooks
  - [ ] restrict plugin loading
  - [ ] force-deny certain tools/capabilities
  - [ ] restrict persistence destinations
- [ ] Define audit trail requirements for policy-driven denials.
- [ ] Define remote-policy refresh semantics and UI messaging (when policy updates mid-session).
- [ ] Define policy-controlled overrides that must be visible to the user (e.g., ‚Äúmanaged settings prevent custom hooks‚Äù) vs silent hardening.

7.6 Permission updates and persistence (write-side semantics)
- [ ] Define an update model that matches legacy operations (setMode, add/replace/remove rules, add/remove directories) with deterministic ordering.
- [ ] Define which destinations are writable (user/project/local) and ensure attempts to write others fail safely and explainably.
- [ ] Define atomic persistence semantics for permission updates (batching, rollback on partial failures, internal-write suppression).
- [ ] Define how ‚Äúsession‚Äù rules are stored and cleared (never persisted; cleared at end-of-session).
[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1040,1225p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 67ms:[0m
[2m  - [ ] namespacing (`mcp:<server>/<tool>`)
  - [ ] permission category mapping (group approvals, per-server rules)
  - [ ] streaming output and structured result
- [ ] Define how PreTool/PostTool hooks can observe and modify MCP tool flows (parity with legacy updatedMCPToolOutput behavior).
- [ ] Define how to surface MCP connection status and errors in the app/session state for UI adapters.
- [ ] Define a per-server connection pool policy (reuse vs reconnect) and how it interacts with cancellation and timeouts.

10.5 Elicitation/ask-user flow (portable)
- [ ] Define an elicitation request/response protocol that is UI-agnostic and works in RN/web/CLI.
- [ ] Define queueing/cancellation rules for elicitation prompts.
- [ ] Define how elicitation interacts with worker/leader permission models (when a background task needs user input).

10.6 MCP CLI parity and migration considerations (no separate process)
- [ ] Define how ‚Äúmcp-cli‚Äù style operations are exposed in v3 (engine command surface) without launching a separate CLI process.
- [ ] Define how endpoint vs direct mode selection is surfaced to users (diagnostics, warnings) in a portable UX.
- [ ] Define how MCP CLI analytics/telemetry wrappers behave in endpoint mode vs non-endpoint mode (parity with legacy ‚Äúskip telemetry in endpoint mode‚Äù behavior).

10.7 Mobile-safe transport constraints (explicit, testable)
- [ ] Define a transport capability matrix: what is supported on RN/web/Node (fetch streaming, SSE, WebSocket) and what is optional.
- [ ] Define fallback behaviors when streaming is unavailable (buffered responses with progress heuristics; explicit UI messaging).[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '699,859p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 29ms:[0m
[2m***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***

Why this phase exists: tools are the primary side-effect boundary. The rewrite must replace ‚Äúshell commands + child processes‚Äù with in-process async tools and/or capability-gated remote execution, with consistent streaming and cancellation semantics.

Risks mitigated: reintroducing subprocess-as-orchestrator patterns, breaking streaming UX, and inconsistent behavior across platforms.

Dependencies: Phase 3 runtime, Phase 4 capabilities, Phase 7 permission engine, Phase 5 state model.

8.1 Tool contract (types + lifecycle, no implementation yet)
- [ ] Define a tool interface that supports:
  - [ ] typed input/output schemas
  - [ ] streaming outputs and progress events
  - [ ] cancellation via AbortSignal
  - [ ] resource budgeting (time, memory, IO)
- [ ] Define tool input validation semantics (schema validation failure is a typed error; never reaches tool body).
- [ ] Define tool output validation semantics (tools must produce schema-conformant outputs or fail with a typed error).
- [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
- [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
- [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
- [ ] Define how tools report structured attachments vs plain text outputs.[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '860,1040p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 26ms:[0m
[2m***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***

Why this phase exists: legacy hooks rely on shell commands, environment variables, stdin/stdout protocols, and subprocess orchestration; this must become a portable, deterministic async workflow system.

Risks mitigated: security vulnerabilities (arbitrary code execution), non-portability, and untestable hook behavior.

Dependencies: Phase 6 settings (hook config sources), Phase 8 tool pipeline (hook integration), Phase 3 runtime (streaming).

9.1 Hook schema redesign (portable and serializable)
- [ ] Define a new hook definition schema that is:
  - [ ] JSON-serializable
  - [ ] versioned
  - [ ] validated at load time
  - [ ] portable across hosts
- [ ] Define hook event names to preserve (at minimum: PreToolUse, PostToolUse, PostToolUseFailure, PermissionRequest, Stop, SubagentStart/Stop, UserPromptSubmit, SessionStart/End, Notification, PreCompact, StatusLine, FileSuggestion).
- [ ] Define the hook input payload shapes (base + event-specific) and ensure they are serializable (no functions, no class instances).
- [ ] Define hook matcher semantics (regex/wildcard/or patterns) and deterministic ordering rules.
- [ ] Define a normalization pipeline for hook configs (sort matchers, sort hooks within matchers, canonical stringification for diffs) so changes are detectable and deterministic.
- [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
- [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).[0m

[35m[3mthinking[0m[0m
**Analyzing project details**

I see that phases 8-12 have good detail, but we could definitely add more specifics. For example, I could define tool streaming event envelopes and progress semantics in 8.1, and conflict resolution in 8.2. It might be helpful to check other phases for any vagueness. Considering iteration 5, maybe I should add a ‚ÄúProject Overview‚Äù that includes a top-level architecture diagram, which might not be explicitly included in the current plan. I‚Äôll need to check Phase 2 for that.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '120,220p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 35ms:[0m
[2m- [ ] For each env var/flag, define the v3 mapping: `host adapter config` ‚Üí `settings overlay` ‚Üí `policy` (and explicitly mark ‚ÄúCLI-only‚Äù controls).
- [ ] Define a ‚Äúdeprecation map‚Äù for env vars/flags that cannot exist on mobile/web (env) and the replacement knobs (settings/policy UI).
- [ ] Add golden tests that assert env/flag mapping produces identical effective configuration snapshots on Node/CLI hosts.

---

***Phase 2: High-Level Architecture and Canonical Module Graph***

Why this phase exists: define stable ownership boundaries and data flow so implementation work can proceed in parallel without entanglement.

Risks mitigated: accidental circular dependencies, UI leaking into core, and platform-specific logic contaminating portable modules.

Dependencies: Phase 1 specs (settings, hooks, permissions, MCP behavior).

2.1 Top-level architecture diagram (text-described, reviewable)
- [ ] Produce an ASCII architecture diagram that includes: core runtime, state model, tools layer, hooks engine, permissions engine, settings system, MCP integration, background agents, and UI adapters.
- [ ] For each component in the diagram, document:
  - [ ] Inputs (events, commands, configs)
  - [ ] Outputs (events, state updates, streams)
  - [ ] Ownership boundaries (who can call whom)[0m

[35m[3mthinking[0m[0m
**Updating function code**

Alright, I see that we don't have the full function code, just the markdown. I'll plan to use apply_patch to make updates. It makes sense to focus on high-value expansions in patch increments. For iteration 5, I‚Äôll need to adjust the header and mention our new focus, while also modifying the risk register and completion criteria. 

I‚Äôll add a checklist summary and incorporate specific areas like runtime scheduling and testing within Phase 14 to ensure we cover all necessary details.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1320,1465p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 46ms:[0m
[2m
***Phase 14: Testing Strategy (Unit, Integration, Cross-Platform, Regression)***

Why this phase exists: a portable async engine requires deterministic tests; migration requires regression harnesses to prevent behavioral drift.

Risks mitigated: platform-only bugs, nondeterministic flakiness, and missed security regressions.

Dependencies: Phase 3 determinism abstractions and Phase 2 module boundaries.

14.1 Unit testing the portable core (pure logic)
- [ ] Define unit-test coverage goals per core module (settings merge, permission evaluation, hook matching, tool pipeline orchestration).
- [ ] Define test doubles for host capabilities (storage, network, filesystem) that are deterministic and replayable.
- [ ] Define golden tests for settings precedence and permission rule evaluation (match legacy semantics until explicitly changed).

14.2 Scheduler and cancellation tests (deterministic time)
- [ ] Implement a test clock and deterministic scheduler harness to simulate timeouts and task interleavings.
- [ ] Add property-based tests for cancellation propagation and queue fairness invariants.
- [ ] Add regression tests for edge cases (cancel during streaming, timeout vs user cancel race, nested task cancellation).

14.3 Integration tests (engine + host adapter)[0m


[35m[3mthinking[0m[0m
**Evaluating testing and implementation strategies**

The testing strategy seems decent, but there's definitely room for expansion. For phase 16, we could focus on aspects like explicit conformance suite and spec tests across all modules, and enhancing tool execution without subprocesses with features like plugin sandboxing and effect restrictions. I'd like to enrich the hooks system redesign with comprehensive schema fields and event lifecycles. Including normative definitions in an appendix sounds beneficial, as long as I avoid printing the entire implementation plan out loud.
[35m[3mthinking[0m[0m
**Reviewing plan file length**

I‚Äôm considering whether to include small illustrative snippets, but only if they're essential. The plan might also include pseudo-code, although I wonder if that‚Äôs necessary to keep. First, I should check the current length of the plan file, which is about 1,700 lines long. I'll run a line count to confirm this and see if adjustments are needed to keep it concise and clear.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'wc -l implementation/1-initial-rewrite-implementation-checklist.md'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 56ms:[0m
[2m    1685 implementation/1-initial-rewrite-implementation-checklist.md[0m


[35m[3mthinking[0m[0m
**Refining project details**

I‚Äôm thinking we can increase depth by adding more checklist items, but I need to be careful not to overwhelm things. The user seems to want a lot of detail. I‚Äôll search for terms like ‚Äútruncated‚Äù or ‚Äú‚Ä¶‚Äù since our tool might have cut off output. We may also need to update our plan for iteration 5 and adjust the risk register. My to-do list might include updating titles, non-goals, focus areas, and possibly adding guiding invariants. For each phase, I should refine it, targeting the most critical details.
[35m[3mthinking[0m[0m
**Focusing on technical phases**

With the requirement for "VERY DEEP, VERY TECHNICAL," I think my focus should be on Phases 3, 7, 8, 9, 10, 11, 13, 14, and 15. I‚Äôll need to add new subsections for Phase 3, including 3.11 for Deterministic I/O, 3.12 for Stream Adapter & Backpressure, 3.13 for Cross-host Run Loop Integration, and 3.14 for Crash/Restart Semantics and Memory Leak Detection. But first, I need to check the existing subsections in Phase 3 to avoid duplication. Using `rg -n "^3\\.[0-9]+"` might help me list them.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "''^3'"\\.[0-9]+\" implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 78ms:[0m
[2m214:3.1 Define the runtime kernel primitives (types + semantics)
237:3.2 Cooperative scheduling model (no background processes)
253:3.3 Cancellation and interruption model (user-driven + system-driven)
264:3.4 Engine event bus and streaming foundation (portable)
297:3.5 Determinism and reproducibility guarantees
305:3.6 Failure handling and escalation (supervision tree)
311:3.7 Host integration points (portable adapters)
316:3.8 Portable stream abstraction (text + binary, uniform backpressure)
330:3.9 Deterministic time and scheduling integration with JS runtimes
338:3.10 Structured concurrency scopes and resource accounting (portable, enforceable)[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '240,360p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 45ms:[0m
[2m- [ ] Define how priorities interact with fairness (e.g., weighted round-robin, aging) and what is considered starvation.
- [ ] Define how long-running tasks yield cooperatively (explicit `await scheduler.yield()` checkpoints).
- [ ] Define mandatory yield points for engine-owned loops (agent loops, hook chains, tool streaming adapters) so UI remains responsive.
- [ ] Define a ‚Äúbudget per tick‚Äù policy (max work/time before yielding) and how it‚Äôs enforced without relying on Node-only timers.
- [ ] Define a starvation-prevention mechanism and testable invariants.
- [ ] Define how UI events (user input) preempt background tasks without killing them.
- [ ] Define preemption semantics for prompts/approvals (foreground prompt can suspend a background agent waiting for user input).
- [ ] Define how to cap concurrency for heavy operations (tool executions, MCP calls, background agents).
- [ ] Define concurrency limiters as first-class runtime resources (named semaphores) so policies can tune them.
- [ ] Define per-category limits (network, filesystem, model queries, MCP) and how limits are surfaced in diagnostics.
- [ ] Define how to surface task progress to UI adapters (typed progress events, not console output).
- [ ] Define ‚Äúprogress event throttling‚Äù semantics to avoid UI overload (coalescing, min interval, max buffered).

3.3 Cancellation and interruption model (user-driven + system-driven)
- [ ] Define user-initiated cancel/stop semantics (what gets cancelled: current tool, hook chain, agent loop, entire session).
- [ ] Define stop escalation policy (e.g., soft stop ‚Üí hard cancel after grace period) and ensure it is deterministic/testable.
- [ ] Define system-initiated cancellation (timeouts, host lifecycle events, policy enforcement).
- [ ] Define ‚Äúpartial completion‚Äù rules for cancellable operations (what state is committed vs rolled back).
- [ ] Define which operations must be atomic from the user‚Äôs perspective (settings patch apply, permission update persistence).
- [ ] Define how cancellation interacts with streaming outputs (final event, resource cleanup, idempotent close).[0m

[35m[3mthinking[0m[0m
**Evaluating phase expansion**

I'm deep into Phase 3 already, and I think we can incorporate 3.11, which focuses on deadlocks and introspection, along with 3.12 for checkpointing event log and replay capture. But I wonder if that might be redundant. Maybe it would be better to expand other phases instead. I should check the state model for Phase 5 and see if it needs more depth. Let's look into the 5.* headings to see what I've got!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "''^5'"\\.[0-9]+\" implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 46ms:[0m
[2m459:5.1 Define canonical domain entities and their lifecycles
467:5.2 Store architecture (deterministic reducers + derived selectors)
476:5.3 Queue-based UX primitives (generalize legacy UI queues)
489:5.4 Persistence and hydration (cross-platform)
495:5.5 Multi-session and concurrency boundaries
500:5.6 Transcript, attachments, and redaction (portable persistence surface)
520:5.7 Derived views and UI adapter contracts (state-to-UI determinism)[0m

[35m[3mthinking[0m[0m
**Evaluating project phases**

I‚Äôm thinking about Phase 5 and how it feels deep but maybe it could use some expansion. It seems adequate for now, but I wonder if there‚Äôs more to explore. Then there's Phase 6, where I need to check the six headings to ensure everything aligns properly. It‚Äôs essential to cover all bases! I want to make sure I‚Äôm thorough so nothing gets overlooked. Let‚Äôs see how this unfolds!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "''^6'"\\.[0-9]+\" implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 73ms:[0m
[2m536:6.1 Schema strategy (types and validation without bundler artifacts)
543:6.2 Settings sources and precedence (portable representation of legacy behavior)
550:6.3 Watchers and change propagation (no filesystem assumption)
559:6.4 Settings patching and atomicity (portable ‚Äúpartial update‚Äù semantics)
565:6.5 Compatibility and migration of existing settings files
572:6.6 Settings precedence and merge edge cases (test-first inventory)
578:6.7 Portable settings storage mapping (per-host implementation checklist)
584:6.8 Settings-derived feature gates and computed configuration (make implicit toggles explicit)
594:6.9 Secrets, credentials, and redaction boundaries in configuration[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "''^9'"\\.[0-9]+\" implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 48ms:[0m
[2m868:9.1 Hook schema redesign (portable and serializable)
883:9.2 Pure-async hook execution model (no shell, no environment variables)
897:9.3 Hook actions/effects (declarative primitives)
922:9.4 Hook config sources, precedence, and policy gating (portable)
931:9.5 Legacy hook migration strategy (compatibility without shell dependence)
940:9.6 Hook matching algorithm spec (deterministic selection)
946:9.7 Model-driven hooks parity (prompt hooks and agent hooks without shell)
956:9.8 Long-running hook parity (legacy ‚Äúasync hook protocol‚Äù replacement)
961:9.9 Legacy ‚Äúasync hook stdout JSON‚Äù protocol mapping (explicit replacement)
976:9.10 Hook effect interpreter (deterministic evaluation, defense-in-depth)[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "''^10'"\\.[0-9]+\" implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 49ms:[0m
[2m995:10.1 MCP client core abstractions (transport-agnostic)
1013:10.2 Endpoint mode (mobile-first)
1027:10.3 Direct mode (host-dependent; do not assume)
1038:10.4 MCP tool invocation integration (permissions + hooks + tools)
1047:10.5 Elicitation/ask-user flow (portable)
1052:10.6 MCP CLI parity and migration considerations (no separate process)
1057:10.7 Mobile-safe transport constraints (explicit, testable)
1065:10.8 MCP CLI behavior parity spec (legacy flags, warnings, timeouts)
1076:10.9 State-file/direct-mode replacement strategy (no separate processes, but external clients exist)[0m


[35m[3mthinking[0m[0m
**Planning expansions and modifications**

I'm considering expanding the plan for the project by adding sections like "MCP server registry persistence," "MCP tool schema caching & validation," and "MCP auth policies." It‚Äôs crucial to incorporate these expansions while ensuring the previous phases and any necessary updates are included. I also need to emphasize "Tool execution without subprocesses" and the redesign of the hooks system. I‚Äôll apply a patch to the file with new additions and checklists. The file is substantial, so I need to maintain correct context.
[35m[3mthinking[0m[0m
**Updating project phases**

I'm planning to update our top header and focus for iterations. I need to break vague items into smaller, more precise bullet points. For example, in Phase 8.1, I can divide "Define how tools report structured attachments" into detailed points about attachment types and semantics. Likewise, in Phase 9, I‚Äôll expand "Define hook matcher semantics" to include specifics on algorithms and priority ordering. Additionally, I'll include testing tasks and expand areas like transport constraints in Phase 10 and telemetry boundaries in Phase 13. Let's locate Phase 13 to refine it further.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1240,1325p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 50ms:[0m
[2m
12.6 Chrome native host / browser-extension bridge (desktop host capability)
- [ ] Specify the legacy Chrome native host contract as a v3 host capability:
  - [ ] length-prefixed message framing
  - [ ] JSON message envelope schema (versioned)
  - [ ] max message size and backpressure behavior
- [ ] Define the v3 equivalent ‚Äúextension bridge‚Äù API surface as engine commands/events (no direct engine internals exposed):
  - [ ] request/response correlation ids
  - [ ] cancellation semantics
  - [ ] permission gating (extension cannot bypass tool permissions)
- [ ] Define security constraints:
  - [ ] origin/app identity checks (host responsibility)
  - [ ] rate limiting + payload size limits
  - [ ] redaction rules (never return secrets)
- [ ] Add contract tests using recorded framing fixtures (valid/invalid length prefixes, partial reads, oversized payloads).

12.7 Local endpoint exposure for external clients (optional, policy-gated)
- [ ] Define when the desktop/CLI host exposes an HTTP endpoint for external tooling (extension, automation) and how it is discovered.
- [ ] Define endpoint authentication/authorization requirements (short-lived token in secure storage; per-workspace scoping).
- [ ] Define endpoint-mode telemetry dedupe behavior (align with Phase 10 endpoint semantics).[0m





[35m[3mthinking[0m[0m
**Ensuring compliance with output standards**

I'm considering the user's specifications about the stdout contract and how tool outputs are displayed in the commentary channel. It looks like I need to focus on the final response instead. I realize I've already printed some of the plan using sed, which could violate the instruction to not print the implementation plan. To stay safe, I‚Äôll minimize any additional plan printing and will only use tools like rg or wc moving forward. Keeping it simple!
[35m[3mthinking[0m[0m
**Evaluating patch visibility concerns**

I'm trying to figure out how to craft a patch while keeping in mind that I need to include contextual lines from the file. But the apply_patch tool could potentially show the patch along with modifications, which may inadvertently display parts of the implementation plan. The guidance says not to print the plan, but I'm unsure if apply_patch content counts. Even though earlier iterations allowed some patch details in the logs, I still want to avoid any violation of the stdout contract in my final response. Better safe than sorry!
[35m[3mthinking[0m[0m
**Assessing patch visibility limitations**

I'm thinking that the tool call for the patch might reveal certain sections, which raises a concern. The instructions state not to print the implementation plan, but it seems to refer to the final message, rather than the tool call details. I'm wondering if the patch content itself might still be considered as printing. I think that apply_patch might not echo the patch content but shows success instead. However, since the patch is part of the tool call, it might be visible in the conversation, and that's confusing!
[35m[3mthinking[0m[0m
**Considering patch context and visibility**

I‚Äôm reflecting on previous logs that show diffs and sed output, which might imply some allowance for printing. However, to be cautious, I‚Äôll aim to minimize the patch context by making specific modifications without revealing the entire plan. Writing the plan on disk is tricky since it might require printing the content.

I realize that using commands like `cat` could include plan content in the visible tool call. So, perhaps the best option is to use `apply_patch` with minimal context to update content, but with an intention for a larger patch, which could become visible. It's all quite complex!
[35m[3mthinking[0m[0m
**Processing tool call visibility and updates**

I‚Äôm analyzing the tool call visibility in commentaries ‚Äî it seems to show parameters but not the patch text directly. For the apply_patch command, it might not display the full patch, which could help. So, I‚Äôll keep the patch manageable while proceeding with it. The final message will only include the change log. Let‚Äôs start by opening the instruction file to confirm the output location and then implement the necessary modifications like updating titles and adding subsections. I have a solid plan!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "''^8'"\\.[0-9]+\" implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 69ms:[0m
[2m707:8.1 Tool contract (types + lifecycle, no implementation yet)
723:8.2 Tool registry and discovery (portable and extensible)
733:8.3 Execution pipeline orchestration (replace spawned-process boundaries)
747:8.4 Replacing legacy subprocess-heavy tools (design-first inventory)
763:8.5 Tool streaming and UI rendering contracts (portable)
771:8.6 Tool isolation and sandboxing (without OS processes)
788:8.7 Tool idempotency, caching, and replay
793:8.8 Security review checklist for tool catalog
798:8.9 In-process search/grep tool track (replacement for legacy embedded `--ripgrep`)
820:8.10 Git operations tool track (no subprocess, host-gated where necessary)
834:8.11 Patch/apply-edits engine (portable, deterministic, audit-friendly)
845:8.12 Engine-internal command surface (replacing legacy `--mcp-cli` / `--ripgrep` entrypoints)[0m



[35m[3mthinking[0m[0m
**Updating patch context**

It looks like to update the file, we need to use "change_context" and add a couple of lines. That seems manageable. However, maybe the better approach is to use "apply_patch" to update right below the heading `8.5 Tool streaming and UI rendering contracts (portable)` without needing to check existing bullets. I want to make sure we don't create duplicates, ideally inserting bullets at the end of section 8.5. We can identify where section 8.6 begins to do this accurately.
[35m[3mthinking[0m[0m
**Planning patch updates**

I see that I can simplify the patch process by replacing the line `8.6 Tool isolation...` with our inserted bullets followed by the line again. This makes it easier! I can insert a new checklist just before the `8.6 Tool isolation and sandboxing` heading without needing the 8.5 content, which helps avoid duplicates. I‚Äôll follow a similar approach for subsequent sections, adding items at the start of 8.6 and before 8.8 for 8.7. I‚Äôll also insert items in section 9.1, right after the existing bullet list about the schema.
[35m[3mthinking[0m[0m
**Implementing the patch**

I can insert a new block above the `9.2 Pure-async...` line with deeper tasks about schema fields like `hookId`, `version`, and others, excluding capability requests from hooks. Also, I plan to expand section 9.6 with additional items for the matching algorithm. In Phase 10, I‚Äôll add new subsections 10.10-10.12 before the `---` separator. The risk register will have its header updated for iteration 5 draft with more rows. I‚Äôll also need to compute the new checklist count after applying the patch, which should be manageable. Let's move forward!

[35m[3mthinking[0m[0m
**Fixing patch issues**

It looks like the patch failed due to a line mismatch because I inadvertently added a stray `7.10 NOTE:`. I also mistakenly placed "7.10 NOTE" in Phase 8.4, and it‚Äôs not actually in the file. So, I need to reapply the patch with the correct hunks. Breaking it into smaller segments could help, and I'll need to inspect Phase 8.4 closely to insert the note and remove that misnumbered part. Let's find the exact lines around 8.4 to patch correctly.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "For each such behavior, create a decision record" -n implementation/1-initial-rewrite-implementation-checklist.md'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 57ms:[0m
[2m751:- [ ] For each such behavior, create a decision record with options:[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '742,758p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 58ms:[0m
[2m- [ ] Define transactional semantics for effect application (e.g., permission updates suggested by hooks only apply if tool ultimately runs and completes successfully, unless explicitly marked otherwise).
- [ ] Define where ‚Äútool output modification‚Äù is allowed (post hooks) and how it is recorded to preserve auditability (original output vs modified output).
- [ ] Define how to enforce that tools cannot bypass the pipeline (no direct capability calls outside tool runner).
- [ ] Define a ‚Äútool runner policy‚Äù that rejects any tool registration that requests forbidden capabilities on a given host (fail fast at startup).

8.4 Replacing legacy subprocess-heavy tools (design-first inventory)
- [ ] Inventory all legacy tool behaviors that currently rely on external binaries/processes (search, git, shell hooks, installers).
- [ ] Build a mapping table: legacy ‚Äúspawn/process‚Äù usage ‚Üí new async construct (tool, background task, MCP request, or removed artifact), with explicit parity notes.
- [ ] Identify legacy ‚Äúinternal entrypoints‚Äù (`--mcp-cli`, `--ripgrep`) that exist primarily to support multi-process packaging, and define v3 equivalents that are in-process.
- [ ] For each such behavior, create a decision record with options:
  - [ ] pure TS implementation
  - [ ] WASM implementation
  - [ ] remote execution via trusted host/server
  - [ ] capability-gated desktop-only implementation
  - [ ] deprecate/omit (with explicit rationale)
- [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
- [ ] Define a parity plan for search/diff operations that avoids shelling out:[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,80p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 48ms:[0m
[2m# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)

## Project Overview

This project is a ground-up rewrite of the current Claude Code CLI application (two bundled variants) into a single, TypeScript-first, **platform-agnostic engine** that can run inside iOS (React Native), web, and desktop hosts. The rewrite explicitly removes the current architecture‚Äôs reliance on spawning child processes as an orchestration/concurrency mechanism, replacing it with **async-first, event-driven execution** and explicit cooperative scheduling.

### Why this rewrite exists

- The current system is tightly coupled to Node + filesystem + subprocess execution, which blocks mobile/web support and makes correctness/testing nondeterministic.
- Multiple ‚Äúsystems‚Äù (hooks, permissions, background tasks) exist primarily to manage process boundaries instead of explicit async boundaries.
- The bundled codebase is difficult to reason about and evolve; the rewrite aims for a clean module graph with explicit ownership boundaries.

### High-level goals

- Core ‚Äúengine‚Äù is TypeScript, portable, and deterministic under test.
- UI layers (CLI, React Native, web) are thin adapters over the engine.
- Tool execution, hooks, and background agents are implemented as **async tasks** (no process-per-task model).
- Permissions and policy are explicit, enforceable, and testable across hosts.
- MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
[0m
[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -1,2 +1,2 @@
[31m-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)[0m
[32m+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)[0m
 
@@ -20,3 +20,3 @@
 
[31m-### Explicit non-goals (Iteration 4 scope guards)[0m
[32m+### Explicit non-goals (Iteration 5 scope guards)[0m
 
@@ -28,9 +28,10 @@
 
[31m-### Iteration 4 focus (what changed vs Iteration 3)[0m
[32m+### Iteration 5 focus (what changed vs Iteration 4)[0m
 
[31m-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.[0m
[31m-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).[0m
[31m-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).[0m
[31m-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).[0m
[31m-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.[0m
[32m+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.[0m
[32m+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.[0m
[32m+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.[0m
[32m+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.[0m
[32m+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.[0m
[32m+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.[0m
 
[32mapply_patch(auto_approved=true) exited 0 in 17ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..28cd45af74e86ff3fb9a488b7cb84282bc0d63da
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 

[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..28cd45af74e86ff3fb9a488b7cb84282bc0d63da
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -353,2 +353,40 @@
 
[32m+3.11 Runtime introspection, hang detection, and debug controls (portable)[0m
[32m+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:[0m
[32m+  - [ ] runnable queue depths by priority[0m
[32m+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)[0m
[32m+  - [ ] all live scopes and their owned tasks[0m
[32m+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)[0m
[32m+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers[0m
[32m+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)[0m
[32m+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.[0m
[32m+- [ ] Define hang detection rules that are deterministic under test:[0m
[32m+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)[0m
[32m+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts[0m
[32m+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)[0m
[32m+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)[0m
[32m+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.[0m
[32m+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).[0m
[32m+- [ ] Add conformance tests that assert:[0m
[32m+  - [ ] snapshots are deterministic given a seeded scheduler/test clock[0m
[32m+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees[0m
[32m+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured[0m
[32m+[0m
[32m+3.12 Replay capture format and deterministic reproduction harness (engine-level)[0m
[32m+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:[0m
[32m+  - [ ] initial capability descriptor (availability + versions; no secrets)[0m
[32m+  - [ ] seeded RNG/UUID source identity[0m
[32m+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)[0m
[32m+  - [ ] injected host events (lifecycle, connectivity) with timestamps[0m
[32m+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs[0m
[32m+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)[0m
[32m+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.[0m
[32m+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.[0m
[32m+- [ ] Define replay assertions:[0m
[32m+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)[0m
[32m+  - [ ] state snapshots at selected checkpoints match (hash-based diff)[0m
[32m+  - [ ] permission decisions + explanations match (source attribution)[0m
[32m+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.[0m
[32m+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.[0m
[32m+[0m
 ---
[32mapply_patch(auto_approved=true) exited 0 in 21ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..da563c04a5fc522c2421ac81fd3ba7738e029653
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***


[35m[3mthinking[0m[0m
**Patching code updates**

I'm focusing on patching Phase 7.9 additions and adding 7.10. First, I need to locate the precise lines in the code. I think I can use `rg -n` for this. Then, to patch, I'll check the context around section 7.9. I plan to use `sed -n '675,715p'` to print those specific lines while keeping it minimal. I‚Äôm working through this step by step!
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..da563c04a5fc522c2421ac81fd3ba7738e029653
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '680,715p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 56ms:[0m
[2m- [ ] Define how tool-specific policy logic plugs into global rule evaluation (tool introspection of inputs).
- [ ] Define how tool-specific checkers declare ‚Äúrequired interactions‚Äù (if tool needs user interaction, mode overrides are constrained).
- [ ] Define deterministic ‚Äúfirst-match‚Äù behavior and how ties/conflicts are resolved.
- [ ] Define evaluation ordering between allow/deny/ask sets (deny-first vs allow-first) and preserve legacy until explicitly changed.

7.3 Ask/deny/allow UX integration (portable prompts)
- [ ] Define a portable ‚Äúpermission prompt request‚Äù event with:
  - [ ] prompt title/body
  - [ ] structured context for rendering (tool, inputs summary, redirections summary if applicable)
  - [ ] allowed response set (allow once, deny, allow+persist, deny+persist, edit scope)
- [ ] Define a portable ‚Äúwhy are we asking?‚Äù payload: matched rules summary, mode, and source labels (user/project/local/policy/session).
- [ ] Define how ‚Äúdon‚Äôt ask again‚Äù becomes persisted rule updates (destination selection, preview of change).
- [ ] Define how persistence destination selection is constrained by policy (managed-only environments).
- [ ] Define how permission prompts are serialized and resumed (if app is backgrounded mid-prompt).
- [ ] Define how policy-managed environments restrict user persistence options (managed-only hooks/permissions).
- [ ] Define a UX requirement for ‚Äúdeny‚Äù messaging that is consistent across CLI/RN/web and is fully attributable.

7.4 Permissions as a capability gate (enforcement layer)
- [ ] Define how permission decisions gate capability access (filesystem, network domains, clipboard, shell/remote).
- [ ] Define enforcement points (tool runner, MCP transport, settings edits, hook actions).[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..da563c04a5fc522c2421ac81fd3ba7738e029653
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '730,795p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 46ms:[0m
[2m- [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
- [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
- [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
- [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
- [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).

---

***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***

Why this phase exists: tools are the primary side-effect boundary. The rewrite must replace ‚Äúshell commands + child processes‚Äù with in-process async tools and/or capability-gated remote execution, with consistent streaming and cancellation semantics.

Risks mitigated: reintroducing subprocess-as-orchestrator patterns, breaking streaming UX, and inconsistent behavior across platforms.

Dependencies: Phase 3 runtime, Phase 4 capabilities, Phase 7 permission engine, Phase 5 state model.

8.1 Tool contract (types + lifecycle, no implementation yet)
- [ ] Define a tool interface that supports:
  - [ ] typed input/output schemas
  - [ ] streaming outputs and progress events[0m

[35m[3mthinking[0m[0m
**Planning document patches**

I‚Äôm noticing that 7.9 lines are just above phase 8, so I‚Äôll patch there. I‚Äôll insert the canonicalization bullets after the decision object bullet, and create a new subsection 7.10 before the separator ‚Äò---‚Äô. It‚Äôs important to do the patch with the exact context. I‚Äôll also make a note to patch Phase 8.1 later, but for now, I‚Äôm focused on patching 7.9 and inserting 7.10 right before ‚Äò---‚Äô. Let‚Äôs craft the patch accordingly!
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..da563c04a5fc522c2421ac81fd3ba7738e029653
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -730,2 +730,8 @@
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
[32m+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:[0m
[32m+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports[0m
[32m+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts[0m
[32m+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching[0m
[32m+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access[0m
[32m+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies[0m
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
@@ -735,2 +741,19 @@
 
[32m+7.10 Permission decision caching and invalidation (correctness-first performance)[0m
[32m+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).[0m
[32m+- [ ] Define canonical cache keys for tool permissions that include:[0m
[32m+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)[0m
[32m+  - [ ] workspace identity/trust state[0m
[32m+  - [ ] effective config hash and policy hash/version[0m
[32m+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)[0m
[32m+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.[0m
[32m+- [ ] Define cache storage semantics:[0m
[32m+  - [ ] in-memory only by default[0m
[32m+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)[0m
[32m+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)[0m
[32m+- [ ] Add regression tests asserting caching does not change observable behavior:[0m
[32m+  - [ ] cached allow/deny decisions preserve explanation attribution[0m
[32m+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts[0m
[32m+  - [ ] invalidation happens before the next decision after a policy/settings update[0m
[32m+[0m
 ---
[32mapply_patch(auto_approved=true) exited 0 in 24ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..0db984ce29c8e4ea22cfbfa66623a4468242c4f1
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***

[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..0db984ce29c8e4ea22cfbfa66623a4468242c4f1
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -779,6 +779,22 @@
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
[31m-- [ ] Define how tools report structured attachments vs plain text outputs.[0m
[31m-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).[0m
[31m-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).[0m
[31m-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).[0m
[32m+- [ ] Define a canonical tool result model that separates:[0m
[32m+  - [ ] machine result (`data`, schema-validated)[0m
[32m+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)[0m
[32m+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)[0m
[32m+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.[0m
[32m+- [ ] Define attachment primitives and lifecycle:[0m
[32m+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)[0m
[32m+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy[0m
[32m+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)[0m
[32m+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)[0m
[32m+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).[0m
[32m+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:[0m
[32m+  - [ ] request schema (prompt, choices, validation)[0m
[32m+  - [ ] cancellation/timeout semantics[0m
[32m+  - [ ] stable request IDs and dedupe behavior[0m
[32m+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.[0m
[32m+- [ ] Define tool idempotency expectations:[0m
[32m+  - [ ] declare idempotent vs non-idempotent tools in registry metadata[0m
[32m+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)[0m
[32m+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)[0m
 
[32mapply_patch(auto_approved=true) exited 0 in 17ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..40ce2769add29aefdddea6c2d7fb94205f841437
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).


[35m[3mthinking[0m[0m
**Updating execution notes**

I want to note that remote execution shouldn't involve a locally spawned helper, and I think placing this in Phase 8.4 is a good idea. I‚Äôll probably add a bullet point under 8.4 after the options list, making sure I keep the numbering correct.

The bullet will define the constraint that "remote execution" must come from an authenticated remote service or host capability and should be visible to the permissions engine. I'll patch this section after the options.
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..40ce2769add29aefdddea6c2d7fb94205f841437
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -834,2 +834,6 @@
   - [ ] deprecate/omit (with explicit rationale)
[32m+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:[0m
[32m+  - [ ] it must not be implemented by spawning local helper processes[0m
[32m+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability[0m
[32m+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)[0m
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
[32mapply_patch(auto_approved=true) exited 0 in 23ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..937137e922557969f9526c50113d4620520e9aeb
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases

[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..937137e922557969f9526c50113d4620520e9aeb
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -939,2 +939,20 @@
 
[32m+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)[0m
[32m+- [ ] Define a tool packaging format for optional tools/plugins:[0m
[32m+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)[0m
[32m+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)[0m
[32m+  - [ ] compatibility constraints (engine version range, host capability requirements)[0m
[32m+- [ ] Define a plugin loading policy model:[0m
[32m+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user[0m
[32m+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories[0m
[32m+  - [ ] policy-managed allow/deny lists for plugin sources and identities[0m
[32m+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):[0m
[32m+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles[0m
[32m+  - [ ] explicit resource budgets and hard timeouts[0m
[32m+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)[0m
[32m+- [ ] Define conformance tests for plugin tool registration:[0m
[32m+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics[0m
[32m+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools[0m
[32m+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers[0m
[32m+[0m
 ---
[32mapply_patch(auto_approved=true) exited 0 in 24ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..9a6b54211bd8aa276c75b830fc44b6588f1e147e
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***

[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..9a6b54211bd8aa276c75b830fc44b6588f1e147e
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -980,2 +980,19 @@
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
[32m+- [ ] Define required hook identity and provenance fields:[0m
[32m+  - [ ] stable `hookId` (deterministic; not derived from file paths)[0m
[32m+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)[0m
[32m+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata[0m
[32m+- [ ] Define per-hook execution policy fields:[0m
[32m+  - [ ] `priority` (integer; stable sorting)[0m
[32m+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)[0m
[32m+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)[0m
[32m+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type[0m
[32m+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).[0m
[32m+- [ ] Add schema-level constraints that prevent unbounded growth:[0m
[32m+  - [ ] maximum matcher count[0m
[32m+  - [ ] maximum action count per hook[0m
[32m+  - [ ] maximum nested effect depth (if effects can reference sub-actions)[0m
[32m+- [ ] Add schema conformance tests:[0m
[32m+  - [ ] canonical stringification is stable across platforms[0m
[32m+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)[0m
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
[32mapply_patch(auto_approved=true) exited 0 in 15ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..fe80e5cda5fa9642d3abb1acf50ed6951b283989
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)


[35m[3mthinking[0m[0m
**Planning document updates**

I need to add new subsections for Phase 10 right after 10.9. First, I‚Äôm trying to pinpoint the exact location for the insertion just before the line with `---` that starts Phase 11. To do this, I‚Äôll look for context around the end of section 10.9. I think I‚Äôll search using commands like `rg -n "10.9 State-file"` and check the last bullet point there. It seems like a logical approach!
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..fe80e5cda5fa9642d3abb1acf50ed6951b283989
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "Define how name normalization" implementation/1-initial-rewrite-implementation-checklist.md'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 59ms:[0m
[2m1201:- [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..fe80e5cda5fa9642d3abb1acf50ed6951b283989
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1188,1215p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 49ms:[0m
[2m  - [ ] Node/CLI host: env ‚Üí host adapter config ‚Üí engine settings overlay (explicit, typed)
  - [ ] Mobile/web: env controls not available; settings/policy equivalents only
- [ ] Define ‚Äúwarn once‚Äù parity requirements for endpoint mode selection (missing endpoint config triggers a single warning + fallback).
- [ ] Define error taxonomy parity for MCP CLI commands (connection failed vs protocol error vs config missing) and ensure stable exit codes for CLI mode.

10.9 State-file/direct-mode replacement strategy (no separate processes, but external clients exist)
- [ ] Decide what v3 supports for ‚Äúexternal client connects to running session‚Äù scenarios (desktop extension, automation):
  - [ ] HTTP endpoint exposed by host adapter (preferred, mobile-safe semantics)
  - [ ] host-specific IPC bridge (desktop-only)
- [ ] If a ‚Äústate file‚Äù exists for external clients, define it as an optional host adapter artifact:
  - [ ] strict schema (versioned; signed/hashed if needed)
  - [ ] explicit lifecycle (create, rotate, delete on shutdown)
  - [ ] security model (least privilege; no secrets in plaintext)
- [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).

---

***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***

Why this phase exists: legacy includes multiple ‚Äúbackground-ish‚Äù agents (Magic Docs, classifier, session memory, prompt suggestion) and long-running operations. The rewrite must run them in the main runtime cooperatively and portably.[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..fe80e5cda5fa9642d3abb1acf50ed6951b283989
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -1202,2 +1202,37 @@
 
[32m+10.10 MCP server registry persistence and trust model (portable)[0m
[32m+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:[0m
[32m+  - [ ] storage-backed registry (per-app and per-workspace partitions)[0m
[32m+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user[0m
[32m+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema[0m
[32m+- [ ] Define a trust model for MCP servers:[0m
[32m+  - [ ] trust level per server (trusted/untrusted/managed)[0m
[32m+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)[0m
[32m+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)[0m
[32m+- [ ] Define how server removal/disablement affects:[0m
[32m+  - [ ] cached tool/resource schemas (invalidate deterministically)[0m
[32m+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)[0m
[32m+[0m
[32m+10.11 MCP schema caching, invalidation, and drift handling[0m
[32m+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).[0m
[32m+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:[0m
[32m+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution[0m
[32m+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)[0m
[32m+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures[0m
[32m+- [ ] Add conformance tests that simulate:[0m
[32m+  - [ ] schema changes mid-session[0m
[32m+  - [ ] cached stale schema causing validation failure[0m
[32m+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing[0m
[32m+[0m
[32m+10.12 MCP streaming normalization and truncation policies (portable UX parity)[0m
[32m+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:[0m
[32m+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)[0m
[32m+  - [ ] deterministic progress/coalescing behavior[0m
[32m+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock[0m
[32m+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).[0m
[32m+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:[0m
[32m+  - [ ] buffered responses with bounded memory usage[0m
[32m+  - [ ] UI messaging that explains reduced fidelity[0m
[32m+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming[0m
[32m+[0m
 ---
[32mapply_patch(auto_approved=true) exited 0 in 17ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..c338faad795c5a81c7caab60d7c2141ea2511d4b
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***


[35m[3mthinking[0m[0m
**Updating risk register**

I'm updating the risk register header and adding more risks. I need to locate the header section first, which is the line that says `***Risk Register & Mitigations (Iteration 4 Draft)***`. I'll change it to Iteration 5. Additionally, I‚Äôll insert new risk bullets and modifications, including ones for hang detection and MCP schema drift. Afterward, I‚Äôll apply the patch using the context from the excerpt at the end. Let's go ahead and do that!
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..c338faad795c5a81c7caab60d7c2141ea2511d4b
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -1765,3 +1765,3 @@
 
[31m-***Risk Register & Mitigations (Iteration 4 Draft)***[0m
[32m+***Risk Register & Mitigations (Iteration 5 Draft)***[0m
 
@@ -1770,2 +1770,3 @@
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
[32m+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.[0m
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
@@ -1775,2 +1776,3 @@
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
[32m+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.[0m
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
[32mapply_patch(auto_approved=true) exited 0 in 20ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..1f21148e411918718c20ded1c370c1e5bd242e7c
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.


[35m[3mthinking[0m[0m
**Updating completion criteria**

I'm looking to update the completion criteria by adding a new bullet point. I also want to refresh the checklist summary, which currently mentions an estimated count of around 1110 for iteration 4. Before I proceed, I need to make sure to update the summary count after inserting the new values, like 3.11. First, I'll find the bullet that mentions the deterministic scheduler test harness and add the new bullet after that. Let‚Äôs apply these changes!
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..1f21148e411918718c20ded1c370c1e5bd242e7c
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -1807,2 +1807,3 @@
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
[32m+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.[0m
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
[32mapply_patch(auto_approved=true) exited 0 in 20ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..f106e45ca983a9012b727490739635f6dfbe07fb
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1805,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.


[35m[3mthinking[0m[0m
**Adding migration criteria**

I want to include a criterion about the phase-gated cutover. I‚Äôll add that near the existing bullet point that discusses how the migration plan supports incremental cutover. I just need to find that snippet first, and then I can insert it appropriately. It‚Äôs important to ensure all relevant details are covered! I‚Äôll patch it in and make sure everything flows smoothly together.
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..f106e45ca983a9012b727490739635f6dfbe07fb
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1805,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "Migration plan supports incremental cutover" -n implementation/1-initial-rewrite-implementation-checklist.md'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 47ms:[0m
[2m1820:- ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..f106e45ca983a9012b727490739635f6dfbe07fb
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1805,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -1820,2 +1820,3 @@
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
[32m+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).[0m
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
[32mapply_patch(auto_approved=true) exited 0 in 22ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..b9cce51e62dd1d1f4bd48109ad401181e0adc9a7
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1805,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,6 +1818,7 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---


[35m[3mthinking[0m[0m
**Updating checklist summary**

I‚Äôm looking to update the checklist summary section. At the end, it notes ‚ÄúEstimated checklist items‚Ä¶ 1110‚Ä¶‚Äù and mentions ‚ÄúThis is Iteration 4.‚Äù I think we need to make some patches, but first, it‚Äôs crucial to compute the actual number of checklist items. I plan to use a command to count the `- [ ]` lines, and I‚Äôll be running that to get accurate results. Let's see what we find!
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..b9cce51e62dd1d1f4bd48109ad401181e0adc9a7
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1805,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,6 +1818,7 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "python - <<'PY'
import re
path='implementation/1-initial-rewrite-implementation-checklist.md'
count=0
with open(path,'r',encoding='utf-8') as f:
    for line in f:
        if re.match(r\""'^'"\\s*- \\[ \\]\", line):
            count+=1
print(count)
PY"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 85ms:[0m
[2m1250[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..b9cce51e62dd1d1f4bd48109ad401181e0adc9a7
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1805,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,6 +1818,7 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"\\*\\*\\*Checklist Summary\\*\\*\\*\" -n implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 72ms:[0m
[2m1826:***Checklist Summary***[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..b9cce51e62dd1d1f4bd48109ad401181e0adc9a7
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1805,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,6 +1818,7 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1826,1845p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 33ms:[0m
[2m***Checklist Summary***

- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.

---

***Notes & Assumptions***

- Assumption: The engine can rely on standard Web APIs (`AbortController`, `fetch`, `TextEncoder/Decoder`) across targets, with host adapters providing polyfills where needed.
- Assumption: Filesystem and shell access are optional host capabilities and must not be required for core correctness or hooks.
- Assumption: The shipped v3 codebase does not spawn OS subprocesses; ‚Äúpower features‚Äù are achieved via in-process TS/WASM/host-native libraries or explicit remote execution.
- Assumption: Legacy behavior parity is initially preferred for settings precedence and permission rule semantics; changes require explicit design decisions and migration UX.
- Assumption: MCP endpoint mode is the primary cross-platform path; direct mode is treated as host-dependent and may be unavailable on mobile/web.
- Assumption: A WASM-based search implementation is feasible on at least desktop/web; mobile may require reduced feature sets or TS fallback to meet budgets.
- Assumption: External client interoperability (extension/automation) is optional for v3 launch and can be capability-gated to desktop/CLI hosts.[0m

[35m[3mthinking[0m[0m
**Patching instructions**

I‚Äôm looking to patch two lines by replacing them with the numbers 1250 and 5 for iteration. I also think it's a good idea to update the note about the count formula, but I want to double-check that it conveys what I need it to. Once I've got everything in order, I'll go ahead and implement these changes. Let's get this done efficiently!
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..b9cce51e62dd1d1f4bd48109ad401181e0adc9a7
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1805,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,6 +1818,7 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -1828,3 +1828,4 @@
 - Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
[31m-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.[0m
[32m+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).[0m
[32m+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.[0m
 
[32mapply_patch(auto_approved=true) exited 0 in 20ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..b23d1d439a37f2e36ab615e755646e01a57ad123
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1805,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,6 +1818,7 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
@@ -1670,7 +1826,8 @@
 ***Checklist Summary***
 
 - Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 


[35m[3mthinking[0m[0m
**Fixing checklist items**

I realize we have two "Estimated checklist items" lines, which should only be one. It seems that while replacing the second line, I inadvertently added another estimated line. Now, there are two consecutive lines. We need to fix this by ensuring there's only one estimated line. I‚Äôll go ahead and edit it so that we have one line and then proceed with the iteration. To do this, I'll use sed to view the section and make the necessary adjustments.
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..b23d1d439a37f2e36ab615e755646e01a57ad123
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1805,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,6 +1818,7 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
@@ -1670,7 +1826,8 @@
 ***Checklist Summary***
 
 - Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1826,1838p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 70ms:[0m
[2m***Checklist Summary***

- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.

---

***Notes & Assumptions***

- Assumption: The engine can rely on standard Web APIs (`AbortController`, `fetch`, `TextEncoder/Decoder`) across targets, with host adapters providing polyfills where needed.
- Assumption: Filesystem and shell access are optional host capabilities and must not be required for core correctness or hooks.
- Assumption: The shipped v3 codebase does not spawn OS subprocesses; ‚Äúpower features‚Äù are achieved via in-process TS/WASM/host-native libraries or explicit remote execution.[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..b23d1d439a37f2e36ab615e755646e01a57ad123
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1805,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,6 +1818,7 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
@@ -1670,7 +1826,8 @@
 ***Checklist Summary***
 
 - Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -1827,3 +1827,2 @@
 
[31m-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).[0m
 - Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
[32mapply_patch(auto_approved=true) exited 0 in 17ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..1d5288672ae6af26b1bd70722e16a14b7ae12157
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1805,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1818,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 


[35m[3mthinking[0m[0m
**Updating file references**

I need to update the file to indicate that we‚Äôre on iteration 5. Plus, I‚Äôve inserted new subsections like 8.13, so I have to adjust other iteration references too, including the risk register and summary. I want to ensure there‚Äôs no mistaken numbering since ‚Äú7.10‚Äù now exists. I‚Äôll double-check to make sure there aren‚Äôt any stray ‚Äú7.10 NOTE‚Äù entries by searching for "NOTE:" and similar terms.
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..1d5288672ae6af26b1bd70722e16a14b7ae12157
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1805,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1818,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"7\\.10 NOTE|~TBD|Iteration 4\" implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 59ms:[0m
[2m29:### Iteration 5 focus (what changed vs Iteration 4)[0m



[35m[3mthinking[0m[0m
**Updating project details**

I've got no leftovers, so now I need to update the risk register and completion criteria. We've added new items, and we might consider minimal expansions to other phases. According to the instructions, iteration 5 requires me to expand, deepen, and refine. That means breaking down vague items, adding missing phases or subsystems, and increasing technical specificity. I wonder if we should also look at expanding section 8.5 and others, focusing on the sections that seem vague.
[35m[3mthinking[0m[0m
**Adding project phases**

I plan to add several new items to my project phases. For phase 8.5, I‚Äôll include details on stream event sequencing and deduplication. In phase 8.6, I need to define "capability membrane" more specifically. Moving to phase 9.6, I‚Äôll further specify the stable ordering algorithm and other factors of the hook matching algorithm. For phase 10.7, I want to clarify support for SSE/WS and define "resume token" and "heartbeat." I‚Äôll also focus on expanding testing in phase 14 by adding fuzzing and contract tests. Time to get to it!
[35m[3mthinking[0m[0m
**Inserting project updates**

I want to show only a minimal portion around the headings in my project. I can add new items right before the heading for "8.6 Tool isolation" without fully reading the content. I'll ensure to check what's already in 8.5 and 8.6 first to avoid any duplicates. To do this, I‚Äôll print a small window around lines 790 to 815. This should help me see the existing bullets without printing out too much. Let's get started!
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..1d5288672ae6af26b1bd70722e16a14b7ae12157
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1805,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1818,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '792,810p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 59ms:[0m
[2m  - [ ] request schema (prompt, choices, validation)
  - [ ] cancellation/timeout semantics
  - [ ] stable request IDs and dedupe behavior
- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
- [ ] Define tool idempotency expectations:
  - [ ] declare idempotent vs non-idempotent tools in registry metadata
  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
  - [ ] define how retries are handled (never auto-retry non-idempotent tools)

8.2 Tool registry and discovery (portable and extensible)
- [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
- [ ] Define a capability-requirements expression model (required vs optional; ‚Äúany of‚Äù vs ‚Äúall of‚Äù) to avoid hardcoding platform logic in tools.
- [ ] Define tool metadata for UX (display name, help text, risk level) without letting UI strings leak into core decisions.
- [ ] Define how MCP-provided tools are represented alongside built-ins (namespacing, grouping, versioning).
- [ ] Define a stable name normalization and conflict-resolution policy for tool identifiers (avoid collisions across MCP servers/plugins).
- [ ] Define how plugins can contribute tools (if supported) without violating portability/security constraints.
- [ ] Define a stable ‚Äútool identity‚Äù format for logs and permissions rules.
- [ ] Define how tool schemas are versioned and how schema changes are migrated across engine versions (compatibility story).
[0m

[35m[3mthinking[0m[0m
**Locating section 8.5**

I haven‚Äôt found section 8.5 yet. I think it starts around line 763, but I might need to check around line 820. This snippet seems to come from section 8.2. Maybe I should look around line 830? I‚Äôll try a command like `sed -n '850,890p'` to see if I can pull the relevant lines quickly. Let's get this sorted out!
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..1d5288672ae6af26b1bd70722e16a14b7ae12157
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1805,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1818,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '845,900p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 43ms:[0m
[2m8.5 Tool streaming and UI rendering contracts (portable)
- [ ] Define a standard set of tool stream event types (stdout-like text, structured chunks, progress, diagnostics).
- [ ] Define chunking rules (max bytes per chunk, line buffering expectations, flush intervals) so UI can render consistently.
- [ ] Define a ‚Äúdiagnostics channel‚Äù separate from user-visible output (debug logs, trace IDs) to avoid polluting transcripts.
- [ ] Define how to render tool output consistently across CLI and RN/web UIs (UI adapter responsibility).
- [ ] Define how tool outputs are persisted (final result + optionally a bounded stream transcript for debugging).
- [ ] Define how to handle binary-like outputs (file diffs, patches) without leaking huge payloads into transcripts by default.

8.6 Tool isolation and sandboxing (without OS processes)
- [ ] Define an isolation policy spectrum: in-process trusted tools (default) vs constrained tools (limited capabilities) vs remote tools.
- [ ] Define how constrained tools are prevented from accessing forbidden capabilities (capability object given to tool is a filtered proxy, not the full host).
- [ ] Define a ‚Äúcapability membrane‚Äù contract for filtered proxies:
  - [ ] deny-by-default for any method not explicitly exposed
  - [ ] stable, typed error on deny (`CapabilityPolicyDeniedError`) with attribution
  - [ ] per-call auditing hooks (who called, which toolRunId/taskId, which capability method)
  - [ ] explicit prohibition on leaking raw underlying handles across the membrane (review checklist + tests)
- [ ] Define per-tool resource budgets and enforcement hooks (time, memory proxy metrics, max output size).
- [ ] Define how to run constrained tools in a worker context when available (Phase 11.5), with a main-thread fallback.
- [ ] Define worker execution semantics (when available) that remain deterministic:
  - [ ] request/response correlation IDs and monotonic sequence numbers for streamed events[0m

[35m[3mthinking[0m[0m
**Expanding on event definitions**

I see that section 8.5 is a bit vague, so I want to expand with more specific details. I‚Äôll define event envelope fields, rendering hints, and considerations for cross-platform functionality and transcript persistence/hashing. Since we already defined the ToolStreamEvent envelope in section 8.1, section 8.5 can refer back to that while specifying UI contracts like stable sequence numbers and semantic markers. I‚Äôll add bullet points within 8.5 after the existing list and before the 8.6 heading.
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..1d5288672ae6af26b1bd70722e16a14b7ae12157
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -855,6 +937,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +978,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1200,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1763,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1805,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1818,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -851,2 +851,17 @@
 - [ ] Define how to handle binary-like outputs (file diffs, patches) without leaking huge payloads into transcripts by default.
[32m+- [ ] Define a strict mapping from `ToolStreamEvent.kind` ‚Üí engine event channels (`transcript`, `ui`, `diagnostic`, `telemetry`) so:[0m
[32m+  - [ ] user-visible output is never emitted on diagnostic-only channels[0m
[32m+  - [ ] diagnostic output is never treated as transcript content[0m
[32m+  - [ ] hosts can safely ‚Äúrender only transcript‚Äù without missing required user content[0m
[32m+- [ ] Define ‚Äúreplaceable output‚Äù semantics for status-like UI (e.g., progress/status line):[0m
[32m+  - [ ] stable `replaceKey` contract (replaces prior event with same key in UI-only views)[0m
[32m+  - [ ] explicit rule: replaceable output must not alter persisted transcript ordering (persist summaries, not per-tick status)[0m
[32m+- [ ] Define truncation/overflow semantics for high-volume tool streams:[0m
[32m+  - [ ] deterministic thresholds (bytes, chunks, time) per host/policy[0m
[32m+  - [ ] required ‚Äútruncated‚Äù marker event containing counters and a retrieval hint (attachment ref if available)[0m
[32m+  - [ ] test fixtures for ‚Äúhuge output‚Äù ensuring bounded memory usage and stable final summaries[0m
[32m+- [ ] Define transcript persistence rules for tool streams:[0m
[32m+  - [ ] default: persist only summarized output + hashes/counters for chunks flagged sensitive[0m
[32m+  - [ ] debug mode (policy-gated): persist bounded raw chunks with redaction applied[0m
[32m+  - [ ] explicit replay strategy: compare hashes/counters for sensitive streams instead of raw content[0m
 
[32mapply_patch(auto_approved=true) exited 0 in 18ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..9f6992d2825d40861199455fc9b83370294c8434
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -767,6 +849,21 @@
 - [ ] Define how to render tool output consistently across CLI and RN/web UIs (UI adapter responsibility).
 - [ ] Define how tool outputs are persisted (final result + optionally a bounded stream transcript for debugging).
 - [ ] Define how to handle binary-like outputs (file diffs, patches) without leaking huge payloads into transcripts by default.
+- [ ] Define a strict mapping from `ToolStreamEvent.kind` ‚Üí engine event channels (`transcript`, `ui`, `diagnostic`, `telemetry`) so:
+  - [ ] user-visible output is never emitted on diagnostic-only channels
+  - [ ] diagnostic output is never treated as transcript content
+  - [ ] hosts can safely ‚Äúrender only transcript‚Äù without missing required user content
+- [ ] Define ‚Äúreplaceable output‚Äù semantics for status-like UI (e.g., progress/status line):
+  - [ ] stable `replaceKey` contract (replaces prior event with same key in UI-only views)
+  - [ ] explicit rule: replaceable output must not alter persisted transcript ordering (persist summaries, not per-tick status)
+- [ ] Define truncation/overflow semantics for high-volume tool streams:
+  - [ ] deterministic thresholds (bytes, chunks, time) per host/policy
+  - [ ] required ‚Äútruncated‚Äù marker event containing counters and a retrieval hint (attachment ref if available)
+  - [ ] test fixtures for ‚Äúhuge output‚Äù ensuring bounded memory usage and stable final summaries
+- [ ] Define transcript persistence rules for tool streams:
+  - [ ] default: persist only summarized output + hashes/counters for chunks flagged sensitive
+  - [ ] debug mode (policy-gated): persist bounded raw chunks with redaction applied
+  - [ ] explicit replay strategy: compare hashes/counters for sensitive streams instead of raw content
 
 8.6 Tool isolation and sandboxing (without OS processes)
 - [ ] Define an isolation policy spectrum: in-process trusted tools (default) vs constrained tools (limited capabilities) vs remote tools.
@@ -855,6 +952,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +993,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1215,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1778,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1820,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1833,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 


[35m[3mthinking[0m[0m
**Expanding hook matching algorithm**

I‚Äôm thinking about expanding the Phase 9.6 hook matching algorithm. First, I need to take a look at the existing 9.6 version to identify any patches or improvements. Then, I‚Äôll focus on what needs to be printed around 9.6 to ensure I have a clear view of its current structure and functioning. This should help in refining the algorithm effectively and making necessary enhancements. Let‚Äôs dive into this process!
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..9f6992d2825d40861199455fc9b83370294c8434
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -767,6 +849,21 @@
 - [ ] Define how to render tool output consistently across CLI and RN/web UIs (UI adapter responsibility).
 - [ ] Define how tool outputs are persisted (final result + optionally a bounded stream transcript for debugging).
 - [ ] Define how to handle binary-like outputs (file diffs, patches) without leaking huge payloads into transcripts by default.
+- [ ] Define a strict mapping from `ToolStreamEvent.kind` ‚Üí engine event channels (`transcript`, `ui`, `diagnostic`, `telemetry`) so:
+  - [ ] user-visible output is never emitted on diagnostic-only channels
+  - [ ] diagnostic output is never treated as transcript content
+  - [ ] hosts can safely ‚Äúrender only transcript‚Äù without missing required user content
+- [ ] Define ‚Äúreplaceable output‚Äù semantics for status-like UI (e.g., progress/status line):
+  - [ ] stable `replaceKey` contract (replaces prior event with same key in UI-only views)
+  - [ ] explicit rule: replaceable output must not alter persisted transcript ordering (persist summaries, not per-tick status)
+- [ ] Define truncation/overflow semantics for high-volume tool streams:
+  - [ ] deterministic thresholds (bytes, chunks, time) per host/policy
+  - [ ] required ‚Äútruncated‚Äù marker event containing counters and a retrieval hint (attachment ref if available)
+  - [ ] test fixtures for ‚Äúhuge output‚Äù ensuring bounded memory usage and stable final summaries
+- [ ] Define transcript persistence rules for tool streams:
+  - [ ] default: persist only summarized output + hashes/counters for chunks flagged sensitive
+  - [ ] debug mode (policy-gated): persist bounded raw chunks with redaction applied
+  - [ ] explicit replay strategy: compare hashes/counters for sensitive streams instead of raw content
 
 8.6 Tool isolation and sandboxing (without OS processes)
 - [ ] Define an isolation policy spectrum: in-process trusted tools (default) vs constrained tools (limited capabilities) vs remote tools.
@@ -855,6 +952,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +993,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1215,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1778,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1820,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1833,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1015,1065p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 53ms:[0m
[2m9.2 Pure-async hook execution model (no shell, no environment variables)
- [ ] Define a hook execution engine that runs hooks as async tasks inside the runtime scheduler.
- [ ] Define two execution surfaces:
  - [ ] streaming mode (UI consumes incremental events)
  - [ ] non-streaming mode (returns a summarized result array for background/non-UI contexts)
- [ ] Define `HookRunId` and per-run monotonic sequence numbers for hook stream events so hosts can resume rendering after backgrounding/crash (mirror the `ToolRunId` sequencing contract).
- [ ] Define a strict `HookStreamEvent` envelope (hookId, hookRunId, seq, tsMono, kind, payload) and validation rules.
- [ ] Define hook cancellation semantics (user stop, tool cancellation, timeout) and required cleanup behavior.
- [ ] Define hook timeouts and budgeting per hook (time, tokens for model hooks, IO budgets for tool calls).
- [ ] Define streaming feedback events for UI (progress/success/non-blocking error/blocking error/cancelled).
- [ ] Define how hooks can produce structured effects (block/allow/ask, modify inputs/outputs, inject messages, update permissions).
- [ ] Define hook chaining semantics (sequential vs parallel; default sequential to preserve legacy ordering) and make it explicit per event.
- [ ] Define how hook failures are classified (blocking vs non-blocking) and when the engine must halt continuation.

9.3 Hook actions/effects (declarative primitives)
- [ ] Define a minimal, composable set of hook actions (examples; final set is provisional):
  - [ ] `EmitNotification`
  - [ ] `RequestPermissionDecision` (advisory; must flow through permissions engine)
  - [ ] `UpdateToolInput`
  - [ ] `UpdateToolOutput` (including MCP output adjustment parity)[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..9f6992d2825d40861199455fc9b83370294c8434
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -767,6 +849,21 @@
 - [ ] Define how to render tool output consistently across CLI and RN/web UIs (UI adapter responsibility).
 - [ ] Define how tool outputs are persisted (final result + optionally a bounded stream transcript for debugging).
 - [ ] Define how to handle binary-like outputs (file diffs, patches) without leaking huge payloads into transcripts by default.
+- [ ] Define a strict mapping from `ToolStreamEvent.kind` ‚Üí engine event channels (`transcript`, `ui`, `diagnostic`, `telemetry`) so:
+  - [ ] user-visible output is never emitted on diagnostic-only channels
+  - [ ] diagnostic output is never treated as transcript content
+  - [ ] hosts can safely ‚Äúrender only transcript‚Äù without missing required user content
+- [ ] Define ‚Äúreplaceable output‚Äù semantics for status-like UI (e.g., progress/status line):
+  - [ ] stable `replaceKey` contract (replaces prior event with same key in UI-only views)
+  - [ ] explicit rule: replaceable output must not alter persisted transcript ordering (persist summaries, not per-tick status)
+- [ ] Define truncation/overflow semantics for high-volume tool streams:
+  - [ ] deterministic thresholds (bytes, chunks, time) per host/policy
+  - [ ] required ‚Äútruncated‚Äù marker event containing counters and a retrieval hint (attachment ref if available)
+  - [ ] test fixtures for ‚Äúhuge output‚Äù ensuring bounded memory usage and stable final summaries
+- [ ] Define transcript persistence rules for tool streams:
+  - [ ] default: persist only summarized output + hashes/counters for chunks flagged sensitive
+  - [ ] debug mode (policy-gated): persist bounded raw chunks with redaction applied
+  - [ ] explicit replay strategy: compare hashes/counters for sensitive streams instead of raw content
 
 8.6 Tool isolation and sandboxing (without OS processes)
 - [ ] Define an isolation policy spectrum: in-process trusted tools (default) vs constrained tools (limited capabilities) vs remote tools.
@@ -855,6 +952,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +993,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1215,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1778,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1820,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1833,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1065,1125p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 32ms:[0m
[2m  - [ ] `command` (shell) ‚Üí new declarative workflows or tool calls (no shell)
  - [ ] `prompt` ‚Üí `RunModelCheck` equivalent with structured `{ ok, reason }` output
  - [ ] `agent` ‚Üí background agent task with explicit structured output contract
- [ ] Define a compatibility linter that flags legacy hooks that cannot be migrated automatically.
- [ ] Define a staged migration for users: warnings, auto-conversion where safe, opt-in compatibility mode where needed.
- [ ] ‚ö†Ô∏è Do not promise full fidelity for shell hooks on mobile/web; define explicit deprecation/fallback messaging.

9.6 Hook matching algorithm spec (deterministic selection)
- [ ] Define how match queries are constructed per event (tool hooks match on tool name; notification hooks match on type; other events may match all).
- [ ] Define matcher evaluation semantics (regex compilation failures, wildcard matching rules, OR-pattern parsing) and required error reporting.
- [ ] Define hook identity/dedup keys and explicitly document which hook types are deduped and which are not (parity with legacy where required).
- [ ] Define the final execution order rules across merged sources (stable sort: source precedence ‚Üí matcher order ‚Üí hook order).

9.7 Model-driven hooks parity (prompt hooks and agent hooks without shell)
- [ ] Define a portable ‚Äúmodel check‚Äù hook type that requires structured output (boolean + optional reason) and runs with explicit token/thinking limits.
- [ ] Define how model-check hook prompts are templated (argument injection parity with legacy `$ARGUMENTS` behavior) without allowing arbitrary code execution.
- [ ] Define a portable ‚Äúhook agent‚Äù task type that:
  - [ ] runs non-interactively
  - [ ] has a max-turn limit
  - [ ] must produce a structured terminal output event (explicit contract)[0m

[35m[3mthinking[0m[0m
**Expanding matching algorithm details**

I‚Äôm looking to expand section 9.6, which has four existing bullets about the matching algorithm. I want to add a few more: first, I‚Äôll define normalized match keys, talk about regex engine limitations, compile caching, and failure semantics. Then I‚Äôll cover match-time budgets and the importance of short-circuiting. I also need to include test cases for determinism. Lastly, I'll address security by discussing avoiding catastrophic regex and considering a safe regex subset or timeouts.
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..9f6992d2825d40861199455fc9b83370294c8434
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -767,6 +849,21 @@
 - [ ] Define how to render tool output consistently across CLI and RN/web UIs (UI adapter responsibility).
 - [ ] Define how tool outputs are persisted (final result + optionally a bounded stream transcript for debugging).
 - [ ] Define how to handle binary-like outputs (file diffs, patches) without leaking huge payloads into transcripts by default.
+- [ ] Define a strict mapping from `ToolStreamEvent.kind` ‚Üí engine event channels (`transcript`, `ui`, `diagnostic`, `telemetry`) so:
+  - [ ] user-visible output is never emitted on diagnostic-only channels
+  - [ ] diagnostic output is never treated as transcript content
+  - [ ] hosts can safely ‚Äúrender only transcript‚Äù without missing required user content
+- [ ] Define ‚Äúreplaceable output‚Äù semantics for status-like UI (e.g., progress/status line):
+  - [ ] stable `replaceKey` contract (replaces prior event with same key in UI-only views)
+  - [ ] explicit rule: replaceable output must not alter persisted transcript ordering (persist summaries, not per-tick status)
+- [ ] Define truncation/overflow semantics for high-volume tool streams:
+  - [ ] deterministic thresholds (bytes, chunks, time) per host/policy
+  - [ ] required ‚Äútruncated‚Äù marker event containing counters and a retrieval hint (attachment ref if available)
+  - [ ] test fixtures for ‚Äúhuge output‚Äù ensuring bounded memory usage and stable final summaries
+- [ ] Define transcript persistence rules for tool streams:
+  - [ ] default: persist only summarized output + hashes/counters for chunks flagged sensitive
+  - [ ] debug mode (policy-gated): persist bounded raw chunks with redaction applied
+  - [ ] explicit replay strategy: compare hashes/counters for sensitive streams instead of raw content
 
 8.6 Tool isolation and sandboxing (without OS processes)
 - [ ] Define an isolation policy spectrum: in-process trusted tools (default) vs constrained tools (limited capabilities) vs remote tools.
@@ -855,6 +952,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +993,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -1083,6 +1215,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1778,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1820,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1833,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -1076,2 +1076,15 @@
 - [ ] Define the final execution order rules across merged sources (stable sort: source precedence ‚Üí matcher order ‚Üí hook order).
[32m+- [ ] Define canonical matching inputs per event type (normalized strings/fields) and prohibit matching against raw, potentially sensitive payloads by default.[0m
[32m+- [ ] Define regex safety constraints for portability:[0m
[32m+  - [ ] require a deterministic ‚Äúregex compile‚Äù stage at config load time (never compile on the hot path)[0m
[32m+  - [ ] define behavior when regex features are unsupported on a host (reject with actionable diagnostics vs degrade to literal)[0m
[32m+  - [ ] define protection against catastrophic backtracking (allowed regex subset, timeout budget, or safe-regex engine decision gate)[0m
[32m+- [ ] Define matcher caching rules (compiled patterns cached by hookId + definitionVersion) and invalidation on config changes.[0m
[32m+- [ ] Define performance invariants and testable limits:[0m
[32m+  - [ ] max matchers evaluated per event[0m
[32m+  - [ ] max hooks executed per event[0m
[32m+  - [ ] deterministic early-exit rules when a blocking effect occurs (what still runs, what is skipped)[0m
[32m+- [ ] Add golden tests for matching determinism:[0m
[32m+  - [ ] same config produces identical matched-hook lists across Node/web/RN-like adapters[0m
[32m+  - [ ] invalid matcher errors include hook source attribution and do not change unrelated hook ordering[0m
 
[32mapply_patch(auto_approved=true) exited 0 in 17ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..187bc11b1e100c631578169684084b5cc7a5f2ef
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -767,6 +849,21 @@
 - [ ] Define how to render tool output consistently across CLI and RN/web UIs (UI adapter responsibility).
 - [ ] Define how tool outputs are persisted (final result + optionally a bounded stream transcript for debugging).
 - [ ] Define how to handle binary-like outputs (file diffs, patches) without leaking huge payloads into transcripts by default.
+- [ ] Define a strict mapping from `ToolStreamEvent.kind` ‚Üí engine event channels (`transcript`, `ui`, `diagnostic`, `telemetry`) so:
+  - [ ] user-visible output is never emitted on diagnostic-only channels
+  - [ ] diagnostic output is never treated as transcript content
+  - [ ] hosts can safely ‚Äúrender only transcript‚Äù without missing required user content
+- [ ] Define ‚Äúreplaceable output‚Äù semantics for status-like UI (e.g., progress/status line):
+  - [ ] stable `replaceKey` contract (replaces prior event with same key in UI-only views)
+  - [ ] explicit rule: replaceable output must not alter persisted transcript ordering (persist summaries, not per-tick status)
+- [ ] Define truncation/overflow semantics for high-volume tool streams:
+  - [ ] deterministic thresholds (bytes, chunks, time) per host/policy
+  - [ ] required ‚Äútruncated‚Äù marker event containing counters and a retrieval hint (attachment ref if available)
+  - [ ] test fixtures for ‚Äúhuge output‚Äù ensuring bounded memory usage and stable final summaries
+- [ ] Define transcript persistence rules for tool streams:
+  - [ ] default: persist only summarized output + hashes/counters for chunks flagged sensitive
+  - [ ] debug mode (policy-gated): persist bounded raw chunks with redaction applied
+  - [ ] explicit replay strategy: compare hashes/counters for sensitive streams instead of raw content
 
 8.6 Tool isolation and sandboxing (without OS processes)
 - [ ] Define an isolation policy spectrum: in-process trusted tools (default) vs constrained tools (limited capabilities) vs remote tools.
@@ -855,6 +952,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +993,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -942,6 +1074,19 @@
 - [ ] Define matcher evaluation semantics (regex compilation failures, wildcard matching rules, OR-pattern parsing) and required error reporting.
 - [ ] Define hook identity/dedup keys and explicitly document which hook types are deduped and which are not (parity with legacy where required).
 - [ ] Define the final execution order rules across merged sources (stable sort: source precedence ‚Üí matcher order ‚Üí hook order).
+- [ ] Define canonical matching inputs per event type (normalized strings/fields) and prohibit matching against raw, potentially sensitive payloads by default.
+- [ ] Define regex safety constraints for portability:
+  - [ ] require a deterministic ‚Äúregex compile‚Äù stage at config load time (never compile on the hot path)
+  - [ ] define behavior when regex features are unsupported on a host (reject with actionable diagnostics vs degrade to literal)
+  - [ ] define protection against catastrophic backtracking (allowed regex subset, timeout budget, or safe-regex engine decision gate)
+- [ ] Define matcher caching rules (compiled patterns cached by hookId + definitionVersion) and invalidation on config changes.
+- [ ] Define performance invariants and testable limits:
+  - [ ] max matchers evaluated per event
+  - [ ] max hooks executed per event
+  - [ ] deterministic early-exit rules when a blocking effect occurs (what still runs, what is skipped)
+- [ ] Add golden tests for matching determinism:
+  - [ ] same config produces identical matched-hook lists across Node/web/RN-like adapters
+  - [ ] invalid matcher errors include hook source attribution and do not change unrelated hook ordering
 
 9.7 Model-driven hooks parity (prompt hooks and agent hooks without shell)
 - [ ] Define a portable ‚Äúmodel check‚Äù hook type that requires structured output (boolean + optional reason) and runs with explicit token/thinking limits.
@@ -1083,6 +1228,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1791,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1833,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1846,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 

[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..187bc11b1e100c631578169684084b5cc7a5f2ef
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -767,6 +849,21 @@
 - [ ] Define how to render tool output consistently across CLI and RN/web UIs (UI adapter responsibility).
 - [ ] Define how tool outputs are persisted (final result + optionally a bounded stream transcript for debugging).
 - [ ] Define how to handle binary-like outputs (file diffs, patches) without leaking huge payloads into transcripts by default.
+- [ ] Define a strict mapping from `ToolStreamEvent.kind` ‚Üí engine event channels (`transcript`, `ui`, `diagnostic`, `telemetry`) so:
+  - [ ] user-visible output is never emitted on diagnostic-only channels
+  - [ ] diagnostic output is never treated as transcript content
+  - [ ] hosts can safely ‚Äúrender only transcript‚Äù without missing required user content
+- [ ] Define ‚Äúreplaceable output‚Äù semantics for status-like UI (e.g., progress/status line):
+  - [ ] stable `replaceKey` contract (replaces prior event with same key in UI-only views)
+  - [ ] explicit rule: replaceable output must not alter persisted transcript ordering (persist summaries, not per-tick status)
+- [ ] Define truncation/overflow semantics for high-volume tool streams:
+  - [ ] deterministic thresholds (bytes, chunks, time) per host/policy
+  - [ ] required ‚Äútruncated‚Äù marker event containing counters and a retrieval hint (attachment ref if available)
+  - [ ] test fixtures for ‚Äúhuge output‚Äù ensuring bounded memory usage and stable final summaries
+- [ ] Define transcript persistence rules for tool streams:
+  - [ ] default: persist only summarized output + hashes/counters for chunks flagged sensitive
+  - [ ] debug mode (policy-gated): persist bounded raw chunks with redaction applied
+  - [ ] explicit replay strategy: compare hashes/counters for sensitive streams instead of raw content
 
 8.6 Tool isolation and sandboxing (without OS processes)
 - [ ] Define an isolation policy spectrum: in-process trusted tools (default) vs constrained tools (limited capabilities) vs remote tools.
@@ -855,6 +952,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +993,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -942,6 +1074,19 @@
 - [ ] Define matcher evaluation semantics (regex compilation failures, wildcard matching rules, OR-pattern parsing) and required error reporting.
 - [ ] Define hook identity/dedup keys and explicitly document which hook types are deduped and which are not (parity with legacy where required).
 - [ ] Define the final execution order rules across merged sources (stable sort: source precedence ‚Üí matcher order ‚Üí hook order).
+- [ ] Define canonical matching inputs per event type (normalized strings/fields) and prohibit matching against raw, potentially sensitive payloads by default.
+- [ ] Define regex safety constraints for portability:
+  - [ ] require a deterministic ‚Äúregex compile‚Äù stage at config load time (never compile on the hot path)
+  - [ ] define behavior when regex features are unsupported on a host (reject with actionable diagnostics vs degrade to literal)
+  - [ ] define protection against catastrophic backtracking (allowed regex subset, timeout budget, or safe-regex engine decision gate)
+- [ ] Define matcher caching rules (compiled patterns cached by hookId + definitionVersion) and invalidation on config changes.
+- [ ] Define performance invariants and testable limits:
+  - [ ] max matchers evaluated per event
+  - [ ] max hooks executed per event
+  - [ ] deterministic early-exit rules when a blocking effect occurs (what still runs, what is skipped)
+- [ ] Add golden tests for matching determinism:
+  - [ ] same config produces identical matched-hook lists across Node/web/RN-like adapters
+  - [ ] invalid matcher errors include hook source attribution and do not change unrelated hook ordering
 
 9.7 Model-driven hooks parity (prompt hooks and agent hooks without shell)
 - [ ] Define a portable ‚Äúmodel check‚Äù hook type that requires structured output (boolean + optional reason) and runs with explicit token/thinking limits.
@@ -1083,6 +1228,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1791,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1833,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1846,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"10\\.7 Mobile-safe transport constraints\" -n implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 56ms:[0m
[2m1202:10.7 Mobile-safe transport constraints (explicit, testable)[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..187bc11b1e100c631578169684084b5cc7a5f2ef
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -767,6 +849,21 @@
 - [ ] Define how to render tool output consistently across CLI and RN/web UIs (UI adapter responsibility).
 - [ ] Define how tool outputs are persisted (final result + optionally a bounded stream transcript for debugging).
 - [ ] Define how to handle binary-like outputs (file diffs, patches) without leaking huge payloads into transcripts by default.
+- [ ] Define a strict mapping from `ToolStreamEvent.kind` ‚Üí engine event channels (`transcript`, `ui`, `diagnostic`, `telemetry`) so:
+  - [ ] user-visible output is never emitted on diagnostic-only channels
+  - [ ] diagnostic output is never treated as transcript content
+  - [ ] hosts can safely ‚Äúrender only transcript‚Äù without missing required user content
+- [ ] Define ‚Äúreplaceable output‚Äù semantics for status-like UI (e.g., progress/status line):
+  - [ ] stable `replaceKey` contract (replaces prior event with same key in UI-only views)
+  - [ ] explicit rule: replaceable output must not alter persisted transcript ordering (persist summaries, not per-tick status)
+- [ ] Define truncation/overflow semantics for high-volume tool streams:
+  - [ ] deterministic thresholds (bytes, chunks, time) per host/policy
+  - [ ] required ‚Äútruncated‚Äù marker event containing counters and a retrieval hint (attachment ref if available)
+  - [ ] test fixtures for ‚Äúhuge output‚Äù ensuring bounded memory usage and stable final summaries
+- [ ] Define transcript persistence rules for tool streams:
+  - [ ] default: persist only summarized output + hashes/counters for chunks flagged sensitive
+  - [ ] debug mode (policy-gated): persist bounded raw chunks with redaction applied
+  - [ ] explicit replay strategy: compare hashes/counters for sensitive streams instead of raw content
 
 8.6 Tool isolation and sandboxing (without OS processes)
 - [ ] Define an isolation policy spectrum: in-process trusted tools (default) vs constrained tools (limited capabilities) vs remote tools.
@@ -855,6 +952,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +993,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -942,6 +1074,19 @@
 - [ ] Define matcher evaluation semantics (regex compilation failures, wildcard matching rules, OR-pattern parsing) and required error reporting.
 - [ ] Define hook identity/dedup keys and explicitly document which hook types are deduped and which are not (parity with legacy where required).
 - [ ] Define the final execution order rules across merged sources (stable sort: source precedence ‚Üí matcher order ‚Üí hook order).
+- [ ] Define canonical matching inputs per event type (normalized strings/fields) and prohibit matching against raw, potentially sensitive payloads by default.
+- [ ] Define regex safety constraints for portability:
+  - [ ] require a deterministic ‚Äúregex compile‚Äù stage at config load time (never compile on the hot path)
+  - [ ] define behavior when regex features are unsupported on a host (reject with actionable diagnostics vs degrade to literal)
+  - [ ] define protection against catastrophic backtracking (allowed regex subset, timeout budget, or safe-regex engine decision gate)
+- [ ] Define matcher caching rules (compiled patterns cached by hookId + definitionVersion) and invalidation on config changes.
+- [ ] Define performance invariants and testable limits:
+  - [ ] max matchers evaluated per event
+  - [ ] max hooks executed per event
+  - [ ] deterministic early-exit rules when a blocking effect occurs (what still runs, what is skipped)
+- [ ] Add golden tests for matching determinism:
+  - [ ] same config produces identical matched-hook lists across Node/web/RN-like adapters
+  - [ ] invalid matcher errors include hook source attribution and do not change unrelated hook ordering
 
 9.7 Model-driven hooks parity (prompt hooks and agent hooks without shell)
 - [ ] Define a portable ‚Äúmodel check‚Äù hook type that requires structured output (boolean + optional reason) and runs with explicit token/thinking limits.
@@ -1083,6 +1228,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1791,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1833,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1846,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1202,1230p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 50ms:[0m
[2m10.7 Mobile-safe transport constraints (explicit, testable)
- [ ] Define a transport capability matrix: what is supported on RN/web/Node (fetch streaming, SSE, WebSocket) and what is optional.
- [ ] Define fallback behaviors when streaming is unavailable (buffered responses with progress heuristics; explicit UI messaging).
- [ ] Add conformance tests that simulate:
  - [ ] endpoint config missing ‚Üí warning + fallback behavior
  - [ ] connection failed ‚Üí typed error + retry/backoff rules
  - [ ] cancelled requests ‚Üí no leaked tasks/connections

10.8 MCP CLI behavior parity spec (legacy flags, warnings, timeouts)
- [ ] Specify the ‚Äúfeature gate‚Äù inputs for MCP CLI parity on hosts that support it (CLI/desktop):
  - [ ] experimental enable flag (legacy `ENABLE_EXPERIMENTAL_MCP_CLI`)
  - [ ] endpoint enable/disable toggle (legacy `ENABLE_MCP_CLI_ENDPOINT`)
  - [ ] tool timeout default and override (legacy `MCP_TOOL_TIMEOUT`, defaulting to ‚Äúeffectively infinite‚Äù)
- [ ] Define how these legacy env-driven controls map to v3:
  - [ ] Node/CLI host: env ‚Üí host adapter config ‚Üí engine settings overlay (explicit, typed)
  - [ ] Mobile/web: env controls not available; settings/policy equivalents only
- [ ] Define ‚Äúwarn once‚Äù parity requirements for endpoint mode selection (missing endpoint config triggers a single warning + fallback).
- [ ] Define error taxonomy parity for MCP CLI commands (connection failed vs protocol error vs config missing) and ensure stable exit codes for CLI mode.

10.9 State-file/direct-mode replacement strategy (no separate processes, but external clients exist)[0m

[35m[3mthinking[0m[0m
**Expanding content sections**

I'm planning to expand section 10.7 by adding items before the 10.8 heading. I think it's important to patch accordingly and include definitions for several key concepts. First, I want to define terms like keepalive/heartbeat, connection liveness detection, and resume tokens for streaming. Next, I'll address proxy restrictions, CORS, and TLS. Finally, I'll define mobile backgrounding behavior to ensure clarity. This approach will help make the content more comprehensive!
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..187bc11b1e100c631578169684084b5cc7a5f2ef
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -767,6 +849,21 @@
 - [ ] Define how to render tool output consistently across CLI and RN/web UIs (UI adapter responsibility).
 - [ ] Define how tool outputs are persisted (final result + optionally a bounded stream transcript for debugging).
 - [ ] Define how to handle binary-like outputs (file diffs, patches) without leaking huge payloads into transcripts by default.
+- [ ] Define a strict mapping from `ToolStreamEvent.kind` ‚Üí engine event channels (`transcript`, `ui`, `diagnostic`, `telemetry`) so:
+  - [ ] user-visible output is never emitted on diagnostic-only channels
+  - [ ] diagnostic output is never treated as transcript content
+  - [ ] hosts can safely ‚Äúrender only transcript‚Äù without missing required user content
+- [ ] Define ‚Äúreplaceable output‚Äù semantics for status-like UI (e.g., progress/status line):
+  - [ ] stable `replaceKey` contract (replaces prior event with same key in UI-only views)
+  - [ ] explicit rule: replaceable output must not alter persisted transcript ordering (persist summaries, not per-tick status)
+- [ ] Define truncation/overflow semantics for high-volume tool streams:
+  - [ ] deterministic thresholds (bytes, chunks, time) per host/policy
+  - [ ] required ‚Äútruncated‚Äù marker event containing counters and a retrieval hint (attachment ref if available)
+  - [ ] test fixtures for ‚Äúhuge output‚Äù ensuring bounded memory usage and stable final summaries
+- [ ] Define transcript persistence rules for tool streams:
+  - [ ] default: persist only summarized output + hashes/counters for chunks flagged sensitive
+  - [ ] debug mode (policy-gated): persist bounded raw chunks with redaction applied
+  - [ ] explicit replay strategy: compare hashes/counters for sensitive streams instead of raw content
 
 8.6 Tool isolation and sandboxing (without OS processes)
 - [ ] Define an isolation policy spectrum: in-process trusted tools (default) vs constrained tools (limited capabilities) vs remote tools.
@@ -855,6 +952,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +993,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -942,6 +1074,19 @@
 - [ ] Define matcher evaluation semantics (regex compilation failures, wildcard matching rules, OR-pattern parsing) and required error reporting.
 - [ ] Define hook identity/dedup keys and explicitly document which hook types are deduped and which are not (parity with legacy where required).
 - [ ] Define the final execution order rules across merged sources (stable sort: source precedence ‚Üí matcher order ‚Üí hook order).
+- [ ] Define canonical matching inputs per event type (normalized strings/fields) and prohibit matching against raw, potentially sensitive payloads by default.
+- [ ] Define regex safety constraints for portability:
+  - [ ] require a deterministic ‚Äúregex compile‚Äù stage at config load time (never compile on the hot path)
+  - [ ] define behavior when regex features are unsupported on a host (reject with actionable diagnostics vs degrade to literal)
+  - [ ] define protection against catastrophic backtracking (allowed regex subset, timeout budget, or safe-regex engine decision gate)
+- [ ] Define matcher caching rules (compiled patterns cached by hookId + definitionVersion) and invalidation on config changes.
+- [ ] Define performance invariants and testable limits:
+  - [ ] max matchers evaluated per event
+  - [ ] max hooks executed per event
+  - [ ] deterministic early-exit rules when a blocking effect occurs (what still runs, what is skipped)
+- [ ] Add golden tests for matching determinism:
+  - [ ] same config produces identical matched-hook lists across Node/web/RN-like adapters
+  - [ ] invalid matcher errors include hook source attribution and do not change unrelated hook ordering
 
 9.7 Model-driven hooks parity (prompt hooks and agent hooks without shell)
 - [ ] Define a portable ‚Äúmodel check‚Äù hook type that requires structured output (boolean + optional reason) and runs with explicit token/thinking limits.
@@ -1083,6 +1228,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1791,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1833,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1846,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -1204,2 +1204,15 @@
 - [ ] Define fallback behaviors when streaming is unavailable (buffered responses with progress heuristics; explicit UI messaging).
[32m+- [ ] Define liveness and keepalive requirements for long-lived transports:[0m
[32m+  - [ ] heartbeat/keepalive intervals (policy-configurable, bounded)[0m
[32m+  - [ ] idle timeout behavior (close vs keep open) per host[0m
[32m+  - [ ] deterministic ‚Äúconnection considered dead‚Äù thresholds for reconnection logic[0m
[32m+- [ ] Define resume semantics where feasible:[0m
[32m+  - [ ] resume token/cursor fields carried in envelopes[0m
[32m+  - [ ] explicit behavior when resume is not supported (fail-fast with retry guidance)[0m
[32m+- [ ] Define web-specific constraints explicitly:[0m
[32m+  - [ ] CORS and credential mode requirements for endpoint mode[0m
[32m+  - [ ] prohibition on assuming raw sockets or localhost reachability in browsers[0m
[32m+- [ ] Define mobile lifecycle constraints explicitly:[0m
[32m+  - [ ] what happens to in-flight streaming calls on background (cancel vs pause) per platform policy[0m
[32m+  - [ ] required UI messaging when backgrounding cancels MCP tool calls[0m
 - [ ] Add conformance tests that simulate:
[32mapply_patch(auto_approved=true) exited 0 in 20ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..db58fcfc86c5eba129ba3e16751eed33e0c7de3e
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -767,6 +849,21 @@
 - [ ] Define how to render tool output consistently across CLI and RN/web UIs (UI adapter responsibility).
 - [ ] Define how tool outputs are persisted (final result + optionally a bounded stream transcript for debugging).
 - [ ] Define how to handle binary-like outputs (file diffs, patches) without leaking huge payloads into transcripts by default.
+- [ ] Define a strict mapping from `ToolStreamEvent.kind` ‚Üí engine event channels (`transcript`, `ui`, `diagnostic`, `telemetry`) so:
+  - [ ] user-visible output is never emitted on diagnostic-only channels
+  - [ ] diagnostic output is never treated as transcript content
+  - [ ] hosts can safely ‚Äúrender only transcript‚Äù without missing required user content
+- [ ] Define ‚Äúreplaceable output‚Äù semantics for status-like UI (e.g., progress/status line):
+  - [ ] stable `replaceKey` contract (replaces prior event with same key in UI-only views)
+  - [ ] explicit rule: replaceable output must not alter persisted transcript ordering (persist summaries, not per-tick status)
+- [ ] Define truncation/overflow semantics for high-volume tool streams:
+  - [ ] deterministic thresholds (bytes, chunks, time) per host/policy
+  - [ ] required ‚Äútruncated‚Äù marker event containing counters and a retrieval hint (attachment ref if available)
+  - [ ] test fixtures for ‚Äúhuge output‚Äù ensuring bounded memory usage and stable final summaries
+- [ ] Define transcript persistence rules for tool streams:
+  - [ ] default: persist only summarized output + hashes/counters for chunks flagged sensitive
+  - [ ] debug mode (policy-gated): persist bounded raw chunks with redaction applied
+  - [ ] explicit replay strategy: compare hashes/counters for sensitive streams instead of raw content
 
 8.6 Tool isolation and sandboxing (without OS processes)
 - [ ] Define an isolation policy spectrum: in-process trusted tools (default) vs constrained tools (limited capabilities) vs remote tools.
@@ -855,6 +952,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +993,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -942,6 +1074,19 @@
 - [ ] Define matcher evaluation semantics (regex compilation failures, wildcard matching rules, OR-pattern parsing) and required error reporting.
 - [ ] Define hook identity/dedup keys and explicitly document which hook types are deduped and which are not (parity with legacy where required).
 - [ ] Define the final execution order rules across merged sources (stable sort: source precedence ‚Üí matcher order ‚Üí hook order).
+- [ ] Define canonical matching inputs per event type (normalized strings/fields) and prohibit matching against raw, potentially sensitive payloads by default.
+- [ ] Define regex safety constraints for portability:
+  - [ ] require a deterministic ‚Äúregex compile‚Äù stage at config load time (never compile on the hot path)
+  - [ ] define behavior when regex features are unsupported on a host (reject with actionable diagnostics vs degrade to literal)
+  - [ ] define protection against catastrophic backtracking (allowed regex subset, timeout budget, or safe-regex engine decision gate)
+- [ ] Define matcher caching rules (compiled patterns cached by hookId + definitionVersion) and invalidation on config changes.
+- [ ] Define performance invariants and testable limits:
+  - [ ] max matchers evaluated per event
+  - [ ] max hooks executed per event
+  - [ ] deterministic early-exit rules when a blocking effect occurs (what still runs, what is skipped)
+- [ ] Add golden tests for matching determinism:
+  - [ ] same config produces identical matched-hook lists across Node/web/RN-like adapters
+  - [ ] invalid matcher errors include hook source attribution and do not change unrelated hook ordering
 
 9.7 Model-driven hooks parity (prompt hooks and agent hooks without shell)
 - [ ] Define a portable ‚Äúmodel check‚Äù hook type that requires structured output (boolean + optional reason) and runs with explicit token/thinking limits.
@@ -1057,6 +1202,19 @@
 10.7 Mobile-safe transport constraints (explicit, testable)
 - [ ] Define a transport capability matrix: what is supported on RN/web/Node (fetch streaming, SSE, WebSocket) and what is optional.
 - [ ] Define fallback behaviors when streaming is unavailable (buffered responses with progress heuristics; explicit UI messaging).
+- [ ] Define liveness and keepalive requirements for long-lived transports:
+  - [ ] heartbeat/keepalive intervals (policy-configurable, bounded)
+  - [ ] idle timeout behavior (close vs keep open) per host
+  - [ ] deterministic ‚Äúconnection considered dead‚Äù thresholds for reconnection logic
+- [ ] Define resume semantics where feasible:
+  - [ ] resume token/cursor fields carried in envelopes
+  - [ ] explicit behavior when resume is not supported (fail-fast with retry guidance)
+- [ ] Define web-specific constraints explicitly:
+  - [ ] CORS and credential mode requirements for endpoint mode
+  - [ ] prohibition on assuming raw sockets or localhost reachability in browsers
+- [ ] Define mobile lifecycle constraints explicitly:
+  - [ ] what happens to in-flight streaming calls on background (cancel vs pause) per platform policy
+  - [ ] required UI messaging when backgrounding cancels MCP tool calls
 - [ ] Add conformance tests that simulate:
   - [ ] endpoint config missing ‚Üí warning + fallback behavior
   - [ ] connection failed ‚Üí typed error + retry/backoff rules
@@ -1083,6 +1241,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1804,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1846,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1859,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 


[35m[3mthinking[0m[0m
**Updating task counts**

I'm noticing that we've added more tasks, which means the checklist count has increased. I need to update the summary count accordingly, so I‚Äôll need to recount everything. That sounds straightforward enough, but I want to make sure I do it right. I‚Äôll go ahead and rerun the count to ensure everything reflects the current tasks accurately. Getting this done is essential for keeping everything organized!
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..db58fcfc86c5eba129ba3e16751eed33e0c7de3e
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -767,6 +849,21 @@
 - [ ] Define how to render tool output consistently across CLI and RN/web UIs (UI adapter responsibility).
 - [ ] Define how tool outputs are persisted (final result + optionally a bounded stream transcript for debugging).
 - [ ] Define how to handle binary-like outputs (file diffs, patches) without leaking huge payloads into transcripts by default.
+- [ ] Define a strict mapping from `ToolStreamEvent.kind` ‚Üí engine event channels (`transcript`, `ui`, `diagnostic`, `telemetry`) so:
+  - [ ] user-visible output is never emitted on diagnostic-only channels
+  - [ ] diagnostic output is never treated as transcript content
+  - [ ] hosts can safely ‚Äúrender only transcript‚Äù without missing required user content
+- [ ] Define ‚Äúreplaceable output‚Äù semantics for status-like UI (e.g., progress/status line):
+  - [ ] stable `replaceKey` contract (replaces prior event with same key in UI-only views)
+  - [ ] explicit rule: replaceable output must not alter persisted transcript ordering (persist summaries, not per-tick status)
+- [ ] Define truncation/overflow semantics for high-volume tool streams:
+  - [ ] deterministic thresholds (bytes, chunks, time) per host/policy
+  - [ ] required ‚Äútruncated‚Äù marker event containing counters and a retrieval hint (attachment ref if available)
+  - [ ] test fixtures for ‚Äúhuge output‚Äù ensuring bounded memory usage and stable final summaries
+- [ ] Define transcript persistence rules for tool streams:
+  - [ ] default: persist only summarized output + hashes/counters for chunks flagged sensitive
+  - [ ] debug mode (policy-gated): persist bounded raw chunks with redaction applied
+  - [ ] explicit replay strategy: compare hashes/counters for sensitive streams instead of raw content
 
 8.6 Tool isolation and sandboxing (without OS processes)
 - [ ] Define an isolation policy spectrum: in-process trusted tools (default) vs constrained tools (limited capabilities) vs remote tools.
@@ -855,6 +952,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +993,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -942,6 +1074,19 @@
 - [ ] Define matcher evaluation semantics (regex compilation failures, wildcard matching rules, OR-pattern parsing) and required error reporting.
 - [ ] Define hook identity/dedup keys and explicitly document which hook types are deduped and which are not (parity with legacy where required).
 - [ ] Define the final execution order rules across merged sources (stable sort: source precedence ‚Üí matcher order ‚Üí hook order).
+- [ ] Define canonical matching inputs per event type (normalized strings/fields) and prohibit matching against raw, potentially sensitive payloads by default.
+- [ ] Define regex safety constraints for portability:
+  - [ ] require a deterministic ‚Äúregex compile‚Äù stage at config load time (never compile on the hot path)
+  - [ ] define behavior when regex features are unsupported on a host (reject with actionable diagnostics vs degrade to literal)
+  - [ ] define protection against catastrophic backtracking (allowed regex subset, timeout budget, or safe-regex engine decision gate)
+- [ ] Define matcher caching rules (compiled patterns cached by hookId + definitionVersion) and invalidation on config changes.
+- [ ] Define performance invariants and testable limits:
+  - [ ] max matchers evaluated per event
+  - [ ] max hooks executed per event
+  - [ ] deterministic early-exit rules when a blocking effect occurs (what still runs, what is skipped)
+- [ ] Add golden tests for matching determinism:
+  - [ ] same config produces identical matched-hook lists across Node/web/RN-like adapters
+  - [ ] invalid matcher errors include hook source attribution and do not change unrelated hook ordering
 
 9.7 Model-driven hooks parity (prompt hooks and agent hooks without shell)
 - [ ] Define a portable ‚Äúmodel check‚Äù hook type that requires structured output (boolean + optional reason) and runs with explicit token/thinking limits.
@@ -1057,6 +1202,19 @@
 10.7 Mobile-safe transport constraints (explicit, testable)
 - [ ] Define a transport capability matrix: what is supported on RN/web/Node (fetch streaming, SSE, WebSocket) and what is optional.
 - [ ] Define fallback behaviors when streaming is unavailable (buffered responses with progress heuristics; explicit UI messaging).
+- [ ] Define liveness and keepalive requirements for long-lived transports:
+  - [ ] heartbeat/keepalive intervals (policy-configurable, bounded)
+  - [ ] idle timeout behavior (close vs keep open) per host
+  - [ ] deterministic ‚Äúconnection considered dead‚Äù thresholds for reconnection logic
+- [ ] Define resume semantics where feasible:
+  - [ ] resume token/cursor fields carried in envelopes
+  - [ ] explicit behavior when resume is not supported (fail-fast with retry guidance)
+- [ ] Define web-specific constraints explicitly:
+  - [ ] CORS and credential mode requirements for endpoint mode
+  - [ ] prohibition on assuming raw sockets or localhost reachability in browsers
+- [ ] Define mobile lifecycle constraints explicitly:
+  - [ ] what happens to in-flight streaming calls on background (cancel vs pause) per platform policy
+  - [ ] required UI messaging when backgrounding cancels MCP tool calls
 - [ ] Add conformance tests that simulate:
   - [ ] endpoint config missing ‚Üí warning + fallback behavior
   - [ ] connection failed ‚Üí typed error + retry/backoff rules
@@ -1083,6 +1241,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1804,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1846,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1859,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "python - <<'PY'
import re
path='implementation/1-initial-rewrite-implementation-checklist.md'
count=0
with open(path,'r',encoding='utf-8') as f:
    for line in f:
        if re.match(r\""'^'"\\s*- \\[ \\]\", line):
            count+=1
print(count)
PY"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 92ms:[0m
[2m1291[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..db58fcfc86c5eba129ba3e16751eed33e0c7de3e
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -767,6 +849,21 @@
 - [ ] Define how to render tool output consistently across CLI and RN/web UIs (UI adapter responsibility).
 - [ ] Define how tool outputs are persisted (final result + optionally a bounded stream transcript for debugging).
 - [ ] Define how to handle binary-like outputs (file diffs, patches) without leaking huge payloads into transcripts by default.
+- [ ] Define a strict mapping from `ToolStreamEvent.kind` ‚Üí engine event channels (`transcript`, `ui`, `diagnostic`, `telemetry`) so:
+  - [ ] user-visible output is never emitted on diagnostic-only channels
+  - [ ] diagnostic output is never treated as transcript content
+  - [ ] hosts can safely ‚Äúrender only transcript‚Äù without missing required user content
+- [ ] Define ‚Äúreplaceable output‚Äù semantics for status-like UI (e.g., progress/status line):
+  - [ ] stable `replaceKey` contract (replaces prior event with same key in UI-only views)
+  - [ ] explicit rule: replaceable output must not alter persisted transcript ordering (persist summaries, not per-tick status)
+- [ ] Define truncation/overflow semantics for high-volume tool streams:
+  - [ ] deterministic thresholds (bytes, chunks, time) per host/policy
+  - [ ] required ‚Äútruncated‚Äù marker event containing counters and a retrieval hint (attachment ref if available)
+  - [ ] test fixtures for ‚Äúhuge output‚Äù ensuring bounded memory usage and stable final summaries
+- [ ] Define transcript persistence rules for tool streams:
+  - [ ] default: persist only summarized output + hashes/counters for chunks flagged sensitive
+  - [ ] debug mode (policy-gated): persist bounded raw chunks with redaction applied
+  - [ ] explicit replay strategy: compare hashes/counters for sensitive streams instead of raw content
 
 8.6 Tool isolation and sandboxing (without OS processes)
 - [ ] Define an isolation policy spectrum: in-process trusted tools (default) vs constrained tools (limited capabilities) vs remote tools.
@@ -855,6 +952,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +993,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -942,6 +1074,19 @@
 - [ ] Define matcher evaluation semantics (regex compilation failures, wildcard matching rules, OR-pattern parsing) and required error reporting.
 - [ ] Define hook identity/dedup keys and explicitly document which hook types are deduped and which are not (parity with legacy where required).
 - [ ] Define the final execution order rules across merged sources (stable sort: source precedence ‚Üí matcher order ‚Üí hook order).
+- [ ] Define canonical matching inputs per event type (normalized strings/fields) and prohibit matching against raw, potentially sensitive payloads by default.
+- [ ] Define regex safety constraints for portability:
+  - [ ] require a deterministic ‚Äúregex compile‚Äù stage at config load time (never compile on the hot path)
+  - [ ] define behavior when regex features are unsupported on a host (reject with actionable diagnostics vs degrade to literal)
+  - [ ] define protection against catastrophic backtracking (allowed regex subset, timeout budget, or safe-regex engine decision gate)
+- [ ] Define matcher caching rules (compiled patterns cached by hookId + definitionVersion) and invalidation on config changes.
+- [ ] Define performance invariants and testable limits:
+  - [ ] max matchers evaluated per event
+  - [ ] max hooks executed per event
+  - [ ] deterministic early-exit rules when a blocking effect occurs (what still runs, what is skipped)
+- [ ] Add golden tests for matching determinism:
+  - [ ] same config produces identical matched-hook lists across Node/web/RN-like adapters
+  - [ ] invalid matcher errors include hook source attribution and do not change unrelated hook ordering
 
 9.7 Model-driven hooks parity (prompt hooks and agent hooks without shell)
 - [ ] Define a portable ‚Äúmodel check‚Äù hook type that requires structured output (boolean + optional reason) and runs with explicit token/thinking limits.
@@ -1057,6 +1202,19 @@
 10.7 Mobile-safe transport constraints (explicit, testable)
 - [ ] Define a transport capability matrix: what is supported on RN/web/Node (fetch streaming, SSE, WebSocket) and what is optional.
 - [ ] Define fallback behaviors when streaming is unavailable (buffered responses with progress heuristics; explicit UI messaging).
+- [ ] Define liveness and keepalive requirements for long-lived transports:
+  - [ ] heartbeat/keepalive intervals (policy-configurable, bounded)
+  - [ ] idle timeout behavior (close vs keep open) per host
+  - [ ] deterministic ‚Äúconnection considered dead‚Äù thresholds for reconnection logic
+- [ ] Define resume semantics where feasible:
+  - [ ] resume token/cursor fields carried in envelopes
+  - [ ] explicit behavior when resume is not supported (fail-fast with retry guidance)
+- [ ] Define web-specific constraints explicitly:
+  - [ ] CORS and credential mode requirements for endpoint mode
+  - [ ] prohibition on assuming raw sockets or localhost reachability in browsers
+- [ ] Define mobile lifecycle constraints explicitly:
+  - [ ] what happens to in-flight streaming calls on background (cancel vs pause) per platform policy
+  - [ ] required UI messaging when backgrounding cancels MCP tool calls
 - [ ] Add conformance tests that simulate:
   - [ ] endpoint config missing ‚Üí warning + fallback behavior
   - [ ] connection failed ‚Üí typed error + retry/backoff rules
@@ -1083,6 +1241,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1804,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1846,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1859,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -1868,3 +1868,3 @@
 
[31m-- Estimated checklist items in this iteration: ~1250 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).[0m
[32m+- Estimated checklist items in this iteration: ~1291 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).[0m
 - This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
[32mapply_patch(auto_approved=true) exited 0 in 21ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..26709be883d441d14fb1bffc4d51a0b56d56c42e
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -767,6 +849,21 @@
 - [ ] Define how to render tool output consistently across CLI and RN/web UIs (UI adapter responsibility).
 - [ ] Define how tool outputs are persisted (final result + optionally a bounded stream transcript for debugging).
 - [ ] Define how to handle binary-like outputs (file diffs, patches) without leaking huge payloads into transcripts by default.
+- [ ] Define a strict mapping from `ToolStreamEvent.kind` ‚Üí engine event channels (`transcript`, `ui`, `diagnostic`, `telemetry`) so:
+  - [ ] user-visible output is never emitted on diagnostic-only channels
+  - [ ] diagnostic output is never treated as transcript content
+  - [ ] hosts can safely ‚Äúrender only transcript‚Äù without missing required user content
+- [ ] Define ‚Äúreplaceable output‚Äù semantics for status-like UI (e.g., progress/status line):
+  - [ ] stable `replaceKey` contract (replaces prior event with same key in UI-only views)
+  - [ ] explicit rule: replaceable output must not alter persisted transcript ordering (persist summaries, not per-tick status)
+- [ ] Define truncation/overflow semantics for high-volume tool streams:
+  - [ ] deterministic thresholds (bytes, chunks, time) per host/policy
+  - [ ] required ‚Äútruncated‚Äù marker event containing counters and a retrieval hint (attachment ref if available)
+  - [ ] test fixtures for ‚Äúhuge output‚Äù ensuring bounded memory usage and stable final summaries
+- [ ] Define transcript persistence rules for tool streams:
+  - [ ] default: persist only summarized output + hashes/counters for chunks flagged sensitive
+  - [ ] debug mode (policy-gated): persist bounded raw chunks with redaction applied
+  - [ ] explicit replay strategy: compare hashes/counters for sensitive streams instead of raw content
 
 8.6 Tool isolation and sandboxing (without OS processes)
 - [ ] Define an isolation policy spectrum: in-process trusted tools (default) vs constrained tools (limited capabilities) vs remote tools.
@@ -855,6 +952,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +993,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -942,6 +1074,19 @@
 - [ ] Define matcher evaluation semantics (regex compilation failures, wildcard matching rules, OR-pattern parsing) and required error reporting.
 - [ ] Define hook identity/dedup keys and explicitly document which hook types are deduped and which are not (parity with legacy where required).
 - [ ] Define the final execution order rules across merged sources (stable sort: source precedence ‚Üí matcher order ‚Üí hook order).
+- [ ] Define canonical matching inputs per event type (normalized strings/fields) and prohibit matching against raw, potentially sensitive payloads by default.
+- [ ] Define regex safety constraints for portability:
+  - [ ] require a deterministic ‚Äúregex compile‚Äù stage at config load time (never compile on the hot path)
+  - [ ] define behavior when regex features are unsupported on a host (reject with actionable diagnostics vs degrade to literal)
+  - [ ] define protection against catastrophic backtracking (allowed regex subset, timeout budget, or safe-regex engine decision gate)
+- [ ] Define matcher caching rules (compiled patterns cached by hookId + definitionVersion) and invalidation on config changes.
+- [ ] Define performance invariants and testable limits:
+  - [ ] max matchers evaluated per event
+  - [ ] max hooks executed per event
+  - [ ] deterministic early-exit rules when a blocking effect occurs (what still runs, what is skipped)
+- [ ] Add golden tests for matching determinism:
+  - [ ] same config produces identical matched-hook lists across Node/web/RN-like adapters
+  - [ ] invalid matcher errors include hook source attribution and do not change unrelated hook ordering
 
 9.7 Model-driven hooks parity (prompt hooks and agent hooks without shell)
 - [ ] Define a portable ‚Äúmodel check‚Äù hook type that requires structured output (boolean + optional reason) and runs with explicit token/thinking limits.
@@ -1057,6 +1202,19 @@
 10.7 Mobile-safe transport constraints (explicit, testable)
 - [ ] Define a transport capability matrix: what is supported on RN/web/Node (fetch streaming, SSE, WebSocket) and what is optional.
 - [ ] Define fallback behaviors when streaming is unavailable (buffered responses with progress heuristics; explicit UI messaging).
+- [ ] Define liveness and keepalive requirements for long-lived transports:
+  - [ ] heartbeat/keepalive intervals (policy-configurable, bounded)
+  - [ ] idle timeout behavior (close vs keep open) per host
+  - [ ] deterministic ‚Äúconnection considered dead‚Äù thresholds for reconnection logic
+- [ ] Define resume semantics where feasible:
+  - [ ] resume token/cursor fields carried in envelopes
+  - [ ] explicit behavior when resume is not supported (fail-fast with retry guidance)
+- [ ] Define web-specific constraints explicitly:
+  - [ ] CORS and credential mode requirements for endpoint mode
+  - [ ] prohibition on assuming raw sockets or localhost reachability in browsers
+- [ ] Define mobile lifecycle constraints explicitly:
+  - [ ] what happens to in-flight streaming calls on background (cancel vs pause) per platform policy
+  - [ ] required UI messaging when backgrounding cancels MCP tool calls
 - [ ] Add conformance tests that simulate:
   - [ ] endpoint config missing ‚Üí warning + fallback behavior
   - [ ] connection failed ‚Üí typed error + retry/backoff rules
@@ -1083,6 +1241,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1804,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1846,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1859,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1291 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 

[35m[3mcodex[0m[0m
## Agent Change Log ‚Äî Iteration 5 of 5

### What sections were added or expanded
- Updated plan framing to Iteration 5 in `implementation/1-initial-rewrite-implementation-checklist.md`, refreshed ‚ÄúIteration 5 focus‚Äù, Risk Register header, Completion Criteria, and Checklist Summary (~1291 checklist items).
- Expanded Phase 3 runtime kernel:
  - Added `3.11` (portable runtime introspection: `RuntimeSnapshot`, progress/heartbeat definitions, deterministic hang detection, debug-dump command, policy gates).
  - Added `3.12` (replay capture artifact format + deterministic reproduction harness, redaction manifest, replay diff classifier, cross-host replay conformance).
- Expanded Phase 7 permissions/policy:
  - Deepened `7.9` with explicit network-approval canonicalization (scheme/ports, punycode/case-folding, IP literals, local-net classification, redirect handling + tests).
  - Added `7.10` (permission decision caching/invalidation: cacheability rules, cache keys, invalidation triggers, deterministic eviction, regression tests).
- Expanded Phase 8 tools (no subprocess model):
  - Deepened `8.1` with a stricter tool result/stream model (validated `ToolStreamEvent` envelope, attachment kinds + lifecycle + access control, deterministic truncation, elicitation IDs/dedupe, idempotency/dry-run/retry constraints).
  - Deepened `8.4` with explicit ‚Äúremote execution must not be local spawn‚Äù constraints and UX/policy visibility requirements.
  - Deepened `8.5` with deterministic streaming‚Üíchannel mapping, replaceable-output semantics, truncation markers + bounded memory fixtures, transcript hashing rules.
  - Added `8.13` (tool packaging/plugin design gates: manifest integrity, loading policy, sandboxing requirements, conformance tests).
- Expanded Phase 9 hooks:
  - Deepened `9.1` with hook identity/provenance + execution policy fields (priority/cooldown/budgets/concurrency), explicit ‚Äúno capability requests‚Äù rule, schema size constraints, conformance tests.
  - Deepened `9.6` with matcher safety/perf (compile-at-load, unsupported-feature behavior, catastrophic-backtracking mitigation gate, caching/invalidation, deterministic early-exit rules, golden determinism tests).
- Expanded Phase 10 MCP:
  - Deepened `10.7` with liveness/keepalive requirements, resume semantics, explicit web CORS/localhost constraints, explicit mobile background semantics.
  - Added `10.10` (server registry persistence + trust levels + default permission posture).
  - Added `10.11` (schema caching + drift detection + permission revalidation + recovery tests).
  - Added `10.12` (stream normalization + deterministic truncation + ‚Äúno streaming‚Äù fallback contract + tests).

### What technical depth was increased
- Made ‚Äúdeterminism‚Äù operational: explicit progress definitions, hang detection thresholds, snapshot schemas, and replay artifacts with deterministic diff classification (engine-level, not UI-only).
- Turned tool streaming/attachments into testable contracts: envelope validation, persistence/redaction rules, boundedness guarantees, replaceable UI output semantics, and deterministic truncation markers.
- Hardened policy/permissions beyond ‚Äúask/allow/deny‚Äù: canonical target normalization for network approvals, cacheability boundaries, invalidation ordering, and regression assertions that caching cannot alter behavior.
- Added concrete MCP robustness requirements: server trust model, schema drift handling tied to permissions, stream normalization independent of transport chunking, and mobile/web constraints explicitly enumerated.

### Assumptions made
- A replay harness can represent nondeterministic host inputs as recorded ‚Äúcapability responses‚Äù without capturing secrets (via redaction + manifest).
- Cross-host ‚Äúweb-like‚Äù and ‚ÄúRN-like‚Äù adapters can be validated in CI using deterministic fakes/stubs even if full device E2E is deferred.
- Resume semantics for MCP streaming are treated as ‚Äúwhere feasible‚Äù (protocol/transport capability-dependent), with explicit non-resume fallback behavior required.

### What remains incomplete or risky
- Isolation/sandboxing mechanism choice remains deferred (worker/realm/SES/etc.); plan now states requirements but not a committed tech stack.
- Regex safety is still a decision gate (allowed subset vs safe engine vs timeouts); portability constraints are now explicit but not resolved.
- MCP resume/drift handling assumes servers expose sufficient identifiers/manifests; exact interoperability details remain protocol/implementation-dependent.
- WASM feasibility/performance on RN runtimes (Hermes/JSC) remains a primary risk for search/git parity; mitigations are listed but require prototyping/benchmarks.
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 6d85d6a5db41aaeb0f149b96131f0c345f1f73c0..26709be883d441d14fb1bffc4d51a0b56d56c42e
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -1,4 +1,4 @@
-# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 4)
+# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)
 
 ## Project Overview
 
@@ -18,7 +18,7 @@
 - Permissions and policy are explicit, enforceable, and testable across hosts.
 - MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
 
-### Explicit non-goals (Iteration 4 scope guards)
+### Explicit non-goals (Iteration 5 scope guards)
 
 - Do not lock in final public APIs for hooks/tools/permissions in this iteration; define boundaries, lifecycles, and data flow first.
 - Do not commit to Node-only APIs (e.g., `fs`, `child_process`, `AsyncLocalStorage`) in core modules.
@@ -26,13 +26,14 @@
 - Do not optimize prematurely (performance work is staged behind correctness + determinism).
 - Do not ‚Äúsolve‚Äù portability by adding hidden host-only fallbacks; missing capabilities must be explicit, typed, and user-visible.
 
-### Iteration 4 focus (what changed vs Iteration 3)
+### Iteration 5 focus (what changed vs Iteration 4)
 
-- Deepened the runtime kernel further with explicit event-envelope contracts (channel QoS, cursor persistence, replay checkpoints) and UI-preemption invariants that can be asserted under deterministic tests.
-- Tightened the ‚Äúno subprocess anywhere‚Äù constraint into concrete enforcement and parity work items (tool tracks must be in-process/WASM/remote; desktop ‚Äúshell-like‚Äù features are explicitly deferred behind non-process alternatives).
-- Expanded tool execution details around isolation without OS processes (capability membranes, worker message-passing contracts, deterministic chunking/backpressure invariants).
-- Expanded hook semantics around deterministic effect conflict resolution, recursion/loop prevention, and ‚Äúhook-initiated tool runs‚Äù safety constraints (still no shell).
-- Expanded MCP portability and security details (transport matrix, auth rotation, schema validation points, reconnection/resume policies) without locking to a single transport.
+- Deepened the runtime kernel into an operable spec: hang/progress detection, runtime introspection snapshots, and replay capture formats tied to deterministic clocks and event cursors.
+- Decomposed tool execution into fully testable contracts: tool stream envelopes, attachment lifecycles, idempotency/replay keys, and an explicit ‚Äúno pipeline bypass‚Äù enforcement model.
+- Expanded hooks into a portable workflow system: schema normalization rules, stricter recursion/loop guards, long-running hook replacement, and migration linting/auto-conversion boundaries.
+- Hardened permissions/policy into a full decision system: network approval canonicalization (scheme/host/IP/local-net), decision caching/invalidation rules, and policy refresh semantics across hosts.
+- Expanded MCP endpoint/direct into transport- and resume-aware behavior: schema drift handling, streaming fallback policy, strict auth handling, and external-client bridging constraints without state-file dependence.
+- Tightened testing/migration gates: deterministic ‚Äúgolden event streams‚Äù harness, cross-host conformance matrix, and explicit phase exit criteria for incremental cutover.
 
 ---
 
@@ -350,6 +351,44 @@
 - [ ] Define invariants that must hold at scope boundaries (no leaked timers, no leaked subscriptions, all streams closed, capability handles released).
 - [ ] Add deterministic tests that assert: closing a session scope cancels all tool/hook/MCP/background tasks and emits a bounded, redacted ‚Äúshutdown summary‚Äù event.
 
+3.11 Runtime introspection, hang detection, and debug controls (portable)
+- [ ] Define a `RuntimeSnapshot` schema that captures, at minimum:
+  - [ ] runnable queue depths by priority
+  - [ ] all live tasks (state, parent, labels, correlation IDs, start tick, last-yield tick)
+  - [ ] all live scopes and their owned tasks
+  - [ ] all active concurrency permits/limiters (current, max, wait queue length)
+  - [ ] all active streams (tool/hook/MCP) and last-emitted sequence numbers
+  - [ ] all pending timers/timeouts (owner task, deadline tick, reason)
+- [ ] Define a ‚Äúprogress heartbeat‚Äù mechanism: what constitutes progress (task yield, event emission, stream chunk) and how frequently progress must occur per long-running category.
+- [ ] Define hang detection rules that are deterministic under test:
+  - [ ] ‚Äúno progress for N monotonic ticks‚Äù thresholds per category (tool run, MCP streaming, background agent)
+  - [ ] explicit ‚Äúwaiting on user‚Äù states that suppress hang alerts
+  - [ ] single-fire escalation (emit diagnostic once per incident; no spam)
+  - [ ] escalation actions (capture snapshot, emit redacted summary, optionally cancel under explicit policy)
+- [ ] Define a portable ‚Äúdebug dump‚Äù engine command that emits a redacted `RuntimeSnapshot` + summary counters; hosts may attach stacks if available.
+- [ ] Define production safety gates: snapshot capture is bounded, redacted, and policy-controlled (may be disabled in managed environments).
+- [ ] Add conformance tests that assert:
+  - [ ] snapshots are deterministic given a seeded scheduler/test clock
+  - [ ] hang detection triggers exactly once per simulated hang and does not regress event ordering guarantees
+  - [ ] hang detection does not auto-cancel tasks that are awaiting elicitation/approvals unless configured
+
+3.12 Replay capture format and deterministic reproduction harness (engine-level)
+- [ ] Define a ‚Äúreplay capture‚Äù artifact format that can reproduce engine behavior without relying on host APIs:
+  - [ ] initial capability descriptor (availability + versions; no secrets)
+  - [ ] seeded RNG/UUID source identity
+  - [ ] deterministic clock timeline (monotonic ticks advanced by the harness)
+  - [ ] injected host events (lifecycle, connectivity) with timestamps
+  - [ ] injected UI inputs (prompt submit, approvals, elicitation responses) with stable IDs
+  - [ ] recorded nondeterministic capability responses (filesystem listing order, simulated network responses)
+- [ ] Define capture redaction rules (PII/secrets/file contents) and require a ‚Äúredaction manifest‚Äù explaining what was removed/hashed.
+- [ ] Define what is not captured (secret store contents; raw model thoughts) and how replays behave when those inputs are absent.
+- [ ] Define replay assertions:
+  - [ ] engine event sequences match (channel + seq + kind + correlation IDs)
+  - [ ] state snapshots at selected checkpoints match (hash-based diff)
+  - [ ] permission decisions + explanations match (source attribution)
+- [ ] Define a replay diff classifier (allowed nondeterminism vs benign UI formatting vs correctness regressions) and require it to be deterministic.
+- [ ] Add a conformance suite that replays a fixture capture across Node + web-like + RN-like adapters and asserts identical classified outcomes.
+
 ---
 
 ***Phase 4: Host Capability Abstraction (iOS/Web/Desktop-Safe)***
@@ -689,11 +728,34 @@
 
 7.9 Sandbox-network approval policy model (separate from tool permissions, but unified UX)
 - [ ] Define the ‚Äúnetwork approval‚Äù decision object (host, port/scheme if known, reason, originating task/tool, workspace scope) and its serialization for persistence and auditing.
+- [ ] Define canonicalization rules for network targets so approvals are stable and non-bypassable:
+  - [ ] normalize scheme (`https`, `http`, `wss`, `ws`) and default ports
+  - [ ] normalize hostnames (case-folding, punycode) and reject invalid/ambiguous hosts
+  - [ ] treat IP literals (IPv4/IPv6) distinctly from hostnames; specify whether DNS resolution affects approval matching
+  - [ ] classify loopback/local-network/private ranges explicitly and require separate policy gates for local network access
+  - [ ] define redirect handling (approve final destination only vs every hop) and require explicit tests for both policies
 - [ ] Define allow/deny persistence semantics for network approvals (domain patterns, expiry/TTL options, per-workspace vs global) and how policy can forbid persistence.
 - [ ] Define deterministic queueing semantics for multiple concurrent network approval requests (dedupe keys, stable ordering, cancellation if origin task cancels).
 - [ ] Define leader/worker mediation protocol for network approvals (request IDs, retries, ack/nack, timeout) without relying on filesystem mailboxes/state files.
 - [ ] Add conformance tests that assert: network approval decisions cannot be bypassed by direct `fetch` usage inside tools (capability filtered + policy enforced).
 
+7.10 Permission decision caching and invalidation (correctness-first performance)
+- [ ] Define which decisions are cacheable (pure function of inputs + effective settings + policy version + workspace trust) vs never cacheable (interactive prompts, time-sensitive, user-contextual).
+- [ ] Define canonical cache keys for tool permissions that include:
+  - [ ] tool identity + normalized input risk signature (schema-based, redacted)
+  - [ ] workspace identity/trust state
+  - [ ] effective config hash and policy hash/version
+  - [ ] capability availability fingerprint (to avoid ‚Äúallowed but unavailable‚Äù mismatches)
+- [ ] Define invalidation triggers (settings change, policy refresh, hook config change, workspace trust change) and deterministic ordering when multiple triggers occur.
+- [ ] Define cache storage semantics:
+  - [ ] in-memory only by default
+  - [ ] optional persisted cache with TTL (policy-controlled; never stores sensitive inputs)
+  - [ ] bounded size + eviction policy that is deterministic in tests (e.g., stable LRU keyed by monotonic ticks)
+- [ ] Add regression tests asserting caching does not change observable behavior:
+  - [ ] cached allow/deny decisions preserve explanation attribution
+  - [ ] cached ‚Äúask‚Äù decisions do not skip UI prompts
+  - [ ] invalidation happens before the next decision after a policy/settings update
+
 ---
 
 ***Phase 8: Tool Execution Layer (Async, Streaming, No Subprocess Model)***
@@ -715,10 +777,26 @@
 - [ ] Define a tool error model that preserves machine-readable codes (permission denied, capability missing, network error, invalid input, internal error).
 - [ ] Define the tool execution lifecycle events (queued, started, streaming, completed, failed, cancelled).
 - [ ] Define ‚Äútool start‚Äù semantics (when a tool is considered started: after permission decision, after pre-hooks, etc.) and make it consistent across tools.
-- [ ] Define how tools report structured attachments vs plain text outputs.
-- [ ] Define attachment size limits and persistence rules (what is stored in logs vs only surfaced in UI).
-- [ ] Define how tools can request elicitation/ask-user flows (portable, UI-mediated).
-- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation).
+- [ ] Define a canonical tool result model that separates:
+  - [ ] machine result (`data`, schema-validated)
+  - [ ] user-facing rendering hints (`display` summaries, optional; UI-controlled formatting)
+  - [ ] attachments (structured artifacts referenced by ID; persisted separately from logs)
+- [ ] Define a canonical `ToolStreamEvent` envelope (toolRunId, seq, tsMono, kind, payload, sensitivity) and validation rules at emit time.
+- [ ] Define attachment primitives and lifecycle:
+  - [ ] attachment kinds (file reference, diff/patch artifact, table, image, diagnostic bundle ref)
+  - [ ] storage location policy (in-memory vs persisted) and retention TTLs per host/policy
+  - [ ] reference semantics (by content hash + metadata; avoid duplicating large blobs in event logs)
+  - [ ] attachment access control (must respect permissions; UI cannot fetch an attachment if denied)
+- [ ] Define attachment size ceilings and truncation rules (deterministic, signaled in metadata).
+- [ ] Define how tools request elicitation/ask-user flows (portable, UI-mediated) including:
+  - [ ] request schema (prompt, choices, validation)
+  - [ ] cancellation/timeout semantics
+  - [ ] stable request IDs and dedupe behavior
+- [ ] Define how tools request additional permissions mid-run (must re-enter the permission pipeline; no implicit escalation) and how partial progress is handled if denied.
+- [ ] Define tool idempotency expectations:
+  - [ ] declare idempotent vs non-idempotent tools in registry metadata
+  - [ ] define ‚Äúdry run / preview‚Äù mode requirements for write tools (used by migration shadow mode)
+  - [ ] define how retries are handled (never auto-retry non-idempotent tools)
 
 8.2 Tool registry and discovery (portable and extensible)
 - [ ] Define a registry format for built-in tools (name, schema, capabilities required, permission categories).
@@ -754,6 +832,10 @@
   - [ ] remote execution via trusted host/server
   - [ ] capability-gated desktop-only implementation
   - [ ] deprecate/omit (with explicit rationale)
+- [ ] Define an explicit constraint for any ‚Äúremote execution‚Äù option:
+  - [ ] it must not be implemented by spawning local helper processes
+  - [ ] it must be an authenticated, separately deployed service or an explicit host capability
+  - [ ] it must be visible in permissions/policy UX (origin, destination, and risk classification)
 - [ ] Define a ‚Äúno subprocess in engine‚Äù enforcement test (static scan + runtime guard).
 - [ ] Define a parity plan for search/diff operations that avoids shelling out:
   - [ ] evaluate WASM search (ripgrep-wasm) vs TS search for common cases
@@ -767,6 +849,21 @@
 - [ ] Define how to render tool output consistently across CLI and RN/web UIs (UI adapter responsibility).
 - [ ] Define how tool outputs are persisted (final result + optionally a bounded stream transcript for debugging).
 - [ ] Define how to handle binary-like outputs (file diffs, patches) without leaking huge payloads into transcripts by default.
+- [ ] Define a strict mapping from `ToolStreamEvent.kind` ‚Üí engine event channels (`transcript`, `ui`, `diagnostic`, `telemetry`) so:
+  - [ ] user-visible output is never emitted on diagnostic-only channels
+  - [ ] diagnostic output is never treated as transcript content
+  - [ ] hosts can safely ‚Äúrender only transcript‚Äù without missing required user content
+- [ ] Define ‚Äúreplaceable output‚Äù semantics for status-like UI (e.g., progress/status line):
+  - [ ] stable `replaceKey` contract (replaces prior event with same key in UI-only views)
+  - [ ] explicit rule: replaceable output must not alter persisted transcript ordering (persist summaries, not per-tick status)
+- [ ] Define truncation/overflow semantics for high-volume tool streams:
+  - [ ] deterministic thresholds (bytes, chunks, time) per host/policy
+  - [ ] required ‚Äútruncated‚Äù marker event containing counters and a retrieval hint (attachment ref if available)
+  - [ ] test fixtures for ‚Äúhuge output‚Äù ensuring bounded memory usage and stable final summaries
+- [ ] Define transcript persistence rules for tool streams:
+  - [ ] default: persist only summarized output + hashes/counters for chunks flagged sensitive
+  - [ ] debug mode (policy-gated): persist bounded raw chunks with redaction applied
+  - [ ] explicit replay strategy: compare hashes/counters for sensitive streams instead of raw content
 
 8.6 Tool isolation and sandboxing (without OS processes)
 - [ ] Define an isolation policy spectrum: in-process trusted tools (default) vs constrained tools (limited capabilities) vs remote tools.
@@ -855,6 +952,24 @@
 - [ ] Define a CLI adapter mapping: CLI arguments ‚Üí engine commands ‚Üí typed output formatting (no separate process execution).
 - [ ] Define telemetry boundaries for commands (especially ‚Äúendpoint-mode dedupe‚Äù parity).
 
+8.13 Tool packaging, distribution, and plugin sandboxing (design gates; no code)
+- [ ] Define a tool packaging format for optional tools/plugins:
+  - [ ] manifest schema (tool IDs, schemas, required capabilities, versioning)
+  - [ ] integrity metadata (hash/signature) and trust source (policy-controlled allowlist)
+  - [ ] compatibility constraints (engine version range, host capability requirements)
+- [ ] Define a plugin loading policy model:
+  - [ ] disabled by default on mobile/web unless explicitly enabled by policy/user
+  - [ ] directory-based discovery only on filesystem hosts, and only within scoped, user-approved directories
+  - [ ] policy-managed allow/deny lists for plugin sources and identities
+- [ ] Define sandboxing requirements for plugin-provided tool code (if supported):
+  - [ ] no direct access to raw host capabilities; only mediated tool-context handles
+  - [ ] explicit resource budgets and hard timeouts
+  - [ ] deterministic message-passing contract if isolation is used (no shared mutable state assumptions)
+- [ ] Define conformance tests for plugin tool registration:
+  - [ ] manifests with forbidden capabilities are rejected at startup with actionable diagnostics
+  - [ ] plugin tools cannot register IDs that collide with built-ins or MCP tools
+  - [ ] plugin tools cannot emit events without valid envelopes/sequence numbers
+
 ---
 
 ***Phase 9: Hooks System Redesign (Pure Async, No Shell, Serializable)***
@@ -878,6 +993,23 @@
 - [ ] Define a ‚Äúhook config diff report‚Äù format that can be shown in UI when hooks change (parity with legacy ‚Äúhooks configuration changed‚Äù messaging).
 - [ ] Define deduplication semantics by hook type (preserve legacy intent where it matters).
 - [ ] Define explicit schema support for ‚Äústatus line‚Äù and ‚Äúfile suggestion‚Äù hooks (legacy has dedicated commands) as first-class events with constrained actions.
+- [ ] Define required hook identity and provenance fields:
+  - [ ] stable `hookId` (deterministic; not derived from file paths)
+  - [ ] `source` attribution (user config vs project config vs policy-managed vs plugin vs session-injected)
+  - [ ] versioned `definitionVersion` and optional `migratedFrom` legacy metadata
+- [ ] Define per-hook execution policy fields:
+  - [ ] `priority` (integer; stable sorting)
+  - [ ] `maxRunsPerSession` / `cooldownMs` (anti-spam controls; deterministic via monotonic clock)
+  - [ ] `concurrency` (serial per hook vs allow parallel; default serial)
+  - [ ] `budget` (time/IO/tool-call budget) and default budgets by event type
+- [ ] Define explicit ‚Äúcapability request‚Äù prohibition: hooks cannot request arbitrary capabilities; they may only request effects interpreted by the engine (tool runs/permission prompts remain mediated).
+- [ ] Add schema-level constraints that prevent unbounded growth:
+  - [ ] maximum matcher count
+  - [ ] maximum action count per hook
+  - [ ] maximum nested effect depth (if effects can reference sub-actions)
+- [ ] Add schema conformance tests:
+  - [ ] canonical stringification is stable across platforms
+  - [ ] invalid configs produce deterministic, user-actionable error reports (with source attribution)
 - [ ] ‚ö†Ô∏è Do not finalize the exact hook action API in this phase; define lifecycle + data flow boundaries only.
 
 9.2 Pure-async hook execution model (no shell, no environment variables)
@@ -942,6 +1074,19 @@
 - [ ] Define matcher evaluation semantics (regex compilation failures, wildcard matching rules, OR-pattern parsing) and required error reporting.
 - [ ] Define hook identity/dedup keys and explicitly document which hook types are deduped and which are not (parity with legacy where required).
 - [ ] Define the final execution order rules across merged sources (stable sort: source precedence ‚Üí matcher order ‚Üí hook order).
+- [ ] Define canonical matching inputs per event type (normalized strings/fields) and prohibit matching against raw, potentially sensitive payloads by default.
+- [ ] Define regex safety constraints for portability:
+  - [ ] require a deterministic ‚Äúregex compile‚Äù stage at config load time (never compile on the hot path)
+  - [ ] define behavior when regex features are unsupported on a host (reject with actionable diagnostics vs degrade to literal)
+  - [ ] define protection against catastrophic backtracking (allowed regex subset, timeout budget, or safe-regex engine decision gate)
+- [ ] Define matcher caching rules (compiled patterns cached by hookId + definitionVersion) and invalidation on config changes.
+- [ ] Define performance invariants and testable limits:
+  - [ ] max matchers evaluated per event
+  - [ ] max hooks executed per event
+  - [ ] deterministic early-exit rules when a blocking effect occurs (what still runs, what is skipped)
+- [ ] Add golden tests for matching determinism:
+  - [ ] same config produces identical matched-hook lists across Node/web/RN-like adapters
+  - [ ] invalid matcher errors include hook source attribution and do not change unrelated hook ordering
 
 9.7 Model-driven hooks parity (prompt hooks and agent hooks without shell)
 - [ ] Define a portable ‚Äúmodel check‚Äù hook type that requires structured output (boolean + optional reason) and runs with explicit token/thinking limits.
@@ -1057,6 +1202,19 @@
 10.7 Mobile-safe transport constraints (explicit, testable)
 - [ ] Define a transport capability matrix: what is supported on RN/web/Node (fetch streaming, SSE, WebSocket) and what is optional.
 - [ ] Define fallback behaviors when streaming is unavailable (buffered responses with progress heuristics; explicit UI messaging).
+- [ ] Define liveness and keepalive requirements for long-lived transports:
+  - [ ] heartbeat/keepalive intervals (policy-configurable, bounded)
+  - [ ] idle timeout behavior (close vs keep open) per host
+  - [ ] deterministic ‚Äúconnection considered dead‚Äù thresholds for reconnection logic
+- [ ] Define resume semantics where feasible:
+  - [ ] resume token/cursor fields carried in envelopes
+  - [ ] explicit behavior when resume is not supported (fail-fast with retry guidance)
+- [ ] Define web-specific constraints explicitly:
+  - [ ] CORS and credential mode requirements for endpoint mode
+  - [ ] prohibition on assuming raw sockets or localhost reachability in browsers
+- [ ] Define mobile lifecycle constraints explicitly:
+  - [ ] what happens to in-flight streaming calls on background (cancel vs pause) per platform policy
+  - [ ] required UI messaging when backgrounding cancels MCP tool calls
 - [ ] Add conformance tests that simulate:
   - [ ] endpoint config missing ‚Üí warning + fallback behavior
   - [ ] connection failed ‚Üí typed error + retry/backoff rules
@@ -1083,6 +1241,41 @@
   - [ ] security model (least privilege; no secrets in plaintext)
 - [ ] Define how name normalization and server resolution works without a state-file global namespace (server IDs stable, display names mutable).
 
+10.10 MCP server registry persistence and trust model (portable)
+- [ ] Define how MCP server configs are stored without assuming a writable filesystem:
+  - [ ] storage-backed registry (per-app and per-workspace partitions)
+  - [ ] policy-managed ‚Äúmanaged servers‚Äù that cannot be edited by the user
+  - [ ] migration mapping from legacy config locations (CLI files) into the registry schema
+- [ ] Define a trust model for MCP servers:
+  - [ ] trust level per server (trusted/untrusted/managed)
+  - [ ] default permission posture per trust level (deny-by-default for untrusted; explicit prompts)
+  - [ ] UI-required warnings when enabling untrusted servers (portable, not CLI-specific)
+- [ ] Define how server removal/disablement affects:
+  - [ ] cached tool/resource schemas (invalidate deterministically)
+  - [ ] in-flight requests (cancel vs allow completion; must be explicit and tested)
+
+10.11 MCP schema caching, invalidation, and drift handling
+- [ ] Define caching policy for MCP tool/resource manifests (TTL, invalidation on reconnect, invalidation on auth rotation).
+- [ ] Define ‚Äúschema drift‚Äù handling when a server changes tool schemas:
+  - [ ] detect changes (hash of manifest) and emit diagnostic event with server attribution
+  - [ ] invalidate permission allowlists that refer to outdated schemas (force re-approval if risk category changes)
+  - [ ] require re-validation of any persisted ‚Äútool allow rules‚Äù that include schema-derived signatures
+- [ ] Add conformance tests that simulate:
+  - [ ] schema changes mid-session
+  - [ ] cached stale schema causing validation failure
+  - [ ] recovery path (refresh + re-run) without losing determinism in event sequencing
+
+10.12 MCP streaming normalization and truncation policies (portable UX parity)
+- [ ] Define normalization rules that map transport-specific streaming into the internal `ToolStreamEvent` model:
+  - [ ] stable chunk aggregation rules (do not rely on arbitrary packet segmentation)
+  - [ ] deterministic progress/coalescing behavior
+  - [ ] final counters (bytes/chunks/duration) derived from monotonic clock
+- [ ] Define truncation rules for overly-large MCP outputs (deterministic thresholds; always signal truncation in metadata; never silently drop).
+- [ ] Define a ‚Äústreaming unavailable‚Äù fallback contract:
+  - [ ] buffered responses with bounded memory usage
+  - [ ] UI messaging that explains reduced fidelity
+  - [ ] test fixtures that assert identical behavior across hosts lacking fetch streaming
+
 ---
 
 ***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
@@ -1611,16 +1804,18 @@
 
 ---
 
-***Risk Register & Mitigations (Iteration 4 Draft)***
+***Risk Register & Mitigations (Iteration 5 Draft)***
 
 - [ ] Risk: ‚ÄúNo subprocesses‚Äù conflicts with power-user expectations (git/rg/shell workflows). Mitigation: capability-gated substitutes (TS/WASM) + optional remote/desktop host, with clear UX and policy controls.
 - [ ] Risk: Portable streaming (ReadableStream vs AsyncIterator vs RN limitations) diverges by platform. Mitigation: define a single internal stream abstraction + adapters; enforce with cross-platform contract tests.
 - [ ] Risk: Event bus cursor/snapshot semantics cause duplicated or missing UI events across background/restore. Mitigation: explicit cursor persistence rules, at-least-once vs exactly-once contracts per channel, and replay-based integration tests.
+- [ ] Risk: Hang detection or ‚Äúno progress‚Äù heuristics spam diagnostics or cancel legitimate waits. Mitigation: category-specific progress definitions, explicit ‚Äúwaiting on user‚Äù states, and deterministic single-fire escalation rules.
 - [ ] Risk: Hook redesign breaks existing user workflows. Mitigation: migration tooling + compatibility lints + staged deprecation; prioritize declarative equivalents for common patterns.
 - [ ] Risk: Permission semantics drift due to re-interpretation of precedence and tool-specific logic. Mitigation: golden tests from legacy behavior; ‚Äúexplainability‚Äù field must attribute sources.
 - [ ] Risk: Global hook gates (`disableAllHooks`, managed-only hooks) behave differently across hosts and surprise users. Mitigation: explicit precedence spec + diagnostics that show which gate suppressed hook execution + golden regression sessions.
 - [ ] Risk: MCP direct mode transport may not be feasible on web/mobile. Mitigation: endpoint-first design; direct mode as host-dependent optional.
 - [ ] Risk: MCP streaming/backpressure differs across fetch implementations (RN vs web) and leads to memory spikes. Mitigation: bounded buffering + transport conformance tests + budgets (Phase 3.10).
+- [ ] Risk: MCP schema drift changes tool risk profile silently (server updates). Mitigation: manifest hashing + drift diagnostics + permission revalidation gates.
 - [ ] Risk: Background agents consume too many resources on mobile. Mitigation: explicit budgets + lifecycle pause/resume rules + feature gates.
 - [ ] Risk: Settings watchers are not uniformly available. Mitigation: treat ‚Äúwatch‚Äù as optional; rely on explicit ‚Äúrefresh‚Äù triggers and storage events where possible.
 - [ ] Risk: WASM-based search/git engines exceed mobile memory/CPU budgets or are incompatible with some RN runtimes. Mitigation: dual-path (WASM + TS fallback), strict budgets, and capability-gated feature reduction on constrained hosts.
@@ -1651,6 +1846,7 @@
 
 - ‚úÖ The core engine boots and runs on iOS (React Native) with filesystem/shell capabilities absent, using only injected portable capabilities.
 - ‚úÖ A deterministic scheduler test harness exists, and core concurrency behavior is reproducible under test (timeouts/cancellation/streaming).
+- ‚úÖ A replay capture + deterministic reproduction harness exists, and a baseline set of golden captures replays identically across Node + web-like + RN-like adapters.
 - ‚úÖ Tool execution is async-first and does not rely on a process-per-task model; streaming output is consistent across CLI/RN/web adapters.
 - ‚úÖ Static ‚Äúno subprocess‚Äù enforcement passes across core and host adapters (no `child_process`/spawn/exec usage in the shipped codebase).
 - ‚úÖ Legacy `--ripgrep` behavior is replaced by an in-process `search.grep` command/tool with parity and performance gates; no packaged binaries/subprocesses required.
@@ -1663,14 +1859,15 @@
 - ‚úÖ Settings layering/merge semantics match legacy behavior unless explicitly changed, with structured errors and portable change propagation.
 - ‚úÖ Background agents run cooperatively with explicit budgets and safe mobile lifecycle behavior.
 - ‚úÖ Migration plan supports incremental cutover from the existing CLI with shadow-mode diff validation.
+- ‚úÖ A phase-gated cutover checklist exists with objective pass/fail criteria (parity suites, conformance matrices, and policy/redaction linting).
 - ‚úÖ Diagnostic bundles can be generated on all hosts and pass automated redaction linting.
 
 ---
 
 ***Checklist Summary***
 
-- Estimated checklist items in this iteration: ~1110 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
-- This is Iteration 4: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
+- Estimated checklist items in this iteration: ~1291 (auto-counted as lines matching `^\\s*- [ ]`; includes nested checklists).
+- This is Iteration 5: multiple sections intentionally avoid final API commitments and instead define boundaries, lifecycles, conformance suites, and testable invariants.
 
 ---
 

[3m[35mtokens used[0m[0m
158,130
## Agent Change Log ‚Äî Iteration 5 of 5

### What sections were added or expanded
- Updated plan framing to Iteration 5 in `implementation/1-initial-rewrite-implementation-checklist.md`, refreshed ‚ÄúIteration 5 focus‚Äù, Risk Register header, Completion Criteria, and Checklist Summary (~1291 checklist items).
- Expanded Phase 3 runtime kernel:
  - Added `3.11` (portable runtime introspection: `RuntimeSnapshot`, progress/heartbeat definitions, deterministic hang detection, debug-dump command, policy gates).
  - Added `3.12` (replay capture artifact format + deterministic reproduction harness, redaction manifest, replay diff classifier, cross-host replay conformance).
- Expanded Phase 7 permissions/policy:
  - Deepened `7.9` with explicit network-approval canonicalization (scheme/ports, punycode/case-folding, IP literals, local-net classification, redirect handling + tests).
  - Added `7.10` (permission decision caching/invalidation: cacheability rules, cache keys, invalidation triggers, deterministic eviction, regression tests).
- Expanded Phase 8 tools (no subprocess model):
  - Deepened `8.1` with a stricter tool result/stream model (validated `ToolStreamEvent` envelope, attachment kinds + lifecycle + access control, deterministic truncation, elicitation IDs/dedupe, idempotency/dry-run/retry constraints).
  - Deepened `8.4` with explicit ‚Äúremote execution must not be local spawn‚Äù constraints and UX/policy visibility requirements.
  - Deepened `8.5` with deterministic streaming‚Üíchannel mapping, replaceable-output semantics, truncation markers + bounded memory fixtures, transcript hashing rules.
  - Added `8.13` (tool packaging/plugin design gates: manifest integrity, loading policy, sandboxing requirements, conformance tests).
- Expanded Phase 9 hooks:
  - Deepened `9.1` with hook identity/provenance + execution policy fields (priority/cooldown/budgets/concurrency), explicit ‚Äúno capability requests‚Äù rule, schema size constraints, conformance tests.
  - Deepened `9.6` with matcher safety/perf (compile-at-load, unsupported-feature behavior, catastrophic-backtracking mitigation gate, caching/invalidation, deterministic early-exit rules, golden determinism tests).
- Expanded Phase 10 MCP:
  - Deepened `10.7` with liveness/keepalive requirements, resume semantics, explicit web CORS/localhost constraints, explicit mobile background semantics.
  - Added `10.10` (server registry persistence + trust levels + default permission posture).
  - Added `10.11` (schema caching + drift detection + permission revalidation + recovery tests).
  - Added `10.12` (stream normalization + deterministic truncation + ‚Äúno streaming‚Äù fallback contract + tests).

### What technical depth was increased
- Made ‚Äúdeterminism‚Äù operational: explicit progress definitions, hang detection thresholds, snapshot schemas, and replay artifacts with deterministic diff classification (engine-level, not UI-only).
- Turned tool streaming/attachments into testable contracts: envelope validation, persistence/redaction rules, boundedness guarantees, replaceable UI output semantics, and deterministic truncation markers.
- Hardened policy/permissions beyond ‚Äúask/allow/deny‚Äù: canonical target normalization for network approvals, cacheability boundaries, invalidation ordering, and regression assertions that caching cannot alter behavior.
- Added concrete MCP robustness requirements: server trust model, schema drift handling tied to permissions, stream normalization independent of transport chunking, and mobile/web constraints explicitly enumerated.

### Assumptions made
- A replay harness can represent nondeterministic host inputs as recorded ‚Äúcapability responses‚Äù without capturing secrets (via redaction + manifest).
- Cross-host ‚Äúweb-like‚Äù and ‚ÄúRN-like‚Äù adapters can be validated in CI using deterministic fakes/stubs even if full device E2E is deferred.
- Resume semantics for MCP streaming are treated as ‚Äúwhere feasible‚Äù (protocol/transport capability-dependent), with explicit non-resume fallback behavior required.

### What remains incomplete or risky
- Isolation/sandboxing mechanism choice remains deferred (worker/realm/SES/etc.); plan now states requirements but not a committed tech stack.
- Regex safety is still a decision gate (allowed subset vs safe engine vs timeouts); portability constraints are now explicit but not resolved.
- MCP resume/drift handling assumes servers expose sufficient identifiers/manifests; exact interoperability details remain protocol/implementation-dependent.
- WASM feasibility/performance on RN runtimes (Hermes/JSC) remains a primary risk for search/git parity; mitigations are listed but require prototyping/benchmarks.
