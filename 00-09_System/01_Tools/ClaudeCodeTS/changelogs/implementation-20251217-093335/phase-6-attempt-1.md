Reading prompt from stdin...
OpenAI Codex v0.73.0 (research preview)
--------
[1mworkdir:[0m /Users/ronaldeddings/ClaudeCodeTS
[1mmodel:[0m gpt-5.2
[1mprovider:[0m openai
[1mapproval:[0m never
[1msandbox:[0m danger-full-access
[1mreasoning effort:[0m high
[1mreasoning summaries:[0m auto
[1msession id:[0m 019b2cfb-3d37-7b12-9bec-70f1ff225df0
--------
[36muser[0m
You are implementing PHASE 6 of 19.

==============================================
MISSION: IMPLEMENT THE REWRITE PLAN (PHASE-BY-PHASE)
==============================================

AUTHORITATIVE INPUTS:
- Implementation Plan: @/Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md
- CLI Encyclopedia: @CLI_ENCYCLOPEDIA.md
- Bundles directory: @/Users/ronaldeddings/ClaudeCodeTS/bundles
- Target source directory: @src
- Local docs directory: @/Users/ronaldeddings/ClaudeCodeTS/docs

PREVIOUS PHASE CHANGELOG:
- @/Users/ronaldeddings/ClaudeCodeTS/changelogs/implementation-20251217-093335/phase-5-changelog.md

CRITICAL RULES:
1) Only implement PHASE 6 right now.
2) Do NOT jump ahead to future phases.
3) Read the relevant files thoroughly, especially the bundled/minified cli.js files @bundles/ClaudeCodeCode/cli.js and @bundles/ClaudeAgentSDKCode/cli.js.
4) You must treat third-party code as dependencies ‚Äî do not re-implement vendor internals.
5) You must build a clean TypeScript module graph in ./src that matches the plan and the encyclopedia and @/Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md
6) Prefer async-first JS/TS, no subprocess-centric control flow.

AUTHENTICATION REQUIREMENT (SAFE):
- Use keychain to extract secrets, search for Claude Code-credentials .... within it there is an accessToken.... Also reference CLAUDE_CODE_SESSION_ACCESS_TOKEN in our old cli.js files
- Assume that using the keychain secret will log you in and you do NOT need to run /login.
- If you're able to run 'claude --dangerously-skip-permissions -p sayhello' and if it works, then creds are good and your code is not good.

WHAT TO DO IN THIS PHASE:
- Locate the 'Phase 6' section in the implementation plan and implement it fully.
- Check off every completed item in that Phase in the plan.
- Add at least one test that proves the phase works (or explain why a test is not applicable).
- If something is ambiguous, make a reasonable best decision and record it in the changelog as a 'Decision'.

VALIDATION:
- Run [0m[1mbun test [0m[2mv1.3.4 (5eb2145b)[0m, , and Import boundary check passed..
- ALSO: YOU MUST RUN THE IDENTICAL COMMAANDS that are in the previous cli.js files....
- If you cannot run something, explain why and what command should be run by the user.

STDOUT CONTRACT:
- Output ONLY a PHASE Change Log.
- Include these sections:
  1) Summary (what you accomplished in Phase 6)
  2) Files changed (created/modified/deleted)
  3) Decisions made (with rationale)
  4) Tests/validation run + results
  5) Remaining work inside Phase 6 (if any)
  6) Handoff notes for next phase

DO NOT print source code to stdout.
Begin now.

[36mmcp:[0m chrome-devtools starting
[36mmcp:[0m context7 starting
[36mmcp:[0m context7 ready
[36mmcp:[0m chrome-devtools ready
[36mmcp startup:[0m ready: context7, chrome-devtools


[35m[3mthinking[0m[0m
**Implementing phase six**

I need to focus on implementing phase six only. First, I‚Äôll find the section for phase six in the implementation plan. I'll read the relevant files carefully, especially the bundled cli.js files in both ClaudeCodeCode and ClaudeAgentSDKCode. I also need to check the changelog for previous phases to guide my implementation in the source code. Then I‚Äôll mark off the completed phase items and add necessary tests. Finally, I'll run the required commands and look for validation in the old cli.js files.
[35m[3mthinking[0m[0m
**Executing necessary commands**

I need to run identical commands from the previous cli.js files, which may include something like `claude --dangerously-skip-permissions -p sayhello`. They mention running those commands, so I'll inspect the bundled cli.js files for potential `git` commands. I should create a multi-step plan, using the update_plan tool, and begin by reading the phase six section of the plan file. I‚Äôll utilize tools like ripgrep and sed for efficient file reading, focusing primarily on authentication requirements that might relate to this phase. Let's get started by executing shell commands.
[35mPlan update[0m
[3mStart Phase 6 by reading the implementation plan and authoritative references, then implement and validate only the Phase 6 scope.[0m
  [36m‚Üí[0m Read Phase 6 requirements
  [2m‚Ä¢[0m [2mInspect bundled CLI behavior[0m
  [2m‚Ä¢[0m [2mImplement Phase 6 modules[0m
  [2m‚Ä¢[0m [2mAdd Phase 6 tests[0m
  [2m‚Ä¢[0m [2mRun required validations[0m
  [2m‚Ä¢[0m [2mUpdate plan checklist and changelog[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'ls -la bundles && ls -la bundles/ClaudeCodeCode && ls -la bundles/ClaudeAgentSDKCode'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 55ms:[0m
[2mtotal 0
drwxr-xr-x   4 ronaldeddings  staff  128 Dec 16 11:13 .
drwxr-xr-x  22 ronaldeddings  staff  704 Dec 17 09:11 ..
drwxr-xr-x  17 ronaldeddings  staff  544 Dec 16 07:57 ClaudeAgentSDKCode
drwxr-xr-x  14 ronaldeddings  staff  448 Dec 16 07:57 ClaudeCodeCode
total 28328
drwxr-xr-x  14 ronaldeddings  staff       448 Dec 16 07:57 .
drwxr-xr-x   4 ronaldeddings  staff       128 Dec 16 11:13 ..
-rw-r--r--@  1 ronaldeddings  staff      6148 Dec 16 07:57 .DS_Store
-rw-r--r--   1 ronaldeddings  staff       551 Dec 15 07:25 bun.lock
-rwxr-xr-x   1 ronaldeddings  staff  10335889 Dec 15 07:25 cli.js
-rw-r--r--   1 ronaldeddings  staff       147 Dec 15 07:25 LICENSE.md
drwxr-xr-x   3 ronaldeddings  staff        96 Dec 15 07:25 node_modules
-rw-r--r--   1 ronaldeddings  staff      1200 Dec 15 07:25 package.json
-rw-r--r--   1 ronaldeddings  staff      1986 Dec 15 07:25 README.md
-rw-r--r--   1 ronaldeddings  staff   2478606 Dec 15 07:25 resvg.wasm
-rw-r--r--   1 ronaldeddings  staff     65063 Dec 15 07:25 sdk-tools.d.ts
-rw-r--r--   1 ronaldeddings  staff   1380769 Dec 15 07:25 tree-sitter-bash.wasm
-rwxr-xr-x   1 ronaldeddings  staff    205498 Dec 15 07:25 tree-sitter.wasm
drwxr-xr-x   3 ronaldeddings  staff        96 Dec 15 07:25 vendor[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,200p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 37ms:[0m
[2m# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)

## Project Overview

This project is a ground-up rewrite of the current Claude Code CLI application (two bundled variants) into a single, TypeScript-first, **platform-agnostic engine** that can run inside iOS (React Native), web, and desktop hosts. The rewrite explicitly removes the current architecture‚Äôs reliance on spawning child processes as an orchestration/concurrency mechanism, replacing it with **async-first, event-driven execution** and explicit cooperative scheduling.

### Why this rewrite exists

- The current system is tightly coupled to Node + filesystem + subprocess execution, which blocks mobile/web support and makes correctness/testing nondeterministic.
- Multiple ‚Äúsystems‚Äù (hooks, permissions, background tasks) exist primarily to manage process boundaries instead of explicit async boundaries.
- The bundled codebase is difficult to reason about and evolve; the rewrite aims for a clean module graph with explicit ownership boundaries.

### High-level goals

- Core ‚Äúengine‚Äù is TypeScript, portable, and deterministic under test.
- UI layers (CLI, React Native, web) are thin adapters over the engine.
- Tool execution, hooks, and background agents are implemented as **async tasks** (no process-per-task model).
- Permissions and policy are explicit, enforceable, and testable across hosts.
- MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'ls -la'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 35ms:[0m
[2mtotal 464
drwxr-xr-x   22 ronaldeddings  staff     704 Dec 17 09:11 .
drwxr-xr-x@ 288 ronaldeddings  staff    9216 Dec 17 09:41 ..
-rw-r--r--@   1 ronaldeddings  staff    6148 Dec 16 07:57 .DS_Store
drwxr-xr-x   13 ronaldeddings  staff     416 Dec 17 09:43 .git
-rw-r--r--    1 ronaldeddings  staff      25 Dec 16 11:39 .gitignore
-rw-r--r--    1 ronaldeddings  staff     809 Dec 16 12:33 bun.lock
drwxr-xr-x    4 ronaldeddings  staff     128 Dec 16 11:13 bundles
drwxr-xr-x   11 ronaldeddings  staff     352 Dec 17 09:33 changelogs
-rw-r--r--    1 ronaldeddings  staff  159739 Dec 15 07:25 CLI_ENCYCLOPEDIA.md
-rw-r--r--    1 ronaldeddings  staff    8625 Dec 15 07:25 CLI_FUNCTION_CLASS_MAP.md
drwxr-xr-x    4 ronaldeddings  staff     128 Dec 16 11:30 docs
drwxr-xr-x    3 ronaldeddings  staff      96 Dec 16 11:08 ignore
drwxr-xr-x    4 ronaldeddings  staff     128 Dec 17 06:19 implementation
-rw-r--r--    1 ronaldeddings  staff   17620 Dec 16 07:25 instruction.md
drwxr-xr-x    6 ronaldeddings  staff     192 Dec 16 12:33 node_modules
-rw-r--r--    1 ronaldeddings  staff     325 Dec 17 05:54 package.json
-rw-r--r--    1 ronaldeddings  staff    5429 Dec 16 12:54 runner-v2.sh
-rwxr-xr-x    1 ronaldeddings  staff   11046 Dec 17 09:12 runner-v3
drwxr-xr-x    6 ronaldeddings  staff     192 Dec 17 06:26 scripts[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "''^##+'"\\s*Phase\\s*6\\b|Phase\\s*6\\b\" implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 48ms:[0m
[2m582:***Phase 6: Settings and Configuration System (Layered, Watchable, Portable)***
661:Dependencies: Phase 6 settings model (sources), Phase 4 capability boundary, and Phase 5 prompt queue semantics.
996:Dependencies: Phase 6 settings (hook config sources), Phase 8 tool pipeline (hook integration), Phase 3 runtime (streaming).
1616:Dependencies: Phase 12 CLI adapter, Phase 6 settings compatibility, Phase 7 permissions parity.[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,200p' changelogs/implementation-20251217-093335/phase-5-changelog.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 37ms:[0m
[2m## Summary (Phase 5)

- Hardened Phase 5 queue determinism by making notification prioritization deterministic even when multiple notifications share the same priority.
- Added Phase 5 tests covering notification queue determinism, transcript redaction + hashing, and session-export attachment redaction.

## Files changed

- Modified: `src/core/state/notifications.ts`
- Added: `tests/phase5-notifications-and-redaction.test.ts`

## Decisions made

- Deterministic notification ordering: use insertion-order tie-breaks for equal-priority notifications to avoid relying on engine-specific `Array.sort` stability across hosts.
- Transcript hashing tests: use a `HostCrypto` shim backed by `node:crypto` in tests to validate the Phase 5 ‚Äúredaction + stable summary hash‚Äù contract without depending on global WebCrypto availability.

## Tests/validation run + results

- `bun test` (bun v1.3.4): PASS
- `bun run typecheck`: PASS
- `bun run check:boundaries`: PASS (`Import boundary check passed.`)[0m

[35m[3mthinking[0m[0m
**Reviewing plan details**

I have the plan file, but it's truncated. I need to locate the section for phase 6, particularly around line 582. I‚Äôll focus on the lines from 560 to 760 to ensure I read the relevant parts thoroughly. My goal is to get a clear understanding of this section for phase 6, as it seems crucial. Let‚Äôs dive in and see what I can find!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "nl -ba implementation/1-initial-rewrite-implementation-checklist.md | sed -n '560,780p'"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 43ms:[0m
[2m   560	  - [x] structured artifacts (JSON tool outputs)
   561	  - [x] binary artifacts (optional; capability-gated; stored out-of-line)
   562	- [x] Define redaction markers at the schema level (fields annotated as `sensitive`) and a deterministic redaction pass used by:
   563	  - [x] logs
   564	  - [x] diagnostic bundles
   565	  - [x] regression corpora
   566	- [x] Define transcript hashing/summary rules for tests (hash chunks + counts; avoid storing sensitive raw data).
   567	- [x] Define export/import behavior for sessions:
   568	  - [x] export contains transcript + minimal metadata + redacted attachments
   569	  - [x] import rehydrates into a read-only ‚Äúreplay session‚Äù unless explicitly migrated
   570	
   571	5.7 Derived views and UI adapter contracts (state-to-UI determinism)
   572	- [x] Define ‚Äúview model selectors‚Äù for each host UI (CLI/RN/web) as pure functions over canonical state (no host-specific IO in selectors).
   573	- [x] Define a stable transcript rendering contract (how tool/hook/MCP events become UI lines/cards) that is consistent across hosts and can be snapshot-tested.
   574	- [x] Define ‚Äústate diff‚Äù event emission rules (when to emit incremental diffs vs full snapshots) to keep mobile/web performant without losing determinism.
   575	- [x] Add golden snapshot tests that render a known transcript into each UI adapter‚Äôs view model and assert identical semantic output (text differs by UI chrome, not by meaning).
   576	
   577	5.8 Phase 5 sanity tests (prove state+queues+rendering)
   578	- [x] `tests/phase5-state.test.ts` asserts session lifecycle creation/activation, overlay selection precedence, and stable transcript semantic rendering.
   579	[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "nl -ba implementation/1-initial-rewrite-implementation-checklist.md | sed -n '580,700p'"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 43ms:[0m
[2m   580	---
   581	
   582	***Phase 6: Settings and Configuration System (Layered, Watchable, Portable)***
   583	
   584	Why this phase exists: settings drive permissions, hooks, tool behavior, MCP, and UI; the rewrite needs a portable equivalent of the legacy layered settings pipeline and watcher semantics.
   585	
   586	Risks mitigated: silent behavior drift, incorrect precedence, and non-portable IO/watch assumptions.
   587	
   588	Dependencies: Phase 4 storage abstraction and Phase 5 state/persistence.
   589	
   590	6.1 Schema strategy (types and validation without bundler artifacts)
   591	- [ ] Decide how settings schemas are authored and validated (schema-first with generated TS types, or TS-first with runtime validation).
   592	- [ ] Define a versioned settings schema format with explicit migration steps.
   593	- [ ] Define a strict parse/validate error model that can surface structured errors to UI (not just logs).
   594	- [ ] Define how ‚Äúempty/missing settings‚Äù are treated (valid empty object) and how IO errors are handled per source.
   595	- [ ] ‚ö†Ô∏è Do not decide final schema tooling yet; define required capabilities (runtime validation, JSON schema export, RN compatibility).
   596	
   597	6.2 Settings sources and precedence (portable representation of legacy behavior)
   598	- [ ] Define settings sources: user/project/local/policy/flag and non-file sources (cliArg/command/session) as first-class keys.
   599	- [ ] Define enabled-source selection semantics (legacy: allowlist for user/project/local, always include policy + flag).[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '630,660p' implementation/1-initial-rewrite-implementation-checklist.md | fold -w 120"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 44ms:[0m
[2m- [ ] Define how the engine behaves when policy settings are present but invalid (fail-closed vs ignore with warning; mu
st be explicit and tested).

6.7 Portable settings storage mapping (per-host implementation checklist)
- [ ] Define the storage keys / documents used to represent each source on non-filesystem hosts (user/project/local/poli
cy/flag).
- [ ] Define how ‚Äúproject settings‚Äù are scoped on mobile/web when there is no project root (explicit workspace concept, 
user-chosen workspace IDs).
- [ ] Define how policy-managed settings are delivered on mobile (secure fetch + cache) and how offline behavior works.
- [ ] Define how to export/import settings for support and migration (sanitized bundle; reproducible).

6.8 Settings-derived feature gates and computed configuration (make implicit toggles explicit)
- [ ] Inventory all legacy boolean ‚Äúswitches‚Äù that alter behavior (e.g., `disableAllHooks`, experimental MCP CLI enable,
 endpoint-mode enable, sandbox/network approval toggles) and classify each as:
  - [ ] portable setting (works on all hosts)
  - [ ] host-only setting (Node/desktop)
  - [ ] env/flag alias (CLI convenience only)
- [ ] Define a computed `EffectiveConfig` snapshot that the engine derives from settings + policy + host capabilities (s
ingle place to reason about feature gating).
- [ ] Define which fields in `EffectiveConfig` are safe to persist vs must remain ephemeral (session-only, host-only).[0m

[35m[3mthinking[0m[0m
**Implementing phase 6 modules**

Alright, so phase 6 includes steps 6.1 to 6.9, and I need to implement them all. I‚Äôm thinking that we might also need to rewrite and implement specific modules within src/core/settings for this phase. It‚Äôs a good idea to inspect the existing structure in the src folder so I can refresh my memory about the earlier phases. I‚Äôll start by making a list of what‚Äôs in src/core/settings and see what we have to work with.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'find src -maxdepth 4 -type f | sort'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 51ms:[0m
[2msrc/core/agents/index.ts
src/core/capabilities/audit.ts
src/core/capabilities/catalog.ts
src/core/capabilities/compliance.ts
src/core/capabilities/index.ts
src/core/capabilities/policy.ts
src/core/capabilities/view.ts
src/core/engine/index.ts
src/core/events/bus.ts
src/core/events/index.ts
src/core/events/recording.ts
src/core/events/streamAdapters.ts
src/core/filesystem/index.ts
src/core/filesystem/path.ts
src/core/hooks/index.ts
src/core/index.ts
src/core/mcp/index.ts
src/core/network/index.ts
src/core/network/retry.ts
src/core/permissions/index.ts[0m

[35m[3mthinking[0m[0m
**Reviewing settings files**

I see there's a core/settings/index.ts file, which seems minimal, so I should check it out. There might also be relevant spec legacy settings to consider. I plan to read through the files and consult the CLI_ENCYCLOPEDIA along with the spec/legacy/settings. It sounds like I'll need to look into layer merge semantics and also inspect the existing settings code to ensure I get a thorough understanding of everything involved.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,200p' src/core/settings/index.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 54ms:[0m
[2mexport type SettingsPlaceholder = {
  phase: "2";
};
[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,120p' src/core/types/schema.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 31ms:[0m
[2mexport type SchemaVersion = number;

export type SchemaKind =
  | "engine_event_envelope"
  | "settings_document"
  | "state_snapshot"
  | "session_export"
  | "hook_definition"
  | "hook_result"
  | "tool_invocation"
  | "tool_result"
  | "mcp_envelope";

export type VersionedEnvelopeBase = {
  kind: SchemaKind;
  schemaVersion: SchemaVersion;
};

export const SCHEMA_VERSION = {
  engineEventEnvelope: 1,[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "Phase 6" -S src | head -n 50'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 47ms:[0m
[2m[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,240p' src/spec/legacy/settings.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 31ms:[0m
[2mexport type LegacySettingsSource =
  | "userSettings"
  | "projectSettings"
  | "localSettings"
  | "policySettings"
  | "flagSettings"
  | "cliArg"
  | "command"
  | "session";

export type LegacyFileBackedSettingsSource =
  | "userSettings"
  | "projectSettings"
  | "localSettings"
  | "policySettings"
  | "flagSettings";

export type LegacyNonFileSettingsSource = Exclude<
  LegacySettingsSource,
  LegacyFileBackedSettingsSource[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "settings" src/core/settings/index.ts src/spec/legacy/settings.ts CLI_ENCYCLOPEDIA.md | head'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 38ms:[0m
[2mCLI_ENCYCLOPEDIA.md:482:  - default false; becomes true when policy/settings allow bypass mode for the session.
CLI_ENCYCLOPEDIA.md:571:Where `wL` / `JL` are the shared settings-sources list:
CLI_ENCYCLOPEDIA.md:590:- This ordering is somewhat surprising if you expect session rules to override persisted settings; document it exactly as implemented and decide in the TS rewrite whether to preserve or change it.
CLI_ENCYCLOPEDIA.md:763:- `LG0/ pG0` which wraps a formatter (`ccA/dcA`) to describe the *source* of a rule (e.g., ‚Äúuser settings‚Äù, ‚Äúproject settings‚Äù, etc.).
CLI_ENCYCLOPEDIA.md:774:2.0.67 definitions are in the ‚Äúsettings source helpers‚Äù area:
CLI_ENCYCLOPEDIA.md:788:- `"userSettings"` ‚Üí `ccA/dcA`: `"user settings"`; `nlQ/TiQ`: `"User settings"`; `Vc/rd`: `"user"`
CLI_ENCYCLOPEDIA.md:789:- `"projectSettings"` ‚Üí `"shared project settings"`; `"Shared project settings"`; `"project"`
CLI_ENCYCLOPEDIA.md:790:- `"localSettings"` ‚Üí `"project local settings"`; `"Project local settings"`; `"project, gitignored"`
CLI_ENCYCLOPEDIA.md:792:- `"policySettings"` ‚Üí `"enterprise managed settings"`; `"Enterprise managed settings"`; `"managed"`
CLI_ENCYCLOPEDIA.md:870:This is the ‚Äúwrite-side‚Äù of the permission system: apply a list of updates and optionally persist them into settings files.[0m

[35m[3mthinking[0m[0m
**Implementing settings schema**

Right now, the settings are just a placeholder. I need to implement the Phase 6 settings system, which involves defining the schema, including things like schemaVersion. It looks like I'll create a versioned settings schema document. Maybe I can use Zod for validation‚ÄîI'll have to check the dependencies in package.json to see what I have available. So, I‚Äôm planning to examine package.json next.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'cat package.json'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 38ms:[0m
[2m{
  "name": "claude-code-ts-rewrite",
  "private": true,
  "type": "module",
  "scripts": {
    "test": "bun test",
    "typecheck": "tsc -p tsconfig.json --noEmit",
    "check:boundaries": "node scripts/check-import-boundaries.mjs"
  },
  "devDependencies": {
    "@types/node": "^22.10.2",
    "typescript": "^5.8.3"
  }
}[0m

[35m[3mthinking[0m[0m
**Evaluating tooling approach**

I‚Äôm considering a TypeScript-first methodology with minimal runtime validation. Since it‚Äôs Phase 6, I shouldn't finalize the tooling yet; I need to focus on required capabilities. I can implement some basic runtime validation within core/types/json. I'll have to inspect the JSON types and check what‚Äôs available. This approach could streamline the process while ensuring that we meet our validation needs without overcomplicating things. Let's see what I find!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,240p' src/core/capabilities/catalog.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 89ms:[0m
[2mimport type { HostCapabilities } from "../types/host.js";

export type HostPlatformKind = "node" | "desktop" | "web" | "rn";

export type HostCapabilityKey = keyof HostCapabilities;

export type HostCapabilityDescriptor = {
  key: HostCapabilityKey;
  optional: boolean;
  summary: string;
  polyfillAllowed?: Partial<Record<HostPlatformKind, boolean>>;
};

export const HOST_CAPABILITIES: readonly HostCapabilityDescriptor[] = [
  { key: "clock", optional: false, summary: "Time source (monotonic + optional wall clock)" },
  { key: "random", optional: false, summary: "UUID/randomness (portable)" },
  {
    key: "crypto",
    optional: true,
    summary: "Portable crypto primitives (e.g., digest)",[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,240p' src/core/types/json.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 83ms:[0m
[2mexport type JsonPrimitive = string | number | boolean | null;
export type JsonValue = JsonPrimitive | JsonObject | JsonArray;
export type JsonObject = { [key: string]: JsonValue };
export type JsonArray = JsonValue[];
[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/spec/legacy/envFlags.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 43ms:[0m
[2mexport type LegacyKnobKind = "hostAdapterConfig" | "settingsOverlay" | "policy" | "cliOnly" | "deprecated";

export type LegacyEnvVarMapping = {
  name: string;
  kind: LegacyKnobKind;
  notes?: string;
};

export type LegacyCliFlagMapping = {
  flag: string;
  kind: LegacyKnobKind;
  notes?: string;
};

export const LEGACY_ENV_VARS: readonly LegacyEnvVarMapping[] = [
  { name: "CLAUDE_CODE_SESSION_ACCESS_TOKEN", kind: "hostAdapterConfig", notes: "Node/CLI-only credential ingress" },
  { name: "CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR", kind: "hostAdapterConfig", notes: "Node/CLI-only credential ingress (fd)" },

  { name: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "cliOnly", notes: "Gates `--mcp-cli` behavior" },
  { name: "ENABLE_MCP_CLI_ENDPOINT", kind: "cliOnly", notes: "Gates endpoint mode inside MCP CLI" },[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,240p' src/core/types/errors.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 40ms:[0m
[2mexport type EngineErrorCode =
  | "capability_missing"
  | "permission_denied"
  | "policy_override"
  | "conflict"
  | "quota_exceeded"
  | "corruption_detected"
  | "transient_failure"
  | "transport_failure"
  | "task_cancelled"
  | "timeout"
  | "unknown";

export type EngineError = {
  code: EngineErrorCode;
  message: string;
  details?: unknown;
  cause?: EngineError;
};
[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,240p' src/core/state/state.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 45ms:[0m
[2mimport type { IdSource } from "../runtime/ids.js";
import type { MonotonicClock } from "../runtime/clock.js";
import {
  asAppId,
  asSessionId,
  type AttachmentRefV1,
  type HookRunEntityV1,
  type McpConnectionEntityV1,
  type PersistedAppStateV1,
  type PersistedSessionStateV1,
  type SessionId,
  type SessionLifecycleState,
  type StateSnapshotV1,
  type ToolRunEntityV1,
  type TranscriptEventV1,
  type TranscriptLogV1
} from "../types/state.js";
import { SCHEMA_VERSION } from "../types/schema.js";
import type { CancellationReason } from "../types/runtime.js";
import type { HostEvent } from "../types/events.js";[0m

[35m[3mthinking[0m[0m
**Implementing settings system**

I‚Äôm focusing on the settings placeholder, which indicates that we need to implement features in phase 6, including schema and validation. I want to create a watchable settings system that layers various sources like user, project, local policy, and flags, along with secret handling in the configuration. To get a better grasp of this, I should inspect the capability interfaces in src/core/types/host.ts to review storage and secrets functionalities.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/types/host.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 75ms:[0m
[2mimport type { HostEvent } from "./events.js";
import type { WorkspaceId } from "./workspace.js";

export type CapabilityUnavailableReason =
  | { kind: "not-provided"; message?: string }
  | { kind: "unsupported"; message?: string }
  | { kind: "disabled"; message?: string }
  | { kind: "policy-denied"; message?: string; policyId?: string };

export type Capability<T> =
  | { kind: "available"; value: T }
  | { kind: "unavailable"; reason: CapabilityUnavailableReason };

export function availableCapability<T>(value: T): Capability<T> {
  return { kind: "available", value };
}

export function unavailableCapability(reason: CapabilityUnavailableReason): Capability<never> {
  return { kind: "unavailable", reason };
}[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/platform/node/host.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 43ms:[0m
[2mimport { availableCapability, unavailableCapability } from "../../core/types/host.js";
import type {
  HostCapabilities,
  HostClock,
  HostCrypto,
  HostFilesystem,
  HostLifecycle,
  HostNetwork,
  HostProcess,
  HostRandom,
  HostSecrets,
  HostStorage,
  StorageNamespace
} from "../../core/types/host.js";
import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
import crypto from "node:crypto";
import { execFile as execFileCb } from "node:child_process";
import fs from "node:fs/promises";
import os from "node:os";
import path from "node:path";[0m




[35m[3mthinking[0m[0m
**Evaluating settings compatibility**

I‚Äôm considering the NodeHost's keychain features, which may be useful for secrets storage. The settings system likely uses HostStorage for JSON storage. Compatibility with legacy settings files is also on my mind ‚Äî but maybe it‚Äôs out of scope? Phase 6 seems to involve mapping legacy file paths into a new storage model, focusing on the settings system rather than full file reading. Requirement 6.5 emphasizes compatibility for existing settings files, including symlink handling. We might need an adapter for loading old settings if we don‚Äôt have a CLI adapter yet.
[35m[3mthinking[0m[0m
**Analyzing CLI settings**

I need to explore the UI/CLI index and read the CLI_ENCYCLOPEDIA sections on settings, particularly around line 571. I'm planning to use `rg` to locate relevant settings like the shared settings-sources list. I should inspect the old cli.js for the settings pipeline, focusing specifically on the settings functions rather than the entire file. I'll search for "settings" in the bundles directory, looking for known symbols. Additionally, since Phase 6 is about settings, I‚Äôll take notes on secrets and keychain extraction for authentication later. Understanding the existing spec for sources and merge semantics is my priority.
[35m[3mthinking[0m[0m
**Defining settings schema**

In Phase 6, I‚Äôll need to establish a schema that includes versioning and parsing/validating errors. I plan to create a robust settings document structure stored as a JSON string, likely using a JSON schema-like runtime check. I‚Äôll define custom validation functions to ensure objects and arrays are formatted correctly. The settings document will be versioned, aligning with schema.ts, while maintaining the legacy naming conventions like "userSettings" to preserve consistency. Lastly, I need to implement a settings event bus via a `SettingsManager` to handle source loading and storage changes independently.
[35m[3mthinking[0m[0m
**Integrating settings into AppState**

I‚Äôm considering that the engine store needs to be updated whenever settings change. Phase 6 might involve connecting this to the state; perhaps I‚Äôll need a new action in the state store specifically for updating the effective config. While there are existing state store actions, none are geared towards settings yet. In Phase 5, the focus is on persisted state, so I need to see how settings can be integrated into the AppState and inspect the types for persisted settings.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"PersistedAppStateV1\" -n src/core/types/state.ts && sed -n '1,220p' src/core/types/state.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 74ms:[0m
[2m170:export type PersistedAppStateV1 = {
182:  state: PersistedAppStateV1;
import type { VersionedEnvelopeBase } from "./schema.js";
import { SCHEMA_VERSION } from "./schema.js";
import type { CancellationReason } from "./runtime.js";

export type AppId = string & { readonly __brand: "AppId" };
export type SessionId = string & { readonly __brand: "SessionId" };
export type AttachmentId = string & { readonly __brand: "AttachmentId" };
export type ToolRunId = string & { readonly __brand: "ToolRunId" };
export type HookRunId = string & { readonly __brand: "HookRunId" };
export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };

export function asAppId(value: string): AppId {
  return value as AppId;
}
export function asSessionId(value: string): SessionId {
  return value as SessionId;
}
export function asAttachmentId(value: string): AttachmentId {[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/state/store.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 51ms:[0m
[2mimport type { IdSource } from "../runtime/ids.js";
import type { MonotonicClock } from "../runtime/clock.js";
import { BoundedAsyncQueue } from "../runtime/queue.js";
import type { StateSnapshotV1 } from "../types/state.js";
import type { AppState, StateAction, StateCommand, StateEffect, StateUiEvent } from "./state.js";
import { commandToActions, createAppState, createStateSnapshot, reduceAppState } from "./state.js";

export type StateStoreOptions = {
  idSource: IdSource;
  clock: MonotonicClock;
  eventBufferSize?: number;
  effectBufferSize?: number;
};

export type StoreUnsubscribe = () => void;

export type Subscription<T> = AsyncIterable<T> & { unsubscribe: StoreUnsubscribe };

export type StateStore = {
  getState: () => AppState;[0m




[35m[3mthinking[0m[0m
**Evaluating settings and state**

I'm considering settings being separate from the state store, but they might trigger state actions like "app/settings-updated." We could add both state and persisted properties. The app state includes both persisted and UI aspects right now. I wonder if we should have a non-persisted `settings` property, which might require migration for state snapshots. Still, we may keep settings either in the UI or a separate store. There's also the idea of a `SettingsController` for better management, which would use various hosts for updates.
[35m[3mthinking[0m[0m
**Designing settings functionality**

I need to consider several components for managing settings. For starters, I'll implement features like `getEffectiveSettings` and `getSourceSettings`. I'll also apply patches to specific sources with CAS for atomic updates. It‚Äôs important to have watchers subscribe to changes in HostStorage.

Now, I‚Äôm thinking about suppressing internal writes, so subsequent subscription events aren‚Äôt mistakenly treated as external changes. Additionally, I‚Äôll focus on enabling source selection, merging semantics for arrays, and defining policy origins. I‚Äôm planning to represent remote and local sources with a `SettingsSourceOrigin` type, though remote fetching may wait for later implementation.
[35m[3mthinking[0m[0m
**Defining settings and policies**

I‚Äôm considering implementing a placeholder for policy origin based on document metadata, defaulting to "local" if it‚Äôs missing. Regarding command configurations and CLI argument overlays, I think it's better to store these as ephemeral overlays in memory instead of persistent storage.

I plan to treat them as sources with varied persistence behaviors, keeping session, command, and CLI arg overlays as in-memory while also potentially integrating with session storage. However, I might need to manage how we handle session IDs in the settings manager, ensuring portability in representation by designating namespaces for each source within the settings framework.
[35m[3mthinking[0m[0m
**Mapping settings sources**

I need to establish mappings for various settings: userSettings will relate to the app, projectSettings to the workspace, and localSettings will also apply to the workspace, though gitignored. The flagSettings could fit as session settings, but I'm thinking they might work better as ephemeral command overlays derived from CLI flags. 

The spec does specify flagSettings as file-backed sources, possibly existing in a "flags.json" file. I guess I should check the CLI_ENCYCLOPEDIA section to clarify how these flag settings are represented and confirm what‚Äôs specified around them.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "nl -ba CLI_ENCYCLOPEDIA.md | sed -n '540,700p'"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 55ms:[0m
[2m   540	## 4.3 Flattening rules across sources (precedence list)
   541	
   542	### `GXA(ctx)` / `AXA(ctx)` / `l81(ctx)`  (2.0.67)
   543	
   544	All defined at `ClaudeAgentSDKCode/cli.js:4322`:
   545	
   546	- `GXA(ctx)` ‚Üí list of allow rules
   547	- `AXA(ctx)` ‚Üí list of deny rules
   548	- `l81(ctx)` ‚Üí list of ask rules
   549	
   550	Each:
   551	
   552	- iterates an array of sources `OY0` (not locally defined in the snippet)
   553	- for each `source` in that list:
   554	  - reads `ctx.alwaysAllowRules[source]` (or deny/ask equivalent)
   555	  - maps each serialized string through `NL(...)`
   556	  - outputs objects `{ source, ruleBehavior, ruleValue }`
   557	
   558	### `GXA(ctx)` / `AXA(ctx)` / `r81(ctx)`  (2.0.69)
   559	[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "enabled sources|enabledSources|--sources|sources" CLI_ENCYCLOPEDIA.md | head -n 50'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 62ms:[0m
[2m62:- list tools/resources
66:- read resources
227:### `qV5(state, serverName)` / `cE5(state, serverName)` ‚Äî resolve server resources
231:- Same logic as server config resolution but for `state.resources` which is keyed by server.
236:- `resolveServerResources(state: McpState, server: string): McpResource[]`
320:- `resources [server]` ‚Äî list resources
449:- rule lists (allow/deny/ask) coming from multiple sources (session/user/project/local/policy/etc.)
540:## 4.3 Flattening rules across sources (precedence list)
552:- iterates an array of sources `OY0` (not locally defined in the snippet)
564:- It‚Äôs the **rule-source precedence list** (sources checked in order).
566:Actual definitions (these are important for a TS rewrite because the order determines which rule ‚Äúwins‚Äù when multiple sources match):
571:Where `wL` / `JL` are the shared settings-sources list:
589:- `GXA/AXA/l81` flatten sources in that order, and `qB0/LB0/MB0` choose the **first** matching rule via `.find(...)`. That means **earlier sources win** over later ones for plain tool rules.
690:- If duplicates exist across sources, later inserts overwrite earlier ones. So precedence depends on the order of `OY0/oY0`.
938:- **settings sources** (user/project/local/policy/flag + non-file sources used by permissions)
949:## 5.1 Settings sources (conceptual model)
951:Across both builds you can identify these source keys (also used as permission rule sources in Chapter 4):
953:- File-backed sources:
959:- Non-file sources (mainly for permissions):
964:The UI labels/formatters for these sources are described in Chapter 4 (¬ß4.8 ‚ÄúSource label formatters‚Äù).[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "nl -ba CLI_ENCYCLOPEDIA.md | sed -n '920,1160p'"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 35ms:[0m
[2m   920	  - updates `permissions.defaultMode` in the destination settings file.
   921	
   922	Batch persist:
   923	
   924	- 2.0.67: `W8A(updates)` loops `$f`
   925	- 2.0.69: `D8A(updates)` loops `eP`
   926	
   927	Canonical TS:
   928	
   929	- `applyPermissionUpdates(ctx, updates): ToolPermissionContext`
   930	- `persistPermissionUpdates(updates): Promise<void>`
   931	
   932	---
   933	
   934	# Chapter 5 ‚Äî Settings system (schema, merge, IO, watchers)
   935	
   936	This subsystem is the single biggest ‚Äúhidden dependency‚Äù in the bundle. It provides:
   937	
   938	- **settings sources** (user/project/local/policy/flag + non-file sources used by permissions)
   939	- **file paths** for settings locations[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "nl -ba CLI_ENCYCLOPEDIA.md | sed -n '1160,1360p'"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 40ms:[0m
[2m  1160	  - `R7()` returns merged settings object
  1161	  - `px()` memoizes the `{settings, errors}` result in `eTA`
  1162	  - module init `jB` assigns `NQ=R7` (see `ClaudeCodeCode/cli.js:4391`)
  1163	
  1164	Cache invalidation:
  1165	
  1166	- 2.0.67: `hR()` sets `ZjA=null`
  1167	- 2.0.69: `TR()` sets `eTA=null`
  1168	
  1169	Canonical TS:
  1170	
  1171	- `getEffectiveSettings(): ClaudeCodeSettings` (‚âà `CQ` / `NQ`)
  1172	- `getEffectiveSettingsWithErrors(): { settings: ClaudeCodeSettings; errors: SettingsError[] }` (‚âà `Gy`/`px`)
  1173	- `invalidateSettingsCache(): void` (‚âà `hR` / `TR`)
  1174	
  1175	## 5.7 Writing settings patches (partial updates)
  1176	
  1177	### Atomic write helper: `KM` vs `rL`
  1178	
  1179	- 2.0.67: `KM(path, content, opts?)` at `ClaudeAgentSDKCode/cli.js:4400`[0m

[35m[3mthinking[0m[0m
**Gathering watcher details**

It looks like the watchers sections in the encyclopedia are truncated, and I'm realizing that I need more details. I'm planning to focus on the range around 1218 to 1280 but want to make sure I don‚Äôt overlap with the hooks section. I‚Äôll open further from 1220 to get the necessary information. I want to ensure things flow nicely, so getting these details right is important!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "nl -ba CLI_ENCYCLOPEDIA.md | sed -n '1218,1290p'"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 148ms:[0m
[2m  1218	   This looks like a ‚Äúensure local settings file is gitignored / tracked correctly‚Äù side-effect.
  1219	
  1220	Canonical TS:
  1221	
  1222	- `updateSettingsFile(source: WritableSettingsSource, patch: DeepPartial<ClaudeCodeSettings>): { error: Error | null }`
  1223	
  1224	## 5.8 Watchers + subscriptions (`SF` / `NF`)
  1225	
  1226	The settings system exposes a small event bus so other systems can react to settings changes.
  1227	
  1228	### Public interface
  1229	
  1230	- 2.0.67: `SF={ initialize: Lt3, dispose: elQ, subscribe: Mt3, markInternalWrite: Ot3, notifyChange: jt3 }` at `ClaudeAgentSDKCode/cli.js` (byte offset ~`4020857`)
  1231	- 2.0.69: `NF={ initialize: se6, dispose: viQ, subscribe: te6, markInternalWrite: ee6, notifyChange: GA3 }` at `ClaudeCodeCode/cli.js` (byte offset ~`4020830`)
  1232	
  1233	### Watch initialization: `Lt3()` vs `se6()`
  1234	
  1235	Behavior:
  1236	
  1237	- Builds a list of watched settings files (via `Rt3()` / `AA3()`; includes `settings.json`, `.claude/settings.json`, `.claude/settings.local.json`, plus policy/flag locations as available).[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "ClaudeCodeSettings|EffectiveConfig|settingsDocument" -S src | head -n 100'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 90ms:[0m
[2msrc/core/types/schema.ts:21:  settingsDocument: 1,[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "disableAllHooks|allowManagedHooksOnly|bypassPermissions|dontAsk|acceptEdits|plan" CLI_ENCYCLOPEDIA.md | head -n 50'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 104ms:[0m
[2m469:  - other observed modes: `"bypassPermissions"`, `"plan"`, `"acceptEdits"`, `"dontAsk"`
470:  - elsewhere in the bundle, other tools use modes like `"acceptEdits"` (file write/edit auto-allow) ‚Äî treat as a broader ‚Äúpermission mode‚Äù enum in the TS rewrite.
490:type PermissionMode = "default" | "bypassPermissions" | "plan" | "acceptEdits" | string;
728:   - If `toolPermissionContext.mode === "bypassPermissions"` ‚Üí allow.
729:   - If `mode === "plan"` AND `isBypassPermissionsModeAvailable` ‚Üí allow.
814:  - `"plan"` ‚Üí `"Plan Mode"`
815:  - `"acceptEdits"` ‚Üí `"Accept edits"`
816:  - `"bypassPermissions"` ‚Üí `"Bypass Permissions"`
817:  - `"dontAsk"` ‚Üí `"Don't Ask"`
821:  - `"plan"` ‚Üí `"‚è∏"`
822:  - `"acceptEdits"` ‚Üí `"‚èµ‚èµ"`
823:  - `"bypassPermissions"` ‚Üí `"‚èµ‚èµ"`
824:  - `"dontAsk"` ‚Üí `"‚èµ‚èµ"`
825:- `zS(mode)` ‚Äî maps mode ‚Üí theme key (e.g. `"text"`, `"planMode"`, `"autoAccept"`, ‚Ä¶)
1359:- If `policySettings.allowManagedHooksOnly === true`, the system uses **only** policy-managed hooks and excludes plugin hooks + user/project/local settings hooks.
1367:    - if `uB("policySettings")?.allowManagedHooksOnly===!0` ‚Üí `policySettings.hooks ?? {}`
1381:    - if `uB("policySettings")?.allowManagedHooksOnly===!0` ‚Üí `policySettings.hooks ?? {}`
1413:The matcher aggregator includes plugin hooks only when the policy does *not* enforce `allowManagedHooksOnly`.
1613:   - `reason?: string` (explanation for decision)
1689:These are heavily used in stop-hook scenarios (‚Äúdid the agent actually complete the plan?‚Äù).[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "nl -ba CLI_ENCYCLOPEDIA.md | sed -n '1720,1820p'"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 50ms:[0m
[2m  1720	   - if `ok:false`:
  1721	     - outcome: `"blocking"`
  1722	     - sets `preventContinuation: true` and `stopReason`
  1723	     - creates a blocking error message referencing the prompt
  1724	   - if parse/validation fails:
  1725	     - outcome: `"non_blocking_error"`
  1726	   - if `ok:true`:
  1727	     - outcome: `"success"`
  1728	
  1729	This is ‚Äúmodel-as-hook-condition-evaluator‚Äù.
  1730	
  1731	#### 6.8.3 Agent hooks (dedicated hook agent, tool-required)
  1732	
  1733	Agent hooks are stronger than prompt hooks: they spawn an actual agent loop and require the agent to emit a structured result via a tool call.
  1734	
  1735	The hook agent:
  1736	
  1737	- runs as `isNonInteractiveSession: true`
  1738	- uses `maxThinkingTokens: 0`
  1739	- has a `max turns` limit of `50` (hard-coded guard; logs `Hooks: Agent turn N hit max turns, aborting`)[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "keychain|security find-generic-password|Claude Code-credentials|CLAUDE_CODE_SESSION_ACCESS_TOKEN" -S src/platform/node/host.ts bundles/ClaudeCodeCode/cli.js bundles/ClaudeAgentSDKCode/cli.js | head -n 50'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 81ms:[0m
[2msrc/platform/node/host.ts:329:    `Claude Code-credentials${suffix}`,
src/platform/node/host.ts:330:    `Claude Code-credentials`,
src/platform/node/host.ts:377:      const envToken = process.env.CLAUDE_CODE_SESSION_ACCESS_TOKEN;
src/platform/node/host.ts:382:          name === "CLAUDE_CODE_SESSION_ACCESS_TOKEN")
src/platform/node/host.ts:396:        name === "CLAUDE_CODE_SESSION_ACCESS_TOKEN"
bundles/ClaudeCodeCode/cli.js:81:`);if(Y!==-1)Q=ku0(Q,Z,G,Y);return G+Q+Z},WT9,Xl5,cA;var t2=L(()=>{ju0();yu0();({stdout:fu0,stderr:bu0}=xu0),pK1=Symbol("GENERATOR"),T9A=Symbol("STYLER"),uKA=Symbol("IS_EMPTY"),hu0=["ansi","ansi","ansi256","ansi16m"],j9A=Object.create(null);Object.setPrototypeOf(mKA.prototype,Function.prototype);for(let[A,Q]of Object.entries(cO))j9A[A]={get(){let B=gyA(this,iK1(Q.open,Q.close,this[T9A]),this[uKA]);return Object.defineProperty(this,A,{value:B}),B}};j9A.visible={get(){let A=gyA(this,this[T9A],!0);return Object.defineProperty(this,"visible",{value:A}),A}};JT9=["rgb","hex","ansi256"];for(let A of JT9){j9A[A]={get(){let{level:B}=this;return function(...G){let Z=iK1(lK1(A,hu0[B],"color",...G),cO.color.close,this[T9A]);return gyA(this,Z,this[uKA])}}};let Q="bg"+A[0].toUpperCase()+A.slice(1);j9A[Q]={get(){let{level:B}=this;return function(...G){let Z=iK1(lK1(A,hu0[B],"bgColor",...G),cO.bgColor.close,this[T9A]);return gyA(this,Z,this[uKA])}}}}IT9=Object.defineProperties(()=>{},{...j9A,level:{enumerable:!0,get(){return this[pK1].level},set(A){this[pK1].level=A}}});Object.defineProperties(mKA.prototype,j9A);WT9=mKA(),Xl5=mKA({level:bu0?bu0.level:0}),cA=WT9});function uu0(A,Q){return{name:`${A.name}-with-${Q.name}-fallback`,read(){let B=A.read();if(B!==null&&B!==void 0)return B;return Q.read()||{}},update(B){let G=A.read(),Z=A.update(B);if(Z.success){if(G===null)Q.delete();return Z}let Y=Q.update(B);if(Y.success)return{success:!0,warning:Y.warning};return{success:!1}},delete(){let B=A.delete(),G=Q.delete();return B||G}}}import{createHash as KT9}from"crypto";import{userInfo as VT9}from"os";function Ym(A=""){let Q=mQ(),G=!process.env.CLAUDE_CONFIG_DIR?"":`-${KT9("sha256").update(Q).digest("hex").substring(0,8)}`;return`Claude Code${u9().OAUTH_FILE_SUFFIX}${A}${G}`}function dKA(){try{return process.env.USER||VT9().username}catch{return"claude-code-user"}}function du0(){if(process.platform!=="darwin")return!1;try{return j2A("security",["show-keychain-info"],{reject:!1,stdio:["ignore","pipe","pipe"]}).exitCode===36}catch{return!1}}var mu0;var cKA=L(()=>{mSA();rQ();eJ();pWA();mu0={name:"keychain",read(){try{let A=Ym("-credentials"),Q=dKA(),B=dG(`security find-generic-password -a "${Q}" -w -s "${A}"`);if(B)return JSON.parse(B)}catch(A){return null}return null},update(A){try{let Q=Ym("-credentials"),B=dKA(),G=JSON.stringify(A),Z=Buffer.from(G,"utf-8").toString("hex"),Y=`add-generic-password -U -a "${B}" -s "${Q}" -X "${Z}"
bundles/ClaudeCodeCode/cli.js:191:`;dG("security -i",{input:J,stdio:["pipe","pipe","pipe"]}),r("tengu_api_key_saved_to_keychain",{}),Q=!0}catch(G){s(G),r("tengu_api_key_keychain_error",{error:G.message}),r("tengu_api_key_saved_to_config",{})}else r("tengu_api_key_saved_to_config",{});let B=d$(A);i0((G)=>{let Z=G.customApiKeyResponses?.approved??[];return{...G,primaryApiKey:Q?G.primaryApiKey:A,customApiKeyResponses:{...G.customApiKeyResponses,approved:Z.includes(B)?Z:[...Z,B],rejected:G.customApiKeyResponses?.rejected??[]}}}),XHA.cache.clear?.()}function mCQ(){dCQ(),i0((A)=>({...A,primaryApiKey:void 0})),XHA.cache.clear?.()}function dCQ(){try{yCQ()}catch(A){s(A)}}function WHA(A){if(!kv(A.scopes))return r("tengu_oauth_tokens_not_claude_ai",{}),{success:!0};if(!A.refreshToken||!A.expiresAt)return r("tengu_oauth_tokens_inference_only",{}),{success:!0};let Q=$$(),B=Q.name;try{let G=Q.read()||{};G.claudeAiOauth={accessToken:A.accessToken,refreshToken:A.refreshToken,expiresAt:A.expiresAt,scopes:A.scopes,subscriptionType:A.subscriptionType,rateLimitTier:A.rateLimitTier};let Z=Q.update(G);if(Z.success)r("tengu_oauth_tokens_saved",{storageBackend:B});else r("tengu_oauth_tokens_save_failed",{storageBackend:B});return t6.cache?.clear?.(),oyA(),Z}catch(G){return s(G),r("tengu_oauth_tokens_save_exception",{storageBackend:B,error:G.message}),{success:!1,warning:"Failed to save OAuth tokens"}}}async function Mk(A=0){let B=t6();if(!B?.refreshToken||!Jm(B.expiresAt))return!1;if(!kv(B.scopes))return!1;if(t6.cache?.clear?.(),B=t6(),!B?.refreshToken||!Jm(B.expiresAt))return!1;let G=mQ();jA().mkdirSync(G);let Y;try{Y=await vCQ.lock(G)}catch(J){if(J.code==="ELOCKED"){if(A<5)return r("tengu_oauth_token_refresh_lock_retry",{retryCount:A+1}),await new Promise((I)=>setTimeout(I,1000+Math.random()*1000)),Mk(A+1);return r("tengu_oauth_token_refresh_lock_retry_limit_reached",{maxRetries:5}),!1}return s(J),r("tengu_oauth_token_refresh_lock_error",{error:J.message}),!1}try{if(t6.cache?.clear?.(),B=t6(),!B?.refreshToken||!Jm(B.expiresAt))return r("tengu_oauth_token_refresh_race_resolved",{}),!1;let J=await iu0(B.refreshToken);return WHA(J),t6.cache?.clear?.(),!0}catch(J){return s(J instanceof Error?J:Error(String(J))),!1}finally{await Y()}}function RB(){if(!Mz())return!1;return kv(t6()?.scopes)}function cCQ(){if(z0(process.env.CLAUDE_CODE_USE_BEDROCK)||z0(process.env.CLAUDE_CODE_USE_VERTEX)||z0(process.env.CLAUDE_CODE_USE_FOUNDRY))return!1;if(RB())return!1;return!0}function q8(){return Mz()?d1().oauthAccount:void 0}function lq(){let A=d6();return A==="max"||A==="enterprise"||A==="team"||A==="pro"||A===null}function d6(){if(Qm0())return Am0();if(!Mz())return null;let A=t6();if(!A)return null;return A.subscriptionType??null}function Kd(){if(!Mz())return null;let A=t6();if(!A)return null;return A.rateLimitTier??null}function pR1(){switch(d6()){case"enterprise":return"Claude Enterprise";case"team":return"Claude Team";case"max":return"Claude Max";case"pro":return"Claude Pro";default:return"Claude API"}}function vP(){return!!(z0(process.env.CLAUDE_CODE_USE_BEDROCK)||z0(process.env.CLAUDE_CODE_USE_VERTEX)||z0(process.env.CLAUDE_CODE_USE_FOUNDRY))}function pCQ(){return(NQ()||{}).otelHeadersHelper}function KHA(){let A=pCQ();if(!A)return!1;let Q=uB("projectSettings"),B=uB("localSettings");return Q?.otelHeadersHelper===A||B?.otelHeadersHelper===A}function lCQ(){let A=pCQ();if(!A)return{};if(KHA()){if(!QY(!0))return{}}try{let Q=dG(A)?.toString().trim();if(!Q)throw Error("otelHeadersHelper did not return a valid value");let B=JSON.parse(Q);if(typeof B!=="object"||B===null||Array.isArray(B))throw Error("otelHeadersHelper must return a JSON object with string key-value pairs");for(let[G,Z]of Object.entries(B))if(typeof Z!=="string")throw Error(`otelHeadersHelper returned non-string value for key "${G}": ${typeof Z}`);return B}catch(Q){throw s(Error(`Error getting OpenTelemetry headers from otelHeadersHelper (in settings): ${Q instanceof Error?Q.message:String(Q)}`)),Q}}function N$6(A){return A==="max"||A==="pro"}function dgA(){let A=d6();return RB()&&A!==null&&N$6(A)}function cgA(){if(X6()!=="firstParty")return;let{source:Q}=Wd(),B={};if(RB())B.subscription=pR1();else B.tokenSource=Q;let{key:G,source:Z}=cD();if(G)B.apiKeySource=Z;if(Q==="claude.ai"||Z==="/login managed key"){let J=q8()?.organizationName;if(J)B.organization=J}let Y=q8()?.emailAddress;if((Q==="claude.ai"||Z==="/login managed key")&&Y)B.email=Y;return B}var vCQ,H$6=300000,IHA,C$6=3600000,$r,XHA,t6;var F2=L(()=>{xQ();jB();I6();o2();byA();h1();Y0();t2();uyA();pu0();Xq();pyA();fv();XQ();rQ();cKA();g0();N$1();T0();hX();mR1();YHA();vCQ=o(Gm(),1);IHA=dK1((A)=>{let Q=JHA();if(!Q)return null;if(fCQ()){if(!QY(!0)&&!A){let G=Error(`Security: apiKeyHelper executed before workspace trust is confirmed. If you see this message, post in ${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.69",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues",BUILD_TIME:"2025-12-13T00:32:01Z"}.FEEDBACK_CHANNEL}.`);eN("apiKeyHelper invoked before trust check",G),r("tengu_apiKeyHelper_missing_trust8",{})}}try{let B=dG(Q)?.toString().trim();if(!B)throw Error("apiKeyHelper did not return a valid value");return B}catch(B){let G=cA.red("Error getting API key from apiKeyHelper (in settings or ~/.claude.json):");if(B instanceof Error&&"stderr"in B)console.error(G,String(B.stderr));else if(B instanceof Error)console.error(G,B.message);else console.error(G,B);return" "}},F$6());$r=dK1(async()=>{let A=await z$6(),Q=await $$6();if(A||Q)await r4Q();return Q},C$6);XHA=Z0(()=>{if(process.platform==="darwin"){let Q=Ym();try{let B=dG(`security find-generic-password -a $USER -w -s "${Q}"`);if(B)return{key:B,source:"/login managed key"}}catch(B){s(B)}}let A=d1();if(!A.primaryApiKey)return null;return{key:A.primaryApiKey,source:"/login managed key"}});t6=Z0(()=>{if(process.env.CLAUDE_CODE_OAUTH_TOKEN)return{accessToken:process.env.CLAUDE_CODE_OAUTH_TOKEN,refreshToken:null,expiresAt:null,scopes:["user:inference"],subscriptionType:null,rateLimitTier:null};let A=rK1();if(A)return{accessToken:A,refreshToken:null,expiresAt:null,scopes:["user:inference"],subscriptionType:null,rateLimitTier:null};try{let G=$$().read()?.claudeAiOauth;if(!G?.accessToken)return null;return G}catch(Q){return s(Q),null}})});import{join as VHA}from"path";function aCQ(){return(process.argv[1]||"").includes("/.claude/local/node_modules/")}async function q$6(){try{if(!jA().existsSync(Vd))jA().mkdirSync(Vd);if(!jA().existsSync(iCQ)){let Q={name:"claude-local",version:"0.0.1",private:!0};jA().writeFileSync(iCQ,JSON.stringify(Q,null,2),{encoding:"utf8",flush:!1})}let A=VHA(Vd,"claude");if(!jA().existsSync(A)){let Q=`#!/bin/bash
bundles/ClaudeCodeCode/cli.js:983:`)||[];for(let G of B){let[Z,Y]=G.split("@");if(Z==="anthropic.claude-code"&&Y)return Y}return null}function f_3(){try{if(dQ()!=="macos")return null;let Q=process.ppid;for(let B=0;B<10;B++){if(!Q||Q===0||Q===1)break;let G=dG(`ps -o command= -p ${Q}`)?.trim();if(G){let Y={"Visual Studio Code.app":"code","Cursor.app":"cursor","Windsurf.app":"windsurf","Visual Studio Code - Insiders.app":"code","VSCodium.app":"codium"},J="/Contents/MacOS/Electron";for(let[I,X]of Object.entries(Y)){let W=G.indexOf(I+"/Contents/MacOS/Electron");if(W!==-1){let K=W+I.length;return G.substring(0,K)+"/Contents/Resources/app/bin/"+X}}}let Z=dG(`ps -o ppid= -p ${Q}`)?.trim();if(!Z)break;Q=parseInt(Z.trim())}return null}catch{return null}}function VDB(A){let Q=f_3();if(Q){if(jA().existsSync(Q))return Q}switch(A){case"vscode":return"code";case"cursor":return"cursor";case"windsurf":return"windsurf";default:break}return null}function drA(){let A=[];try{let Q=dQ();if(Q==="macos"){let B=dG('ps aux | grep -E "Visual Studio Code|Code Helper|Cursor Helper|Windsurf Helper|IntelliJ IDEA|PyCharm|WebStorm|PhpStorm|RubyMine|CLion|GoLand|Rider|DataGrip|AppCode|DataSpell|Aqua|Gateway|Fleet|Android Studio" | grep -v grep')??"";for(let[G,Z]of Object.entries(b7A))for(let Y of Z.processKeywordsMac)if(B.includes(Y)){A.push(G);break}}else if(Q==="windows"){let G=(dG('tasklist | findstr /I "Code.exe Cursor.exe Windsurf.exe idea64.exe pycharm64.exe webstorm64.exe phpstorm64.exe rubymine64.exe clion64.exe goland64.exe rider64.exe datagrip64.exe appcode.exe dataspell64.exe aqua64.exe gateway64.exe fleet.exe studio64.exe"')??"").toLowerCase();for(let[Z,Y]of Object.entries(b7A))for(let J of Y.processKeywordsWindows)if(G.includes(J.toLowerCase())){A.push(Z);break}}else if(Q==="linux"){let G=(dG('ps aux | grep -E "code|cursor|windsurf|idea|pycharm|webstorm|phpstorm|rubymine|clion|goland|rider|datagrip|dataspell|aqua|gateway|fleet|android-studio" | grep -v grep')??"").toLowerCase();for(let[Z,Y]of Object.entries(b7A))for(let J of Y.processKeywordsLinux)if(G.includes(J)){if(Z!=="vscode"){A.push(Z);break}else if(!G.includes("cursor")&&!G.includes("appcode")){A.push(Z);break}}}}catch(Q){s(Q)}return A}function crA(A){let Q=A.find((B)=>B.type==="connected"&&B.name==="ide");return zp1(Q)}function zp1(A){let Q=A?.config;return Q?.type==="sse-ide"||Q?.type==="ws-ide"?Q.ideName:ZW()?WV(Rz.terminal):null}function WV(A){if(!A)return"IDE";let Q=b7A[A];if(Q)return Q.displayName;let B=JDB[A.toLowerCase().trim()];if(B)return B;let G=A.split(" ")[0],Z=G?O_3(G).toLowerCase():null;if(Z){let Y=JDB[Z];if(Y)return Y;return gHA(Z)}return gHA(A)}function ez(A){if(!A)return;let Q=A.find((B)=>B.type==="connected"&&B.name==="ide");return Q?.type==="connected"?Q:void 0}async function FDB(A){try{await Bb("closeAllDiffTabs",{},A)}catch(Q){}}async function CDB(A,Q,B,G){GDB().then(A);let Z=d1().autoInstallIdeExtension??!0;if(process.env.CLAUDE_CODE_IDE_SKIP_AUTO_INSTALL!=="true"&&Z){let Y=Q??k7A();if(Y){if(grA(Y))ZDB(Y).then(async(J)=>{x_3(Y).catch((I)=>{return{installed:!1,error:I.message||"Installation failed",installedVersion:null,ideType:Y}}).then((I)=>{if(G(I),I?.installed)GDB().then(A);if(!J&&I?.installed===!0&&!krA())B()})});else if(U_(Y)&&!krA())ZDB(Y).then(async(J)=>{if(J)B()})}}}var IDB,b7A,TwA,jwA,ZW,S_3,Go7,frA=null,y_3="anthropic.claude-code",EDB,DDB,HDB,JDB,zDB;var PJ=L(()=>{$8();rQ();PuA();I6();xQ();T0();sT1();o2();g0();XQ();h1();k3();$_();Vp1();Ep1();Dp1();Y0();LZ();ur();IDB=o(zR(),1);b7A={cursor:{ideKind:"vscode",displayName:"Cursor",processKeywordsMac:["Cursor Helper","Cursor.app"],processKeywordsWindows:["cursor.exe"],processKeywordsLinux:["cursor"]},windsurf:{ideKind:"vscode",displayName:"Windsurf",processKeywordsMac:["Windsurf Helper","Windsurf.app"],processKeywordsWindows:["windsurf.exe"],processKeywordsLinux:["windsurf"]},vscode:{ideKind:"vscode",displayName:"VS Code",processKeywordsMac:["Visual Studio Code","Code Helper"],processKeywordsWindows:["code.exe"],processKeywordsLinux:["code"]},intellij:{ideKind:"jetbrains",displayName:"IntelliJ IDEA",processKeywordsMac:["IntelliJ IDEA"],processKeywordsWindows:["idea64.exe"],processKeywordsLinux:["idea","intellij"]},pycharm:{ideKind:"jetbrains",displayName:"PyCharm",processKeywordsMac:["PyCharm"],processKeywordsWindows:["pycharm64.exe"],processKeywordsLinux:["pycharm"]},webstorm:{ideKind:"jetbrains",displayName:"WebStorm",processKeywordsMac:["WebStorm"],processKeywordsWindows:["webstorm64.exe"],processKeywordsLinux:["webstorm"]},phpstorm:{ideKind:"jetbrains",displayName:"PhpStorm",processKeywordsMac:["PhpStorm"],processKeywordsWindows:["phpstorm64.exe"],processKeywordsLinux:["phpstorm"]},rubymine:{ideKind:"jetbrains",displayName:"RubyMine",processKeywordsMac:["RubyMine"],processKeywordsWindows:["rubymine64.exe"],processKeywordsLinux:["rubymine"]},clion:{ideKind:"jetbrains",displayName:"CLion",processKeywordsMac:["CLion"],processKeywordsWindows:["clion64.exe"],processKeywordsLinux:["clion"]},goland:{ideKind:"jetbrains",displayName:"GoLand",processKeywordsMac:["GoLand"],processKeywordsWindows:["goland64.exe"],processKeywordsLinux:["goland"]},rider:{ideKind:"jetbrains",displayName:"Rider",processKeywordsMac:["Rider"],processKeywordsWindows:["rider64.exe"],processKeywordsLinux:["rider"]},datagrip:{ideKind:"jetbrains",displayName:"DataGrip",processKeywordsMac:["DataGrip"],processKeywordsWindows:["datagrip64.exe"],processKeywordsLinux:["datagrip"]},appcode:{ideKind:"jetbrains",displayName:"AppCode",processKeywordsMac:["AppCode"],processKeywordsWindows:["appcode.exe"],processKeywordsLinux:["appcode"]},dataspell:{ideKind:"jetbrains",displayName:"DataSpell",processKeywordsMac:["DataSpell"],processKeywordsWindows:["dataspell64.exe"],processKeywordsLinux:["dataspell"]},aqua:{ideKind:"jetbrains",displayName:"Aqua",processKeywordsMac:[],processKeywordsWindows:["aqua64.exe"],processKeywordsLinux:[]},gateway:{ideKind:"jetbrains",displayName:"Gateway",processKeywordsMac:[],processKeywordsWindows:["gateway64.exe"],processKeywordsLinux:[]},fleet:{ideKind:"jetbrains",displayName:"Fleet",processKeywordsMac:[],processKeywordsWindows:["fleet.exe"],processKeywordsLinux:[]},androidstudio:{ideKind:"jetbrains",displayName:"Android Studio",processKeywordsMac:["Android Studio"],processKeywordsWindows:["studio64.exe"],processKeywordsLinux:["android-studio"]}};TwA=Z0(()=>{return grA(JQ.terminal)}),jwA=Z0(()=>{return U_(Rz.terminal)}),ZW=Z0(()=>{return TwA()||jwA()||Boolean(process.env.FORCE_CODE_TERMINAL)});S_3=R_3(import.meta.url),Go7=hrA(S_3,"../");EDB=Z0(()=>{try{return dG("cursor --version"),!0}catch{return!1}}),DDB=Z0(()=>{try{return dG("windsurf --version"),!0}catch{return!1}}),HDB=Z0(()=>{try{let A=dG("code --help");return Boolean(A&&A.includes("Visual Studio Code"))}catch{return!1}});JDB={code:"VS Code",cursor:"Cursor",windsurf:"Windsurf",antigravity:"Antigravity",vi:"Vim",vim:"Vim",nano:"nano",notepad:"Notepad","start /wait notepad":"Notepad",emacs:"Emacs",subl:"Sublime Text",atom:"Atom"};zDB=Z0(async(A,Q)=>{if(process.env.CLAUDE_CODE_IDE_HOST_OVERRIDE)return process.env.CLAUDE_CODE_IDE_HOST_OVERRIDE;if(dQ()!=="wsl"||!A)return"127.0.0.1";try{let G=M_3("ip route show | grep -i default",{encoding:"utf8"}).match(/default via (\d+\.\d+\.\d+\.\d+)/);if(G){let Z=G[1];if(await Fp1(Z,Q))return Z}}catch(B){}return"127.0.0.1"})});function b_3(){let A=RK0();if(A!==void 0)return A;let Q=process.env.CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR;if(!Q)return xBA(null),null;let B=parseInt(Q,10);if(Number.isNaN(B))return f(`CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR must be a valid file descriptor number, got: ${Q}`,{level:"error"}),xBA(null),null;try{let G=jA(),Z=process.platform==="darwin"||process.platform==="freebsd"?`/dev/fd/${B}`:`/proc/self/fd/${B}`,Y=G.readFileSync(Z,{encoding:"utf8"}).trim();if(!Y)return f("File descriptor contained empty token",{level:"error"}),xBA(null),null;return f(`Successfully read token from file descriptor ${B}`),xBA(Y),Y}catch(G){return f(`Failed to read token from file descriptor ${B}: ${G instanceof Error?G.message:String(G)}`,{level:"error"}),xBA(null),null}}function Le(){let A=process.env.CLAUDE_CODE_SESSION_ACCESS_TOKEN;if(A)return A;return b_3()}var prA=L(()=>{Y0();XQ();g0()});function h_3(A){let Q=A,B="",G=0,Z=10;while(Q!==B&&G<Z)B=Q,Q=Q.normalize("NFKC"),Q=Q.replace(/[\p{Cf}\p{Co}\p{Cn}]/gu,""),Q=Q.replace(/[\u200B-\u200F]/g,"").replace(/[\u202A-\u202E]/g,"").replace(/[\u2066-\u2069]/g,"").replace(/[\uFEFF]/g,"").replace(/[\uE000-\uF8FF]/g,""),G++;if(G>=Z)throw Error(`Unicode sanitization reached maximum iterations (${Z}) for input: ${A.slice(0,100)}`);return Q}function wp(A){if(typeof A==="string")return h_3(A);if(Array.isArray(A))return A.map(wp);if(A!==null&&typeof A==="object"){let Q={};for(let[B,G]of Object.entries(A))Q[wp(B)]=wp(G);return Q}return A}function lrA(){return parseInt(process.env.MAX_MCP_OUTPUT_TOKENS??"25000",10)}function $DB(A){return A.type==="text"}function wDB(A){return A.type==="image"}function Up1(A){if(!A)return 0;if(typeof A==="string")return OG(A);return A.reduce((Q,B)=>{if($DB(B))return Q+OG(B.text);else if(wDB(B))return Q+UDB;return Q},0)}function u_3(){return lrA()*4}function m_3(){return`
bundles/ClaudeCodeCode/cli.js:2597:- View comments on a Github PR: gh api repos/foo/bar/pulls/123/comments`}var Q_A=L(()=>{uR();jB();AV();JS();cs();Y0();DPA();g0();XI();CV();l2()});function vF2({param:A,addMargin:Q,tools:B,verbose:G,erroredToolUseIDs:Z,inProgressToolUseIDs:Y,resolvedToolUseIDs:J,progressMessagesForMessage:I,shouldAnimate:X,shouldShowDot:W,inProgressToolCallCount:K,messages:V}){let E=kB(),[D]=I2(),F=fF2()?.[0]?.pendingWorkerRequest;if(!B)return s(Error(`Tools array is undefined for tool ${A.name}`)),null;let C=B.find((h)=>h.name===A.name);if(!C)return s(Error(`Tool ${A.name} not found`)),null;let U=J.has(A.id),O=!Y.has(A.id)&&!U,q=F?.toolUseId===A.id,M=C.inputSchema.safeParse(A.input),_=C.userFacingName(M.success?M.data:void 0),T=C.userFacingNameBackgroundColor?.(M.success?M.data:void 0);if(_==="")return null;let y=M.success?G45(C,M.data,{theme:D,verbose:G}):null;if(y===null)return null;return zY.default.createElement(j,{flexDirection:"row",justifyContent:"space-between",marginTop:Q?1:0,width:"100%"},zY.default.createElement(j,{flexDirection:"column"},zY.default.createElement(j,{flexDirection:"row",flexWrap:"nowrap",minWidth:_.length+(W?2:0)},W&&(O?zY.default.createElement(j,{minWidth:2},zY.default.createElement(z,{dimColor:O},UI)):zY.default.createElement(C0A,{shouldAnimate:X,isUnresolved:!U,isError:Z.has(A.id)})),zY.default.createElement(j,{flexShrink:0},zY.default.createElement(z,{bold:!0,wrap:"truncate-end",backgroundColor:T,color:T?"inverseText":void 0},_)),y!==""&&zY.default.createElement(j,{flexWrap:"nowrap"},zY.default.createElement(z,null,"(",y,")")),C.name===e9&&M.success&&M.data.timeout&&(()=>{let h=M.data.timeout,x=RIA();if(h!==x)return zY.default.createElement(j,{flexWrap:"nowrap",marginLeft:1},zY.default.createElement(z,{dimColor:!0},"timeout: ",lK(h)));return null})(),C.name===X3&&M.success&&M.data.resume&&zY.default.createElement(j,{flexWrap:"nowrap",marginLeft:1},zY.default.createElement(z,{dimColor:!0},"resuming ",M.data.resume)),C.name===X3&&M.success&&M.data.model&&(()=>{let h=nI(M.data.model),x=g8();if(h!==x)return zY.default.createElement(j,{flexWrap:"nowrap",marginLeft:1},zY.default.createElement(z,{dimColor:!0},nD(h)));return null})(),C.name===VH&&M.success&&M.data.task_id&&zY.default.createElement(j,{flexWrap:"nowrap",marginLeft:1},zY.default.createElement(z,{dimColor:!0},M.data.task_id)),!1),!U&&!O&&(q?zY.default.createElement(h0,{height:1},zY.default.createElement(z,{dimColor:!0},"Waiting for permission‚Ä¶")):Z45(C,B,V,A.id,I,{verbose:G,inProgressToolCallCount:K},E)),!U&&O&&Y45(C)))}function G45(A,Q,{theme:B,verbose:G}){try{let Z=A.inputSchema.safeParse(Q);if(!Z.success)return"";return A.renderToolUseMessage(Z.data,{theme:B,verbose:G})}catch(Z){return s(Error(`Error rendering tool use message for ${A.name}: ${Z}`)),""}}function Z45(A,Q,B,G,Z,{verbose:Y,inProgressToolCallCount:J},I){let X=Z.filter((W)=>W.data.type!=="hook_progress");try{let W=A.renderToolUseProgressMessage(X,{tools:Q,verbose:Y,terminalSize:I,inProgressToolCallCount:J??1});return zY.default.createElement(zY.default.Fragment,null,zY.default.createElement(V0A,null,zY.default.createElement(n61,{hookEvent:"PreToolUse",messages:B,toolUseID:G,verbose:Y})),W)}catch(W){return s(Error(`Error rendering tool use progress message for ${A.name}: ${W}`)),null}}function Y45(A){try{return A.renderToolUseQueuedMessage?.()}catch(Q){return s(Error(`Error rendering tool use queued message for ${A.name}: ${Q}`)),null}}var zY;var kF2=L(()=>{fA();h1();o61();xx();y6();Q_A();l2();T80();L61();u2();h4();di1();zY=o(WA(),1)});var hF2=w((bF2)=>{Object.defineProperty(bF2,"__esModule",{value:!0})});var uF2=w((gF2)=>{Object.defineProperty(gF2,"__esModule",{value:!0})});var P80=w((mF2)=>{Object.defineProperty(mF2,"__esModule",{value:!0})});var S80=w((I45)=>{function J45(A,Q,B){Q.split&&(Q=Q.split("."));var G=0,Z=Q.length,Y=A,J,I;while(G<Z){if(I=""+Q[G++],I==="__proto__"||I==="constructor"||I==="prototype")break;Y=Y[I]=G===Z?B:typeof(J=Y[I])===typeof Q?J:Q[G]*0!==0||!!~(""+Q[G]).indexOf(".")?{}:[]}}I45.dset=J45});var pF2=w((dF2)=>{Object.defineProperty(dF2,"__esModule",{value:!0});dF2.pickBy=void 0;var W45=function(A,Q){return Object.keys(A).filter(function(B){return Q(B,A[B])}).reduce(function(B,G){return B[G]=A[G],B},{})};dF2.pickBy=W45});var x80=w((lF2)=>{Object.defineProperty(lF2,"__esModule",{value:!0});lF2.ValidationError=void 0;var K45=HG(),V45=function(A){K45.__extends(Q,A);function Q(B,G){var Z=A.call(this,"".concat(B," ").concat(G))||this;return Z.field=B,Z}return Q}(Error);lF2.ValidationError=V45});var y80=w((nF2)=>{Object.defineProperty(nF2,"__esModule",{value:!0});nF2.isPlainObject=nF2.exists=nF2.isFunction=nF2.isNumber=nF2.isString=void 0;function E45(A){return typeof A==="string"}nF2.isString=E45;function D45(A){return typeof A==="number"}nF2.isNumber=D45;function H45(A){return typeof A==="function"}nF2.isFunction=H45;function F45(A){return A!==void 0&&A!==null}nF2.exists=F45;function C45(A){return Object.prototype.toString.call(A).slice(8,-1).toLowerCase()==="object"}nF2.isPlainObject=C45});var f80=w((BC2)=>{Object.defineProperty(BC2,"__esModule",{value:!0});BC2.validateEvent=BC2.assertTraits=BC2.assertTrackEventProperties=BC2.assertTrackEventName=BC2.assertEventType=BC2.assertEventExists=BC2.assertUserIdentity=void 0;var oi=x80(),z0A=y80(),v80="is not a string",k80="is not an object",oF2="is nil";function rF2(A){var Q=".userId/anonymousId/previousId/groupId",B=function(Z){var Y,J,I;return(I=(J=(Y=Z.userId)!==null&&Y!==void 0?Y:Z.anonymousId)!==null&&J!==void 0?J:Z.groupId)!==null&&I!==void 0?I:Z.previousId},G=B(A);if(!(0,z0A.exists)(G))throw new oi.ValidationError(Q,oF2);else if(!(0,z0A.isString)(G))throw new oi.ValidationError(Q,v80)}BC2.assertUserIdentity=rF2;function sF2(A){if(!(0,z0A.exists)(A))throw new oi.ValidationError("Event",oF2);if(typeof A!=="object")throw new oi.ValidationError("Event",k80)}BC2.assertEventExists=sF2;function tF2(A){if(!(0,z0A.isString)(A.type))throw new oi.ValidationError(".type",v80)}BC2.assertEventType=tF2;function eF2(A){if(!(0,z0A.isString)(A.event))throw new oi.ValidationError(".event",v80)}BC2.assertTrackEventName=eF2;function AC2(A){if(!(0,z0A.isPlainObject)(A.properties))throw new oi.ValidationError(".properties",k80)}BC2.assertTrackEventProperties=AC2;function QC2(A){if(!(0,z0A.isPlainObject)(A.traits))throw new oi.ValidationError(".traits",k80)}BC2.assertTraits=QC2;function N45(A){if(sF2(A),tF2(A),A.type==="track")eF2(A),AC2(A);if(["group","identify"].includes(A.type))QC2(A);rF2(A)}BC2.validateEvent=N45});var JC2=w((b80)=>{Object.defineProperty(b80,"__esModule",{value:!0});b80.EventFactory=void 0;var c3=HG();c3.__exportStar(P80(),b80);var ZC2=S80(),T45=pF2(),j45=f80(),P45=function(){function A(Q){this.user=Q.user,this.createMessageId=Q.createMessageId}return A.prototype.track=function(Q,B,G,Z){return this.normalize(c3.__assign(c3.__assign({},this.baseEvent()),{event:Q,type:"track",properties:B!==null&&B!==void 0?B:{},options:c3.__assign({},G),integrations:c3.__assign({},Z)}))},A.prototype.page=function(Q,B,G,Z,Y){var J,I={type:"page",properties:c3.__assign({},G),options:c3.__assign({},Z),integrations:c3.__assign({},Y)};if(Q!==null)I.category=Q,I.properties=(J=I.properties)!==null&&J!==void 0?J:{},I.properties.category=Q;if(B!==null)I.name=B;return this.normalize(c3.__assign(c3.__assign({},this.baseEvent()),I))},A.prototype.screen=function(Q,B,G,Z,Y){var J={type:"screen",properties:c3.__assign({},G),options:c3.__assign({},Z),integrations:c3.__assign({},Y)};if(Q!==null)J.category=Q;if(B!==null)J.name=B;return this.normalize(c3.__assign(c3.__assign({},this.baseEvent()),J))},A.prototype.identify=function(Q,B,G,Z){return this.normalize(c3.__assign(c3.__assign({},this.baseEvent()),{type:"identify",userId:Q,traits:B!==null&&B!==void 0?B:{},options:c3.__assign({},G),integrations:Z}))},A.prototype.group=function(Q,B,G,Z){return this.normalize(c3.__assign(c3.__assign({},this.baseEvent()),{type:"group",traits:B!==null&&B!==void 0?B:{},options:c3.__assign({},G),integrations:c3.__assign({},Z),groupId:Q}))},A.prototype.alias=function(Q,B,G,Z){var Y={userId:Q,type:"alias",options:c3.__assign({},G),integrations:c3.__assign({},Z)};if(B!==null)Y.previousId=B;if(Q===void 0)return this.normalize(c3.__assign(c3.__assign({},Y),this.baseEvent()));return this.normalize(c3.__assign(c3.__assign({},this.baseEvent()),Y))},A.prototype.baseEvent=function(){var Q={integrations:{},options:{}};if(!this.user)return Q;var B=this.user;if(B.id())Q.userId=B.id();if(B.anonymousId())Q.anonymousId=B.anonymousId();return Q},A.prototype.context=function(Q){var B,G=["userId","anonymousId","timestamp"];delete Q.integrations;var Z=Object.keys(Q),Y=(B=Q.context)!==null&&B!==void 0?B:{},J={};return Z.forEach(function(I){if(I==="context")return;if(G.includes(I))(0,ZC2.dset)(J,I,Q[I]);else(0,ZC2.dset)(Y,I,Q[I])}),[Y,J]},A.prototype.normalize=function(Q){var B,G,Z=Object.keys((B=Q.integrations)!==null&&B!==void 0?B:{}).reduce(function(D,H){var F,C;return c3.__assign(c3.__assign({},D),(F={},F[H]=Boolean((C=Q.integrations)===null||C===void 0?void 0:C[H]),F))},{});Q.options=(0,T45.pickBy)(Q.options||{},function(D,H){return H!==void 0});var Y=c3.__assign(c3.__assign({},Z),(G=Q.options)===null||G===void 0?void 0:G.integrations),J=Q.options?this.context(Q.options):[],I=J[0],X=J[1],W=Q.options,K=c3.__rest(Q,["options"]),V=c3.__assign(c3.__assign(c3.__assign({timestamp:new Date},K),{integrations:Y,context:I}),X),E=c3.__assign(c3.__assign({},V),{messageId:this.createMessageId()});return(0,j45.validateEvent)(E),E},A}();b80.EventFactory=P45});var h80=w((WC2)=>{Object.defineProperty(WC2,"__esModule",{value:!0});WC2.invokeCallback=WC2.sleep=WC2.pTimeout=void 0;function IC2(A,Q){return new Promise(function(B,G){var Z=setTimeout(function(){G(Error("Promise timed out"))},Q);A.then(function(Y){return clearTimeout(Z),B(Y)}).catch(G)})}WC2.pTimeout=IC2;function XC2(A){return new Promise(function(Q){return setTimeout(Q,A)})}WC2.sleep=XC2;function S45(A,Q,B){var G=function(){try{return Promise.resolve(Q(A))}catch(Z){return Promise.reject(Z)}};return XC2(B).then(function(){return IC2(G(),1000)}).catch(function(Z){A===null||A===void 0||A.log("warn","Callback Error",{error:Z}),A===null||A===void 0||A.stats.increment("callback_error")}).then(function(){return A})}WC2.invokeCallback=S45});var DC2=w((VC2)=>{Object.defineProperty(VC2,"__esModule",{value:!0});VC2.createDeferred=void 0;var v45=function(){var A,Q,B=new Promise(function(G,Z){A=G,Q=Z});return{resolve:A,reject:Q,promise:B}};VC2.createDeferred=v45});var HC2=w((g80)=>{Object.defineProperty(g80,"__esModule",{value:!0});var k45=HG();k45.__exportStar(DC2(),g80)});var zC2=w((FC2)=>{Object.defineProperty(FC2,"__esModule",{value:!0});FC2.Emitter=void 0;var f45=function(){function A(Q){var B;this.callbacks={},this.warned=!1,this.maxListeners=(B=Q===null||Q===void 0?void 0:Q.maxListeners)!==null&&B!==void 0?B:10}return A.prototype.warnIfPossibleMemoryLeak=function(Q){if(this.warned)return;if(this.maxListeners&&this.callbacks[Q].length>this.maxListeners)console.warn("Event Emitter: Possible memory leak detected; ".concat(String(Q)," has exceeded ").concat(this.maxListeners," listeners.")),this.warned=!0},A.prototype.on=function(Q,B){if(!this.callbacks[Q])this.callbacks[Q]=[B];else this.callbacks[Q].push(B),this.warnIfPossibleMemoryLeak(Q);return this},A.prototype.once=function(Q,B){var G=this,Z=function(){var Y=[];for(var J=0;J<arguments.length;J++)Y[J]=arguments[J];G.off(Q,Z),B.apply(G,Y)};return this.on(Q,Z),this},A.prototype.off=function(Q,B){var G,Z=(G=this.callbacks[Q])!==null&&G!==void 0?G:[],Y=Z.filter(function(J){return J!==B});return this.callbacks[Q]=Y,this},A.prototype.emit=function(Q){var B=this,G,Z=[];for(var Y=1;Y<arguments.length;Y++)Z[Y-1]=arguments[Y];var J=(G=this.callbacks[Q])!==null&&G!==void 0?G:[];return J.forEach(function(I){I.apply(B,Z)}),this},A}();FC2.Emitter=f45});var UC2=w((u80)=>{Object.defineProperty(u80,"__esModule",{value:!0});var b45=HG();b45.__exportStar(zC2(),u80)});var _IA=w((t61)=>{Object.defineProperty(t61,"__esModule",{value:!0});var $C2=HG();$C2.__exportStar(HC2(),t61);$C2.__exportStar(UC2(),t61)});var m80=w((wC2)=>{Object.defineProperty(wC2,"__esModule",{value:!0});wC2.backoff=void 0;function h45(A){var Q=Math.random()+1,B=A.minTimeout,G=B===void 0?500:B,Z=A.factor,Y=Z===void 0?2:Z,J=A.attempt,I=A.maxTimeout,X=I===void 0?1/0:I;return Math.min(Q*G*Math.pow(Y,J),X)}wC2.backoff=h45});var d80=w((qC2)=>{Object.defineProperty(qC2,"__esModule",{value:!0});qC2.PriorityQueue=qC2.ON_REMOVE_FROM_FUTURE=void 0;var g45=HG(),u45=_IA(),m45=m80();qC2.ON_REMOVE_FROM_FUTURE="onRemoveFromFuture";var d45=function(A){g45.__extends(Q,A);function Q(B,G,Z){var Y=A.call(this)||this;return Y.future=[],Y.maxAttempts=B,Y.queue=G,Y.seen=Z!==null&&Z!==void 0?Z:{},Y}return Q.prototype.push=function(){var B=this,G=[];for(var Z=0;Z<arguments.length;Z++)G[Z]=arguments[Z];var Y=G.map(function(J){var I=B.updateAttempts(J);if(I>B.maxAttempts||B.includes(J))return!1;return B.queue.push(J),!0});return this.queue=this.queue.sort(function(J,I){return B.getAttempts(J)-B.getAttempts(I)}),Y},Q.prototype.pushWithBackoff=function(B){var G=this;if(this.getAttempts(B)===0)return this.push(B)[0];var Z=this.updateAttempts(B);if(Z>this.maxAttempts||this.includes(B))return!1;var Y=(0,m45.backoff)({attempt:Z-1});return setTimeout(function(){G.queue.push(B),G.future=G.future.filter(function(J){return J.id!==B.id}),G.emit(qC2.ON_REMOVE_FROM_FUTURE)},Y),this.future.push(B),!0},Q.prototype.getAttempts=function(B){var G;return(G=this.seen[B.id])!==null&&G!==void 0?G:0},Q.prototype.updateAttempts=function(B){return this.seen[B.id]=this.getAttempts(B)+1,this.getAttempts(B)},Q.prototype.includes=function(B){return this.queue.includes(B)||this.future.includes(B)||Boolean(this.queue.find(function(G){return G.id===B.id}))||Boolean(this.future.find(function(G){return G.id===B.id}))},Q.prototype.pop=function(){return this.queue.shift()},Object.defineProperty(Q.prototype,"length",{get:function(){return this.queue.length},enumerable:!1,configurable:!0}),Object.defineProperty(Q.prototype,"todo",{get:function(){return this.queue.length+this.future.length},enumerable:!1,configurable:!0}),Q}(u45.Emitter);qC2.PriorityQueue=d45});var c80=w((p45)=>{var U0A=256,A31=[],e61;while(U0A--)A31[U0A]=(U0A+256).toString(16).substring(1);function c45(){var A=0,Q,B="";if(!e61||U0A+16>256){e61=Array(A=256);while(A--)e61[A]=256*Math.random()|0;A=U0A=0}for(;A<16;A++){if(Q=e61[U0A+A],A==6)B+=A31[Q&15|64];else if(A==8)B+=A31[Q&63|128];else B+=A31[Q];if(A&1&&A>1&&A<11)B+="-"}return U0A++,B}p45.v4=c45});var p80=w((OC2)=>{Object.defineProperty(OC2,"__esModule",{value:!0});OC2.CoreLogger=void 0;var Q31=HG(),i45=function(){function A(){this._logs=[]}return A.prototype.log=function(Q,B,G){var Z=new Date;this._logs.push({level:Q,message:B,time:Z,extras:G})},Object.defineProperty(A.prototype,"logs",{get:function(){return this._logs},enumerable:!1,configurable:!0}),A.prototype.flush=function(){if(this.logs.length>1){var Q=this._logs.reduce(function(B,G){var Z,Y,J,I=Q31.__assign(Q31.__assign({},G),{json:JSON.stringify(G.extras,null," "),extras:G.extras});delete I.time;var X=(J=(Y=G.time)===null||Y===void 0?void 0:Y.toISOString())!==null&&J!==void 0?J:"";if(B[X])X="".concat(X,"-").concat(Math.random());return Q31.__assign(Q31.__assign({},B),(Z={},Z[X]=I,Z))},{});if(console.table)console.table(Q);else console.log(Q)}else this.logs.forEach(function(B){var{level:G,message:Z,extras:Y}=B;if(G==="info"||G==="debug")console.log(Z,Y!==null&&Y!==void 0?Y:"");else console[G](Z,Y!==null&&Y!==void 0?Y:"")});this._logs=[]},A}();OC2.CoreLogger=i45});var i80=w((TC2)=>{Object.defineProperty(TC2,"__esModule",{value:!0});TC2.NullStats=TC2.CoreStats=void 0;var l80=HG(),n45=function(A){var Q={gauge:"g",counter:"c"};return Q[A]},_C2=function(){function A(){this.metrics=[]}return A.prototype.increment=function(Q,B,G){if(B===void 0)B=1;this.metrics.push({metric:Q,value:B,tags:G!==null&&G!==void 0?G:[],type:"counter",timestamp:Date.now()})},A.prototype.gauge=function(Q,B,G){this.metrics.push({metric:Q,value:B,tags:G!==null&&G!==void 0?G:[],type:"gauge",timestamp:Date.now()})},A.prototype.flush=function(){var Q=this.metrics.map(function(B){return l80.__assign(l80.__assign({},B),{tags:B.tags.join(",")})});if(console.table)console.table(Q);else console.log(Q);this.metrics=[]},A.prototype.serialize=function(){return this.metrics.map(function(Q){return{m:Q.metric,v:Q.value,t:Q.tags,k:n45(Q.type),e:Q.timestamp}})},A}();TC2.CoreStats=_C2;var a45=function(A){l80.__extends(Q,A);function Q(){return A!==null&&A.apply(this,arguments)||this}return Q.prototype.gauge=function(){var B=[];for(var G=0;G<arguments.length;G++)B[G]=arguments[G]},Q.prototype.increment=function(){var B=[];for(var G=0;G<arguments.length;G++)B[G]=arguments[G]},Q.prototype.flush=function(){var B=[];for(var G=0;G<arguments.length;G++)B[G]=arguments[G]},Q.prototype.serialize=function(){var B=[];for(var G=0;G<arguments.length;G++)B[G]=arguments[G];return[]},Q}(_C2);TC2.NullStats=a45});var B31=w((SC2)=>{Object.defineProperty(SC2,"__esModule",{value:!0});SC2.CoreContext=SC2.ContextCancelation=void 0;var r45=c80(),s45=S80(),t45=p80(),e45=i80(),PC2=function(){function A(Q){var B,G,Z;this.retry=(B=Q.retry)!==null&&B!==void 0?B:!0,this.type=(G=Q.type)!==null&&G!==void 0?G:"plugin Error",this.reason=(Z=Q.reason)!==null&&Z!==void 0?Z:""}return A}();SC2.ContextCancelation=PC2;var A65=function(){function A(Q,B,G,Z){if(B===void 0)B=(0,r45.v4)();if(G===void 0)G=new e45.NullStats;if(Z===void 0)Z=new t45.CoreLogger;this.attempts=0,this.event=Q,this._id=B,this.logger=Z,this.stats=G}return A.system=function(){},A.prototype.isSame=function(Q){return Q.id===this.id},A.prototype.cancel=function(Q){if(Q)throw Q;throw new PC2({reason:"Context Cancel"})},A.prototype.log=function(Q,B,G){this.logger.log(Q,B,G)},Object.defineProperty(A.prototype,"id",{get:function(){return this._id},enumerable:!1,configurable:!0}),A.prototype.updateEvent=function(Q,B){var G;if(Q.split(".")[0]==="integrations"){var Z=Q.split(".")[1];if(((G=this.event.integrations)===null||G===void 0?void 0:G[Z])===!1)return this.event}return(0,s45.dset)(this.event,Q,B),this.event},A.prototype.failedDelivery=function(){return this._failedDelivery},A.prototype.setFailedDelivery=function(Q){this._failedDelivery=Q},A.prototype.logs=function(){return this.logger.logs},A.prototype.flush=function(){this.logger.flush(),this.stats.flush()},A.prototype.toJSON=function(){return{id:this._id,event:this.event,logs:this.logger.logs,metrics:this.stats.metrics}},A}();SC2.CoreContext=A65});var fC2=w((vC2)=>{Object.defineProperty(vC2,"__esModule",{value:!0});vC2.groupBy=void 0;var yC2=HG();function B65(A,Q){var B={};return A.forEach(function(G){var Z,Y=void 0;if(typeof Q==="string"){var J=G[Q];Y=typeof J!=="string"?JSON.stringify(J):J}else if(Q instanceof Function)Y=Q(G);if(Y===void 0)return;B[Y]=yC2.__spreadArray(yC2.__spreadArray([],(Z=B[Y])!==null&&Z!==void 0?Z:[],!0),[G],!1)}),B}vC2.groupBy=B65});var gC2=w((bC2)=>{Object.defineProperty(bC2,"__esModule",{value:!0});bC2.isThenable=void 0;var G65=function(A){return typeof A==="object"&&A!==null&&"then"in A&&typeof A.then==="function"};bC2.isThenable=G65});var dC2=w((uC2)=>{Object.defineProperty(uC2,"__esModule",{value:!0});uC2.createTaskGroup=void 0;var Z65=gC2(),Y65=function(){var A,Q,B=0;return{done:function(){return A},run:function(G){var Z=G();if((0,Z65.isThenable)(Z)){if(++B===1)A=new Promise(function(Y){return Q=Y});Z.finally(function(){return--B===0&&Q()})}return Z}}};uC2.createTaskGroup=Y65});var a80=w((lC2)=>{Object.defineProperty(lC2,"__esModule",{value:!0});lC2.ensure=lC2.attempt=void 0;var cC2=HG(),n80=B31();function J65(A){return cC2.__awaiter(this,void 0,void 0,function(){var Q;return cC2.__generator(this,function(B){switch(B.label){case 0:return B.trys.push([0,2,,3]),[4,A()];case 1:return[2,B.sent()];case 2:return Q=B.sent(),[2,Promise.reject(Q)];case 3:return[2]}})})}function pC2(A,Q){A.log("debug","plugin",{plugin:Q.name});var B=new Date().getTime(),G=Q[A.event.type];if(G===void 0)return Promise.resolve(A);var Z=J65(function(){return G.apply(Q,[A])}).then(function(Y){var J=new Date().getTime()-B;return Y.stats.gauge("plugin_time",J,["plugin:".concat(Q.name)]),Y}).catch(function(Y){if(Y instanceof n80.ContextCancelation&&Y.type==="middleware_cancellation")throw Y;if(Y instanceof n80.ContextCancelation)return A.log("warn",Y.type,{plugin:Q.name,error:Y}),Y;return A.log("error","plugin Error",{plugin:Q.name,error:Y}),A.stats.increment("plugin_error",1,["plugin:".concat(Q.name)]),Y});return Z}lC2.attempt=pC2;function I65(A,Q){return pC2(A,Q).then(function(B){if(B instanceof n80.CoreContext)return B;A.log("debug","Context canceled"),A.stats.increment("context_canceled"),A.cancel(B)})}lC2.ensure=I65});var oC2=w((nC2)=>{Object.defineProperty(nC2,"__esModule",{value:!0});nC2.CoreEventQueue=void 0;var eE=HG(),W65=fC2(),K65=d80(),o80=B31(),V65=_IA(),E65=dC2(),G31=a80(),D65=function(A){eE.__extends(Q,A);function Q(B){var G=A.call(this)||this;return G.criticalTasks=(0,E65.createTaskGroup)(),G.plugins=[],G.failedInitializations=[],G.flushing=!1,G.queue=B,G.queue.on(K65.ON_REMOVE_FROM_FUTURE,function(){G.scheduleFlush(0)}),G}return Q.prototype.register=function(B,G,Z){return eE.__awaiter(this,void 0,void 0,function(){var Y=this;return eE.__generator(this,function(J){switch(J.label){case 0:return[4,Promise.resolve(G.load(B,Z)).then(function(){Y.plugins.push(G)}).catch(function(I){if(G.type==="destination"){Y.failedInitializations.push(G.name),console.warn(G.name,I),B.log("warn","Failed to load destination",{plugin:G.name,error:I});return}throw I})];case 1:return J.sent(),[2]}})})},Q.prototype.deregister=function(B,G,Z){return eE.__awaiter(this,void 0,void 0,function(){var Y;return eE.__generator(this,function(J){switch(J.label){case 0:if(J.trys.push([0,3,,4]),!G.unload)return[3,2];return[4,Promise.resolve(G.unload(B,Z))];case 1:J.sent(),J.label=2;case 2:return this.plugins=this.plugins.filter(function(I){return I.name!==G.name}),[3,4];case 3:return Y=J.sent(),B.log("warn","Failed to unload destination",{plugin:G.name,error:Y}),[3,4];case 4:return[2]}})})},Q.prototype.dispatch=function(B){return eE.__awaiter(this,void 0,void 0,function(){var G;return eE.__generator(this,function(Z){return B.log("debug","Dispatching"),B.stats.increment("message_dispatched"),this.queue.push(B),G=this.subscribeToDelivery(B),this.scheduleFlush(0),[2,G]})})},Q.prototype.subscribeToDelivery=function(B){return eE.__awaiter(this,void 0,void 0,function(){var G=this;return eE.__generator(this,function(Z){return[2,new Promise(function(Y){var J=function(I,X){if(I.isSame(B))if(G.off("flush",J),X)Y(I);else Y(I)};G.on("flush",J)})]})})},Q.prototype.dispatchSingle=function(B){return eE.__awaiter(this,void 0,void 0,function(){var G=this;return eE.__generator(this,function(Z){return B.log("debug","Dispatching"),B.stats.increment("message_dispatched"),this.queue.updateAttempts(B),B.attempts=1,[2,this.deliver(B).catch(function(Y){var J=G.enqueuRetry(Y,B);if(!J)return B.setFailedDelivery({reason:Y}),B;return G.subscribeToDelivery(B)})]})})},Q.prototype.isEmpty=function(){return this.queue.length===0},Q.prototype.scheduleFlush=function(B){var G=this;if(B===void 0)B=500;if(this.flushing)return;this.flushing=!0,setTimeout(function(){G.flush().then(function(){setTimeout(function(){if(G.flushing=!1,G.queue.length)G.scheduleFlush(0)},0)})},B)},Q.prototype.deliver=function(B){return eE.__awaiter(this,void 0,void 0,function(){var G,Z,Y,J;return eE.__generator(this,function(I){switch(I.label){case 0:return[4,this.criticalTasks.done()];case 1:I.sent(),G=Date.now(),I.label=2;case 2:return I.trys.push([2,4,,5]),[4,this.flushOne(B)];case 3:return B=I.sent(),Z=Date.now()-G,this.emit("delivery_success",B),B.stats.gauge("delivered",Z),B.log("debug","Delivered",B.event),[2,B];case 4:throw Y=I.sent(),J=Y,B.log("error","Failed to deliver",J),this.emit("delivery_failure",B,J),B.stats.increment("delivery_failed"),Y;case 5:return[2]}})})},Q.prototype.enqueuRetry=function(B,G){var Z=!(B instanceof o80.ContextCancelation)||B.retry;if(!Z)return!1;return this.queue.pushWithBackoff(G)},Q.prototype.flush=function(){return eE.__awaiter(this,void 0,void 0,function(){var B,G,Z;return eE.__generator(this,function(Y){switch(Y.label){case 0:if(this.queue.length===0)return[2,[]];if(B=this.queue.pop(),!B)return[2,[]];B.attempts=this.queue.getAttempts(B),Y.label=1;case 1:return Y.trys.push([1,3,,4]),[4,this.deliver(B)];case 2:return B=Y.sent(),this.emit("flush",B,!0),[3,4];case 3:if(G=Y.sent(),Z=this.enqueuRetry(G,B),!Z)B.setFailedDelivery({reason:G}),this.emit("flush",B,!1);return[2,[]];case 4:return[2,[B]]}})})},Q.prototype.isReady=function(){return!0},Q.prototype.availableExtensions=function(B){var G=this.plugins.filter(function(D){var H,F,C;if(D.type!=="destination"&&D.name!=="Segment.io")return!0;var U=void 0;return(H=D.alternativeNames)===null||H===void 0||H.forEach(function(O){if(B[O]!==void 0)U=B[O]}),(C=(F=B[D.name])!==null&&F!==void 0?F:U)!==null&&C!==void 0?C:(D.name==="Segment.io"?!0:B.All)!==!1}),Z=(0,W65.groupBy)(G,"type"),Y=Z.before,J=Y===void 0?[]:Y,I=Z.enrichment,X=I===void 0?[]:I,W=Z.destination,K=W===void 0?[]:W,V=Z.after,E=V===void 0?[]:V;return{before:J,enrichment:X,destinations:K,after:E}},Q.prototype.flushOne=function(B){var G,Z;return eE.__awaiter(this,void 0,void 0,function(){var Y,J,I,X,W,K,H,V,E,D,H,F,C,U,O;return eE.__generator(this,function(q){switch(q.label){case 0:if(!this.isReady())throw Error("Not ready");if(B.attempts>1)this.emit("delivery_retry",B);Y=this.availableExtensions((G=B.event.integrations)!==null&&G!==void 0?G:{}),J=Y.before,I=Y.enrichment,X=0,W=J,q.label=1;case 1:if(!(X<W.length))return[3,4];return K=W[X],[4,(0,G31.ensure)(B,K)];case 2:if(H=q.sent(),H instanceof o80.CoreContext)B=H;this.emit("message_enriched",B,K),q.label=3;case 3:return X++,[3,1];case 4:V=0,E=I,q.label=5;case 5:if(!(V<E.length))return[3,8];return D=E[V],[4,(0,G31.attempt)(B,D)];case 6:if(H=q.sent(),H instanceof o80.CoreContext)B=H;this.emit("message_enriched",B,D),q.label=7;case 7:return V++,[3,5];case 8:return F=this.availableExtensions((Z=B.event.integrations)!==null&&Z!==void 0?Z:{}),C=F.destinations,U=F.after,[4,new Promise(function(M,_){setTimeout(function(){var T=C.map(function(y){return(0,G31.attempt)(B,y)});Promise.all(T).then(M).catch(_)},0)})];case 9:return q.sent(),B.stats.increment("message_delivered"),this.emit("message_delivered",B),O=U.map(function(M){return(0,G31.attempt)(B,M)}),[4,Promise.all(O)];case 10:return q.sent(),[2,B]}})})},Q}(V65.Emitter);nC2.CoreEventQueue=D65});var sC2=w((rC2)=>{Object.defineProperty(rC2,"__esModule",{value:!0})});var Bz2=w((eC2)=>{Object.defineProperty(eC2,"__esModule",{value:!0});eC2.dispatch=eC2.getDelay=void 0;var tC2=HG(),H65=h80(),F65=function(A,Q){var B=Date.now()-A;return Math.max((Q!==null&&Q!==void 0?Q:300)-B,0)};eC2.getDelay=F65;function C65(A,Q,B,G){return tC2.__awaiter(this,void 0,void 0,function(){var Z,Y;return tC2.__generator(this,function(J){switch(J.label){case 0:if(B.emit("dispatch_start",A),Z=Date.now(),!Q.isEmpty())return[3,2];return[4,Q.dispatchSingle(A)];case 1:return Y=J.sent(),[3,4];case 2:return[4,Q.dispatch(A)];case 3:Y=J.sent(),J.label=4;case 4:if(!(G===null||G===void 0?void 0:G.callback))return[3,6];return[4,(0,H65.invokeCallback)(Y,G.callback,eC2.getDelay(Z,G.timeout))];case 5:Y=J.sent(),J.label=6;case 6:if(G===null||G===void 0?void 0:G.debug)Y.flush();return[2,Y]}})})}eC2.dispatch=C65});var Yz2=w((Gz2)=>{Object.defineProperty(Gz2,"__esModule",{value:!0});Gz2.bindAll=void 0;function z65(A){var Q=A.constructor.prototype;for(var B=0,G=Object.getOwnPropertyNames(Q);B<G.length;B++){var Z=G[B];if(Z!=="constructor"){var Y=Object.getOwnPropertyDescriptor(A.constructor.prototype,Z);if(!!Y&&typeof Y.value==="function")A[Z]=A[Z].bind(A)}}return A}Gz2.bindAll=z65});var ri=w((wW)=>{Object.defineProperty(wW,"__esModule",{value:!0});wW.CoreLogger=wW.backoff=void 0;var yH=HG();yH.__exportStar(hF2(),wW);yH.__exportStar(uF2(),wW);yH.__exportStar(P80(),wW);yH.__exportStar(JC2(),wW);yH.__exportStar(h80(),wW);yH.__exportStar(d80(),wW);var U65=m80();Object.defineProperty(wW,"backoff",{enumerable:!0,get:function(){return U65.backoff}});yH.__exportStar(B31(),wW);yH.__exportStar(oC2(),wW);yH.__exportStar(sC2(),wW);yH.__exportStar(Bz2(),wW);yH.__exportStar(y80(),wW);yH.__exportStar(x80(),wW);yH.__exportStar(f80(),wW);yH.__exportStar(Yz2(),wW);yH.__exportStar(i80(),wW);var $65=p80();Object.defineProperty(wW,"CoreLogger",{enumerable:!0,get:function(){return $65.CoreLogger}});yH.__exportStar(a80(),wW)});var Xz2=w((Jz2)=>{Object.defineProperty(Jz2,"__esModule",{value:!0});Jz2.validateSettings=void 0;var N65=ri(),q65=(A)=>{if(!A.writeKey)throw new N65.ValidationError("writeKey","writeKey is missing.")};Jz2.validateSettings=q65});var r80=w((Wz2)=>{Object.defineProperty(Wz2,"__esModule",{value:!0});Wz2.version=void 0;Wz2.version="1.3.0"});var Dz2=w((Vz2)=>{Object.defineProperty(Vz2,"__esModule",{value:!0});Vz2.tryCreateFormattedUrl=void 0;var L65=(A)=>A.replace(/\/$/,""),M65=(A,Q)=>{return L65(new URL(Q||"",A).href)};Vz2.tryCreateFormattedUrl=M65});var t80=w((s80)=>{Object.defineProperty(s80,"__esModule",{value:!0});s80.uuid=void 0;var O65=c80();Object.defineProperty(s80,"uuid",{enumerable:!0,get:function(){return O65.v4}})});var $z2=w((zz2)=>{Object.defineProperty(zz2,"__esModule",{value:!0});zz2.ContextBatch=void 0;var _65=t80(),Hz2=32,Fz2=480;class Cz2{constructor(A){this.id=(0,_65.uuid)(),this.items=[],this.sizeInBytes=0,this.maxEventCount=Math.max(1,A)}tryAdd(A){if(this.length===this.maxEventCount)return{success:!1,message:`Event limit of ${this.maxEventCount} has been exceeded.`};let Q=this.calculateSize(A.context);if(Q>Hz2*1024)return{success:!1,message:`Event exceeds maximum event size of ${Hz2} KB`};if(this.sizeInBytes+Q>Fz2*1024)return{success:!1,message:`Event has caused batch size to exceed ${Fz2} KB`};return this.items.push(A),this.sizeInBytes+=Q,{success:!0}}get length(){return this.items.length}calculateSize(A){return encodeURI(JSON.stringify(A.event)).split(/%..|i/).length}getEvents(){return this.items.map(({context:Q})=>Q.event)}getContexts(){return this.items.map((A)=>A.context)}resolveEvents(){this.items.forEach(({resolver:A,context:Q})=>A(Q))}}zz2.ContextBatch=Cz2});var qz2=w((wz2)=>{Object.defineProperty(wz2,"__esModule",{value:!0});wz2.b64encode=void 0;var T65=qA("buffer"),j65=(A)=>{return T65.Buffer.from(A).toString("base64")};wz2.b64encode=j65});var _z2=w((Oz2)=>{Object.defineProperty(Oz2,"__esModule",{value:!0});Oz2.Publisher=void 0;var P65=ri(),S65=Dz2(),x65=_IA(),y65=$z2(),v65=qz2();function k65(A){return new Promise((Q)=>setTimeout(Q,A))}function B_A(){}class Mz2{constructor({host:A,path:Q,maxRetries:B,flushAt:G,flushInterval:Z,writeKey:Y,httpRequestTimeout:J,httpClient:I,disable:X},W){this._emitter=W,this._maxRetries=B,this._flushAt=Math.max(G,1),this._flushInterval=Z,this._auth=(0,v65.b64encode)(`${Y}:`),this._url=(0,S65.tryCreateFormattedUrl)(A??"https://api.segment.io",Q??"/v1/batch"),this._httpRequestTimeout=J??1e4,this._disable=Boolean(X),this._httpClient=I}createBatch(){this.pendingFlushTimeout&&clearTimeout(this.pendingFlushTimeout);let A=new y65.ContextBatch(this._flushAt);return this._batch=A,this.pendingFlushTimeout=setTimeout(()=>{if(A===this._batch)this._batch=void 0;if(this.pendingFlushTimeout=void 0,A.length)this.send(A).catch(B_A)},this._flushInterval),A}clearBatch(){this.pendingFlushTimeout&&clearTimeout(this.pendingFlushTimeout),this._batch=void 0}flush(A){if(!A)return;if(this._flushPendingItemsCount=A,!this._batch)return;if(this._batch.length===A)this.send(this._batch).catch(B_A),this.clearBatch()}enqueue(A){let Q=this._batch??this.createBatch(),{promise:B,resolve:G}=(0,x65.createDeferred)(),Z={context:A,resolver:G};if(Q.tryAdd(Z).success){let X=Q.length===this._flushPendingItemsCount;if(Q.length===this._flushAt||X)this.send(Q).catch(B_A),this.clearBatch();return B}if(Q.length)this.send(Q).catch(B_A),this.clearBatch();let J=this.createBatch(),I=J.tryAdd(Z);if(I.success){if(J.length===this._flushPendingItemsCount)this.send(J).catch(B_A),this.clearBatch();return B}else return A.setFailedDelivery({reason:Error(I.message)}),Promise.resolve(A)}async send(A){if(this._flushPendingItemsCount)this._flushPendingItemsCount-=A.length;let Q=A.getEvents(),B=this._maxRetries+1,G=0;while(G<B){G++;let Z;try{if(this._disable)return A.resolveEvents();let Y={url:this._url,method:"POST",headers:{"Content-Type":"application/json",Authorization:`Basic ${this._auth}`,"User-Agent":"analytics-node-next/latest"},data:{batch:Q,sentAt:new Date},httpRequestTimeout:this._httpRequestTimeout};this._emitter.emit("http_request",{body:Y.data,method:Y.method,url:Y.url,headers:Y.headers});let J=await this._httpClient.makeRequest(Y);if(J.status>=200&&J.status<300){A.resolveEvents();return}else if(J.status===400){Lz2(A,Error(`[${J.status}] ${J.statusText}`));return}else Z=Error(`[${J.status}] ${J.statusText}`)}catch(Y){Z=Y}if(G===B){Lz2(A,Z);return}await k65((0,P65.backoff)({attempt:G,minTimeout:25,maxTimeout:1000}))}}}Oz2.Publisher=Mz2;function Lz2(A,Q){A.getContexts().forEach((B)=>B.setFailedDelivery({reason:Q})),A.resolveEvents()}});var e80=w((Tz2)=>{Object.defineProperty(Tz2,"__esModule",{value:!0});Tz2.detectRuntime=void 0;var f65=()=>{if(typeof process==="object"&&process&&typeof process.env==="object"&&process.env&&typeof process.version==="string")return"node";if(typeof window==="object")return"browser";if(typeof WebSocketPair<"u")return"cloudflare-worker";if(typeof EdgeRuntime==="string")return"vercel-edge";if(typeof WorkerGlobalScope<"u"&&typeof importScripts==="function")return"web-worker";return"unknown"};Tz2.detectRuntime=f65});var yz2=w((Sz2)=>{Object.defineProperty(Sz2,"__esModule",{value:!0});Sz2.createConfiguredNodePlugin=Sz2.createNodePlugin=void 0;var b65=_z2(),h65=r80(),g65=e80();function u65(A){A.updateEvent("context.library.name","@segment/analytics-node"),A.updateEvent("context.library.version",h65.version);let Q=(0,g65.detectRuntime)();if(Q==="node")A.updateEvent("_metadata.nodeVersion",process.version);A.updateEvent("_metadata.jsRuntime",Q)}function Pz2(A){function Q(B){return u65(B),A.enqueue(B)}return{name:"Segment.io",type:"destination",version:"1.0.0",isLoaded:()=>!0,load:()=>Promise.resolve(),alias:Q,group:Q,identify:Q,page:Q,screen:Q,track:Q}}Sz2.createNodePlugin=Pz2;var m65=(A,Q)=>{let B=new b65.Publisher(A,Q);return{publisher:B,plugin:Pz2(B)}};Sz2.createConfiguredNodePlugin=m65});var fz2=w((vz2)=>{Object.defineProperty(vz2,"__esModule",{value:!0});vz2.createMessageId=void 0;var c65=t80(),p65=()=>{return`node-next-${Date.now()}-${(0,c65.uuid)()}`};vz2.createMessageId=p65});var uz2=w((hz2)=>{Object.defineProperty(hz2,"__esModule",{value:!0});hz2.NodeEventFactory=void 0;var l65=ri(),i65=fz2();class bz2 extends l65.EventFactory{constructor(){super({createMessageId:i65.createMessageId})}}hz2.NodeEventFactory=bz2});var Z31=w((dz2)=>{Object.defineProperty(dz2,"__esModule",{value:!0});dz2.Context=void 0;var n65=ri();class mz2 extends n65.CoreContext{static system(){return new this({type:"track",event:"system"})}}dz2.Context=mz2});var iz2=w((pz2)=>{Object.defineProperty(pz2,"__esModule",{value:!0});pz2.dispatchAndEmit=void 0;var a65=ri(),o65=Z31(),r65=(A)=>(Q)=>{let B=Q.failedDelivery();return B?A(B.reason,Q):A(void 0,Q)},s65=async(A,Q,B,G)=>{try{let Z=new o65.Context(A),Y=await(0,a65.dispatch)(Z,Q,B,{...G?{callback:r65(G)}:{}}),J=Y.failedDelivery();if(J)B.emit("error",{code:"delivery_failure",reason:J.reason,ctx:Y});else B.emit(A.type,Y)}catch(Z){B.emit("error",{code:"unknown",reason:Z})}};pz2.dispatchAndEmit=s65});var rz2=w((az2)=>{Object.defineProperty(az2,"__esModule",{value:!0});az2.NodeEmitter=void 0;var t65=_IA();class nz2 extends t65.Emitter{}az2.NodeEmitter=nz2});var BU2=w((AU2)=>{Object.defineProperty(AU2,"__esModule",{value:!0});AU2.NodeEventQueue=void 0;var sz2=ri();class tz2 extends sz2.PriorityQueue{constructor(){super(1,[])}getAttempts(A){return A.attempts??0}updateAttempts(A){return A.attempts=this.getAttempts(A)+1,this.getAttempts(A)}}class ez2 extends sz2.CoreEventQueue{constructor(){super(new tz2)}}AU2.NodeEventQueue=ez2});var JU2=w((ZU2)=>{Object.defineProperty(ZU2,"__esModule",{value:!0});ZU2.abortSignalAfterTimeout=ZU2.AbortSignal=void 0;var e65=_IA(),A35=e80();class A50{constructor(){this.onabort=null,this.aborted=!1,this.eventEmitter=new e65.Emitter}toString(){return"[object AbortSignal]"}get[Symbol.toStringTag](){return"AbortSignal"}removeEventListener(...A){this.eventEmitter.off(...A)}addEventListener(...A){this.eventEmitter.on(...A)}dispatchEvent(A){let Q={type:A,target:this},B=`on${A}`;if(typeof this[B]==="function")this[B](Q);this.eventEmitter.emit(A,Q)}}ZU2.AbortSignal=A50;class GU2{constructor(){this.signal=new A50}abort(){if(this.signal.aborted)return;this.signal.aborted=!0,this.signal.dispatchEvent("abort")}toString(){return"[object AbortController]"}get[Symbol.toStringTag](){return"AbortController"}}var Q35=(A)=>{if((0,A35.detectRuntime)()==="cloudflare-worker")return[];let Q=new(globalThis.AbortController||GU2),B=setTimeout(()=>{Q.abort()},A);return B?.unref?.(),[Q.signal,B]};ZU2.abortSignalAfterTimeout=Q35});var IU2=w((Ly)=>{var G35=Ly&&Ly.__createBinding||(Object.create?function(A,Q,B,G){if(G===void 0)G=B;var Z=Object.getOwnPropertyDescriptor(Q,B);if(!Z||("get"in Z?!Q.__esModule:Z.writable||Z.configurable))Z={enumerable:!0,get:function(){return Q[B]}};Object.defineProperty(A,G,Z)}:function(A,Q,B,G){if(G===void 0)G=B;A[G]=Q[B]}),Z35=Ly&&Ly.__setModuleDefault||(Object.create?function(A,Q){Object.defineProperty(A,"default",{enumerable:!0,value:Q})}:function(A,Q){A.default=Q}),Y35=Ly&&Ly.__importStar||function(A){if(A&&A.__esModule)return A;var Q={};if(A!=null){for(var B in A)if(B!=="default"&&Object.prototype.hasOwnProperty.call(A,B))G35(Q,A,B)}return Z35(Q,A),Q};Object.defineProperty(Ly,"__esModule",{value:!0});Ly.fetch=void 0;var J35=async(...A)=>{if(globalThis.fetch)return globalThis.fetch(...A);else if(typeof EdgeRuntime!=="string")return(await Promise.resolve().then(()=>Y35(wf1()))).default(...A);else throw Error("Invariant: an edge runtime that does not support fetch should not exist")};Ly.fetch=J35});var Q50=w((WU2)=>{Object.defineProperty(WU2,"__esModule",{value:!0});WU2.FetchHTTPClient=void 0;var I35=JU2(),X35=IU2();class XU2{constructor(A){this._fetch=A??X35.fetch}async makeRequest(A){let[Q,B]=(0,I35.abortSignalAfterTimeout)(A.httpRequestTimeout),G={url:A.url,method:A.method,headers:A.headers,body:JSON.stringify(A.data),signal:Q};return this._fetch(A.url,G).finally(()=>clearTimeout(B))}}WU2.FetchHTTPClient=XU2});var B50=w((FU2)=>{Object.defineProperty(FU2,"__esModule",{value:!0});FU2.Analytics=void 0;var VU2=ri(),W35=Xz2(),K35=r80(),V35=yz2(),E35=uz2(),D35=iz2(),H35=rz2(),EU2=Z31(),F35=BU2(),DU2=Q50();class HU2 extends H35.NodeEmitter{constructor(A){super();this._isClosed=!1,this._pendingEvents=0,this._isFlushing=!1,(0,W35.validateSettings)(A),this._eventFactory=new E35.NodeEventFactory,this._queue=new F35.NodeEventQueue;let Q=A.flushInterval??1e4;this._closeAndFlushDefaultTimeout=Q*1.25;let{plugin:B,publisher:G}=(0,V35.createConfiguredNodePlugin)({writeKey:A.writeKey,host:A.host,path:A.path,maxRetries:A.maxRetries??3,flushAt:A.flushAt??A.maxEventsInBatch??15,httpRequestTimeout:A.httpRequestTimeout,disable:A.disable,flushInterval:Q,httpClient:typeof A.httpClient==="function"?new DU2.FetchHTTPClient(A.httpClient):A.httpClient??new DU2.FetchHTTPClient},this);this._publisher=G,this.ready=this.register(B).then(()=>{return}),this.emit("initialize",A),(0,VU2.bindAll)(this)}get VERSION(){return K35.version}closeAndFlush({timeout:A=this._closeAndFlushDefaultTimeout}={}){return this.flush({timeout:A,close:!0})}async flush({timeout:A,close:Q=!1}={}){if(this._isFlushing){console.warn("Overlapping flush calls detected. Please wait for the previous flush to finish before calling .flush again");return}else this._isFlushing=!0;if(Q)this._isClosed=!0;this._publisher.flush(this._pendingEvents);let B=new Promise((G)=>{if(!this._pendingEvents)G();else this.once("drained",()=>{G()})}).finally(()=>{this._isFlushing=!1});return A?(0,VU2.pTimeout)(B,A).catch(()=>{return}):B}_dispatch(A,Q){if(this._isClosed){this.emit("call_after_close",A);return}this._pendingEvents++,(0,D35.dispatchAndEmit)(A,this._queue,this,Q).catch((B)=>B).finally(()=>{if(this._pendingEvents--,!this._pendingEvents)this.emit("drained")})}alias({userId:A,previousId:Q,context:B,timestamp:G,integrations:Z},Y){let J=this._eventFactory.alias(A,Q,{context:B,integrations:Z,timestamp:G});this._dispatch(J,Y)}group({timestamp:A,groupId:Q,userId:B,anonymousId:G,traits:Z={},context:Y,integrations:J},I){let X=this._eventFactory.group(Q,Z,{context:Y,anonymousId:G,userId:B,timestamp:A,integrations:J});this._dispatch(X,I)}identify({userId:A,anonymousId:Q,traits:B={},context:G,timestamp:Z,integrations:Y},J){let I=this._eventFactory.identify(A,B,{context:G,anonymousId:Q,userId:A,timestamp:Z,integrations:Y});this._dispatch(I,J)}page({userId:A,anonymousId:Q,category:B,name:G,properties:Z,context:Y,timestamp:J,integrations:I},X){let W=this._eventFactory.page(B??null,G??null,Z,{context:Y,anonymousId:Q,userId:A,timestamp:J,integrations:I});this._dispatch(W,X)}screen({userId:A,anonymousId:Q,category:B,name:G,properties:Z,context:Y,timestamp:J,integrations:I},X){let W=this._eventFactory.screen(B??null,G??null,Z,{context:Y,anonymousId:Q,userId:A,timestamp:J,integrations:I});this._dispatch(W,X)}track({userId:A,anonymousId:Q,event:B,properties:G,context:Z,timestamp:Y,integrations:J},I){let X=this._eventFactory.track(B,G,{context:Z,userId:A,anonymousId:Q,timestamp:Y,integrations:J});this._dispatch(X,I)}register(...A){return this._queue.criticalTasks.run(async()=>{let Q=EU2.Context.system(),B=A.map((G)=>this._queue.register(Q,G,this));await Promise.all(B),this.emit("register",A.map((G)=>G.name))})}async deregister(...A){let Q=EU2.Context.system(),B=A.map((G)=>{let Z=this._queue.plugins.find((Y)=>Y.name===G);if(Z)return this._queue.deregister(Q,Z,this);else Q.log("warn",`plugin ${G} not found`)});await Promise.all(B),this.emit("deregister",A)}}FU2.Analytics=HU2});var zU2=w((G_A)=>{Object.defineProperty(G_A,"__esModule",{value:!0});G_A.FetchHTTPClient=G_A.Context=G_A.Analytics=void 0;var C35=B50();Object.defineProperty(G_A,"Analytics",{enumerable:!0,get:function(){return C35.Analytics}});var z35=Z31();Object.defineProperty(G_A,"Context",{enumerable:!0,get:function(){return z35.Context}});var U35=Q50();Object.defineProperty(G_A,"FetchHTTPClient",{enumerable:!0,get:function(){return U35.FetchHTTPClient}});var $35=B50();G_A.default=$35.Analytics});function L35(){let A=["test","dev"].includes("production")?"development":"production";return q35[A]}async function M35(){if(aX())return!1;return!0}async function G50(A,Q){let B=await $U2();if(!B)return;try{let G=Y50(),Z=q8(),Y=await Ld({model:Q.model}),J=$bQ(Y,Q),I={anonymousId:G,event:A,properties:J};if(Z){let X=si(!0);I.userId=X.userID,I.properties.accountUuid=Z.accountUuid,I.properties.organizationUuid=Z.organizationUuid}B.track(I)}catch(G){s(G instanceof Error?G:Error(String(G)))}}async function wU2(A){let Q=await $U2();if(!Q)return;try{let B=Y50(),G=q8(),Z={anonymousId:B,traits:A};if(G){let Y=si(!0);Z.userId=Y.userID}Q.identify(Z)}catch(B){s(B instanceof Error?B:Error(String(B)))}}var UU2,q35,Y31=null,$U2;var Z50=L(()=>{o2();Sk();xQ();h1();F2();$3A();Mr();UU2=o(zU2(),1),q35={production:"LKJN8LsLERHEOXkw487o7qCTFOrGPimI",development:"b64sf1kxwDGe1PiSAlv5ixuH0f509RKK"};$U2=Z0(async()=>{if(!await M35())return null;try{return Y31=new UU2.Analytics({writeKey:L35()}),process.on("beforeExit",async()=>{await Y31?.closeAndFlush()}),process.on("exit",()=>{Y31?.closeAndFlush()}),Y31}catch(Q){return s(Q instanceof Error?Q:Error(String(Q))),null}})});function O35(){let A=q8();if(!A)return{};return{email:A.emailAddress,account_uuid:A.accountUuid,organization_uuid:A.organizationUuid}}function Z_A(A){let Q=ai(),B=_Q(()=>A.onDone(!1,Q));return k1((G,Z)=>{if(Z.escape)A.onDone(!1,Q)}),vH.createElement(j,{flexDirection:"column",marginTop:1},vH.createElement(al,{onDone:()=>A.onDone(!0,Q),startingMessage:A.startingMessage}),vH.createElement(j,{marginLeft:1},vH.createElement(z,{dimColor:!0},B.pending?vH.createElement(vH.Fragment,null,"Press ",B.keyName," again to exit"):"")))}var vH,NU2=()=>({type:"local-jsx",name:"login",description:kCQ()?"Switch Anthropic accounts":"Sign in with your Anthropic account",isEnabled:()=>!process.env.DISABLE_LOGIN_COMMAND,isHidden:!1,async call(A,Q){return vH.createElement(Z_A,{onDone:async(B)=>{if(Q.onChangeAPIKey(),B)DWA(),u1A(),wU2(O35()),YnB();A(B?"Login successful":"Login interrupted")}})},userFacingName(){return"login"}});var J31=L(()=>{QMA();c9();fA();F2();lRA();J4();g0();Z50();F2();LYA();vH=o(WA(),1)});async function qU2(A){let{accessToken:Q,orgUUID:B}=await sS(),G={...oW(Q),"x-organization-uuid":B},Z=`${u9().BASE_API_URL}/api/oauth/organizations/${B}/admin_requests`;return(await wQ.post(Z,A,{headers:G})).data}async function LU2(A,Q){let{accessToken:B,orgUUID:G}=await sS(),Z={...oW(B),"x-organization-uuid":G},Y=`${u9().BASE_API_URL}/api/oauth/organizations/${G}/admin_requests/me`;return(await wQ.get(Y,{headers:Z,params:{request_type:A,statuses:Q.join(",")}})).data}var MU2=L(()=>{b8();eJ();zb()});var OU2,R35,dh;var Y_A=L(()=>{h1();F2();AU();J31();xQ();MU2();OU2=o(WA(),1),R35={type:"local-jsx",name:"extra-usage",description:"Access and configure extra usage to keep working when limits are hit",isEnabled:()=>{if(process.env.DISABLE_EXTRA_USAGE_COMMAND)return!1;if(!RB())return!1;if(J50())return!0;let A=d6();return A==="pro"||A==="max"},isHidden:!1,async call(A,Q){let B=d6(),G=B==="team"||B==="enterprise",Z=RU2(),Y=J50(),J=q8()?.hasExtraUsageEnabled===!0;if(!Z&&G){if(Y){try{let X=await LU2("limit_increase",["pending","dismissed"]);if(X&&X.length>0)return A("You have already submitted a request for extra usage to your admin."),null}catch(X){s(X)}try{return await qU2({request_type:"limit_increase",details:null}),A(J?"Sent a request to your admin to increase extra usage.":"Sent a request to your admin to enable extra usage."),null}catch(X){s(X)}}return A("Please contact your admin to manage extra usage settings."),null}let I=G?"https://claude.ai/admin-settings/usage":"https://claude.ai/settings/usage";try{return await e5(I),OU2.default.createElement(Z_A,{startingMessage:"Starting new login following /extra-usage. Exit with Ctrl-C to use existing account.",onDone:(X)=>{Q.onChangeAPIKey(),A(X?"Login successful":"Login interrupted")}})}catch(X){s(X),A(`Failed to open browser. Please visit ${I} to see your extra usage.`)}return null},userFacingName(){return"extra-usage"}},dh=R35});function _U2({text:A,onOpenRateLimitOptions:Q}){let B=d6(),G=Kd(),Z=B==="pro"||B==="max",Y=G==="default_claude_max_20x",J=b7("hide_overages_option_at_rate_limit_hit","enabled",!1),I=(S9A()||RB())&&Z,X=I&&!Y,[W,K]=lU.useState(!1),V=X&&!W&&Q;lU.useEffect(()=>{if(V)K(!0),Q()},[V,Q]);let E=lU.useMemo(()=>{if(!I)return null;let D=dh.isEnabled();if(Y&&D)return lU.default.createElement(z,{dimColor:!0},"/extra-usage to finish what you're working on.");if(V)return lU.default.createElement(z,{dimColor:!0},"Opening your options‚Ä¶");if(J||!D)return lU.default.createElement(z,{dimColor:!0},"/upgrade to increase your usage limit.");return lU.default.createElement(z,{dimColor:!0},"/upgrade or /extra-usage to finish what you're working on.")},[I,Y,V,J]);if(W)return null;return lU.default.createElement(h0,null,lU.default.createElement(j,{flexDirection:"column"},lU.default.createElement(z,{color:"error"},A),E))}var lU;var TU2=L(()=>{F2();AqA();fA();h4();Y_A();J4();lU=o(WA(),1)});function _35(){let A=du0();return I5.default.createElement(h0,null,I5.default.createElement(j,{flexDirection:"column"},I5.default.createElement(z,{color:"error"},SeA),A&&I5.default.createElement(z,{dimColor:!0},"¬∑ Run in another terminal: security unlock-keychain")))}function jU2({param:{text:A},addMargin:Q,shouldShowDot:B,onOpenRateLimitOptions:G}){if(uB1(A))return null;if(hRB(A))return I5.default.createElement(_U2,{text:A,onOpenRateLimitOptions:G});switch(A){case CAA:return null;case JZA:{let Z=E0A("warning")??"Run /compact to compact & continue";return I5.default.createElement(h0,{height:1},I5.default.createElement(z,{color:"error"},"Context low ¬∑ ",Z))}case PeA:return I5.default.createElement(h0,{height:1},I5.default.createElement(z,{color:"error"},"Credit balance too low ¬∑ Add funds: https://console.anthropic.com/settings/billing"));case SeA:return I5.default.createElement(_35,null);case xeA:return I5.default.createElement(h0,{height:1},I5.default.createElement(z,{color:"error"},xeA));case yeA:return I5.default.createElement(h0,{height:1},I5.default.createElement(z,{color:"error"},yeA));case veA:return I5.default.createElement(h0,{height:1},I5.default.createElement(z,{color:"error"},veA,process.env.API_TIMEOUT_MS&&I5.default.createElement(I5.default.Fragment,null," ","(API_TIMEOUT_MS=",process.env.API_TIMEOUT_MS,"ms, try increasing it)")));case FAA:return I5.default.createElement(h0,null,I5.default.createElement(j,{flexDirection:"column",gap:1},I5.default.createElement(z,{color:"error"},"We are experiencing high demand for Opus 4."),I5.default.createElement(z,null,"To continue immediately, use /model to switch to"," ",nD(_z())," and continue coding.")));case IMA:return I5.default.createElement(h0,{height:1},I5.default.createElement(vS,null));default:if(A.startsWith(tW))return I5.default.createElement(h0,null,I5.default.createElement(z,{color:"error"},A===tW?`${tW}: Please wait a moment and try again.`:A));return I5.default.createElement(j,{alignItems:"flex-start",flexDirection:"row",justifyContent:"space-between",marginTop:Q?1:0,width:"100%"},I5.default.createElement(j,{flexDirection:"row"},B&&I5.default.createElement(j,{minWidth:2},I5.default.createElement(z,{color:"text"},UI)),I5.default.createElement(Vx,null,I5.default.createElement(j,{flexDirection:"column"},I5.default.createElement(jM,null,A)))))}}var I5;var PU2=L(()=>{fA();CqA();JM();HB();xx();v1A();h4();l2();M61();XMA();L7A();xa1();cKA();TU2();I5=o(WA(),1)});function I31({param:{text:A},addMargin:Q}){let B=Q9(A,"bash-input");if(!B)return null;return ch.createElement(j,{flexDirection:"column",marginTop:Q?1:0,width:"100%"},ch.createElement(j,null,ch.createElement(z,{backgroundColor:"bashMessageBackgroundColor",color:"bashBorder"},"!"),ch.createElement(z,{backgroundColor:"bashMessageBackgroundColor",color:"text"}," ",B," ")))}var ch;var I50=L(()=>{fA();HB();ch=o(WA(),1)});function SU2({addMargin:A,param:{text:Q}}){let B=Q9(Q,"command-message"),G=Q9(Q,"command-args");if(!B)return null;f(`UserCommandMessage rendering: "${B}" (args: "${G||"none"}")`);let Z=B.startsWith("The "),Y=Z?"":"/";return f(`  isSkillFormat: ${Z}, prefix: "${Y}"`),J_A.createElement(j,{flexDirection:"column",marginTop:A?1:0,width:"100%"},J_A.createElement(z,{backgroundColor:"userMessageBackground",color:"text"},"> ",Y,[B,G].filter(Boolean).join(" ")," "))}var J_A;var xU2=L(()=>{fA();HB();Y0();J_A=o(WA(),1)});function yU2({text:A,thinkingMetadata:Q}){if(!Q||Q.triggers.length===0)return YN.createElement(z,{backgroundColor:"userMessageBackground",color:"text"},"> ",A+" ");let B=Q.disabled?void 0:wB1[Q.level],G=i02(A,Q.triggers);return YN.createElement(z,null,">"," ",G.map((Z,Y)=>{if(Z.isTrigger)if(NB1(Z.text))return YN.createElement(z,{key:Y},Z.text.split("").map((I,X)=>YN.createElement(z,{key:X,backgroundColor:"userMessageBackground",color:bMA(X,!1)},I)));else return YN.createElement(z,{key:Y,backgroundColor:"userMessageBackground",color:B},Z.text);return YN.createElement(z,{key:Y,backgroundColor:"userMessageBackground",color:"text"},Z.text)})," ")}var YN;var vU2=L(()=>{fA();qM();YN=o(WA(),1)});function kU2({addMargin:A,param:{text:Q},thinkingMetadata:B}){let{columns:G}=kB();if(!Q)return s(Error("No content found in user prompt message")),null;let Z=Q.trim();return X50.default.createElement(j,{flexDirection:"column",marginTop:A?1:0,width:G-4},X50.default.createElement(yU2,{text:Z,thinkingMetadata:B}))}var X50;var fU2=L(()=>{fA();h1();y6();vU2();X50=o(WA(),1)});var bU2=w((I_A,X_A)=>{(function(){var A,Q="4.17.21",B=200,G="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",Z="Expected a function",Y="Invalid `variable` option passed into `_.template`",J="__lodash_hash_undefined__",I=500,X="__lodash_placeholder__",W=1,K=2,V=4,E=1,D=2,H=1,F=2,C=4,U=8,O=16,q=32,M=64,_=128,T=256,y=512,h=30,x="...",m=800,g=16,t=1,p=2,k=3,c=1/0,e=9007199254740991,AA=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,VA=NaN,OA=4294967295,EA=OA-1,SA=OA>>>1,yA=[["ary",_],["bind",H],["bindKey",F],["curry",U],["curryRight",O],["flip",y],["partial",q],["partialRight",M],["rearg",T]],ZA="[object Arguments]",GA="[object Array]",zA="[object AsyncFunction]",bA="[object Boolean]",TA="[object Date]",G1="[object DOMException]",YA="[object Error]",CA="[object Function]",MA="[object GeneratorFunction]",NA="[object Map]",UA="[object Number]",LA="[object Null]",lA="[object Object]",gA="[object Promise]",I1="[object Proxy]",$1="[object RegExp]",RA="[object Set]",B1="[object String]",m1="[object Symbol]",S1="[object Undefined]",H0="[object WeakMap]",ZQ="[object WeakSet]",o0="[object ArrayBuffer]",EQ="[object DataView]",WQ="[object Float32Array]",w1="[object Float64Array]",eA="[object Int8Array]",V1="[object Int16Array]",R1="[object Int32Array]",G0="[object Uint8Array]",U0="[object Uint8ClampedArray]",C0="[object Uint16Array]",HA="[object Uint32Array]",wA=/\b__p \+= '';/g,tA=/\b(__p \+=) '' \+/g,N1=/(__e\(.*?\)|\b__t\)) \+\n'';/g,C1=/&(?:amp|lt|gt|quot|#39);/g,D1=/[&<>"']/g,X0=RegExp(C1.source),p1=RegExp(D1.source),k0=/<%-([\s\S]+?)%>/g,KQ=/<%([\s\S]+?)%>/g,bB=/<%=([\s\S]+?)%>/g,IB=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,W2=/^\w*$/,d0=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,OQ=/[\\^$.*+?()[\]{}|]/g,fB=RegExp(OQ.source),_9=/^\s+/,GB=/\s/,K1=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,iA=/\{\n\/\* \[wrapped with (.+)\] \*/,F1=/,? & /,A0=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,D0=/[()=,{}\[\]\/\s]/,YQ=/\\(\\)?/g,Q2=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,K9=/\w*$/,b9=/^[-+]0x[0-9a-f]+$/i,g6=/^0b[01]+$/i,T9=/^\[object .+?Constructor\]$/,M6=/^0o[0-7]+$/i,n6=/^(?:0|[1-9]\d*)$/,k4=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,$2=/($^)/,s2=/['\n\r\u2028\u2029\\]/g,H9="\\ud800-\\udfff",E5="\\u0300-\\u036f",w3="\\ufe20-\\ufe2f",U6="\\u20d0-\\u20ff",h9=E5+w3+U6,t0="\\u2700-\\u27bf",nQ="a-z\\xdf-\\xf6\\xf8-\\xff",xB="\\xac\\xb1\\xd7\\xf7",Y4="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",e4="\\u2000-\\u206f",kG=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",DZ="A-Z\\xc0-\\xd6\\xd8-\\xde",S3="\\ufe0e\\ufe0f",N3=xB+Y4+e4+kG,nA="['‚Äô]",IA="["+H9+"]",BA="["+N3+"]",xA="["+h9+"]",hA="\\d+",dA="["+t0+"]",q1="["+nQ+"]",v1="[^"+H9+N3+hA+t0+nQ+DZ+"]",f1="\\ud83c[\\udffb-\\udfff]",a1="(?:"+xA+"|"+f1+")",e1="[^"+H9+"]",L0="(?:\\ud83c[\\udde6-\\uddff]){2}",LQ="[\\ud800-\\udbff][\\udc00-\\udfff]",XB="["+DZ+"]",S2="\\u200d",iB="(?:"+q1+"|"+v1+")",c2="(?:"+XB+"|"+v1+")",O6="(?:"+nA+"(?:d|ll|m|re|s|t|ve))?",D5="(?:"+nA+"(?:D|LL|M|RE|S|T|VE))?",F8=a1+"?",wK="["+S3+"]?",JG="(?:"+S2+"(?:"+[e1,L0,LQ].join("|")+")"+wK+F8+")*",gJ="\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",uJ="\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",_W=wK+F8+JG,H5="(?:"+[dA,L0,LQ].join("|")+")"+_W,IG="(?:"+[e1+xA+"?",xA,L0,LQ,IA].join("|")+")",NK=RegExp(nA,"g"),RX=RegExp(xA,"g"),_X=RegExp(f1+"(?="+f1+")|"+IG+_W,"g"),TW=RegExp([XB+"?"+q1+"+"+O6+"(?="+[BA,XB,"$"].join("|")+")",c2+"+"+D5+"(?="+[BA,XB+iB,"$"].join("|")+")",XB+"?"+iB+"+"+O6,XB+"+"+D5,uJ,gJ,hA,H5].join("|"),"g"),HZ=RegExp("["+S2+H9+h9+S3+"]"),mJ=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,eM=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],lV=-1,x3={};x3[WQ]=x3[w1]=x3[eA]=x3[V1]=x3[R1]=x3[G0]=x3[U0]=x3[C0]=x3[HA]=!0,x3[ZA]=x3[GA]=x3[o0]=x3[bA]=x3[EQ]=x3[TA]=x3[YA]=x3[CA]=x3[NA]=x3[UA]=x3[lA]=x3[$1]=x3[RA]=x3[B1]=x3[H0]=!1;var a6={};a6[ZA]=a6[GA]=a6[o0]=a6[EQ]=a6[bA]=a6[TA]=a6[WQ]=a6[w1]=a6[eA]=a6[V1]=a6[R1]=a6[NA]=a6[UA]=a6[lA]=a6[$1]=a6[RA]=a6[B1]=a6[m1]=a6[G0]=a6[U0]=a6[C0]=a6[HA]=!0,a6[YA]=a6[CA]=a6[H0]=!1;var gC={"√Ä":"A","√Å":"A","√Ç":"A","√É":"A","√Ñ":"A","√Ö":"A","√†":"a","√°":"a","√¢":"a","√£":"a","√§":"a","√•":"a","√á":"C","√ß":"c","√ê":"D","√∞":"d","√à":"E","√â":"E","√ä":"E","√ã":"E","√®":"e","√©":"e","√™":"e","√´":"e","√å":"I","√ç":"I","√é":"I","√è":"I","√¨":"i","√≠":"i","√Æ":"i","√Ø":"i","√ë":"N","√±":"n","√í":"O","√ì":"O","√î":"O","√ï":"O","√ñ":"O","√ò":"O","√≤":"o","√≥":"o","√¥":"o","√µ":"o","√∂":"o","√∏":"o","√ô":"U","√ö":"U","√õ":"U","√ú":"U","√π":"u","√∫":"u","√ª":"u","√º":"u","√ù":"Y","√Ω":"y","√ø":"y","√Ü":"Ae","√¶":"ae","√û":"Th","√æ":"th","√ü":"ss","ƒÄ":"A","ƒÇ":"A","ƒÑ":"A","ƒÅ":"a","ƒÉ":"a","ƒÖ":"a","ƒÜ":"C","ƒà":"C","ƒä":"C","ƒå":"C","ƒá":"c","ƒâ":"c","ƒã":"c","ƒç":"c","ƒé":"D","ƒê":"D","ƒè":"d","ƒë":"d","ƒí":"E","ƒî":"E","ƒñ":"E","ƒò":"E","ƒö":"E","ƒì":"e","ƒï":"e","ƒó":"e","ƒô":"e","ƒõ":"e","ƒú":"G","ƒû":"G","ƒ†":"G","ƒ¢":"G","ƒù":"g","ƒü":"g","ƒ°":"g","ƒ£":"g","ƒ§":"H","ƒ¶":"H","ƒ•":"h","ƒß":"h","ƒ®":"I","ƒ™":"I","ƒ¨":"I","ƒÆ":"I","ƒ∞":"I","ƒ©":"i","ƒ´":"i","ƒ≠":"i","ƒØ":"i","ƒ±":"i","ƒ¥":"J","ƒµ":"j","ƒ∂":"K","ƒ∑":"k","ƒ∏":"k","ƒπ":"L","ƒª":"L","ƒΩ":"L","ƒø":"L","≈Å":"L","ƒ∫":"l","ƒº":"l","ƒæ":"l","≈Ä":"l","≈Ç":"l","≈É":"N","≈Ö":"N","≈á":"N","≈ä":"N","≈Ñ":"n","≈Ü":"n","≈à":"n","≈ã":"n","≈å":"O","≈é":"O","≈ê":"O","≈ç":"o","≈è":"o","≈ë":"o","≈î":"R","≈ñ":"R","≈ò":"R","≈ï":"r","≈ó":"r","≈ô":"r","≈ö":"S","≈ú":"S","≈û":"S","≈†":"S","≈õ":"s","≈ù":"s","≈ü":"s","≈°":"s","≈¢":"T","≈§":"T","≈¶":"T","≈£":"t","≈•":"t","≈ß":"t","≈®":"U","≈™":"U","≈¨":"U","≈Æ":"U","≈∞":"U","≈≤":"U","≈©":"u","≈´":"u","≈≠":"u","≈Ø":"u","≈±":"u","≈≥":"u","≈¥":"W","≈µ":"w","≈∂":"Y","≈∑":"y","≈∏":"Y","≈π":"Z","≈ª":"Z","≈Ω":"Z","≈∫":"z","≈º":"z","≈æ":"z","ƒ≤":"IJ","ƒ≥":"ij","≈í":"Oe","≈ì":"oe","≈â":"'n","≈ø":"s"},pH={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},iV={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},LN={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},AO=parseFloat,QO=parseInt,lH=typeof global=="object"&&global&&global.Object===Object&&global,S7=typeof self=="object"&&self&&self.Object===Object&&self,J7=lH||S7||Function("return this")(),iH=typeof I_A=="object"&&I_A&&!I_A.nodeType&&I_A,PI=iH&&typeof X_A=="object"&&X_A&&!X_A.nodeType&&X_A,BO=PI&&PI.exports===iH,MN=BO&&lH.process,cZ=function(){try{var s1=PI&&PI.require&&PI.require("util").types;if(s1)return s1;return MN&&MN.binding&&MN.binding("util")}catch(l0){}}(),w0=cZ&&cZ.isArrayBuffer,ZB=cZ&&cZ.isDate,gB=cZ&&cZ.isMap,A6=cZ&&cZ.isRegExp,w2=cZ&&cZ.isSet,N4=cZ&&cZ.isTypedArray;function p2(s1,l0,y0){switch(y0.length){case 0:return s1.call(l0);case 1:return s1.call(l0,y0[0]);case 2:return s1.call(l0,y0[0],y0[1]);case 3:return s1.call(l0,y0[0],y0[1],y0[2])}return s1.apply(l0,y0)}function UB(s1,l0,y0,J2){var V9=-1,n3=s1==null?0:s1.length;while(++V9<n3){var lZ=s1[V9];l0(J2,lZ,y0(lZ),s1)}return J2}function Q6(s1,l0){var y0=-1,J2=s1==null?0:s1.length;while(++y0<J2)if(l0(s1[y0],y0,s1)===!1)break;return s1}function _4(s1,l0){var y0=s1==null?0:s1.length;while(y0--)if(l0(s1[y0],y0,s1)===!1)break;return s1}function MY(s1,l0){var y0=-1,J2=s1==null?0:s1.length;while(++y0<J2)if(!l0(s1[y0],y0,s1))return!1;return!0}function FZ(s1,l0){var y0=-1,J2=s1==null?0:s1.length,V9=0,n3=[];while(++y0<J2){var lZ=s1[y0];if(l0(lZ,y0,s1))n3[V9++]=lZ}return n3}function OY(s1,l0){var y0=s1==null?0:s1.length;return!!y0&&jW(s1,l0,0)>-1}function l5(s1,l0,y0){var J2=-1,V9=s1==null?0:s1.length;while(++J2<V9)if(y0(l0,s1[J2]))return!0;return!1}function B6(s1,l0){var y0=-1,J2=s1==null?0:s1.length,V9=Array(J2);while(++y0<J2)V9[y0]=l0(s1[y0],y0,s1);return V9}function x7(s1,l0){var y0=-1,J2=l0.length,V9=s1.length;while(++y0<J2)s1[V9+y0]=l0[y0];return s1}function TX(s1,l0,y0,J2){var V9=-1,n3=s1==null?0:s1.length;if(J2&&n3)y0=s1[++V9];while(++V9<n3)y0=l0(y0,s1[V9],V9,s1);return y0}function dT(s1,l0,y0,J2){var V9=s1==null?0:s1.length;if(J2&&V9)y0=s1[--V9];while(V9--)y0=l0(y0,s1[V9],V9,s1);return y0}function ID(s1,l0){var y0=-1,J2=s1==null?0:s1.length;while(++y0<J2)if(l0(s1[y0],y0,s1))return!0;return!1}var XD=$0("length");function qK(s1){return s1.split("")}function Ug(s1){return s1.match(A0)||[]}function Sn(s1,l0,y0){var J2;return y0(s1,function(V9,n3,lZ){if(l0(V9,n3,lZ))return J2=n3,!1}),J2}function cT(s1,l0,y0,J2){var V9=s1.length,n3=y0+(J2?1:-1);while(J2?n3--:++n3<V9)if(l0(s1[n3],n3,s1))return n3;return-1}function jW(s1,l0,y0){return l0===l0?ON(s1,l0,y0):cT(s1,_A,y0)}function $A(s1,l0,y0,J2){var V9=y0-1,n3=s1.length;while(++V9<n3)if(J2(s1[V9],l0))return V9;return-1}function _A(s1){return s1!==s1}function z1(s1,l0){var y0=s1==null?0:s1.length;return y0?K4(s1,l0)/y0:VA}function $0(s1){return function(l0){return l0==null?A:l0[s1]}}function x0(s1){return function(l0){return s1==null?A:s1[l0]}}function EB(s1,l0,y0,J2,V9){return V9(s1,function(n3,lZ,i5){y0=J2?(J2=!1,n3):l0(y0,n3,lZ,i5)}),y0}function nB(s1,l0){var y0=s1.length;s1.sort(l0);while(y0--)s1[y0]=s1[y0].value;return s1}function K4(s1,l0){var y0,J2=-1,V9=s1.length;while(++J2<V9){var n3=l0(s1[J2]);if(n3!==A)y0=y0===A?n3:y0+n3}return y0}function F5(s1,l0){var y0=-1,J2=Array(s1);while(++y0<s1)J2[y0]=l0(y0);return J2}function CZ(s1,l0){return B6(l0,function(y0){return[y0,s1[y0]]})}function fG(s1){return s1?s1.slice(0,dJ(s1)+1).replace(_9,""):s1}function o6(s1){return function(l0){return s1(l0)}}function n4(s1,l0){return B6(l0,function(y0){return s1[y0]})}function PW(s1,l0){return s1.has(l0)}function pZ(s1,l0){var y0=-1,J2=s1.length;while(++y0<J2&&jW(l0,s1[y0],0)>-1);return y0}function my(s1,l0){var y0=s1.length;while(y0--&&jW(l0,s1[y0],0)>-1);return y0}function nH(s1,l0){var y0=s1.length,J2=0;while(y0--)if(s1[y0]===l0)++J2;return J2}var x8=x0(gC),dy=x0(pH);function pT(s1){return"\\"+LN[s1]}function GO(s1,l0){return s1==null?A:s1[l0]}function lT(s1){return HZ.test(s1)}function xn(s1){return mJ.test(s1)}function iT(s1){var l0,y0=[];while(!(l0=s1.next()).done)y0.push(l0.value);return y0}function y7(s1){var l0=-1,y0=Array(s1.size);return s1.forEach(function(J2,V9){y0[++l0]=[V9,J2]}),y0}function EQA(s1,l0){return function(y0){return s1(l0(y0))}}function SW(s1,l0){var y0=-1,J2=s1.length,V9=0,n3=[];while(++y0<J2){var lZ=s1[y0];if(lZ===l0||lZ===X)s1[y0]=X,n3[V9++]=y0}return n3}function nT(s1){var l0=-1,y0=Array(s1.size);return s1.forEach(function(J2){y0[++l0]=J2}),y0}function cy(s1){var l0=-1,y0=Array(s1.size);return s1.forEach(function(J2){y0[++l0]=[J2,J2]}),y0}function ON(s1,l0,y0){var J2=y0-1,V9=s1.length;while(++J2<V9)if(s1[J2]===l0)return J2;return-1}function DQA(s1,l0,y0){var J2=y0+1;while(J2--)if(s1[J2]===l0)return J2;return J2}function ZO(s1){return lT(s1)?$g(s1):XD(s1)}function XJ(s1){return lT(s1)?HQA(s1):qK(s1)}function dJ(s1){var l0=s1.length;while(l0--&&GB.test(s1.charAt(l0)));return l0}var yn=x0(iV);function $g(s1){var l0=_X.lastIndex=0;while(_X.test(s1))++l0;return l0}function HQA(s1){return s1.match(_X)||[]}function vn(s1){return s1.match(TW)||[]}var kn=function s1(l0){l0=l0==null?J7:cJ.defaults(J7.Object(),l0,cJ.pick(J7,eM));var{Array:y0,Date:J2,Error:V9,Function:n3,Math:lZ,Object:i5,RegExp:aT,String:RY,TypeError:nV}=l0,pJ=y0.prototype,wg=n3.prototype,jX=i5.prototype,aH=l0["__core-js_shared__"],oH=wg.toString,a3=jX.hasOwnProperty,FQA=0,RN=function(){var R=/[^.]+$/.exec(aH&&aH.keys&&aH.keys.IE_PROTO||"");return R?"Symbol(src)_1."+R:""}(),Ng=jX.toString,py=oH.call(i5),ly=J7._,YO=aT("^"+oH.call(a3).replace(OQ,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),qg=BO?l0.Buffer:A,_N=l0.Symbol,JO=l0.Uint8Array,CQA=qg?qg.allocUnsafe:A,IO=EQA(i5.getPrototypeOf,i5),fn=i5.create,bn=jX.propertyIsEnumerable,iy=pJ.splice,ny=_N?_N.isConcatSpreadable:A,XO=_N?_N.iterator:A,rH=_N?_N.toStringTag:A,lJ=function(){try{var R=u1(i5,"defineProperty");return R({},"",{}),R}catch(S){}}(),zQA=l0.clearTimeout!==J7.clearTimeout&&l0.clearTimeout,xW=J2&&J2.now!==J7.Date.now&&J2.now,Lg=l0.setTimeout!==J7.setTimeout&&l0.setTimeout,TN=lZ.ceil,Mg=lZ.floor,UQA=i5.getOwnPropertySymbols,jN=qg?qg.isBuffer:A,$QA=l0.isFinite,wQA=pJ.join,WO=EQA(i5.keys,i5),WJ=lZ.max,SI=lZ.min,TXA=J2.now,NQA=l0.parseInt,Og=lZ.random,hn=pJ.reverse,gn=u1(l0,"DataView"),ay=u1(l0,"Map"),oy=u1(l0,"Promise"),KO=u1(l0,"Set"),PN=u1(l0,"WeakMap"),sH=u1(i5,"create"),VO=PN&&new PN,oT={},jXA=v7(gn),FjA=v7(ay),un=v7(oy),rT=v7(KO),PXA=v7(PN),o3=_N?_N.prototype:A,EO=o3?o3.valueOf:A,SXA=o3?o3.toString:A;function rA(R){if(t1(R)&&!J6(R)&&!(R instanceof r6)){if(R instanceof PX)return R;if(a3.call(R,"__wrapped__"))return WG(R)}return new PX(R)}var KJ=function(){function R(){}return function(S){if(!U1(S))return{};if(fn)return fn(S);R.prototype=S;var d=new R;return R.prototype=A,d}}();function Rg(){}function PX(R,S){this.__wrapped__=R,this.__actions__=[],this.__chain__=!!S,this.__index__=0,this.__values__=A}rA.templateSettings={escape:k0,evaluate:KQ,interpolate:bB,variable:"",imports:{_:rA}},rA.prototype=Rg.prototype,rA.prototype.constructor=rA,PX.prototype=KJ(Rg.prototype),PX.prototype.constructor=PX;function r6(R){this.__wrapped__=R,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=OA,this.__views__=[]}function _g(){var R=new r6(this.__wrapped__);return R.__actions__=RK(this.__actions__),R.__dir__=this.__dir__,R.__filtered__=this.__filtered__,R.__iteratees__=RK(this.__iteratees__),R.__takeCount__=this.__takeCount__,R.__views__=RK(this.__views__),R}function Q$(){if(this.__filtered__){var R=new r6(this);R.__dir__=-1,R.__filtered__=!0}else R=this.clone(),R.__dir__*=-1;return R}function mn(){var R=this.__wrapped__.value(),S=this.__dir__,d=J6(R),JA=S<0,kA=d?R.length:0,Z1=B2(0,kA,this.__views__),O1=Z1.start,b1=Z1.end,K0=b1-O1,HQ=JA?b1:O1-1,$Q=this.__iteratees__,SQ=$Q.length,aB=0,Y9=SI(K0,this.__takeCount__);if(!d||!JA&&kA==K0&&Y9==K0)return Ja(R,this.__actions__);var q4=[];A:while(K0--&&aB<Y9){HQ+=S;var I3=-1,L4=R[HQ];while(++I3<SQ){var e3=$Q[I3],f8=e3.iteratee,W$=e3.type,GF=f8(L4);if(W$==p)L4=GF;else if(!GF)if(W$==t)continue A;else break A}q4[aB++]=L4}return q4}r6.prototype=KJ(Rg.prototype),r6.prototype.constructor=r6;function tH(R){var S=-1,d=R==null?0:R.length;this.clear();while(++S<d){var JA=R[S];this.set(JA[0],JA[1])}}function SN(){this.__data__=sH?sH(null):{},this.size=0}function dn(R){var S=this.has(R)&&delete this.__data__[R];return this.size-=S?1:0,S}function Tg(R){var S=this.__data__;if(sH){var d=S[R];return d===J?A:d}return a3.call(S,R)?S[R]:A}function cn(R){var S=this.__data__;return sH?S[R]!==A:a3.call(S,R)}function xXA(R,S){var d=this.__data__;return this.size+=this.has(R)?0:1,d[R]=sH&&S===A?J:S,this}tH.prototype.clear=SN,tH.prototype.delete=dn,tH.prototype.get=Tg,tH.prototype.has=cn,tH.prototype.set=xXA;function LK(R){var S=-1,d=R==null?0:R.length;this.clear();while(++S<d){var JA=R[S];this.set(JA[0],JA[1])}}function jg(){this.__data__=[],this.size=0}function B$(R){var S=this.__data__,d=ry(S,R);if(d<0)return!1;var JA=S.length-1;if(d==JA)S.pop();else iy.call(S,d,1);return--this.size,!0}function Pg(R){var S=this.__data__,d=ry(S,R);return d<0?A:S[d][1]}function yXA(R){return ry(this.__data__,R)>-1}function qQA(R,S){var d=this.__data__,JA=ry(d,R);if(JA<0)++this.size,d.push([R,S]);else d[JA][1]=S;return this}LK.prototype.clear=jg,LK.prototype.delete=B$,LK.prototype.get=Pg,LK.prototype.has=yXA,LK.prototype.set=qQA;function V4(R){var S=-1,d=R==null?0:R.length;this.clear();while(++S<d){var JA=R[S];this.set(JA[0],JA[1])}}function pn(){this.size=0,this.__data__={hash:new tH,map:new(ay||LK),string:new tH}}function ln(R){var S=Q1(this,R).delete(R);return this.size-=S?1:0,S}function Sg(R){return Q1(this,R).get(R)}function DO(R){return Q1(this,R).has(R)}function HO(R,S){var d=Q1(this,R),JA=d.size;return d.set(R,S),this.size+=d.size==JA?0:1,this}V4.prototype.clear=pn,V4.prototype.delete=ln,V4.prototype.get=Sg,V4.prototype.has=DO,V4.prototype.set=HO;function xN(R){var S=-1,d=R==null?0:R.length;this.__data__=new V4;while(++S<d)this.add(R[S])}function xg(R){return this.__data__.set(R,J),this}function vXA(R){return this.__data__.has(R)}xN.prototype.add=xN.prototype.push=xg,xN.prototype.has=vXA;function WD(R){var S=this.__data__=new LK(R);this.size=S.size}function G$(){this.__data__=new LK,this.size=0}function nn(R){var S=this.__data__,d=S.delete(R);return this.size=S.size,d}function an(R){return this.__data__.get(R)}function FO(R){return this.__data__.has(R)}function yg(R,S){var d=this.__data__;if(d instanceof LK){var JA=d.__data__;if(!ay||JA.length<B-1)return JA.push([R,S]),this.size=++d.size,this;d=this.__data__=new V4(JA)}return d.set(R,S),this.size=d.size,this}WD.prototype.clear=G$,WD.prototype.delete=nn,WD.prototype.get=an,WD.prototype.has=FO,WD.prototype.set=yg;function KD(R,S){var d=J6(R),JA=!d&&Wj(R),kA=!d&&!JA&&Kj(R),Z1=!d&&!JA&&!kA&&kX(R),O1=d||JA||kA||Z1,b1=O1?F5(R.length,RY):[],K0=b1.length;for(var HQ in R)if((S||a3.call(R,HQ))&&!(O1&&(HQ=="length"||kA&&(HQ=="offset"||HQ=="parent")||Z1&&(HQ=="buffer"||HQ=="byteLength"||HQ=="byteOffset")||F9(HQ,K0))))b1.push(HQ);return b1}function vg(R){var S=R.length;return S?R[Qa(0,S-1)]:A}function R6(R,S){return _K(RK(R),yN(S,0,R.length))}function on(R){return _K(RK(R))}function kg(R,S,d){if(d!==A&&!fI(R[S],d)||d===A&&!(S in R))uC(R,S,d)}function r9(R,S,d){var JA=R[S];if(!(a3.call(R,S)&&fI(JA,d))||d===A&&!(S in R))uC(R,S,d)}function ry(R,S){var d=R.length;while(d--)if(fI(R[d][0],S))return d;return-1}function LQA(R,S,d,JA){return vN(R,function(kA,Z1,O1){S(JA,kA,d(kA),O1)}),JA}function fg(R,S){return R&&QF(S,PK(S),R)}function bg(R,S){return R&&QF(S,nC(S),R)}function uC(R,S,d){if(S=="__proto__"&&lJ)lJ(R,S,{configurable:!0,enumerable:!0,value:d,writable:!0});else R[S]=d}function sy(R,S){var d=-1,JA=S.length,kA=y0(JA),Z1=R==null;while(++d<JA)kA[d]=Z1?A:BG1(R,S[d]);return kA}function yN(R,S,d){if(R===R){if(d!==A)R=R<=d?R:d;if(S!==A)R=R>=S?R:S}return R}function xI(R,S,d,JA,kA,Z1){var O1,b1=S&W,K0=S&K,HQ=S&V;if(d)O1=kA?d(R,JA,kA,Z1):d(R);if(O1!==A)return O1;if(!U1(R))return R;var $Q=J6(R);if($Q){if(O1=i2(R),!b1)return RK(R,O1)}else{var SQ=bQ(R),aB=SQ==CA||SQ==MA;if(Kj(R))return g4(R,b1);if(SQ==lA||SQ==ZA||aB&&!kA){if(O1=K0||aB?{}:N2(R),!b1)return K0?lQA(R,bg(O1,R)):pQA(R,fg(O1,R))}else{if(!a6[SQ])return kA?R:{};O1=OB(R,SQ,b1)}}Z1||(Z1=new WD);var Y9=Z1.get(R);if(Y9)return Y9;if(Z1.set(R,O1),jK(R))R.forEach(function(L4){O1.add(xI(L4,S,d,L4,R,Z1))});else if(BQ(R))R.forEach(function(L4,e3){O1.set(e3,xI(L4,S,d,e3,R,Z1))});var q4=HQ?K0?DA:a:K0?nC:PK,I3=$Q?A:q4(R);return Q6(I3||R,function(L4,e3){if(I3)e3=L4,L4=R[e3];r9(O1,e3,xI(L4,S,d,e3,R,Z1))}),O1}function kXA(R){var S=PK(R);return function(d){return MQA(d,R,S)}}function MQA(R,S,d){var JA=d.length;if(R==null)return!JA;R=i5(R);while(JA--){var kA=d[JA],Z1=S[kA],O1=R[kA];if(O1===A&&!(kA in R)||!Z1(O1))return!1}return!0}function OQA(R,S,d){if(typeof R!="function")throw new nV(Z);return j5(function(){R.apply(A,d)},S)}function CO(R,S,d,JA){var kA=-1,Z1=OY,O1=!0,b1=R.length,K0=[],HQ=S.length;if(!b1)return K0;if(d)S=B6(S,o6(d));if(JA)Z1=l5,O1=!1;else if(S.length>=B)Z1=PW,O1=!1,S=new xN(S);A:while(++kA<b1){var $Q=R[kA],SQ=d==null?$Q:d($Q);if($Q=JA||$Q!==0?$Q:0,O1&&SQ===SQ){var aB=HQ;while(aB--)if(S[aB]===SQ)continue A;K0.push($Q)}else if(!Z1(S,SQ,JA))K0.push($Q)}return K0}var vN=gN(I7),hg=gN(hG,!0);function RQA(R,S){var d=!0;return vN(R,function(JA,kA,Z1){return d=!!S(JA,kA,Z1),d}),d}function eH(R,S,d){var JA=-1,kA=R.length;while(++JA<kA){var Z1=R[JA],O1=S(Z1);if(O1!=null&&(b1===A?O1===O1&&!qZ(O1):d(O1,b1)))var b1=O1,K0=Z1}return K0}function gg(R,S,d,JA){var kA=R.length;if(d=$6(d),d<0)d=-d>kA?0:kA+d;if(JA=JA===A||JA>kA?kA:$6(JA),JA<0)JA+=kA;JA=d>JA?0:eQA(JA);while(d<JA)R[d++]=S;return R}function ug(R,S){var d=[];return vN(R,function(JA,kA,Z1){if(S(JA,kA,Z1))d.push(JA)}),d}function bG(R,S,d,JA,kA){var Z1=-1,O1=R.length;d||(d=y8),kA||(kA=[]);while(++Z1<O1){var b1=R[Z1];if(S>0&&d(b1))if(S>1)bG(b1,S-1,d,JA,kA);else x7(kA,b1);else if(!JA)kA[kA.length]=b1}return kA}var ty=iQA(),VD=iQA(!0);function I7(R,S){return R&&ty(R,S,PK)}function hG(R,S){return R&&VD(R,S,PK)}function C5(R,S){return FZ(S,function(d){return uA(R[d])})}function kN(R,S){S=bN(S,R);var d=0,JA=S.length;while(R!=null&&d<JA)R=R[gG(S[d++])];return d&&d==JA?R:A}function _QA(R,S,d){var JA=S(R);return J6(R)?JA:x7(JA,d(R))}function _5(R){if(R==null)return R===A?S1:LA;return rH&&rH in i5(R)?N0(R):sB(R)}function Z$(R,S){return R>S}function fXA(R,S){return R!=null&&a3.call(R,S)}function bXA(R,S){return R!=null&&S in i5(R)}function TQA(R,S,d){return R>=SI(S,d)&&R<WJ(S,d)}function ey(R,S,d){var JA=d?l5:OY,kA=R[0].length,Z1=R.length,O1=Z1,b1=y0(Z1),K0=1/0,HQ=[];while(O1--){var $Q=R[O1];if(O1&&S)$Q=B6($Q,o6(S));K0=SI($Q.length,K0),b1[O1]=!d&&(S||kA>=120&&$Q.length>=120)?new xN(O1&&$Q):A}$Q=R[0];var SQ=-1,aB=b1[0];A:while(++SQ<kA&&HQ.length<K0){var Y9=$Q[SQ],q4=S?S(Y9):Y9;if(Y9=d||Y9!==0?Y9:0,!(aB?PW(aB,q4):JA(HQ,q4,d))){O1=Z1;while(--O1){var I3=b1[O1];if(!(I3?PW(I3,q4):JA(R[O1],q4,d)))continue A}if(aB)aB.push(q4);HQ.push(Y9)}}return HQ}function jQA(R,S,d,JA){return I7(R,function(kA,Z1,O1){S(JA,d(kA),Z1,O1)}),JA}function Av(R,S,d){S=bN(S,R),R=n5(R,S);var JA=R==null?R:R[gG(s8(S))];return JA==null?A:p2(JA,R,d)}function rn(R){return t1(R)&&_5(R)==ZA}function hXA(R){return t1(R)&&_5(R)==o0}function sT(R){return t1(R)&&_5(R)==TA}function AF(R,S,d,JA,kA){if(R===S)return!0;if(R==null||S==null||!t1(R)&&!t1(S))return R!==R&&S!==S;return gXA(R,S,d,JA,AF,kA)}function gXA(R,S,d,JA,kA,Z1){var O1=J6(R),b1=J6(S),K0=O1?GA:bQ(R),HQ=b1?GA:bQ(S);K0=K0==ZA?lA:K0,HQ=HQ==ZA?lA:HQ;var $Q=K0==lA,SQ=HQ==lA,aB=K0==HQ;if(aB&&Kj(R)){if(!Kj(S))return!1;O1=!0,$Q=!1}if(aB&&!$Q)return Z1||(Z1=new WD),O1||kX(R)?eT(R,S,d,JA,kA,Z1):oQA(R,S,K0,d,JA,kA,Z1);if(!(d&E)){var Y9=$Q&&a3.call(R,"__wrapped__"),q4=SQ&&a3.call(S,"__wrapped__");if(Y9||q4){var I3=Y9?R.value():R,L4=q4?S.value():S;return Z1||(Z1=new WD),kA(I3,L4,d,JA,Z1)}}if(!aB)return!1;return Z1||(Z1=new WD),b(R,S,d,JA,kA,Z1)}function PQA(R){return t1(R)&&bQ(R)==NA}function mg(R,S,d,JA){var kA=d.length,Z1=kA,O1=!JA;if(R==null)return!Z1;R=i5(R);while(kA--){var b1=d[kA];if(O1&&b1[2]?b1[1]!==R[b1[0]]:!(b1[0]in R))return!1}while(++kA<Z1){b1=d[kA];var K0=b1[0],HQ=R[K0],$Q=b1[1];if(O1&&b1[2]){if(HQ===A&&!(K0 in R))return!1}else{var SQ=new WD;if(JA)var aB=JA(HQ,$Q,K0,R,S,SQ);if(!(aB===A?AF($Q,HQ,E|D,JA,SQ):aB))return!1}}return!0}function yI(R){if(!U1(R)||zZ(R))return!1;var S=uA(R)?YO:T9;return S.test(v7(R))}function sn(R){return t1(R)&&_5(R)==$1}function SQA(R){return t1(R)&&bQ(R)==RA}function Qv(R){return t1(R)&&L1(R.length)&&!!x3[_5(R)]}function zO(R){if(typeof R=="function")return R;if(R==null)return aC;if(typeof R=="object")return J6(R)?tT(R[0],R[1]):vQA(R);return $I0(R)}function xQA(R){if(!r8(R))return WO(R);var S=[];for(var d in i5(R))if(a3.call(R,d)&&d!="constructor")S.push(d);return S}function yQA(R){if(!U1(R))return $B(R);var S=r8(R),d=[];for(var JA in R)if(!(JA=="constructor"&&(S||!a3.call(R,JA))))d.push(JA);return d}function MK(R,S){return R<S}function tn(R,S){var d=-1,JA=kW(R)?y0(R.length):[];return vN(R,function(kA,Z1,O1){JA[++d]=S(kA,Z1,O1)}),JA}function vQA(R){var S=_1(R);if(S.length==1&&S[0][2])return y3(S[0][0],S[0][1]);return function(d){return d===R||mg(d,R,S)}}function tT(R,S){if(r3(R)&&C9(S))return y3(gG(R),S);return function(d){var JA=BG1(d,R);return JA===A&&JA===S?GG1(d,R):AF(S,JA,E|D)}}function dg(R,S,d,JA,kA){if(R===S)return;ty(S,function(Z1,O1){if(kA||(kA=new WD),U1(Z1))uXA(R,S,O1,d,dg,JA,kA);else{var b1=JA?JA(T5(R,O1),Z1,O1+"",R,S,kA):A;if(b1===A)b1=Z1;kg(R,O1,b1)}},nC)}function uXA(R,S,d,JA,kA,Z1,O1){var b1=T5(R,d),K0=T5(S,d),HQ=O1.get(K0);if(HQ){kg(R,d,HQ);return}var $Q=Z1?Z1(b1,K0,d+"",R,S,O1):A,SQ=$Q===A;if(SQ){var aB=J6(K0),Y9=!aB&&Kj(K0),q4=!aB&&!Y9&&kX(K0);if($Q=K0,aB||Y9||q4)if(J6(b1))$Q=b1;else if(VG(b1))$Q=RK(b1);else if(Y9)SQ=!1,$Q=g4(K0,!0);else if(q4)SQ=!1,$Q=Wa(K0,!0);else $Q=[];else if(a5(K0)||Wj(K0)){if($Q=b1,Wj(b1))$Q=rXA(b1);else if(!U1(b1)||uA(b1))$Q=N2(K0)}else SQ=!1}if(SQ)O1.set(K0,$Q),kA($Q,K0,JA,Z1,O1),O1.delete(K0);kg(R,d,$Q)}function en(R,S){var d=R.length;if(!d)return;return S+=S<0?d:0,F9(S,d)?R[S]:A}function kQA(R,S,d){if(S.length)S=B6(S,function(Z1){if(J6(Z1))return function(O1){return kN(O1,Z1.length===1?Z1[0]:Z1)};return Z1});else S=[aC];var JA=-1;S=B6(S,o6(E1()));var kA=tn(R,function(Z1,O1,b1){var K0=B6(S,function(HQ){return HQ(Z1)});return{criteria:K0,index:++JA,value:Z1}});return nB(kA,function(Z1,O1){return cQA(Z1,O1,d)})}function mXA(R,S){return Bv(R,S,function(d,JA){return GG1(R,JA)})}function Bv(R,S,d){var JA=-1,kA=S.length,Z1={};while(++JA<kA){var O1=S[JA],b1=kN(R,O1);if(d(b1,O1))Zv(Z1,bN(O1,R),b1)}return Z1}function fQA(R){return function(S){return kN(S,R)}}function Aa(R,S,d,JA){var kA=JA?$A:jW,Z1=-1,O1=S.length,b1=R;if(R===S)S=RK(S);if(d)b1=B6(R,o6(d));while(++Z1<O1){var K0=0,HQ=S[Z1],$Q=d?d(HQ):HQ;while((K0=kA(b1,$Q,K0,JA))>-1){if(b1!==R)iy.call(b1,K0,1);iy.call(R,K0,1)}}return R}function bQA(R,S){var d=R?S.length:0,JA=d-1;while(d--){var kA=S[d];if(d==JA||kA!==Z1){var Z1=kA;if(F9(kA))iy.call(R,kA,1);else Ya(R,kA)}}return R}function Qa(R,S){return R+Mg(Og()*(S-R+1))}function dXA(R,S,d,JA){var kA=-1,Z1=WJ(TN((S-R)/(d||1)),0),O1=y0(Z1);while(Z1--)O1[JA?Z1:++kA]=R,R+=d;return O1}function Gv(R,S){var d="";if(!R||S<1||S>e)return d;do{if(S%2)d+=R;if(S=Mg(S/2),S)R+=R}while(S);return d}function _6(R,S){return SX(n2(R,S,aC),R+"")}function Ba(R){return vg(BBA(R))}function hQA(R,S){var d=BBA(R);return _K(d,yN(S,0,d.length))}function Zv(R,S,d,JA){if(!U1(R))return R;S=bN(S,R);var kA=-1,Z1=S.length,O1=Z1-1,b1=R;while(b1!=null&&++kA<Z1){var K0=gG(S[kA]),HQ=d;if(K0==="__proto__"||K0==="constructor"||K0==="prototype")return R;if(kA!=O1){var $Q=b1[K0];if(HQ=JA?JA($Q,K0,b1):A,HQ===A)HQ=U1($Q)?$Q:F9(S[kA+1])?[]:{}}r9(b1,K0,HQ),b1=b1[K0]}return R}var Yv=!VO?aC:function(R,S){return VO.set(R,S),R},gQA=!lJ?aC:function(R,S){return lJ(R,"toString",{configurable:!0,enumerable:!1,value:YG1(S),writable:!0})};function uQA(R){return _K(BBA(R))}function iZ(R,S,d){var JA=-1,kA=R.length;if(S<0)S=-S>kA?0:kA+S;if(d=d>kA?kA:d,d<0)d+=kA;kA=S>d?0:d-S>>>0,S>>>=0;var Z1=y0(kA);while(++JA<kA)Z1[JA]=R[JA+S];return Z1}function Ga(R,S){var d;return vN(R,function(JA,kA,Z1){return d=S(JA,kA,Z1),!d}),!!d}function UO(R,S,d){var JA=0,kA=R==null?JA:R.length;if(typeof S=="number"&&S===S&&kA<=SA){while(JA<kA){var Z1=JA+kA>>>1,O1=R[Z1];if(O1!==null&&!qZ(O1)&&(d?O1<=S:O1<S))JA=Z1+1;else kA=Z1}return kA}return fN(R,S,aC,d)}function fN(R,S,d,JA){var kA=0,Z1=R==null?0:R.length;if(Z1===0)return 0;S=d(S);var O1=S!==S,b1=S===null,K0=qZ(S),HQ=S===A;while(kA<Z1){var $Q=Mg((kA+Z1)/2),SQ=d(R[$Q]),aB=SQ!==A,Y9=SQ===null,q4=SQ===SQ,I3=qZ(SQ);if(O1)var L4=JA||q4;else if(HQ)L4=q4&&(JA||aB);else if(b1)L4=q4&&aB&&(JA||!Y9);else if(K0)L4=q4&&aB&&!Y9&&(JA||!I3);else if(Y9||I3)L4=!1;else L4=JA?SQ<=S:SQ<S;if(L4)kA=$Q+1;else Z1=$Q}return SI(Z1,EA)}function mQA(R,S){var d=-1,JA=R.length,kA=0,Z1=[];while(++d<JA){var O1=R[d],b1=S?S(O1):O1;if(!d||!fI(b1,K0)){var K0=b1;Z1[kA++]=O1===0?0:O1}}return Z1}function Za(R){if(typeof R=="number")return R;if(qZ(R))return VA;return+R}function yW(R){if(typeof R=="string")return R;if(J6(R))return B6(R,yW)+"";if(qZ(R))return SXA?SXA.call(R):"";var S=R+"";return S=="0"&&1/R==-c?"-0":S}function Y$(R,S,d){var JA=-1,kA=OY,Z1=R.length,O1=!0,b1=[],K0=b1;if(d)O1=!1,kA=l5;else if(Z1>=B){var HQ=S?null:lXA(R);if(HQ)return nT(HQ);O1=!1,kA=PW,K0=new xN}else K0=S?[]:b1;A:while(++JA<Z1){var $Q=R[JA],SQ=S?S($Q):$Q;if($Q=d||$Q!==0?$Q:0,O1&&SQ===SQ){var aB=K0.length;while(aB--)if(K0[aB]===SQ)continue A;if(S)K0.push(SQ);b1.push($Q)}else if(!kA(K0,SQ,d)){if(K0!==b1)K0.push(SQ);b1.push($Q)}}return b1}function Ya(R,S){return S=bN(S,R),R=n5(R,S),R==null||delete R[gG(s8(S))]}function Jv(R,S,d,JA){return Zv(R,S,d(kN(R,S)),JA)}function cg(R,S,d,JA){var kA=R.length,Z1=JA?kA:-1;while((JA?Z1--:++Z1<kA)&&S(R[Z1],Z1,R));return d?iZ(R,JA?0:Z1,JA?Z1+1:kA):iZ(R,JA?Z1+1:0,JA?kA:Z1)}function Ja(R,S){var d=R;if(d instanceof r6)d=d.value();return TX(S,function(JA,kA){return kA.func.apply(kA.thisArg,x7([JA],kA.args))},d)}function Ia(R,S,d){var JA=R.length;if(JA<2)return JA?Y$(R[0]):[];var kA=-1,Z1=y0(JA);while(++kA<JA){var O1=R[kA],b1=-1;while(++b1<JA)if(b1!=kA)Z1[kA]=CO(Z1[kA]||O1,R[b1],S,d)}return Y$(bG(Z1,1),S,d)}function dQA(R,S,d){var JA=-1,kA=R.length,Z1=S.length,O1={};while(++JA<kA){var b1=JA<Z1?S[JA]:A;d(O1,R[JA],b1)}return O1}function Iv(R){return VG(R)?R:[]}function Xa(R){return typeof R=="function"?R:aC}function bN(R,S){if(J6(R))return R;return r3(R,S)?[R]:kI(k8(R))}var T4=_6;function hN(R,S,d){var JA=R.length;return d=d===A?JA:d,!S&&d>=JA?R:iZ(R,S,d)}var Xv=zQA||function(R){return J7.clearTimeout(R)};function g4(R,S){if(S)return R.slice();var d=R.length,JA=CQA?CQA(d):new R.constructor(d);return R.copy(JA),JA}function Wv(R){var S=new R.constructor(R.byteLength);return new JO(S).set(new JO(R)),S}function cXA(R,S){var d=S?Wv(R.buffer):R.buffer;return new R.constructor(d,R.byteOffset,R.byteLength)}function pg(R){var S=new R.constructor(R.source,K9.exec(R));return S.lastIndex=R.lastIndex,S}function OK(R){return EO?i5(EO.call(R)):{}}function Wa(R,S){var d=S?Wv(R.buffer):R.buffer;return new R.constructor(d,R.byteOffset,R.length)}function lg(R,S){if(R!==S){var d=R!==A,JA=R===null,kA=R===R,Z1=qZ(R),O1=S!==A,b1=S===null,K0=S===S,HQ=qZ(S);if(!b1&&!HQ&&!Z1&&R>S||Z1&&O1&&K0&&!b1&&!HQ||JA&&O1&&K0||!d&&K0||!kA)return 1;if(!JA&&!Z1&&!HQ&&R<S||HQ&&d&&kA&&!JA&&!Z1||b1&&d&&kA||!O1&&kA||!K0)return-1}return 0}function cQA(R,S,d){var JA=-1,kA=R.criteria,Z1=S.criteria,O1=kA.length,b1=d.length;while(++JA<O1){var K0=lg(kA[JA],Z1[JA]);if(K0){if(JA>=b1)return K0;var HQ=d[JA];return K0*(HQ=="desc"?-1:1)}}return R.index-S.index}function Ka(R,S,d,JA){var kA=-1,Z1=R.length,O1=d.length,b1=-1,K0=S.length,HQ=WJ(Z1-O1,0),$Q=y0(K0+HQ),SQ=!JA;while(++b1<K0)$Q[b1]=S[b1];while(++kA<O1)if(SQ||kA<Z1)$Q[d[kA]]=R[kA];while(HQ--)$Q[b1++]=R[kA++];return $Q}function Kv(R,S,d,JA){var kA=-1,Z1=R.length,O1=-1,b1=d.length,K0=-1,HQ=S.length,$Q=WJ(Z1-b1,0),SQ=y0($Q+HQ),aB=!JA;while(++kA<$Q)SQ[kA]=R[kA];var Y9=kA;while(++K0<HQ)SQ[Y9+K0]=S[K0];while(++O1<b1)if(aB||kA<Z1)SQ[Y9+d[O1]]=R[kA++];return SQ}function RK(R,S){var d=-1,JA=R.length;S||(S=y0(JA));while(++d<JA)S[d]=R[d];return S}function QF(R,S,d,JA){var kA=!d;d||(d={});var Z1=-1,O1=S.length;while(++Z1<O1){var b1=S[Z1],K0=JA?JA(d[b1],R[b1],b1,d,R):A;if(K0===A)K0=R[b1];if(kA)uC(d,b1,K0);else r9(d,b1,K0)}return d}function pQA(R,S){return QF(R,Q0(R),S)}function lQA(R,S){return QF(R,a0(R),S)}function ED(R,S){return function(d,JA){var kA=J6(d)?UB:LQA,Z1=S?S():{};return kA(d,R,E1(JA,2),Z1)}}function $O(R){return _6(function(S,d){var JA=-1,kA=d.length,Z1=kA>1?d[kA-1]:A,O1=kA>2?d[2]:A;if(Z1=R.length>3&&typeof Z1=="function"?(kA--,Z1):A,O1&&E4(d[0],d[1],O1))Z1=kA<3?A:Z1,kA=1;S=i5(S);while(++JA<kA){var b1=d[JA];if(b1)R(S,b1,JA,Z1)}return S})}function gN(R,S){return function(d,JA){if(d==null)return d;if(!kW(d))return R(d,JA);var kA=d.length,Z1=S?kA:-1,O1=i5(d);while(S?Z1--:++Z1<kA)if(JA(O1[Z1],Z1,O1)===!1)break;return d}}function iQA(R){return function(S,d,JA){var kA=-1,Z1=i5(S),O1=JA(S),b1=O1.length;while(b1--){var K0=O1[R?b1:++kA];if(d(Z1[K0],K0,Z1)===!1)break}return S}}function _Y(R,S,d){var JA=S&H,kA=J$(R);function Z1(){var O1=this&&this!==J7&&this instanceof Z1?kA:R;return O1.apply(JA?d:this,arguments)}return Z1}function wO(R){return function(S){S=k8(S);var d=lT(S)?XJ(S):A,JA=d?d[0]:S.charAt(0),kA=d?hN(d,1).join(""):S.slice(1);return JA[R]()+kA}}function vW(R){return function(S){return TX(zI0(CI0(S).replace(NK,"")),R,"")}}function J$(R){return function(){var S=arguments;switch(S.length){case 0:return new R;case 1:return new R(S[0]);case 2:return new R(S[0],S[1]);case 3:return new R(S[0],S[1],S[2]);case 4:return new R(S[0],S[1],S[2],S[3]);case 5:return new R(S[0],S[1],S[2],S[3],S[4]);case 6:return new R(S[0],S[1],S[2],S[3],S[4],S[5]);case 7:return new R(S[0],S[1],S[2],S[3],S[4],S[5],S[6])}var d=KJ(R.prototype),JA=R.apply(d,S);return U1(JA)?JA:d}}function pXA(R,S,d){var JA=J$(R);function kA(){var Z1=arguments.length,O1=y0(Z1),b1=Z1,K0=M1(kA);while(b1--)O1[b1]=arguments[b1];var HQ=Z1<3&&O1[0]!==K0&&O1[Z1-1]!==K0?[]:SW(O1,K0);if(Z1-=HQ.length,Z1<d)return ag(R,S,mC,kA.placeholder,A,O1,HQ,A,A,d-Z1);var $Q=this&&this!==J7&&this instanceof kA?JA:R;return p2($Q,this,O1)}return kA}function Va(R){return function(S,d,JA){var kA=i5(S);if(!kW(S)){var Z1=E1(d,3);S=PK(S),d=function(b1){return Z1(kA[b1],b1,kA)}}var O1=R(S,d,JA);return O1>-1?kA[Z1?S[O1]:O1]:A}}function ig(R){return n(function(S){var d=S.length,JA=d,kA=PX.prototype.thru;if(R)S.reverse();while(JA--){var Z1=S[JA];if(typeof Z1!="function")throw new nV(Z);if(kA&&!O1&&Y1(Z1)=="wrapper")var O1=new PX([],!0)}JA=O1?JA:d;while(++JA<d){Z1=S[JA];var b1=Y1(Z1),K0=b1=="wrapper"?KA(Z1):A;if(K0&&j9(K0[0])&&K0[1]==(_|U|q|T)&&!K0[4].length&&K0[9]==1)O1=O1[Y1(K0[0])].apply(O1,K0[3]);else O1=Z1.length==1&&j9(Z1)?O1[b1]():O1.thru(Z1)}return function(){var HQ=arguments,$Q=HQ[0];if(O1&&HQ.length==1&&J6($Q))return O1.plant($Q).value();var SQ=0,aB=d?S[SQ].apply(this,HQ):$Q;while(++SQ<d)aB=S[SQ].call(this,aB);return aB}})}function mC(R,S,d,JA,kA,Z1,O1,b1,K0,HQ){var $Q=S&_,SQ=S&H,aB=S&F,Y9=S&(U|O),q4=S&y,I3=aB?A:J$(R);function L4(){var e3=arguments.length,f8=y0(e3),W$=e3;while(W$--)f8[W$]=arguments[W$];if(Y9)var GF=M1(L4),K$=nH(f8,GF);if(JA)f8=Ka(f8,JA,kA,Y9);if(Z1)f8=Kv(f8,Z1,O1,Y9);if(e3-=K$,Y9&&e3<HQ){var bI=SW(f8,GF);return ag(R,S,mC,L4.placeholder,d,f8,bI,b1,K0,HQ-e3)}var xO=SQ?d:this,Fv=aB?xO[R]:R;if(e3=f8.length,b1)f8=W7(f8,b1);else if(q4&&e3>1)f8.reverse();if($Q&&K0<e3)f8.length=K0;if(this&&this!==J7&&this instanceof L4)Fv=I3||J$(Fv);return Fv.apply(xO,f8)}return L4}function DD(R,S){return function(d,JA){return jQA(d,R,S(JA),{})}}function VJ(R,S){return function(d,JA){var kA;if(d===A&&JA===A)return S;if(d!==A)kA=d;if(JA!==A){if(kA===A)return JA;if(typeof d=="string"||typeof JA=="string")d=yW(d),JA=yW(JA);else d=Za(d),JA=Za(JA);kA=R(d,JA)}return kA}}function ng(R){return n(function(S){return S=B6(S,o6(E1())),_6(function(d){var JA=this;return R(S,function(kA){return p2(kA,JA,d)})})})}function Vv(R,S){S=S===A?" ":yW(S);var d=S.length;if(d<2)return d?Gv(S,R):S;var JA=Gv(S,TN(R/ZO(S)));return lT(S)?hN(XJ(JA),0,R).join(""):JA.slice(0,R)}function uN(R,S,d,JA){var kA=S&H,Z1=J$(R);function O1(){var b1=-1,K0=arguments.length,HQ=-1,$Q=JA.length,SQ=y0($Q+K0),aB=this&&this!==J7&&this instanceof O1?Z1:R;while(++HQ<$Q)SQ[HQ]=JA[HQ];while(K0--)SQ[HQ++]=arguments[++b1];return p2(aB,kA?d:this,SQ)}return O1}function NO(R){return function(S,d,JA){if(JA&&typeof JA!="number"&&E4(S,d,JA))d=JA=A;if(S=iC(S),d===A)d=S,S=0;else d=iC(d);return JA=JA===A?S<d?1:-1:iC(JA),dXA(S,d,JA,R)}}function mN(R){return function(S,d){if(!(typeof S=="string"&&typeof d=="string"))S=qD(S),d=qD(d);return R(S,d)}}function ag(R,S,d,JA,kA,Z1,O1,b1,K0,HQ){var $Q=S&U,SQ=$Q?O1:A,aB=$Q?A:O1,Y9=$Q?Z1:A,q4=$Q?A:Z1;if(S|=$Q?q:M,S&=~($Q?M:q),!(S&C))S&=~(H|F);var I3=[R,S,kA,Y9,SQ,q4,aB,b1,K0,HQ],L4=d.apply(A,I3);if(j9(R))K7(L4,I3);return L4.placeholder=JA,iJ(L4,R,S)}function Ea(R){var S=lZ[R];return function(d,JA){if(d=qD(d),JA=JA==null?0:SI($6(JA),292),JA&&$QA(d)){var kA=(k8(d)+"e").split("e"),Z1=S(kA[0]+"e"+(+kA[1]+JA));return kA=(k8(Z1)+"e").split("e"),+(kA[0]+"e"+(+kA[1]-JA))}return S(d)}}var lXA=!(KO&&1/nT(new KO([,-0]))[1]==c)?XG1:function(R){return new KO(R)};function HD(R){return function(S){var d=bQ(S);if(d==NA)return y7(S);if(d==RA)return cy(S);return CZ(S,R(S))}}function dC(R,S,d,JA,kA,Z1,O1,b1){var K0=S&F;if(!K0&&typeof R!="function")throw new nV(Z);var HQ=JA?JA.length:0;if(!HQ)S&=~(q|M),JA=kA=A;if(O1=O1===A?O1:WJ($6(O1),0),b1=b1===A?b1:$6(b1),HQ-=kA?kA.length:0,S&M){var $Q=JA,SQ=kA;JA=kA=A}var aB=K0?A:KA(R),Y9=[R,S,d,JA,kA,$Q,SQ,Z1,O1,b1];if(aB)$Z(Y9,aB);if(R=Y9[0],S=Y9[1],d=Y9[2],JA=Y9[3],kA=Y9[4],b1=Y9[9]=Y9[9]===A?K0?0:R.length:WJ(Y9[9]-HQ,0),!b1&&S&(U|O))S&=~(U|O);if(!S||S==H)var q4=_Y(R,S,d);else if(S==U||S==O)q4=pXA(R,S,b1);else if((S==q||S==(H|q))&&!kA.length)q4=uN(R,S,d,JA);else q4=mC.apply(A,Y9);var I3=aB?Yv:K7;return iJ(I3(q4,Y9),R,S)}function nQA(R,S,d,JA){if(R===A||fI(R,jX[d])&&!a3.call(JA,d))return S;return R}function aV(R,S,d,JA,kA,Z1){if(U1(R)&&U1(S))Z1.set(S,R),dg(R,S,A,aV,Z1),Z1.delete(S);return R}function aQA(R){return a5(R)?A:R}function eT(R,S,d,JA,kA,Z1){var O1=d&E,b1=R.length,K0=S.length;if(b1!=K0&&!(O1&&K0>b1))return!1;var HQ=Z1.get(R),$Q=Z1.get(S);if(HQ&&$Q)return HQ==S&&$Q==R;var SQ=-1,aB=!0,Y9=d&D?new xN:A;Z1.set(R,S),Z1.set(S,R);while(++SQ<b1){var q4=R[SQ],I3=S[SQ];if(JA)var L4=O1?JA(I3,q4,SQ,S,R,Z1):JA(q4,I3,SQ,R,S,Z1);if(L4!==A){if(L4)continue;aB=!1;break}if(Y9){if(!ID(S,function(e3,f8){if(!PW(Y9,f8)&&(q4===e3||kA(q4,e3,d,JA,Z1)))return Y9.push(f8)})){aB=!1;break}}else if(!(q4===I3||kA(q4,I3,d,JA,Z1))){aB=!1;break}}return Z1.delete(R),Z1.delete(S),aB}function oQA(R,S,d,JA,kA,Z1,O1){switch(d){case EQ:if(R.byteLength!=S.byteLength||R.byteOffset!=S.byteOffset)return!1;R=R.buffer,S=S.buffer;case o0:if(R.byteLength!=S.byteLength||!Z1(new JO(R),new JO(S)))return!1;return!0;case bA:case TA:case UA:return fI(+R,+S);case YA:return R.name==S.name&&R.message==S.message;case $1:case B1:return R==S+"";case NA:var b1=y7;case RA:var K0=JA&E;if(b1||(b1=nT),R.size!=S.size&&!K0)return!1;var HQ=O1.get(R);if(HQ)return HQ==S;JA|=D,O1.set(R,S);var $Q=eT(b1(R),b1(S),JA,kA,Z1,O1);return O1.delete(R),$Q;case m1:if(EO)return EO.call(R)==EO.call(S)}return!1}function b(R,S,d,JA,kA,Z1){var O1=d&E,b1=a(R),K0=b1.length,HQ=a(S),$Q=HQ.length;if(K0!=$Q&&!O1)return!1;var SQ=K0;while(SQ--){var aB=b1[SQ];if(!(O1?aB in S:a3.call(S,aB)))return!1}var Y9=Z1.get(R),q4=Z1.get(S);if(Y9&&q4)return Y9==S&&q4==R;var I3=!0;Z1.set(R,S),Z1.set(S,R);var L4=O1;while(++SQ<K0){aB=b1[SQ];var e3=R[aB],f8=S[aB];if(JA)var W$=O1?JA(f8,e3,aB,S,R,Z1):JA(e3,f8,aB,R,S,Z1);if(!(W$===A?e3===f8||kA(e3,f8,d,JA,Z1):W$)){I3=!1;break}L4||(L4=aB=="constructor")}if(I3&&!L4){var GF=R.constructor,K$=S.constructor;if(GF!=K$&&(("constructor"in R)&&("constructor"in S))&&!(typeof GF=="function"&&GF instanceof GF&&typeof K$=="function"&&K$ instanceof K$))I3=!1}return Z1.delete(R),Z1.delete(S),I3}function n(R){return SX(n2(R,A,e0),R+"")}function a(R){return _QA(R,PK,Q0)}function DA(R){return _QA(R,nC,a0)}var KA=!VO?XG1:function(R){return VO.get(R)};function Y1(R){var S=R.name+"",d=oT[S],JA=a3.call(oT,S)?d.length:0;while(JA--){var kA=d[JA],Z1=kA.func;if(Z1==null||Z1==R)return kA.name}return S}function M1(R){var S=a3.call(rA,"placeholder")?rA:R;return S.placeholder}function E1(){var R=rA.iteratee||JG1;return R=R===JG1?zO:R,arguments.length?R(arguments[0],arguments[1]):R}function Q1(R,S){var d=R.__data__;return XG(S)?d[typeof S=="string"?"string":"hash"]:d.map}function _1(R){var S=PK(R),d=S.length;while(d--){var JA=S[d],kA=R[JA];S[d]=[JA,kA,C9(kA)]}return S}function u1(R,S){var d=GO(R,S);return yI(d)?d:A}function N0(R){var S=a3.call(R,rH),d=R[rH];try{R[rH]=A;var JA=!0}catch(Z1){}var kA=Ng.call(R);if(JA)if(S)R[rH]=d;else delete R[rH];return kA}var Q0=!UQA?WG1:function(R){if(R==null)return[];return R=i5(R),FZ(UQA(R),function(S){return bn.call(R,S)})},a0=!UQA?WG1:function(R){var S=[];while(R)x7(S,Q0(R)),R=IO(R);return S},bQ=_5;if(gn&&bQ(new gn(new ArrayBuffer(1)))!=EQ||ay&&bQ(new ay)!=NA||oy&&bQ(oy.resolve())!=gA||KO&&bQ(new KO)!=RA||PN&&bQ(new PN)!=H0)bQ=function(R){var S=_5(R),d=S==lA?R.constructor:A,JA=d?v7(d):"";if(JA)switch(JA){case jXA:return EQ;case FjA:return NA;case un:return gA;case rT:return RA;case PXA:return H0}return S};function B2(R,S,d){var JA=-1,kA=d.length;while(++JA<kA){var Z1=d[JA],O1=Z1.size;switch(Z1.type){case"drop":R+=O1;break;case"dropRight":S-=O1;break;case"take":S=SI(S,R+O1);break;case"takeRight":R=WJ(R,S-O1);break}}return{start:R,end:S}}function YB(R){var S=R.match(iA);return S?S[1].split(F1):[]}function G2(R,S,d){S=bN(S,R);var JA=-1,kA=S.length,Z1=!1;while(++JA<kA){var O1=gG(S[JA]);if(!(Z1=R!=null&&d(R,O1)))break;R=R[O1]}if(Z1||++JA!=kA)return Z1;return kA=R==null?0:R.length,!!kA&&L1(kA)&&F9(O1,kA)&&(J6(R)||Wj(R))}function i2(R){var S=R.length,d=new R.constructor(S);if(S&&typeof R[0]=="string"&&a3.call(R,"index"))d.index=R.index,d.input=R.input;return d}function N2(R){return typeof R.constructor=="function"&&!r8(R)?KJ(IO(R)):{}}function OB(R,S,d){var JA=R.constructor;switch(S){case o0:return Wv(R);case bA:case TA:return new JA(+R);case EQ:return cXA(R,d);case WQ:case w1:case eA:case V1:case R1:case G0:case U0:case C0:case HA:return Wa(R,d);case NA:return new JA;case UA:case B1:return new JA(R);case $1:return pg(R);case RA:return new JA;case m1:return OK(R)}}function u4(R,S){var d=S.length;if(!d)return R;var JA=d-1;return S[JA]=(d>1?"& ":"")+S[JA],S=S.join(d>2?", ":" "),R.replace(K1,`{
bundles/ClaudeCodeCode/cli.js:4686:`)),process.exit(1)}}function AF5(){L9("eagerLoadSettings_start");let A=process.argv.findIndex((B)=>B==="--settings");if(A!==-1&&A+1<process.argv.length){let B=process.argv[A+1];if(B)tH5(B)}let Q=process.argv.findIndex((B)=>B==="--setting-sources");if(Q!==-1&&Q+1<process.argv.length){let B=process.argv[Q+1];if(B!==void 0)eH5(B)}L9("eagerLoadSettings_end")}function QF5(A){if(process.env.CLAUDE_CODE_ENTRYPOINT)return;let Q=process.argv.slice(2),B=Q.indexOf("mcp");if(B!==-1&&Q[B+1]==="serve"){process.env.CLAUDE_CODE_ENTRYPOINT="mcp";return}if(z0(process.env.CLAUDE_CODE_ACTION)){process.env.CLAUDE_CODE_ENTRYPOINT="claude-code-github-action";return}process.env.CLAUDE_CODE_ENTRYPOINT=A?"sdk-cli":"cli"}async function BF5(){L9("main_function_start"),process.env.NoDefaultCurrentDirectoryInExePath="1",xm2(),process.on("exit",()=>{IF5()}),process.on("SIGINT",()=>{process.exit(0)}),L9("main_warning_handler_initialized");let A=process.argv.slice(2),Q=A.includes("-p")||A.includes("--print"),B=A.some((J)=>J.startsWith("--sdk-url")),G=Q||B||!process.stdout.isTTY;LK0(!G),QF5(G);let Y=(()=>{if(process.env.GITHUB_ACTIONS==="true")return"github-action";if(process.env.CLAUDE_CODE_ENTRYPOINT==="sdk-ts")return"sdk-typescript";if(process.env.CLAUDE_CODE_ENTRYPOINT==="sdk-py")return"sdk-python";if(process.env.CLAUDE_CODE_ENTRYPOINT==="sdk-cli")return"sdk-cli";if(process.env.CLAUDE_CODE_ENTRYPOINT==="claude-vscode")return"claude-vscode";if(process.env.CLAUDE_CODE_SESSION_ACCESS_TOKEN||process.env.CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR)return"remote";return"cli"})();MK0(Y),L9("main_client_type_determined"),AF5(),L9("main_before_run"),process.title="claude",await YF5(),L9("main_after_run")}function GF5(A){let Q=0,B={exitOnCtrlC:A,onFlicker:(G,Z,Y,J)=>{if(J==="resize")return;let I=Date.now();if(I-Q<1000)r("tengu_flicker",{desiredHeight:G,actualHeight:Z,ink2Enabled:Y,reason:J});Q=I}};if(!process.stdin.isTTY&&!z0(!1)&&!process.argv.includes("mcp")){if(r("tengu_stdin_interactive",{}),process.platform!=="win32")try{let G=cH5("/dev/tty","r");B={...B,stdin:new dH5(G)}}catch(G){s(G)}}return B}async function ZF5(A,Q){if(!process.stdin.isTTY&&!process.argv.includes("mcp")){if(Q==="stream-json")return process.stdin;process.stdin.setEncoding("utf8");let B="";return process.stdin.on("data",(G)=>{B+=G}),await new Promise((G)=>{process.stdin.on("end",G)}),[A,B].filter(Boolean).join(`
bundles/ClaudeAgentSDKCode/cli.js:80:`);if(Y!==-1)Q=Au0(Q,Z,G,Y);return G+Q+Z},mR9,Lc5,pA;var o2=q(()=>{ag0();tg0();({stdout:Qu0,stderr:Bu0}=sg0),OK1=Symbol("GENERATOR"),q9A=Symbol("STYLER"),iKA=Symbol("IS_EMPTY"),Gu0=["ansi","ansi","ansi256","ansi16m"],L9A=Object.create(null);Object.setPrototypeOf(nKA.prototype,Function.prototype);for(let[A,Q]of Object.entries(eO))L9A[A]={get(){let B=gyA(this,_K1(Q.open,Q.close,this[q9A]),this[iKA]);return Object.defineProperty(this,A,{value:B}),B}};L9A.visible={get(){let A=gyA(this,this[q9A],!0);return Object.defineProperty(this,"visible",{value:A}),A}};hR9=["rgb","hex","ansi256"];for(let A of hR9){L9A[A]={get(){let{level:B}=this;return function(...G){let Z=_K1(RK1(A,Gu0[B],"color",...G),eO.color.close,this[q9A]);return gyA(this,Z,this[iKA])}}};let Q="bg"+A[0].toUpperCase()+A.slice(1);L9A[Q]={get(){let{level:B}=this;return function(...G){let Z=_K1(RK1(A,Gu0[B],"bgColor",...G),eO.bgColor.close,this[q9A]);return gyA(this,Z,this[iKA])}}}}gR9=Object.defineProperties(()=>{},{...L9A,level:{enumerable:!0,get(){return this[OK1].level},set(A){this[OK1].level=A}}});Object.defineProperties(nKA.prototype,L9A);mR9=nKA(),Lc5=nKA({level:Bu0?Bu0.level:0}),pA=mR9});function Yu0(A,Q){return{name:`${A.name}-with-${Q.name}-fallback`,read(){let B=A.read();if(B!==null&&B!==void 0)return B;return Q.read()||{}},update(B){let G=A.read(),Z=A.update(B);if(Z.success){if(G===null)Q.delete();return Z}let Y=Q.update(B);if(Y.success)return{success:!0,warning:Y.warning};return{success:!1}},delete(){let B=A.delete(),G=Q.delete();return B||G}}}import{createHash as dR9}from"crypto";import{userInfo as cR9}from"os";function Nm(A=""){let Q=uQ(),G=!process.env.CLAUDE_CONFIG_DIR?"":`-${dR9("sha256").update(Q).digest("hex").substring(0,8)}`;return`Claude Code${k9().OAUTH_FILE_SUFFIX}${A}${G}`}function aKA(){try{return process.env.USER||cR9().username}catch{return"claude-code-user"}}function Iu0(){if(process.platform!=="darwin")return!1;try{return T2A("security",["show-keychain-info"],{reject:!1,stdio:["ignore","pipe","pipe"]}).exitCode===36}catch{return!1}}var Ju0;var oKA=q(()=>{pSA();sQ();nJ();sWA();Ju0={name:"keychain",read(){try{let A=Nm("-credentials"),Q=aKA(),B=pG(`security find-generic-password -a "${Q}" -w -s "${A}"`);if(B)return JSON.parse(B)}catch(A){return null}return null},update(A){try{let Q=Nm("-credentials"),B=aKA(),G=JSON.stringify(A),Z=Buffer.from(G,"utf-8").toString("hex"),Y=`add-generic-password -U -a "${B}" -s "${Q}" -X "${Z}"
bundles/ClaudeAgentSDKCode/cli.js:190:`;pG("security -i",{input:J,stdio:["pipe","pipe","pipe"]}),s("tengu_api_key_saved_to_keychain",{}),Q=!0}catch(G){r(G),s("tengu_api_key_keychain_error",{error:G.message}),s("tengu_api_key_saved_to_config",{})}else s("tengu_api_key_saved_to_config",{});let B=Ww(A);i0((G)=>{let Z=G.customApiKeyResponses?.approved??[];return{...G,primaryApiKey:Q?G.primaryApiKey:A,customApiKeyResponses:{...G.customApiKeyResponses,approved:Z.includes(B)?Z:[...Z,B],rejected:G.customApiKeyResponses?.rejected??[]}}}),HHA.cache.clear?.()}function YCQ(){JCQ(),i0((A)=>({...A,primaryApiKey:void 0})),HHA.cache.clear?.()}function JCQ(){try{sFQ()}catch(A){r(A)}}function FHA(A){if(!Qk(A.scopes))return s("tengu_oauth_tokens_not_claude_ai",{}),{success:!0};if(!A.refreshToken||!A.expiresAt)return s("tengu_oauth_tokens_inference_only",{}),{success:!0};let Q=u$(),B=Q.name;try{let G=Q.read()||{};G.claudeAiOauth={accessToken:A.accessToken,refreshToken:A.refreshToken,expiresAt:A.expiresAt,scopes:A.scopes,subscriptionType:A.subscriptionType,rateLimitTier:A.rateLimitTier};let Z=Q.update(G);if(Z.success)s("tengu_oauth_tokens_saved",{storageBackend:B});else s("tengu_oauth_tokens_save_failed",{storageBackend:B});return r3.cache?.clear?.(),oyA(),Z}catch(G){return r(G),s("tengu_oauth_tokens_save_exception",{storageBackend:B,error:G.message}),{success:!1,warning:"Failed to save OAuth tokens"}}}async function pk(A=0){let B=r3();if(!B?.refreshToken||!qm(B.expiresAt))return!1;if(!Qk(B.scopes))return!1;if(r3.cache?.clear?.(),B=r3(),!B?.refreshToken||!qm(B.expiresAt))return!1;let G=uQ();jA().mkdirSync(G);let Y;try{Y=await tFQ.lock(G)}catch(J){if(J.code==="ELOCKED"){if(A<5)return s("tengu_oauth_token_refresh_lock_retry",{retryCount:A+1}),await new Promise((I)=>setTimeout(I,1000+Math.random()*1000)),pk(A+1);return s("tengu_oauth_token_refresh_lock_retry_limit_reached",{maxRetries:5}),!1}return r(J),s("tengu_oauth_token_refresh_lock_error",{error:J.message}),!1}try{if(r3.cache?.clear?.(),B=r3(),!B?.refreshToken||!qm(B.expiresAt))return s("tengu_oauth_token_refresh_race_resolved",{}),!1;let J=await Vu0(B.refreshToken);return FHA(J),r3.cache?.clear?.(),!0}catch(J){return r(J instanceof Error?J:Error(String(J))),!1}finally{await Y()}}function LB(){if(!kz())return!1;return Qk(r3()?.scopes)}function ICQ(){if(C0(process.env.CLAUDE_CODE_USE_BEDROCK)||C0(process.env.CLAUDE_CODE_USE_VERTEX)||C0(process.env.CLAUDE_CODE_USE_FOUNDRY))return!1;if(LB())return!1;return!0}function j8(){return kz()?c1().oauthAccount:void 0}function YL(){let A=c3();return A==="max"||A==="enterprise"||A==="team"||A==="pro"||A===null}function c3(){if(wu0())return $u0();if(!kz())return null;let A=r3();if(!A)return null;return A.subscriptionType??null}function Rd(){if(!kz())return null;let A=r3();if(!A)return null;return A.rateLimitTier??null}function OR1(){switch(c3()){case"enterprise":return"Claude Enterprise";case"team":return"Claude Team";case"max":return"Claude Max";case"pro":return"Claude Pro";default:return"Claude API"}}function nP(){return!!(C0(process.env.CLAUDE_CODE_USE_BEDROCK)||C0(process.env.CLAUDE_CODE_USE_VERTEX)||C0(process.env.CLAUDE_CODE_USE_FOUNDRY))}function XCQ(){return(CQ()||{}).otelHeadersHelper}function CHA(){let A=XCQ();if(!A)return!1;let Q=uB("projectSettings"),B=uB("localSettings");return Q?.otelHeadersHelper===A||B?.otelHeadersHelper===A}function WCQ(){let A=XCQ();if(!A)return{};if(CHA()){if(!tZ(!0))return{}}try{let Q=pG(A)?.toString().trim();if(!Q)throw Error("otelHeadersHelper did not return a valid value");let B=JSON.parse(Q);if(typeof B!=="object"||B===null||Array.isArray(B))throw Error("otelHeadersHelper must return a JSON object with string key-value pairs");for(let[G,Z]of Object.entries(B))if(typeof Z!=="string")throw Error(`otelHeadersHelper returned non-string value for key "${G}": ${typeof Z}`);return B}catch(Q){throw r(Error(`Error getting OpenTelemetry headers from otelHeadersHelper (in settings): ${Q instanceof Error?Q.message:String(Q)}`)),Q}}function ez3(A){return A==="max"||A==="pro"}function dgA(){let A=c3();return LB()&&A!==null&&ez3(A)}function cgA(){if(_3()!=="firstParty")return;let{source:Q}=Od(),B={};if(LB())B.subscription=OR1();else B.tokenSource=Q;let{key:G,source:Z}=aD();if(G)B.apiKeySource=Z;if(Q==="claude.ai"||Z==="/login managed key"){let J=j8()?.organizationName;if(J)B.organization=J}let Y=j8()?.emailAddress;if((Q==="claude.ai"||Z==="/login managed key")&&Y)B.email=Y;return B}var tFQ,iz3=300000,DHA,az3=3600000,xr,HHA,r3;var V2=q(()=>{vQ();gB();Q3();p2();byA();g1();Q0();o2();uyA();Wu0();qq();pyA();Bk();YQ();sQ();oKA();u0();B$1();_0();hW();qR1();VHA();tFQ=o($m(),1);DHA=LK1((A)=>{let Q=EHA();if(!Q)return null;if(ACQ()){if(!tZ(!0)&&!A){let G=Error(`Security: apiKeyHelper executed before workspace trust is confirmed. If you see this message, post in ${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.67",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues",BUILD_TIME:"2025-12-11T23:56:11Z"}.FEEDBACK_CHANNEL}.`);Dq("apiKeyHelper invoked before trust check",G),s("tengu_apiKeyHelper_missing_trust8",{})}}try{let B=pG(Q)?.toString().trim();if(!B)throw Error("apiKeyHelper did not return a valid value");return B}catch(B){let G=pA.red("Error getting API key from apiKeyHelper (in settings or ~/.claude.json):");if(B instanceof Error&&"stderr"in B)console.error(G,String(B.stderr));else if(B instanceof Error)console.error(G,B.message);else console.error(G,B);return" "}},nz3());xr=LK1(async()=>{let A=await oz3(),Q=await sz3();if(A||Q)await H4Q();return Q},az3);HHA=Z0(()=>{if(process.platform==="darwin"){let Q=Nm();try{let B=pG(`security find-generic-password -a $USER -w -s "${Q}"`);if(B)return{key:B,source:"/login managed key"}}catch(B){r(B)}}let A=c1();if(!A.primaryApiKey)return null;return{key:A.primaryApiKey,source:"/login managed key"}});r3=Z0(()=>{if(process.env.CLAUDE_CODE_OAUTH_TOKEN)return{accessToken:process.env.CLAUDE_CODE_OAUTH_TOKEN,refreshToken:null,expiresAt:null,scopes:["user:inference"],subscriptionType:null,rateLimitTier:null};let A=SK1();if(A)return{accessToken:A,refreshToken:null,expiresAt:null,scopes:["user:inference"],subscriptionType:null,rateLimitTier:null};try{let G=u$().read()?.claudeAiOauth;if(!G?.accessToken)return null;return G}catch(Q){return r(Q),null}})});import{join as zHA}from"path";function ECQ(){return(process.argv[1]||"").includes("/.claude/local/node_modules/")}async function AU3(){try{if(!jA().existsSync(_d))jA().mkdirSync(_d);if(!jA().existsSync(KCQ)){let Q={name:"claude-local",version:"0.0.1",private:!0};jA().writeFileSync(KCQ,JSON.stringify(Q,null,2),{encoding:"utf8",flush:!1})}let A=zHA(_d,"claude");if(!jA().existsSync(A)){let Q=`#!/bin/bash
bundles/ClaudeAgentSDKCode/cli.js:983:`)||[];for(let G of B){let[Z,Y]=G.split("@");if(Z==="anthropic.claude-code"&&Y)return Y}return null}function DR6(){try{if(pQ()!=="macos")return null;let Q=process.ppid;for(let B=0;B<10;B++){if(!Q||Q===0||Q===1)break;let G=pG(`ps -o command= -p ${Q}`)?.trim();if(G){let Y={"Visual Studio Code.app":"code","Cursor.app":"cursor","Windsurf.app":"windsurf","Visual Studio Code - Insiders.app":"code","VSCodium.app":"codium"},J="/Contents/MacOS/Electron";for(let[I,X]of Object.entries(Y)){let W=G.indexOf(I+"/Contents/MacOS/Electron");if(W!==-1){let K=W+I.length;return G.substring(0,K)+"/Contents/Resources/app/bin/"+X}}}let Z=pG(`ps -o ppid= -p ${Q}`)?.trim();if(!Z)break;Q=parseInt(Z.trim())}return null}catch{return null}}function kEB(A){let Q=DR6();if(Q){if(jA().existsSync(Q))return Q}switch(A){case"vscode":return"code";case"cursor":return"cursor";case"windsurf":return"windsurf";default:break}return null}function prA(){let A=[];try{let Q=pQ();if(Q==="macos"){let B=pG('ps aux | grep -E "Visual Studio Code|Code Helper|Cursor Helper|Windsurf Helper|IntelliJ IDEA|PyCharm|WebStorm|PhpStorm|RubyMine|CLion|GoLand|Rider|DataGrip|AppCode|DataSpell|Aqua|Gateway|Fleet|Android Studio" | grep -v grep')??"";for(let[G,Z]of Object.entries(b7A))for(let Y of Z.processKeywordsMac)if(B.includes(Y)){A.push(G);break}}else if(Q==="windows"){let G=(pG('tasklist | findstr /I "Code.exe Cursor.exe Windsurf.exe idea64.exe pycharm64.exe webstorm64.exe phpstorm64.exe rubymine64.exe clion64.exe goland64.exe rider64.exe datagrip64.exe appcode.exe dataspell64.exe aqua64.exe gateway64.exe fleet.exe studio64.exe"')??"").toLowerCase();for(let[Z,Y]of Object.entries(b7A))for(let J of Y.processKeywordsWindows)if(G.includes(J.toLowerCase())){A.push(Z);break}}else if(Q==="linux"){let G=(pG('ps aux | grep -E "code|cursor|windsurf|idea|pycharm|webstorm|phpstorm|rubymine|clion|goland|rider|datagrip|dataspell|aqua|gateway|fleet|android-studio" | grep -v grep')??"").toLowerCase();for(let[Z,Y]of Object.entries(b7A))for(let J of Y.processKeywordsLinux)if(G.includes(J)){if(Z!=="vscode"){A.push(Z);break}else if(!G.includes("cursor")&&!G.includes("appcode")){A.push(Z);break}}}}catch(Q){r(Q)}return A}function lrA(A){let Q=A.find((B)=>B.type==="connected"&&B.name==="ide");return ec1(Q)}function ec1(A){let Q=A?.config;return Q?.type==="sse-ide"||Q?.type==="ws-ide"?Q.ideName:BW()?DV(bz.terminal):null}function DV(A){if(!A)return"IDE";let Q=b7A[A];if(Q)return Q.displayName;let B=PEB[A.toLowerCase().trim()];if(B)return B;let G=A.split(" ")[0],Z=G?BR6(G).toLowerCase():null;if(Z){let Y=PEB[Z];if(Y)return Y;return lHA(Z)}return lHA(A)}function VU(A){if(!A)return;let Q=A.find((B)=>B.type==="connected"&&B.name==="ide");return Q?.type==="connected"?Q:void 0}async function gEB(A){try{await Rb("closeAllDiffTabs",{},A)}catch(Q){}}async function uEB(A,Q,B,G){_EB().then(A);let Z=c1().autoInstallIdeExtension??!0;if(process.env.CLAUDE_CODE_IDE_SKIP_AUTO_INSTALL!=="true"&&Z){let Y=Q??k7A();if(Y){if(mrA(Y))TEB(Y).then(async(J)=>{WR6(Y).catch((I)=>{return{installed:!1,error:I.message||"Installation failed",installedVersion:null,ideType:Y}}).then((I)=>{if(G(I),I?.installed)_EB().then(A);if(!J&&I?.installed===!0&&!brA())B()})});else if(O_(Y)&&!brA())TEB(Y).then(async(J)=>{if(J)B()})}}}var SEB,b7A,ywA,vwA,BW,XR6,vn7,hrA=null,KR6="anthropic.claude-code",fEB,bEB,hEB,PEB,mEB;var RJ=q(()=>{R8();sQ();PuA();Q3();vQ();_0();xT1();p2();u0();YQ();g1();Z8();R_();nc1();ac1();oc1();Q0();NZ();er();SEB=o(_R(),1);b7A={cursor:{ideKind:"vscode",displayName:"Cursor",processKeywordsMac:["Cursor Helper","Cursor.app"],processKeywordsWindows:["cursor.exe"],processKeywordsLinux:["cursor"]},windsurf:{ideKind:"vscode",displayName:"Windsurf",processKeywordsMac:["Windsurf Helper","Windsurf.app"],processKeywordsWindows:["windsurf.exe"],processKeywordsLinux:["windsurf"]},vscode:{ideKind:"vscode",displayName:"VS Code",processKeywordsMac:["Visual Studio Code","Code Helper"],processKeywordsWindows:["code.exe"],processKeywordsLinux:["code"]},intellij:{ideKind:"jetbrains",displayName:"IntelliJ IDEA",processKeywordsMac:["IntelliJ IDEA"],processKeywordsWindows:["idea64.exe"],processKeywordsLinux:["idea","intellij"]},pycharm:{ideKind:"jetbrains",displayName:"PyCharm",processKeywordsMac:["PyCharm"],processKeywordsWindows:["pycharm64.exe"],processKeywordsLinux:["pycharm"]},webstorm:{ideKind:"jetbrains",displayName:"WebStorm",processKeywordsMac:["WebStorm"],processKeywordsWindows:["webstorm64.exe"],processKeywordsLinux:["webstorm"]},phpstorm:{ideKind:"jetbrains",displayName:"PhpStorm",processKeywordsMac:["PhpStorm"],processKeywordsWindows:["phpstorm64.exe"],processKeywordsLinux:["phpstorm"]},rubymine:{ideKind:"jetbrains",displayName:"RubyMine",processKeywordsMac:["RubyMine"],processKeywordsWindows:["rubymine64.exe"],processKeywordsLinux:["rubymine"]},clion:{ideKind:"jetbrains",displayName:"CLion",processKeywordsMac:["CLion"],processKeywordsWindows:["clion64.exe"],processKeywordsLinux:["clion"]},goland:{ideKind:"jetbrains",displayName:"GoLand",processKeywordsMac:["GoLand"],processKeywordsWindows:["goland64.exe"],processKeywordsLinux:["goland"]},rider:{ideKind:"jetbrains",displayName:"Rider",processKeywordsMac:["Rider"],processKeywordsWindows:["rider64.exe"],processKeywordsLinux:["rider"]},datagrip:{ideKind:"jetbrains",displayName:"DataGrip",processKeywordsMac:["DataGrip"],processKeywordsWindows:["datagrip64.exe"],processKeywordsLinux:["datagrip"]},appcode:{ideKind:"jetbrains",displayName:"AppCode",processKeywordsMac:["AppCode"],processKeywordsWindows:["appcode.exe"],processKeywordsLinux:["appcode"]},dataspell:{ideKind:"jetbrains",displayName:"DataSpell",processKeywordsMac:["DataSpell"],processKeywordsWindows:["dataspell64.exe"],processKeywordsLinux:["dataspell"]},aqua:{ideKind:"jetbrains",displayName:"Aqua",processKeywordsMac:[],processKeywordsWindows:["aqua64.exe"],processKeywordsLinux:[]},gateway:{ideKind:"jetbrains",displayName:"Gateway",processKeywordsMac:[],processKeywordsWindows:["gateway64.exe"],processKeywordsLinux:[]},fleet:{ideKind:"jetbrains",displayName:"Fleet",processKeywordsMac:[],processKeywordsWindows:["fleet.exe"],processKeywordsLinux:[]},androidstudio:{ideKind:"jetbrains",displayName:"Android Studio",processKeywordsMac:["Android Studio"],processKeywordsWindows:["studio64.exe"],processKeywordsLinux:["android-studio"]}};ywA=Z0(()=>{return mrA(QQ.terminal)}),vwA=Z0(()=>{return O_(bz.terminal)}),BW=Z0(()=>{return ywA()||vwA()||Boolean(process.env.FORCE_CODE_TERMINAL)});XR6=GR6(import.meta.url),vn7=urA(XR6,"../");fEB=Z0(()=>{try{return pG("cursor --version"),!0}catch{return!1}}),bEB=Z0(()=>{try{return pG("windsurf --version"),!0}catch{return!1}}),hEB=Z0(()=>{try{let A=pG("code --help");return Boolean(A&&A.includes("Visual Studio Code"))}catch{return!1}});PEB={code:"VS Code",cursor:"Cursor",windsurf:"Windsurf",antigravity:"Antigravity",vi:"Vim",vim:"Vim",nano:"nano",notepad:"Notepad","start /wait notepad":"Notepad",emacs:"Emacs",subl:"Sublime Text",atom:"Atom"};mEB=Z0(async(A,Q)=>{if(process.env.CLAUDE_CODE_IDE_HOST_OVERRIDE)return process.env.CLAUDE_CODE_IDE_HOST_OVERRIDE;if(pQ()!=="wsl"||!A)return"127.0.0.1";try{let G=QR6("ip route show | grep -i default",{encoding:"utf8"}).match(/default via (\d+\.\d+\.\d+\.\d+)/);if(G){let Z=G[1];if(await sc1(Z,Q))return Z}}catch(B){}return"127.0.0.1"})});function HR6(){let A=ZK0();if(A!==void 0)return A;let Q=process.env.CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR;if(!Q)return SBA(null),null;let B=parseInt(Q,10);if(Number.isNaN(B))return f(`CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR must be a valid file descriptor number, got: ${Q}`,{level:"error"}),SBA(null),null;try{let G=jA(),Z=process.platform==="darwin"||process.platform==="freebsd"?`/dev/fd/${B}`:`/proc/self/fd/${B}`,Y=G.readFileSync(Z,{encoding:"utf8"}).trim();if(!Y)return f("File descriptor contained empty token",{level:"error"}),SBA(null),null;return f(`Successfully read token from file descriptor ${B}`),SBA(Y),Y}catch(G){return f(`Failed to read token from file descriptor ${B}: ${G instanceof Error?G.message:String(G)}`,{level:"error"}),SBA(null),null}}function fe(){let A=process.env.CLAUDE_CODE_SESSION_ACCESS_TOKEN;if(A)return A;return HR6()}var irA=q(()=>{Q0();YQ();u0()});function FR6(A){let Q=A,B="",G=0,Z=10;while(Q!==B&&G<Z)B=Q,Q=Q.normalize("NFKC"),Q=Q.replace(/[\p{Cf}\p{Co}\p{Cn}]/gu,""),Q=Q.replace(/[\u200B-\u200F]/g,"").replace(/[\u202A-\u202E]/g,"").replace(/[\u2066-\u2069]/g,"").replace(/[\uFEFF]/g,"").replace(/[\uE000-\uF8FF]/g,""),G++;if(G>=Z)throw Error(`Unicode sanitization reached maximum iterations (${Z}) for input: ${A.slice(0,100)}`);return Q}function fp(A){if(typeof A==="string")return FR6(A);if(Array.isArray(A))return A.map(fp);if(A!==null&&typeof A==="object"){let Q={};for(let[B,G]of Object.entries(A))Q[fp(B)]=fp(G);return Q}return A}function nrA(){return parseInt(process.env.MAX_MCP_OUTPUT_TOKENS??"25000",10)}function cEB(A){return A.type==="text"}function pEB(A){return A.type==="image"}function Ap1(A){if(!A)return 0;if(typeof A==="string")return jG(A);return A.reduce((Q,B)=>{if(cEB(B))return Q+jG(B.text);else if(pEB(B))return Q+dEB;return Q},0)}function zR6(){return nrA()*4}function UR6(){return`
bundles/ClaudeAgentSDKCode/cli.js:2597:- View comments on a Github PR: gh api repos/foo/bar/pulls/123/comments`}var J_A=q(()=>{$S();gB();jE();wS();Gt();Q0();CPA();u0();BI();pE();d2()});function cH2({param:A,addMargin:Q,tools:B,verbose:G,erroredToolUseIDs:Z,inProgressToolUseIDs:Y,resolvedToolUseIDs:J,progressMessagesForMessage:I,shouldAnimate:X,shouldShowDot:W,inProgressToolCallCount:K,messages:V}){let E=SB(),[D]=E2(),F=lH2()?.[0]?.pendingWorkerRequest;if(!B)return r(Error(`Tools array is undefined for tool ${A.name}`)),null;let C=B.find((b)=>b.name===A.name);if(!C)return r(Error(`Tool ${A.name} not found`)),null;let $=J.has(A.id),O=!Y.has(A.id)&&!$,M=F?.toolUseId===A.id,L=C.inputSchema.safeParse(A.input),_=C.userFacingName(L.success?L.data:void 0),T=C.userFacingNameBackgroundColor?.(L.success?L.data:void 0);if(_==="")return null;let x=L.success?s25(C,L.data,{theme:D,verbose:G}):null;if(x===null)return null;return FY.default.createElement(j,{flexDirection:"row",justifyContent:"space-between",marginTop:Q?1:0,width:"100%"},FY.default.createElement(j,{flexDirection:"column"},FY.default.createElement(j,{flexDirection:"row",flexWrap:"nowrap",minWidth:_.length+(W?2:0)},W&&(O?FY.default.createElement(j,{minWidth:2},FY.default.createElement(z,{dimColor:O},YX)):FY.default.createElement(i31,{shouldAnimate:X,isUnresolved:!$,isError:Z.has(A.id)})),FY.default.createElement(j,{flexShrink:0},FY.default.createElement(z,{bold:!0,wrap:"truncate-end",backgroundColor:T,color:T?"inverseText":void 0},_)),x!==""&&FY.default.createElement(j,{flexWrap:"nowrap"},FY.default.createElement(z,null,"(",x,")")),C.name===n9&&L.success&&L.data.timeout&&(()=>{let b=L.data.timeout,v=_IA();if(b!==v)return FY.default.createElement(j,{flexWrap:"nowrap",marginLeft:1},FY.default.createElement(z,{dimColor:!0},"timeout: ",rK(b)));return null})(),C.name===V6&&L.success&&L.data.resume&&FY.default.createElement(j,{flexWrap:"nowrap",marginLeft:1},FY.default.createElement(z,{dimColor:!0},"resuming ",L.data.resume)),C.name===V6&&L.success&&L.data.model&&(()=>{let b=uI(L.data.model),v=c8();if(b!==v)return FY.default.createElement(j,{flexWrap:"nowrap",marginLeft:1},FY.default.createElement(z,{dimColor:!0},tD(b)));return null})(),C.name===CH&&L.success&&L.data.task_id&&FY.default.createElement(j,{flexWrap:"nowrap",marginLeft:1},FY.default.createElement(z,{dimColor:!0},L.data.task_id)),!1),!$&&!O&&(M?FY.default.createElement(h0,{height:1},FY.default.createElement(z,{dimColor:!0},"Waiting for permission‚Ä¶")):t25(C,B,V,A.id,I,{verbose:G,inProgressToolCallCount:K},E)),!$&&O&&e25(C)))}function s25(A,Q,{theme:B,verbose:G}){try{let Z=A.inputSchema.safeParse(Q);if(!Z.success)return"";return A.renderToolUseMessage(Z.data,{theme:B,verbose:G})}catch(Z){return r(Error(`Error rendering tool use message for ${A.name}: ${Z}`)),""}}function t25(A,Q,B,G,Z,{verbose:Y,inProgressToolCallCount:J},I){let X=Z.filter((W)=>W.data.type!=="hook_progress");try{let W=A.renderToolUseProgressMessage(X,{tools:Q,verbose:Y,terminalSize:I,inProgressToolCallCount:J??1});return FY.default.createElement(FY.default.Fragment,null,FY.default.createElement(L0A,null,FY.default.createElement(p31,{hookEvent:"PreToolUse",messages:B,toolUseID:G,verbose:Y})),W)}catch(W){return r(Error(`Error rendering tool use progress message for ${A.name}: ${W}`)),null}}function e25(A){try{return A.renderToolUseQueuedMessage?.()}catch(Q){return r(Error(`Error rendering tool use queued message for ${A.name}: ${Q}`)),null}}var FY;var pH2=q(()=>{hA();g1();V80();nx();y3();J_A();d2();W80();w31();f2();g4();Mi1();FY=o(KA(),1)});var nH2=w((iH2)=>{Object.defineProperty(iH2,"__esModule",{value:!0})});var oH2=w((aH2)=>{Object.defineProperty(aH2,"__esModule",{value:!0})});var E80=w((rH2)=>{Object.defineProperty(rH2,"__esModule",{value:!0})});var D80=w((Q95)=>{function A95(A,Q,B){Q.split&&(Q=Q.split("."));var G=0,Z=Q.length,Y=A,J,I;while(G<Z){if(I=""+Q[G++],I==="__proto__"||I==="constructor"||I==="prototype")break;Y=Y[I]=G===Z?B:typeof(J=Y[I])===typeof Q?J:Q[G]*0!==0||!!~(""+Q[G]).indexOf(".")?{}:[]}}Q95.dset=A95});var eH2=w((sH2)=>{Object.defineProperty(sH2,"__esModule",{value:!0});sH2.pickBy=void 0;var G95=function(A,Q){return Object.keys(A).filter(function(B){return Q(B,A[B])}).reduce(function(B,G){return B[G]=A[G],B},{})};sH2.pickBy=G95});var H80=w((AF2)=>{Object.defineProperty(AF2,"__esModule",{value:!0});AF2.ValidationError=void 0;var Z95=UG(),Y95=function(A){Z95.__extends(Q,A);function Q(B,G){var Z=A.call(this,"".concat(B," ").concat(G))||this;return Z.field=B,Z}return Q}(Error);AF2.ValidationError=Y95});var F80=w((BF2)=>{Object.defineProperty(BF2,"__esModule",{value:!0});BF2.isPlainObject=BF2.exists=BF2.isFunction=BF2.isNumber=BF2.isString=void 0;function J95(A){return typeof A==="string"}BF2.isString=J95;function I95(A){return typeof A==="number"}BF2.isNumber=I95;function X95(A){return typeof A==="function"}BF2.isFunction=X95;function W95(A){return A!==void 0&&A!==null}BF2.exists=W95;function K95(A){return Object.prototype.toString.call(A).slice(8,-1).toLowerCase()==="object"}BF2.isPlainObject=K95});var U80=w((VF2)=>{Object.defineProperty(VF2,"__esModule",{value:!0});VF2.validateEvent=VF2.assertTraits=VF2.assertTrackEventProperties=VF2.assertTrackEventName=VF2.assertEventType=VF2.assertEventExists=VF2.assertUserIdentity=void 0;var Dn=H80(),T0A=F80(),C80="is not a string",z80="is not an object",ZF2="is nil";function YF2(A){var Q=".userId/anonymousId/previousId/groupId",B=function(Z){var Y,J,I;return(I=(J=(Y=Z.userId)!==null&&Y!==void 0?Y:Z.anonymousId)!==null&&J!==void 0?J:Z.groupId)!==null&&I!==void 0?I:Z.previousId},G=B(A);if(!(0,T0A.exists)(G))throw new Dn.ValidationError(Q,ZF2);else if(!(0,T0A.isString)(G))throw new Dn.ValidationError(Q,C80)}VF2.assertUserIdentity=YF2;function JF2(A){if(!(0,T0A.exists)(A))throw new Dn.ValidationError("Event",ZF2);if(typeof A!=="object")throw new Dn.ValidationError("Event",z80)}VF2.assertEventExists=JF2;function IF2(A){if(!(0,T0A.isString)(A.type))throw new Dn.ValidationError(".type",C80)}VF2.assertEventType=IF2;function XF2(A){if(!(0,T0A.isString)(A.event))throw new Dn.ValidationError(".event",C80)}VF2.assertTrackEventName=XF2;function WF2(A){if(!(0,T0A.isPlainObject)(A.properties))throw new Dn.ValidationError(".properties",z80)}VF2.assertTrackEventProperties=WF2;function KF2(A){if(!(0,T0A.isPlainObject)(A.traits))throw new Dn.ValidationError(".traits",z80)}VF2.assertTraits=KF2;function F95(A){if(JF2(A),IF2(A),A.type==="track")XF2(A),WF2(A);if(["group","identify"].includes(A.type))KF2(A);YF2(A)}VF2.validateEvent=F95});var FF2=w(($80)=>{Object.defineProperty($80,"__esModule",{value:!0});$80.EventFactory=void 0;var a6=UG();a6.__exportStar(E80(),$80);var DF2=D80(),q95=eH2(),L95=U80(),M95=function(){function A(Q){this.user=Q.user,this.createMessageId=Q.createMessageId}return A.prototype.track=function(Q,B,G,Z){return this.normalize(a6.__assign(a6.__assign({},this.baseEvent()),{event:Q,type:"track",properties:B!==null&&B!==void 0?B:{},options:a6.__assign({},G),integrations:a6.__assign({},Z)}))},A.prototype.page=function(Q,B,G,Z,Y){var J,I={type:"page",properties:a6.__assign({},G),options:a6.__assign({},Z),integrations:a6.__assign({},Y)};if(Q!==null)I.category=Q,I.properties=(J=I.properties)!==null&&J!==void 0?J:{},I.properties.category=Q;if(B!==null)I.name=B;return this.normalize(a6.__assign(a6.__assign({},this.baseEvent()),I))},A.prototype.screen=function(Q,B,G,Z,Y){var J={type:"screen",properties:a6.__assign({},G),options:a6.__assign({},Z),integrations:a6.__assign({},Y)};if(Q!==null)J.category=Q;if(B!==null)J.name=B;return this.normalize(a6.__assign(a6.__assign({},this.baseEvent()),J))},A.prototype.identify=function(Q,B,G,Z){return this.normalize(a6.__assign(a6.__assign({},this.baseEvent()),{type:"identify",userId:Q,traits:B!==null&&B!==void 0?B:{},options:a6.__assign({},G),integrations:Z}))},A.prototype.group=function(Q,B,G,Z){return this.normalize(a6.__assign(a6.__assign({},this.baseEvent()),{type:"group",traits:B!==null&&B!==void 0?B:{},options:a6.__assign({},G),integrations:a6.__assign({},Z),groupId:Q}))},A.prototype.alias=function(Q,B,G,Z){var Y={userId:Q,type:"alias",options:a6.__assign({},G),integrations:a6.__assign({},Z)};if(B!==null)Y.previousId=B;if(Q===void 0)return this.normalize(a6.__assign(a6.__assign({},Y),this.baseEvent()));return this.normalize(a6.__assign(a6.__assign({},this.baseEvent()),Y))},A.prototype.baseEvent=function(){var Q={integrations:{},options:{}};if(!this.user)return Q;var B=this.user;if(B.id())Q.userId=B.id();if(B.anonymousId())Q.anonymousId=B.anonymousId();return Q},A.prototype.context=function(Q){var B,G=["userId","anonymousId","timestamp"];delete Q.integrations;var Z=Object.keys(Q),Y=(B=Q.context)!==null&&B!==void 0?B:{},J={};return Z.forEach(function(I){if(I==="context")return;if(G.includes(I))(0,DF2.dset)(J,I,Q[I]);else(0,DF2.dset)(Y,I,Q[I])}),[Y,J]},A.prototype.normalize=function(Q){var B,G,Z=Object.keys((B=Q.integrations)!==null&&B!==void 0?B:{}).reduce(function(D,H){var F,C;return a6.__assign(a6.__assign({},D),(F={},F[H]=Boolean((C=Q.integrations)===null||C===void 0?void 0:C[H]),F))},{});Q.options=(0,q95.pickBy)(Q.options||{},function(D,H){return H!==void 0});var Y=a6.__assign(a6.__assign({},Z),(G=Q.options)===null||G===void 0?void 0:G.integrations),J=Q.options?this.context(Q.options):[],I=J[0],X=J[1],W=Q.options,K=a6.__rest(Q,["options"]),V=a6.__assign(a6.__assign(a6.__assign({timestamp:new Date},K),{integrations:Y,context:I}),X),E=a6.__assign(a6.__assign({},V),{messageId:this.createMessageId()});return(0,L95.validateEvent)(E),E},A}();$80.EventFactory=M95});var w80=w((UF2)=>{Object.defineProperty(UF2,"__esModule",{value:!0});UF2.invokeCallback=UF2.sleep=UF2.pTimeout=void 0;function CF2(A,Q){return new Promise(function(B,G){var Z=setTimeout(function(){G(Error("Promise timed out"))},Q);A.then(function(Y){return clearTimeout(Z),B(Y)}).catch(G)})}UF2.pTimeout=CF2;function zF2(A){return new Promise(function(Q){return setTimeout(Q,A)})}UF2.sleep=zF2;function O95(A,Q,B){var G=function(){try{return Promise.resolve(Q(A))}catch(Z){return Promise.reject(Z)}};return zF2(B).then(function(){return CF2(G(),1000)}).catch(function(Z){A===null||A===void 0||A.log("warn","Callback Error",{error:Z}),A===null||A===void 0||A.stats.increment("callback_error")}).then(function(){return A})}UF2.invokeCallback=O95});var qF2=w((wF2)=>{Object.defineProperty(wF2,"__esModule",{value:!0});wF2.createDeferred=void 0;var T95=function(){var A,Q,B=new Promise(function(G,Z){A=G,Q=Z});return{resolve:A,reject:Q,promise:B}};wF2.createDeferred=T95});var LF2=w((N80)=>{Object.defineProperty(N80,"__esModule",{value:!0});var j95=UG();j95.__exportStar(qF2(),N80)});var RF2=w((MF2)=>{Object.defineProperty(MF2,"__esModule",{value:!0});MF2.Emitter=void 0;var P95=function(){function A(Q){var B;this.callbacks={},this.warned=!1,this.maxListeners=(B=Q===null||Q===void 0?void 0:Q.maxListeners)!==null&&B!==void 0?B:10}return A.prototype.warnIfPossibleMemoryLeak=function(Q){if(this.warned)return;if(this.maxListeners&&this.callbacks[Q].length>this.maxListeners)console.warn("Event Emitter: Possible memory leak detected; ".concat(String(Q)," has exceeded ").concat(this.maxListeners," listeners.")),this.warned=!0},A.prototype.on=function(Q,B){if(!this.callbacks[Q])this.callbacks[Q]=[B];else this.callbacks[Q].push(B),this.warnIfPossibleMemoryLeak(Q);return this},A.prototype.once=function(Q,B){var G=this,Z=function(){var Y=[];for(var J=0;J<arguments.length;J++)Y[J]=arguments[J];G.off(Q,Z),B.apply(G,Y)};return this.on(Q,Z),this},A.prototype.off=function(Q,B){var G,Z=(G=this.callbacks[Q])!==null&&G!==void 0?G:[],Y=Z.filter(function(J){return J!==B});return this.callbacks[Q]=Y,this},A.prototype.emit=function(Q){var B=this,G,Z=[];for(var Y=1;Y<arguments.length;Y++)Z[Y-1]=arguments[Y];var J=(G=this.callbacks[Q])!==null&&G!==void 0?G:[];return J.forEach(function(I){I.apply(B,Z)}),this},A}();MF2.Emitter=P95});var _F2=w((q80)=>{Object.defineProperty(q80,"__esModule",{value:!0});var S95=UG();S95.__exportStar(RF2(),q80)});var TIA=w((o31)=>{Object.defineProperty(o31,"__esModule",{value:!0});var TF2=UG();TF2.__exportStar(LF2(),o31);TF2.__exportStar(_F2(),o31)});var L80=w((jF2)=>{Object.defineProperty(jF2,"__esModule",{value:!0});jF2.backoff=void 0;function x95(A){var Q=Math.random()+1,B=A.minTimeout,G=B===void 0?500:B,Z=A.factor,Y=Z===void 0?2:Z,J=A.attempt,I=A.maxTimeout,X=I===void 0?1/0:I;return Math.min(Q*G*Math.pow(Y,J),X)}jF2.backoff=x95});var M80=w((SF2)=>{Object.defineProperty(SF2,"__esModule",{value:!0});SF2.PriorityQueue=SF2.ON_REMOVE_FROM_FUTURE=void 0;var y95=UG(),v95=TIA(),k95=L80();SF2.ON_REMOVE_FROM_FUTURE="onRemoveFromFuture";var f95=function(A){y95.__extends(Q,A);function Q(B,G,Z){var Y=A.call(this)||this;return Y.future=[],Y.maxAttempts=B,Y.queue=G,Y.seen=Z!==null&&Z!==void 0?Z:{},Y}return Q.prototype.push=function(){var B=this,G=[];for(var Z=0;Z<arguments.length;Z++)G[Z]=arguments[Z];var Y=G.map(function(J){var I=B.updateAttempts(J);if(I>B.maxAttempts||B.includes(J))return!1;return B.queue.push(J),!0});return this.queue=this.queue.sort(function(J,I){return B.getAttempts(J)-B.getAttempts(I)}),Y},Q.prototype.pushWithBackoff=function(B){var G=this;if(this.getAttempts(B)===0)return this.push(B)[0];var Z=this.updateAttempts(B);if(Z>this.maxAttempts||this.includes(B))return!1;var Y=(0,k95.backoff)({attempt:Z-1});return setTimeout(function(){G.queue.push(B),G.future=G.future.filter(function(J){return J.id!==B.id}),G.emit(SF2.ON_REMOVE_FROM_FUTURE)},Y),this.future.push(B),!0},Q.prototype.getAttempts=function(B){var G;return(G=this.seen[B.id])!==null&&G!==void 0?G:0},Q.prototype.updateAttempts=function(B){return this.seen[B.id]=this.getAttempts(B)+1,this.getAttempts(B)},Q.prototype.includes=function(B){return this.queue.includes(B)||this.future.includes(B)||Boolean(this.queue.find(function(G){return G.id===B.id}))||Boolean(this.future.find(function(G){return G.id===B.id}))},Q.prototype.pop=function(){return this.queue.shift()},Object.defineProperty(Q.prototype,"length",{get:function(){return this.queue.length},enumerable:!1,configurable:!0}),Object.defineProperty(Q.prototype,"todo",{get:function(){return this.queue.length+this.future.length},enumerable:!1,configurable:!0}),Q}(v95.Emitter);SF2.PriorityQueue=f95});var O80=w((h95)=>{var j0A=256,s31=[],r31;while(j0A--)s31[j0A]=(j0A+256).toString(16).substring(1);function b95(){var A=0,Q,B="";if(!r31||j0A+16>256){r31=Array(A=256);while(A--)r31[A]=256*Math.random()|0;A=j0A=0}for(;A<16;A++){if(Q=r31[j0A+A],A==6)B+=s31[Q&15|64];else if(A==8)B+=s31[Q&63|128];else B+=s31[Q];if(A&1&&A>1&&A<11)B+="-"}return j0A++,B}h95.v4=b95});var R80=w((vF2)=>{Object.defineProperty(vF2,"__esModule",{value:!0});vF2.CoreLogger=void 0;var t31=UG(),u95=function(){function A(){this._logs=[]}return A.prototype.log=function(Q,B,G){var Z=new Date;this._logs.push({level:Q,message:B,time:Z,extras:G})},Object.defineProperty(A.prototype,"logs",{get:function(){return this._logs},enumerable:!1,configurable:!0}),A.prototype.flush=function(){if(this.logs.length>1){var Q=this._logs.reduce(function(B,G){var Z,Y,J,I=t31.__assign(t31.__assign({},G),{json:JSON.stringify(G.extras,null," "),extras:G.extras});delete I.time;var X=(J=(Y=G.time)===null||Y===void 0?void 0:Y.toISOString())!==null&&J!==void 0?J:"";if(B[X])X="".concat(X,"-").concat(Math.random());return t31.__assign(t31.__assign({},B),(Z={},Z[X]=I,Z))},{});if(console.table)console.table(Q);else console.log(Q)}else this.logs.forEach(function(B){var{level:G,message:Z,extras:Y}=B;if(G==="info"||G==="debug")console.log(Z,Y!==null&&Y!==void 0?Y:"");else console[G](Z,Y!==null&&Y!==void 0?Y:"")});this._logs=[]},A}();vF2.CoreLogger=u95});var T80=w((bF2)=>{Object.defineProperty(bF2,"__esModule",{value:!0});bF2.NullStats=bF2.CoreStats=void 0;var _80=UG(),m95=function(A){var Q={gauge:"g",counter:"c"};return Q[A]},fF2=function(){function A(){this.metrics=[]}return A.prototype.increment=function(Q,B,G){if(B===void 0)B=1;this.metrics.push({metric:Q,value:B,tags:G!==null&&G!==void 0?G:[],type:"counter",timestamp:Date.now()})},A.prototype.gauge=function(Q,B,G){this.metrics.push({metric:Q,value:B,tags:G!==null&&G!==void 0?G:[],type:"gauge",timestamp:Date.now()})},A.prototype.flush=function(){var Q=this.metrics.map(function(B){return _80.__assign(_80.__assign({},B),{tags:B.tags.join(",")})});if(console.table)console.table(Q);else console.log(Q);this.metrics=[]},A.prototype.serialize=function(){return this.metrics.map(function(Q){return{m:Q.metric,v:Q.value,t:Q.tags,k:m95(Q.type),e:Q.timestamp}})},A}();bF2.CoreStats=fF2;var d95=function(A){_80.__extends(Q,A);function Q(){return A!==null&&A.apply(this,arguments)||this}return Q.prototype.gauge=function(){var B=[];for(var G=0;G<arguments.length;G++)B[G]=arguments[G]},Q.prototype.increment=function(){var B=[];for(var G=0;G<arguments.length;G++)B[G]=arguments[G]},Q.prototype.flush=function(){var B=[];for(var G=0;G<arguments.length;G++)B[G]=arguments[G]},Q.prototype.serialize=function(){var B=[];for(var G=0;G<arguments.length;G++)B[G]=arguments[G];return[]},Q}(fF2);bF2.NullStats=d95});var e31=w((uF2)=>{Object.defineProperty(uF2,"__esModule",{value:!0});uF2.CoreContext=uF2.ContextCancelation=void 0;var p95=O80(),l95=D80(),i95=R80(),n95=T80(),gF2=function(){function A(Q){var B,G,Z;this.retry=(B=Q.retry)!==null&&B!==void 0?B:!0,this.type=(G=Q.type)!==null&&G!==void 0?G:"plugin Error",this.reason=(Z=Q.reason)!==null&&Z!==void 0?Z:""}return A}();uF2.ContextCancelation=gF2;var a95=function(){function A(Q,B,G,Z){if(B===void 0)B=(0,p95.v4)();if(G===void 0)G=new n95.NullStats;if(Z===void 0)Z=new i95.CoreLogger;this.attempts=0,this.event=Q,this._id=B,this.logger=Z,this.stats=G}return A.system=function(){},A.prototype.isSame=function(Q){return Q.id===this.id},A.prototype.cancel=function(Q){if(Q)throw Q;throw new gF2({reason:"Context Cancel"})},A.prototype.log=function(Q,B,G){this.logger.log(Q,B,G)},Object.defineProperty(A.prototype,"id",{get:function(){return this._id},enumerable:!1,configurable:!0}),A.prototype.updateEvent=function(Q,B){var G;if(Q.split(".")[0]==="integrations"){var Z=Q.split(".")[1];if(((G=this.event.integrations)===null||G===void 0?void 0:G[Z])===!1)return this.event}return(0,l95.dset)(this.event,Q,B),this.event},A.prototype.failedDelivery=function(){return this._failedDelivery},A.prototype.setFailedDelivery=function(Q){this._failedDelivery=Q},A.prototype.logs=function(){return this.logger.logs},A.prototype.flush=function(){this.logger.flush(),this.stats.flush()},A.prototype.toJSON=function(){return{id:this._id,event:this.event,logs:this.logger.logs,metrics:this.stats.metrics}},A}();uF2.CoreContext=a95});var lF2=w((cF2)=>{Object.defineProperty(cF2,"__esModule",{value:!0});cF2.groupBy=void 0;var dF2=UG();function r95(A,Q){var B={};return A.forEach(function(G){var Z,Y=void 0;if(typeof Q==="string"){var J=G[Q];Y=typeof J!=="string"?JSON.stringify(J):J}else if(Q instanceof Function)Y=Q(G);if(Y===void 0)return;B[Y]=dF2.__spreadArray(dF2.__spreadArray([],(Z=B[Y])!==null&&Z!==void 0?Z:[],!0),[G],!1)}),B}cF2.groupBy=r95});var aF2=w((iF2)=>{Object.defineProperty(iF2,"__esModule",{value:!0});iF2.isThenable=void 0;var s95=function(A){return typeof A==="object"&&A!==null&&"then"in A&&typeof A.then==="function"};iF2.isThenable=s95});var sF2=w((oF2)=>{Object.defineProperty(oF2,"__esModule",{value:!0});oF2.createTaskGroup=void 0;var t95=aF2(),e95=function(){var A,Q,B=0;return{done:function(){return A},run:function(G){var Z=G();if((0,t95.isThenable)(Z)){if(++B===1)A=new Promise(function(Y){return Q=Y});Z.finally(function(){return--B===0&&Q()})}return Z}}};oF2.createTaskGroup=e95});var P80=w((AC2)=>{Object.defineProperty(AC2,"__esModule",{value:!0});AC2.ensure=AC2.attempt=void 0;var tF2=UG(),j80=e31();function A45(A){return tF2.__awaiter(this,void 0,void 0,function(){var Q;return tF2.__generator(this,function(B){switch(B.label){case 0:return B.trys.push([0,2,,3]),[4,A()];case 1:return[2,B.sent()];case 2:return Q=B.sent(),[2,Promise.reject(Q)];case 3:return[2]}})})}function eF2(A,Q){A.log("debug","plugin",{plugin:Q.name});var B=new Date().getTime(),G=Q[A.event.type];if(G===void 0)return Promise.resolve(A);var Z=A45(function(){return G.apply(Q,[A])}).then(function(Y){var J=new Date().getTime()-B;return Y.stats.gauge("plugin_time",J,["plugin:".concat(Q.name)]),Y}).catch(function(Y){if(Y instanceof j80.ContextCancelation&&Y.type==="middleware_cancellation")throw Y;if(Y instanceof j80.ContextCancelation)return A.log("warn",Y.type,{plugin:Q.name,error:Y}),Y;return A.log("error","plugin Error",{plugin:Q.name,error:Y}),A.stats.increment("plugin_error",1,["plugin:".concat(Q.name)]),Y});return Z}AC2.attempt=eF2;function Q45(A,Q){return eF2(A,Q).then(function(B){if(B instanceof j80.CoreContext)return B;A.log("debug","Context canceled"),A.stats.increment("context_canceled"),A.cancel(B)})}AC2.ensure=Q45});var ZC2=w((BC2)=>{Object.defineProperty(BC2,"__esModule",{value:!0});BC2.CoreEventQueue=void 0;var XD=UG(),G45=lF2(),Z45=M80(),S80=e31(),Y45=TIA(),J45=sF2(),A61=P80(),I45=function(A){XD.__extends(Q,A);function Q(B){var G=A.call(this)||this;return G.criticalTasks=(0,J45.createTaskGroup)(),G.plugins=[],G.failedInitializations=[],G.flushing=!1,G.queue=B,G.queue.on(Z45.ON_REMOVE_FROM_FUTURE,function(){G.scheduleFlush(0)}),G}return Q.prototype.register=function(B,G,Z){return XD.__awaiter(this,void 0,void 0,function(){var Y=this;return XD.__generator(this,function(J){switch(J.label){case 0:return[4,Promise.resolve(G.load(B,Z)).then(function(){Y.plugins.push(G)}).catch(function(I){if(G.type==="destination"){Y.failedInitializations.push(G.name),console.warn(G.name,I),B.log("warn","Failed to load destination",{plugin:G.name,error:I});return}throw I})];case 1:return J.sent(),[2]}})})},Q.prototype.deregister=function(B,G,Z){return XD.__awaiter(this,void 0,void 0,function(){var Y;return XD.__generator(this,function(J){switch(J.label){case 0:if(J.trys.push([0,3,,4]),!G.unload)return[3,2];return[4,Promise.resolve(G.unload(B,Z))];case 1:J.sent(),J.label=2;case 2:return this.plugins=this.plugins.filter(function(I){return I.name!==G.name}),[3,4];case 3:return Y=J.sent(),B.log("warn","Failed to unload destination",{plugin:G.name,error:Y}),[3,4];case 4:return[2]}})})},Q.prototype.dispatch=function(B){return XD.__awaiter(this,void 0,void 0,function(){var G;return XD.__generator(this,function(Z){return B.log("debug","Dispatching"),B.stats.increment("message_dispatched"),this.queue.push(B),G=this.subscribeToDelivery(B),this.scheduleFlush(0),[2,G]})})},Q.prototype.subscribeToDelivery=function(B){return XD.__awaiter(this,void 0,void 0,function(){var G=this;return XD.__generator(this,function(Z){return[2,new Promise(function(Y){var J=function(I,X){if(I.isSame(B))if(G.off("flush",J),X)Y(I);else Y(I)};G.on("flush",J)})]})})},Q.prototype.dispatchSingle=function(B){return XD.__awaiter(this,void 0,void 0,function(){var G=this;return XD.__generator(this,function(Z){return B.log("debug","Dispatching"),B.stats.increment("message_dispatched"),this.queue.updateAttempts(B),B.attempts=1,[2,this.deliver(B).catch(function(Y){var J=G.enqueuRetry(Y,B);if(!J)return B.setFailedDelivery({reason:Y}),B;return G.subscribeToDelivery(B)})]})})},Q.prototype.isEmpty=function(){return this.queue.length===0},Q.prototype.scheduleFlush=function(B){var G=this;if(B===void 0)B=500;if(this.flushing)return;this.flushing=!0,setTimeout(function(){G.flush().then(function(){setTimeout(function(){if(G.flushing=!1,G.queue.length)G.scheduleFlush(0)},0)})},B)},Q.prototype.deliver=function(B){return XD.__awaiter(this,void 0,void 0,function(){var G,Z,Y,J;return XD.__generator(this,function(I){switch(I.label){case 0:return[4,this.criticalTasks.done()];case 1:I.sent(),G=Date.now(),I.label=2;case 2:return I.trys.push([2,4,,5]),[4,this.flushOne(B)];case 3:return B=I.sent(),Z=Date.now()-G,this.emit("delivery_success",B),B.stats.gauge("delivered",Z),B.log("debug","Delivered",B.event),[2,B];case 4:throw Y=I.sent(),J=Y,B.log("error","Failed to deliver",J),this.emit("delivery_failure",B,J),B.stats.increment("delivery_failed"),Y;case 5:return[2]}})})},Q.prototype.enqueuRetry=function(B,G){var Z=!(B instanceof S80.ContextCancelation)||B.retry;if(!Z)return!1;return this.queue.pushWithBackoff(G)},Q.prototype.flush=function(){return XD.__awaiter(this,void 0,void 0,function(){var B,G,Z;return XD.__generator(this,function(Y){switch(Y.label){case 0:if(this.queue.length===0)return[2,[]];if(B=this.queue.pop(),!B)return[2,[]];B.attempts=this.queue.getAttempts(B),Y.label=1;case 1:return Y.trys.push([1,3,,4]),[4,this.deliver(B)];case 2:return B=Y.sent(),this.emit("flush",B,!0),[3,4];case 3:if(G=Y.sent(),Z=this.enqueuRetry(G,B),!Z)B.setFailedDelivery({reason:G}),this.emit("flush",B,!1);return[2,[]];case 4:return[2,[B]]}})})},Q.prototype.isReady=function(){return!0},Q.prototype.availableExtensions=function(B){var G=this.plugins.filter(function(D){var H,F,C;if(D.type!=="destination"&&D.name!=="Segment.io")return!0;var $=void 0;return(H=D.alternativeNames)===null||H===void 0||H.forEach(function(O){if(B[O]!==void 0)$=B[O]}),(C=(F=B[D.name])!==null&&F!==void 0?F:$)!==null&&C!==void 0?C:(D.name==="Segment.io"?!0:B.All)!==!1}),Z=(0,G45.groupBy)(G,"type"),Y=Z.before,J=Y===void 0?[]:Y,I=Z.enrichment,X=I===void 0?[]:I,W=Z.destination,K=W===void 0?[]:W,V=Z.after,E=V===void 0?[]:V;return{before:J,enrichment:X,destinations:K,after:E}},Q.prototype.flushOne=function(B){var G,Z;return XD.__awaiter(this,void 0,void 0,function(){var Y,J,I,X,W,K,H,V,E,D,H,F,C,$,O;return XD.__generator(this,function(M){switch(M.label){case 0:if(!this.isReady())throw Error("Not ready");if(B.attempts>1)this.emit("delivery_retry",B);Y=this.availableExtensions((G=B.event.integrations)!==null&&G!==void 0?G:{}),J=Y.before,I=Y.enrichment,X=0,W=J,M.label=1;case 1:if(!(X<W.length))return[3,4];return K=W[X],[4,(0,A61.ensure)(B,K)];case 2:if(H=M.sent(),H instanceof S80.CoreContext)B=H;this.emit("message_enriched",B,K),M.label=3;case 3:return X++,[3,1];case 4:V=0,E=I,M.label=5;case 5:if(!(V<E.length))return[3,8];return D=E[V],[4,(0,A61.attempt)(B,D)];case 6:if(H=M.sent(),H instanceof S80.CoreContext)B=H;this.emit("message_enriched",B,D),M.label=7;case 7:return V++,[3,5];case 8:return F=this.availableExtensions((Z=B.event.integrations)!==null&&Z!==void 0?Z:{}),C=F.destinations,$=F.after,[4,new Promise(function(L,_){setTimeout(function(){var T=C.map(function(x){return(0,A61.attempt)(B,x)});Promise.all(T).then(L).catch(_)},0)})];case 9:return M.sent(),B.stats.increment("message_delivered"),this.emit("message_delivered",B),O=$.map(function(L){return(0,A61.attempt)(B,L)}),[4,Promise.all(O)];case 10:return M.sent(),[2,B]}})})},Q}(Y45.Emitter);BC2.CoreEventQueue=I45});var JC2=w((YC2)=>{Object.defineProperty(YC2,"__esModule",{value:!0})});var VC2=w((XC2)=>{Object.defineProperty(XC2,"__esModule",{value:!0});XC2.dispatch=XC2.getDelay=void 0;var IC2=UG(),X45=w80(),W45=function(A,Q){var B=Date.now()-A;return Math.max((Q!==null&&Q!==void 0?Q:300)-B,0)};XC2.getDelay=W45;function K45(A,Q,B,G){return IC2.__awaiter(this,void 0,void 0,function(){var Z,Y;return IC2.__generator(this,function(J){switch(J.label){case 0:if(B.emit("dispatch_start",A),Z=Date.now(),!Q.isEmpty())return[3,2];return[4,Q.dispatchSingle(A)];case 1:return Y=J.sent(),[3,4];case 2:return[4,Q.dispatch(A)];case 3:Y=J.sent(),J.label=4;case 4:if(!(G===null||G===void 0?void 0:G.callback))return[3,6];return[4,(0,X45.invokeCallback)(Y,G.callback,XC2.getDelay(Z,G.timeout))];case 5:Y=J.sent(),J.label=6;case 6:if(G===null||G===void 0?void 0:G.debug)Y.flush();return[2,Y]}})})}XC2.dispatch=K45});var HC2=w((EC2)=>{Object.defineProperty(EC2,"__esModule",{value:!0});EC2.bindAll=void 0;function V45(A){var Q=A.constructor.prototype;for(var B=0,G=Object.getOwnPropertyNames(Q);B<G.length;B++){var Z=G[B];if(Z!=="constructor"){var Y=Object.getOwnPropertyDescriptor(A.constructor.prototype,Z);if(!!Y&&typeof Y.value==="function")A[Z]=A[Z].bind(A)}}return A}EC2.bindAll=V45});var Hn=w((zW)=>{Object.defineProperty(zW,"__esModule",{value:!0});zW.CoreLogger=zW.backoff=void 0;var bH=UG();bH.__exportStar(nH2(),zW);bH.__exportStar(oH2(),zW);bH.__exportStar(E80(),zW);bH.__exportStar(FF2(),zW);bH.__exportStar(w80(),zW);bH.__exportStar(M80(),zW);var E45=L80();Object.defineProperty(zW,"backoff",{enumerable:!0,get:function(){return E45.backoff}});bH.__exportStar(e31(),zW);bH.__exportStar(ZC2(),zW);bH.__exportStar(JC2(),zW);bH.__exportStar(VC2(),zW);bH.__exportStar(F80(),zW);bH.__exportStar(H80(),zW);bH.__exportStar(U80(),zW);bH.__exportStar(HC2(),zW);bH.__exportStar(T80(),zW);var D45=R80();Object.defineProperty(zW,"CoreLogger",{enumerable:!0,get:function(){return D45.CoreLogger}});bH.__exportStar(P80(),zW)});var zC2=w((FC2)=>{Object.defineProperty(FC2,"__esModule",{value:!0});FC2.validateSettings=void 0;var F45=Hn(),C45=(A)=>{if(!A.writeKey)throw new F45.ValidationError("writeKey","writeKey is missing.")};FC2.validateSettings=C45});var x80=w((UC2)=>{Object.defineProperty(UC2,"__esModule",{value:!0});UC2.version=void 0;UC2.version="1.3.0"});var qC2=w((wC2)=>{Object.defineProperty(wC2,"__esModule",{value:!0});wC2.tryCreateFormattedUrl=void 0;var z45=(A)=>A.replace(/\/$/,""),U45=(A,Q)=>{return z45(new URL(Q||"",A).href)};wC2.tryCreateFormattedUrl=U45});var v80=w((y80)=>{Object.defineProperty(y80,"__esModule",{value:!0});y80.uuid=void 0;var $45=O80();Object.defineProperty(y80,"uuid",{enumerable:!0,get:function(){return $45.v4}})});var TC2=w((RC2)=>{Object.defineProperty(RC2,"__esModule",{value:!0});RC2.ContextBatch=void 0;var N45=v80(),LC2=32,MC2=480;class OC2{constructor(A){this.id=(0,N45.uuid)(),this.items=[],this.sizeInBytes=0,this.maxEventCount=Math.max(1,A)}tryAdd(A){if(this.length===this.maxEventCount)return{success:!1,message:`Event limit of ${this.maxEventCount} has been exceeded.`};let Q=this.calculateSize(A.context);if(Q>LC2*1024)return{success:!1,message:`Event exceeds maximum event size of ${LC2} KB`};if(this.sizeInBytes+Q>MC2*1024)return{success:!1,message:`Event has caused batch size to exceed ${MC2} KB`};return this.items.push(A),this.sizeInBytes+=Q,{success:!0}}get length(){return this.items.length}calculateSize(A){return encodeURI(JSON.stringify(A.event)).split(/%..|i/).length}getEvents(){return this.items.map(({context:Q})=>Q.event)}getContexts(){return this.items.map((A)=>A.context)}resolveEvents(){this.items.forEach(({resolver:A,context:Q})=>A(Q))}}RC2.ContextBatch=OC2});var SC2=w((jC2)=>{Object.defineProperty(jC2,"__esModule",{value:!0});jC2.b64encode=void 0;var q45=qA("buffer"),L45=(A)=>{return q45.Buffer.from(A).toString("base64")};jC2.b64encode=L45});var fC2=w((vC2)=>{Object.defineProperty(vC2,"__esModule",{value:!0});vC2.Publisher=void 0;var M45=Hn(),O45=qC2(),R45=TIA(),_45=TC2(),T45=SC2();function j45(A){return new Promise((Q)=>setTimeout(Q,A))}function I_A(){}class yC2{constructor({host:A,path:Q,maxRetries:B,flushAt:G,flushInterval:Z,writeKey:Y,httpRequestTimeout:J,httpClient:I,disable:X},W){this._emitter=W,this._maxRetries=B,this._flushAt=Math.max(G,1),this._flushInterval=Z,this._auth=(0,T45.b64encode)(`${Y}:`),this._url=(0,O45.tryCreateFormattedUrl)(A??"https://api.segment.io",Q??"/v1/batch"),this._httpRequestTimeout=J??1e4,this._disable=Boolean(X),this._httpClient=I}createBatch(){this.pendingFlushTimeout&&clearTimeout(this.pendingFlushTimeout);let A=new _45.ContextBatch(this._flushAt);return this._batch=A,this.pendingFlushTimeout=setTimeout(()=>{if(A===this._batch)this._batch=void 0;if(this.pendingFlushTimeout=void 0,A.length)this.send(A).catch(I_A)},this._flushInterval),A}clearBatch(){this.pendingFlushTimeout&&clearTimeout(this.pendingFlushTimeout),this._batch=void 0}flush(A){if(!A)return;if(this._flushPendingItemsCount=A,!this._batch)return;if(this._batch.length===A)this.send(this._batch).catch(I_A),this.clearBatch()}enqueue(A){let Q=this._batch??this.createBatch(),{promise:B,resolve:G}=(0,R45.createDeferred)(),Z={context:A,resolver:G};if(Q.tryAdd(Z).success){let X=Q.length===this._flushPendingItemsCount;if(Q.length===this._flushAt||X)this.send(Q).catch(I_A),this.clearBatch();return B}if(Q.length)this.send(Q).catch(I_A),this.clearBatch();let J=this.createBatch(),I=J.tryAdd(Z);if(I.success){if(J.length===this._flushPendingItemsCount)this.send(J).catch(I_A),this.clearBatch();return B}else return A.setFailedDelivery({reason:Error(I.message)}),Promise.resolve(A)}async send(A){if(this._flushPendingItemsCount)this._flushPendingItemsCount-=A.length;let Q=A.getEvents(),B=this._maxRetries+1,G=0;while(G<B){G++;let Z;try{if(this._disable)return A.resolveEvents();let Y={url:this._url,method:"POST",headers:{"Content-Type":"application/json",Authorization:`Basic ${this._auth}`,"User-Agent":"analytics-node-next/latest"},data:{batch:Q,sentAt:new Date},httpRequestTimeout:this._httpRequestTimeout};this._emitter.emit("http_request",{body:Y.data,method:Y.method,url:Y.url,headers:Y.headers});let J=await this._httpClient.makeRequest(Y);if(J.status>=200&&J.status<300){A.resolveEvents();return}else if(J.status===400){xC2(A,Error(`[${J.status}] ${J.statusText}`));return}else Z=Error(`[${J.status}] ${J.statusText}`)}catch(Y){Z=Y}if(G===B){xC2(A,Z);return}await j45((0,M45.backoff)({attempt:G,minTimeout:25,maxTimeout:1000}))}}}vC2.Publisher=yC2;function xC2(A,Q){A.getContexts().forEach((B)=>B.setFailedDelivery({reason:Q})),A.resolveEvents()}});var k80=w((bC2)=>{Object.defineProperty(bC2,"__esModule",{value:!0});bC2.detectRuntime=void 0;var P45=()=>{if(typeof process==="object"&&process&&typeof process.env==="object"&&process.env&&typeof process.version==="string")return"node";if(typeof window==="object")return"browser";if(typeof WebSocketPair<"u")return"cloudflare-worker";if(typeof EdgeRuntime==="string")return"vercel-edge";if(typeof WorkerGlobalScope<"u"&&typeof importScripts==="function")return"web-worker";return"unknown"};bC2.detectRuntime=P45});var dC2=w((uC2)=>{Object.defineProperty(uC2,"__esModule",{value:!0});uC2.createConfiguredNodePlugin=uC2.createNodePlugin=void 0;var S45=fC2(),x45=x80(),y45=k80();function v45(A){A.updateEvent("context.library.name","@segment/analytics-node"),A.updateEvent("context.library.version",x45.version);let Q=(0,y45.detectRuntime)();if(Q==="node")A.updateEvent("_metadata.nodeVersion",process.version);A.updateEvent("_metadata.jsRuntime",Q)}function gC2(A){function Q(B){return v45(B),A.enqueue(B)}return{name:"Segment.io",type:"destination",version:"1.0.0",isLoaded:()=>!0,load:()=>Promise.resolve(),alias:Q,group:Q,identify:Q,page:Q,screen:Q,track:Q}}uC2.createNodePlugin=gC2;var k45=(A,Q)=>{let B=new S45.Publisher(A,Q);return{publisher:B,plugin:gC2(B)}};uC2.createConfiguredNodePlugin=k45});var lC2=w((cC2)=>{Object.defineProperty(cC2,"__esModule",{value:!0});cC2.createMessageId=void 0;var b45=v80(),h45=()=>{return`node-next-${Date.now()}-${(0,b45.uuid)()}`};cC2.createMessageId=h45});var oC2=w((nC2)=>{Object.defineProperty(nC2,"__esModule",{value:!0});nC2.NodeEventFactory=void 0;var g45=Hn(),u45=lC2();class iC2 extends g45.EventFactory{constructor(){super({createMessageId:u45.createMessageId})}}nC2.NodeEventFactory=iC2});var Q61=w((sC2)=>{Object.defineProperty(sC2,"__esModule",{value:!0});sC2.Context=void 0;var m45=Hn();class rC2 extends m45.CoreContext{static system(){return new this({type:"track",event:"system"})}}sC2.Context=rC2});var Qz2=w((eC2)=>{Object.defineProperty(eC2,"__esModule",{value:!0});eC2.dispatchAndEmit=void 0;var d45=Hn(),c45=Q61(),p45=(A)=>(Q)=>{let B=Q.failedDelivery();return B?A(B.reason,Q):A(void 0,Q)},l45=async(A,Q,B,G)=>{try{let Z=new c45.Context(A),Y=await(0,d45.dispatch)(Z,Q,B,{...G?{callback:p45(G)}:{}}),J=Y.failedDelivery();if(J)B.emit("error",{code:"delivery_failure",reason:J.reason,ctx:Y});else B.emit(A.type,Y)}catch(Z){B.emit("error",{code:"unknown",reason:Z})}};eC2.dispatchAndEmit=l45});var Yz2=w((Gz2)=>{Object.defineProperty(Gz2,"__esModule",{value:!0});Gz2.NodeEmitter=void 0;var i45=TIA();class Bz2 extends i45.Emitter{}Gz2.NodeEmitter=Bz2});var Vz2=w((Wz2)=>{Object.defineProperty(Wz2,"__esModule",{value:!0});Wz2.NodeEventQueue=void 0;var Jz2=Hn();class Iz2 extends Jz2.PriorityQueue{constructor(){super(1,[])}getAttempts(A){return A.attempts??0}updateAttempts(A){return A.attempts=this.getAttempts(A)+1,this.getAttempts(A)}}class Xz2 extends Jz2.CoreEventQueue{constructor(){super(new Iz2)}}Wz2.NodeEventQueue=Xz2});var Fz2=w((Dz2)=>{Object.defineProperty(Dz2,"__esModule",{value:!0});Dz2.abortSignalAfterTimeout=Dz2.AbortSignal=void 0;var n45=TIA(),a45=k80();class f80{constructor(){this.onabort=null,this.aborted=!1,this.eventEmitter=new n45.Emitter}toString(){return"[object AbortSignal]"}get[Symbol.toStringTag](){return"AbortSignal"}removeEventListener(...A){this.eventEmitter.off(...A)}addEventListener(...A){this.eventEmitter.on(...A)}dispatchEvent(A){let Q={type:A,target:this},B=`on${A}`;if(typeof this[B]==="function")this[B](Q);this.eventEmitter.emit(A,Q)}}Dz2.AbortSignal=f80;class Ez2{constructor(){this.signal=new f80}abort(){if(this.signal.aborted)return;this.signal.aborted=!0,this.signal.dispatchEvent("abort")}toString(){return"[object AbortController]"}get[Symbol.toStringTag](){return"AbortController"}}var o45=(A)=>{if((0,a45.detectRuntime)()==="cloudflare-worker")return[];let Q=new(globalThis.AbortController||Ez2),B=setTimeout(()=>{Q.abort()},A);return B?.unref?.(),[Q.signal,B]};Dz2.abortSignalAfterTimeout=o45});var Cz2=w((ky)=>{var s45=ky&&ky.__createBinding||(Object.create?function(A,Q,B,G){if(G===void 0)G=B;var Z=Object.getOwnPropertyDescriptor(Q,B);if(!Z||("get"in Z?!Q.__esModule:Z.writable||Z.configurable))Z={enumerable:!0,get:function(){return Q[B]}};Object.defineProperty(A,G,Z)}:function(A,Q,B,G){if(G===void 0)G=B;A[G]=Q[B]}),t45=ky&&ky.__setModuleDefault||(Object.create?function(A,Q){Object.defineProperty(A,"default",{enumerable:!0,value:Q})}:function(A,Q){A.default=Q}),e45=ky&&ky.__importStar||function(A){if(A&&A.__esModule)return A;var Q={};if(A!=null){for(var B in A)if(B!=="default"&&Object.prototype.hasOwnProperty.call(A,B))s45(Q,A,B)}return t45(Q,A),Q};Object.defineProperty(ky,"__esModule",{value:!0});ky.fetch=void 0;var A35=async(...A)=>{if(globalThis.fetch)return globalThis.fetch(...A);else if(typeof EdgeRuntime!=="string")return(await Promise.resolve().then(()=>e45(Bf1()))).default(...A);else throw Error("Invariant: an edge runtime that does not support fetch should not exist")};ky.fetch=A35});var b80=w((Uz2)=>{Object.defineProperty(Uz2,"__esModule",{value:!0});Uz2.FetchHTTPClient=void 0;var Q35=Fz2(),B35=Cz2();class zz2{constructor(A){this._fetch=A??B35.fetch}async makeRequest(A){let[Q,B]=(0,Q35.abortSignalAfterTimeout)(A.httpRequestTimeout),G={url:A.url,method:A.method,headers:A.headers,body:JSON.stringify(A.data),signal:Q};return this._fetch(A.url,G).finally(()=>clearTimeout(B))}}Uz2.FetchHTTPClient=zz2});var h80=w((Mz2)=>{Object.defineProperty(Mz2,"__esModule",{value:!0});Mz2.Analytics=void 0;var wz2=Hn(),G35=zC2(),Z35=x80(),Y35=dC2(),J35=oC2(),I35=Qz2(),X35=Yz2(),Nz2=Q61(),W35=Vz2(),qz2=b80();class Lz2 extends X35.NodeEmitter{constructor(A){super();this._isClosed=!1,this._pendingEvents=0,this._isFlushing=!1,(0,G35.validateSettings)(A),this._eventFactory=new J35.NodeEventFactory,this._queue=new W35.NodeEventQueue;let Q=A.flushInterval??1e4;this._closeAndFlushDefaultTimeout=Q*1.25;let{plugin:B,publisher:G}=(0,Y35.createConfiguredNodePlugin)({writeKey:A.writeKey,host:A.host,path:A.path,maxRetries:A.maxRetries??3,flushAt:A.flushAt??A.maxEventsInBatch??15,httpRequestTimeout:A.httpRequestTimeout,disable:A.disable,flushInterval:Q,httpClient:typeof A.httpClient==="function"?new qz2.FetchHTTPClient(A.httpClient):A.httpClient??new qz2.FetchHTTPClient},this);this._publisher=G,this.ready=this.register(B).then(()=>{return}),this.emit("initialize",A),(0,wz2.bindAll)(this)}get VERSION(){return Z35.version}closeAndFlush({timeout:A=this._closeAndFlushDefaultTimeout}={}){return this.flush({timeout:A,close:!0})}async flush({timeout:A,close:Q=!1}={}){if(this._isFlushing){console.warn("Overlapping flush calls detected. Please wait for the previous flush to finish before calling .flush again");return}else this._isFlushing=!0;if(Q)this._isClosed=!0;this._publisher.flush(this._pendingEvents);let B=new Promise((G)=>{if(!this._pendingEvents)G();else this.once("drained",()=>{G()})}).finally(()=>{this._isFlushing=!1});return A?(0,wz2.pTimeout)(B,A).catch(()=>{return}):B}_dispatch(A,Q){if(this._isClosed){this.emit("call_after_close",A);return}this._pendingEvents++,(0,I35.dispatchAndEmit)(A,this._queue,this,Q).catch((B)=>B).finally(()=>{if(this._pendingEvents--,!this._pendingEvents)this.emit("drained")})}alias({userId:A,previousId:Q,context:B,timestamp:G,integrations:Z},Y){let J=this._eventFactory.alias(A,Q,{context:B,integrations:Z,timestamp:G});this._dispatch(J,Y)}group({timestamp:A,groupId:Q,userId:B,anonymousId:G,traits:Z={},context:Y,integrations:J},I){let X=this._eventFactory.group(Q,Z,{context:Y,anonymousId:G,userId:B,timestamp:A,integrations:J});this._dispatch(X,I)}identify({userId:A,anonymousId:Q,traits:B={},context:G,timestamp:Z,integrations:Y},J){let I=this._eventFactory.identify(A,B,{context:G,anonymousId:Q,userId:A,timestamp:Z,integrations:Y});this._dispatch(I,J)}page({userId:A,anonymousId:Q,category:B,name:G,properties:Z,context:Y,timestamp:J,integrations:I},X){let W=this._eventFactory.page(B??null,G??null,Z,{context:Y,anonymousId:Q,userId:A,timestamp:J,integrations:I});this._dispatch(W,X)}screen({userId:A,anonymousId:Q,category:B,name:G,properties:Z,context:Y,timestamp:J,integrations:I},X){let W=this._eventFactory.screen(B??null,G??null,Z,{context:Y,anonymousId:Q,userId:A,timestamp:J,integrations:I});this._dispatch(W,X)}track({userId:A,anonymousId:Q,event:B,properties:G,context:Z,timestamp:Y,integrations:J},I){let X=this._eventFactory.track(B,G,{context:Z,userId:A,anonymousId:Q,timestamp:Y,integrations:J});this._dispatch(X,I)}register(...A){return this._queue.criticalTasks.run(async()=>{let Q=Nz2.Context.system(),B=A.map((G)=>this._queue.register(Q,G,this));await Promise.all(B),this.emit("register",A.map((G)=>G.name))})}async deregister(...A){let Q=Nz2.Context.system(),B=A.map((G)=>{let Z=this._queue.plugins.find((Y)=>Y.name===G);if(Z)return this._queue.deregister(Q,Z,this);else Q.log("warn",`plugin ${G} not found`)});await Promise.all(B),this.emit("deregister",A)}}Mz2.Analytics=Lz2});var Rz2=w((X_A)=>{Object.defineProperty(X_A,"__esModule",{value:!0});X_A.FetchHTTPClient=X_A.Context=X_A.Analytics=void 0;var K35=h80();Object.defineProperty(X_A,"Analytics",{enumerable:!0,get:function(){return K35.Analytics}});var V35=Q61();Object.defineProperty(X_A,"Context",{enumerable:!0,get:function(){return V35.Context}});var E35=b80();Object.defineProperty(X_A,"FetchHTTPClient",{enumerable:!0,get:function(){return E35.FetchHTTPClient}});var D35=h80();X_A.default=D35.Analytics});function z35(){let A=["test","dev"].includes("production")?"development":"production";return C35[A]}async function U35(){if(iX())return!1;return!0}async function g80(A,Q){let B=await Tz2();if(!B)return;try{let G=m80(),Z=j8(),Y=await hd({model:Q.model}),J=ffQ(Y,Q),I={anonymousId:G,event:A,properties:J};if(Z){let X=Fn(!0);I.userId=X.userID,I.properties.accountUuid=Z.accountUuid,I.properties.organizationUuid=Z.organizationUuid}B.track(I)}catch(G){r(G instanceof Error?G:Error(String(G)))}}async function jz2(A){let Q=await Tz2();if(!Q)return;try{let B=m80(),G=j8(),Z={anonymousId:B,traits:A};if(G){let Y=Fn(!0);Z.userId=Y.userID}Q.identify(Z)}catch(B){r(B instanceof Error?B:Error(String(B)))}}var _z2,C35,B61=null,Tz2;var u80=q(()=>{p2();tk();vQ();g1();V2();D6A();br();_z2=o(Rz2(),1),C35={production:"LKJN8LsLERHEOXkw487o7qCTFOrGPimI",development:"b64sf1kxwDGe1PiSAlv5ixuH0f509RKK"};Tz2=Z0(async()=>{if(!await U35())return null;try{return B61=new _z2.Analytics({writeKey:z35()}),process.on("beforeExit",async()=>{await B61?.closeAndFlush()}),process.on("exit",()=>{B61?.closeAndFlush()}),B61}catch(Q){return r(Q instanceof Error?Q:Error(String(Q))),null}})});function $35(){let A=j8();if(!A)return{};return{email:A.emailAddress,account_uuid:A.accountUuid,organization_uuid:A.organizationUuid}}function W_A(A){let Q=En(),B=jQ(()=>A.onDone(!1,Q));return f1((G,Z)=>{if(Z.escape)A.onDone(!1,Q)}),hH.createElement(j,{flexDirection:"column",marginTop:1},hH.createElement(Wi,{onDone:()=>A.onDone(!0,Q),startingMessage:A.startingMessage}),hH.createElement(j,{marginLeft:1},hH.createElement(z,{dimColor:!0},B.pending?hH.createElement(hH.Fragment,null,"Press ",B.keyName," again to exit"):"")))}var hH,Pz2=()=>({type:"local-jsx",name:"login",description:eFQ()?"Switch Anthropic accounts":"Sign in with your Anthropic account",isEnabled:()=>!process.env.DISABLE_LOGIN_COMMAND,isHidden:!1,async call(A,Q){return hH.createElement(W_A,{onDone:async(B)=>{if(Q.onChangeAPIKey(),B)wWA(),t1A(),jz2($35()),_iB();A(B?"Login successful":"Login interrupted")}})},userFacingName(){return"login"}});var G61=q(()=>{JMA();o9();hA();V2();rRA();w4();u0();u80();V2();MYA();hH=o(KA(),1)});async function Sz2(A){let{accessToken:Q,orgUUID:B}=await Ex(),G={...oW(Q),"x-organization-uuid":B},Z=`${k9().BASE_API_URL}/api/oauth/organizations/${B}/admin_requests`;return(await FQ.post(Z,A,{headers:G})).data}async function xz2(A,Q){let{accessToken:B,orgUUID:G}=await Ex(),Z={...oW(B),"x-organization-uuid":G},Y=`${k9().BASE_API_URL}/api/oauth/organizations/${G}/admin_requests/me`;return(await FQ.get(Y,{headers:Z,params:{request_type:A,statuses:Q.join(",")}})).data}var yz2=q(()=>{m8();nJ();mb()});var vz2,w35,Dg;var K_A=q(()=>{g1();V2();EU();G61();vQ();yz2();vz2=o(KA(),1),w35={type:"local-jsx",name:"extra-usage",description:"Access and configure extra usage to keep working when limits are hit",isEnabled:()=>{if(process.env.DISABLE_EXTRA_USAGE_COMMAND)return!1;if(!LB())return!1;if(d80())return!0;let A=c3();return A==="pro"||A==="max"},isHidden:!1,async call(A,Q){let B=c3(),G=B==="team"||B==="enterprise",Z=kz2(),Y=d80(),J=j8()?.hasExtraUsageEnabled===!0;if(!Z&&G){if(Y){try{let X=await xz2("limit_increase",["pending","dismissed"]);if(X&&X.length>0)return A("You have already submitted a request for extra usage to your admin."),null}catch(X){r(X)}try{return await Sz2({request_type:"limit_increase",details:null}),A(J?"Sent a request to your admin to increase extra usage.":"Sent a request to your admin to enable extra usage."),null}catch(X){r(X)}}return A("Please contact your admin to manage extra usage settings."),null}let I=G?"https://claude.ai/admin-settings/usage":"https://claude.ai/settings/usage";try{return await Y7(I),vz2.default.createElement(W_A,{startingMessage:"Starting new login following /extra-usage. Exit with Ctrl-C to use existing account.",onDone:(X)=>{Q.onChangeAPIKey(),A(X?"Login successful":"Login interrupted")}})}catch(X){r(X),A(`Failed to open browser. Please visit ${I} to see your extra usage.`)}return null},userFacingName(){return"extra-usage"}},Dg=w35});function fz2({text:A,onOpenRateLimitOptions:Q}){let B=c3(),G=Rd(),Z=B==="pro"||B==="max",Y=G==="default_claude_max_20x",J=u7("hide_overages_option_at_rate_limit_hit","enabled",!1),I=(O9A()||LB())&&Z,X=I&&!Y,[W,K]=G$.useState(!1),V=X&&!W&&Q;G$.useEffect(()=>{if(V)K(!0),Q()},[V,Q]);let E=G$.useMemo(()=>{if(!I)return null;let D=Dg.isEnabled();if(Y&&D)return G$.default.createElement(z,{dimColor:!0},"/extra-usage to finish what you're working on.");if(V)return G$.default.createElement(z,{dimColor:!0},"Opening your options‚Ä¶");if(J||!D)return G$.default.createElement(z,{dimColor:!0},"/upgrade to increase your usage limit.");return G$.default.createElement(z,{dimColor:!0},"/upgrade or /extra-usage to finish what you're working on.")},[I,Y,V,J]);if(W)return null;return G$.default.createElement(h0,null,G$.default.createElement(j,{flexDirection:"column"},G$.default.createElement(z,{color:"error"},A),E))}var G$;var bz2=q(()=>{V2();YqA();hA();g4();K_A();w4();G$=o(KA(),1)});function N35(){let A=Iu0();return H5.default.createElement(h0,null,H5.default.createElement(j,{flexDirection:"column"},H5.default.createElement(z,{color:"error"},yeA),A&&H5.default.createElement(z,{dimColor:!0},"¬∑ Run in another terminal: security unlock-keychain")))}function hz2({param:{text:A},addMargin:Q,shouldShowDot:B,onOpenRateLimitOptions:G}){if(bB1(A))return null;if(XRB(A))return H5.default.createElement(fz2,{text:A,onOpenRateLimitOptions:G});switch(A){case jAA:return null;case IZA:{let Z=M0A("warning")??"Run /compact to compact & continue";return H5.default.createElement(h0,{height:1},H5.default.createElement(z,{color:"error"},"Context low ¬∑ ",Z))}case xeA:return H5.default.createElement(h0,{height:1},H5.default.createElement(z,{color:"error"},"Credit balance too low ¬∑ Add funds: https://console.anthropic.com/settings/billing"));case yeA:return H5.default.createElement(N35,null);case veA:return H5.default.createElement(h0,{height:1},H5.default.createElement(z,{color:"error"},veA));case keA:return H5.default.createElement(h0,{height:1},H5.default.createElement(z,{color:"error"},keA));case feA:return H5.default.createElement(h0,{height:1},H5.default.createElement(z,{color:"error"},feA,process.env.API_TIMEOUT_MS&&H5.default.createElement(H5.default.Fragment,null," ","(API_TIMEOUT_MS=",process.env.API_TIMEOUT_MS,"ms, try increasing it)")));case TAA:return H5.default.createElement(h0,null,H5.default.createElement(j,{flexDirection:"column",gap:1},H5.default.createElement(z,{color:"error"},"We are experiencing high demand for Opus 4."),H5.default.createElement(z,null,"To continue immediately, use /model to switch to"," ",tD(hz())," and continue coding.")));case EMA:return H5.default.createElement(h0,{height:1},H5.default.createElement(oS,null));default:if(A.startsWith(tW))return H5.default.createElement(h0,null,H5.default.createElement(z,{color:"error"},A===tW?`${tW}: Please wait a moment and try again.`:A));return H5.default.createElement(j,{alignItems:"flex-start",flexDirection:"row",justifyContent:"space-between",marginTop:Q?1:0,width:"100%"},H5.default.createElement(j,{flexDirection:"row"},B&&H5.default.createElement(j,{minWidth:2},H5.default.createElement(z,{color:"text"},YX)),H5.default.createElement(Rx,null,H5.default.createElement(j,{flexDirection:"column"},H5.default.createElement(pM,null,A)))))}}var H5;var gz2=q(()=>{hA();NqA();wM();KB();nx();i1A();g4();d2();N31();DMA();q7A();Ha1();oKA();bz2();H5=o(KA(),1)});function Z61({param:{text:A},addMargin:Q}){let B=t2(A,"bash-input");if(!B)return null;return Hg.createElement(j,{flexDirection:"column",marginTop:Q?1:0,width:"100%"},Hg.createElement(j,null,Hg.createElement(z,{backgroundColor:"bashMessageBackgroundColor",color:"bashBorder"},"!"),Hg.createElement(z,{backgroundColor:"bashMessageBackgroundColor",color:"text"}," ",B," ")))}var Hg;var c80=q(()=>{hA();KB();Hg=o(KA(),1)});function uz2({addMargin:A,param:{text:Q}}){let B=t2(Q,"command-message"),G=t2(Q,"command-args");if(!B)return null;f(`UserCommandMessage rendering: "${B}" (args: "${G||"none"}")`);let Z=B.startsWith("The "),Y=Z?"":"/";return f(`  isSkillFormat: ${Z}, prefix: "${Y}"`),V_A.createElement(j,{flexDirection:"column",marginTop:A?1:0,width:"100%"},V_A.createElement(z,{backgroundColor:"userMessageBackground",color:"text"},"> ",Y,[B,G].filter(Boolean).join(" ")," "))}var V_A;var mz2=q(()=>{hA();KB();Q0();V_A=o(KA(),1)});function dz2({text:A,thinkingMetadata:Q}){if(!Q||Q.triggers.length===0)return RN.createElement(z,{backgroundColor:"userMessageBackground",color:"text"},"> ",A+" ");let B=Q.disabled?void 0:wB1[Q.level],G=Z02(A,Q.triggers);return RN.createElement(z,null,">"," ",G.map((Z,Y)=>{if(Z.isTrigger)if(NB1(Z.text))return RN.createElement(z,{key:Y},Z.text.split("").map((I,X)=>RN.createElement(z,{key:X,backgroundColor:"userMessageBackground",color:mMA(X,!1)},I)));else return RN.createElement(z,{key:Y,backgroundColor:"userMessageBackground",color:B},Z.text);return RN.createElement(z,{key:Y,backgroundColor:"userMessageBackground",color:"text"},Z.text)})," ")}var RN;var cz2=q(()=>{hA();bM();RN=o(KA(),1)});function pz2({addMargin:A,param:{text:Q},thinkingMetadata:B}){let{columns:G}=SB();if(!Q)return r(Error("No content found in user prompt message")),null;let Z=Q.trim();return p80.default.createElement(j,{flexDirection:"column",marginTop:A?1:0,width:G-4},p80.default.createElement(dz2,{text:Z,thinkingMetadata:B}))}var p80;var lz2=q(()=>{hA();g1();y3();cz2();p80=o(KA(),1)});var iz2=w((E_A,D_A)=>{(function(){var A,Q="4.17.21",B=200,G="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",Z="Expected a function",Y="Invalid `variable` option passed into `_.template`",J="__lodash_hash_undefined__",I=500,X="__lodash_placeholder__",W=1,K=2,V=4,E=1,D=2,H=1,F=2,C=4,$=8,O=16,M=32,L=64,_=128,T=256,x=512,b=30,v="...",m=800,u=16,e=1,p=2,k=3,c=1/0,t=9007199254740991,AA=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,VA=NaN,OA=4294967295,IA=OA-1,PA=OA>>>1,kA=[["ary",_],["bind",H],["bindKey",F],["curry",$],["curryRight",O],["flip",x],["partial",M],["partialRight",L],["rearg",T]],YA="[object Arguments]",ZA="[object Array]",zA="[object AsyncFunction]",bA="[object Boolean]",TA="[object Date]",B1="[object DOMException]",JA="[object Error]",CA="[object Function]",MA="[object GeneratorFunction]",NA="[object Map]",UA="[object Number]",LA="[object Null]",nA="[object Object]",gA="[object Promise]",I1="[object Proxy]",q1="[object RegExp]",_A="[object Set]",Q1="[object String]",h1="[object Symbol]",_1="[object Undefined]",V0="[object WeakMap]",AQ="[object WeakSet]",n0="[object ArrayBuffer]",JQ="[object DataView]",BQ="[object Float32Array]",F1="[object Float64Array]",eA="[object Int8Array]",K1="[object Int16Array]",O1="[object Int32Array]",G0="[object Uint8Array]",$0="[object Uint8ClampedArray]",F0="[object Uint16Array]",HA="[object Uint32Array]",$A=/\b__p \+= '';/g,A1=/\b(__p \+=) '' \+/g,N1=/(__e\(.*?\)|\b__t\)) \+\n'';/g,C1=/&(?:amp|lt|gt|quot|#39);/g,D1=/[&<>"']/g,B0=RegExp(C1.source),i1=RegExp(D1.source),P0=/<%-([\s\S]+?)%>/g,IQ=/<%([\s\S]+?)%>/g,fB=/<%=([\s\S]+?)%>/g,oQ=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,H2=/^\w*$/,d0=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,NQ=/[\\^$.*+?()[\]{}|]/g,RB=RegExp(NQ.source),z9=/^\s+/,JB=/\s/,V1=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,iA=/\{\n\/\* \[wrapped with (.+)\] \*/,z1=/,? & /,A0=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,E0=/[()=,{}\[\]\/\s]/,xQ=/\\(\\)?/g,eB=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,X9=/\w*$/,Q9=/^[-+]0x[0-9a-f]+$/i,y4=/^0b[01]+$/i,B9=/^\[object .+?Constructor\]$/,$3=/^0o[0-7]+$/i,w3=/^(?:0|[1-9]\d*)$/,C4=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,O9=/($^)/,N3=/['\n\r\u2028\u2029\\]/g,p9="\\ud800-\\udfff",v5="\\u0300-\\u036f",M6="\\ufe20-\\ufe2f",q3="\\u20d0-\\u20ff",l9=v5+M6+q3,s0="\\u2700-\\u27bf",mQ="a-z\\xdf-\\xf6\\xf8-\\xff",XB="\\xac\\xb1\\xd7\\xf7",e9="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",x2="\\u2000-\\u206f",WG=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",gG="A-Z\\xc0-\\xd6\\xd8-\\xde",f6="\\ufe0e\\ufe0f",b6=XB+e9+x2+WG,aA="['‚Äô]",WA="["+p9+"]",BA="["+b6+"]",xA="["+l9+"]",fA="\\d+",uA="["+s0+"]",w1="["+mQ+"]",x1="[^"+p9+b6+fA+s0+mQ+gG+"]",k1="\\ud83c[\\udffb-\\udfff]",n1="(?:"+xA+"|"+k1+")",p1="[^"+p9+"]",z0="(?:\\ud83c[\\udde6-\\uddff]){2}",qQ="[\\ud800-\\udbff][\\udc00-\\udfff]",HB="["+gG+"]",j2="\\u200d",A2="(?:"+w1+"|"+x1+")",n2="(?:"+HB+"|"+x1+")",L3="(?:"+aA+"(?:d|ll|m|re|s|t|ve))?",k5="(?:"+aA+"(?:D|LL|M|RE|S|T|VE))?",N8=n1+"?",MW="["+f6+"]?",KG="(?:"+j2+"(?:"+[p1,z0,qQ].join("|")+")"+MW+N8+")*",LI="\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",MI="\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",OW=MW+N8+KG,$5="(?:"+[uA,z0,qQ].join("|")+")"+OW,VG="(?:"+[p1+xA+"?",xA,z0,qQ,WA].join("|")+")",UK=RegExp(aA,"g"),NX=RegExp(xA,"g"),qX=RegExp(k1+"(?="+k1+")|"+VG+OW,"g"),$K=RegExp([HB+"?"+w1+"+"+L3+"(?="+[BA,HB,"$"].join("|")+")",n2+"+"+k5+"(?="+[BA,HB+A2,"$"].join("|")+")",HB+"?"+A2+"+"+L3,HB+"+"+k5,MI,LI,fA,$5].join("|"),"g"),DZ=RegExp("["+j2+p9+l9+f6+"]"),OI=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,pN=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],fJ=-1,h6={};h6[BQ]=h6[F1]=h6[eA]=h6[K1]=h6[O1]=h6[G0]=h6[$0]=h6[F0]=h6[HA]=!0,h6[YA]=h6[ZA]=h6[n0]=h6[bA]=h6[JQ]=h6[TA]=h6[JA]=h6[CA]=h6[NA]=h6[UA]=h6[nA]=h6[q1]=h6[_A]=h6[Q1]=h6[V0]=!1;var Y6={};Y6[YA]=Y6[ZA]=Y6[n0]=Y6[JQ]=Y6[bA]=Y6[TA]=Y6[BQ]=Y6[F1]=Y6[eA]=Y6[K1]=Y6[O1]=Y6[NA]=Y6[UA]=Y6[nA]=Y6[q1]=Y6[_A]=Y6[Q1]=Y6[h1]=Y6[G0]=Y6[$0]=Y6[F0]=Y6[HA]=!0,Y6[JA]=Y6[CA]=Y6[V0]=!1;var aH={"√Ä":"A","√Å":"A","√Ç":"A","√É":"A","√Ñ":"A","√Ö":"A","√†":"a","√°":"a","√¢":"a","√£":"a","√§":"a","√•":"a","√á":"C","√ß":"c","√ê":"D","√∞":"d","√à":"E","√â":"E","√ä":"E","√ã":"E","√®":"e","√©":"e","√™":"e","√´":"e","√å":"I","√ç":"I","√é":"I","√è":"I","√¨":"i","√≠":"i","√Æ":"i","√Ø":"i","√ë":"N","√±":"n","√í":"O","√ì":"O","√î":"O","√ï":"O","√ñ":"O","√ò":"O","√≤":"o","√≥":"o","√¥":"o","√µ":"o","√∂":"o","√∏":"o","√ô":"U","√ö":"U","√õ":"U","√ú":"U","√π":"u","√∫":"u","√ª":"u","√º":"u","√ù":"Y","√Ω":"y","√ø":"y","√Ü":"Ae","√¶":"ae","√û":"Th","√æ":"th","√ü":"ss","ƒÄ":"A","ƒÇ":"A","ƒÑ":"A","ƒÅ":"a","ƒÉ":"a","ƒÖ":"a","ƒÜ":"C","ƒà":"C","ƒä":"C","ƒå":"C","ƒá":"c","ƒâ":"c","ƒã":"c","ƒç":"c","ƒé":"D","ƒê":"D","ƒè":"d","ƒë":"d","ƒí":"E","ƒî":"E","ƒñ":"E","ƒò":"E","ƒö":"E","ƒì":"e","ƒï":"e","ƒó":"e","ƒô":"e","ƒõ":"e","ƒú":"G","ƒû":"G","ƒ†":"G","ƒ¢":"G","ƒù":"g","ƒü":"g","ƒ°":"g","ƒ£":"g","ƒ§":"H","ƒ¶":"H","ƒ•":"h","ƒß":"h","ƒ®":"I","ƒ™":"I","ƒ¨":"I","ƒÆ":"I","ƒ∞":"I","ƒ©":"i","ƒ´":"i","ƒ≠":"i","ƒØ":"i","ƒ±":"i","ƒ¥":"J","ƒµ":"j","ƒ∂":"K","ƒ∑":"k","ƒ∏":"k","ƒπ":"L","ƒª":"L","ƒΩ":"L","ƒø":"L","≈Å":"L","ƒ∫":"l","ƒº":"l","ƒæ":"l","≈Ä":"l","≈Ç":"l","≈É":"N","≈Ö":"N","≈á":"N","≈ä":"N","≈Ñ":"n","≈Ü":"n","≈à":"n","≈ã":"n","≈å":"O","≈é":"O","≈ê":"O","≈ç":"o","≈è":"o","≈ë":"o","≈î":"R","≈ñ":"R","≈ò":"R","≈ï":"r","≈ó":"r","≈ô":"r","≈ö":"S","≈ú":"S","≈û":"S","≈†":"S","≈õ":"s","≈ù":"s","≈ü":"s","≈°":"s","≈¢":"T","≈§":"T","≈¶":"T","≈£":"t","≈•":"t","≈ß":"t","≈®":"U","≈™":"U","≈¨":"U","≈Æ":"U","≈∞":"U","≈≤":"U","≈©":"u","≈´":"u","≈≠":"u","≈Ø":"u","≈±":"u","≈≥":"u","≈¥":"W","≈µ":"w","≈∂":"Y","≈∑":"y","≈∏":"Y","≈π":"Z","≈ª":"Z","≈Ω":"Z","≈∫":"z","≈º":"z","≈æ":"z","ƒ≤":"IJ","ƒ≥":"ij","≈í":"Oe","≈ì":"oe","≈â":"'n","≈ø":"s"},H$={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},wK={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},DO={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},oT=parseFloat,HO=parseInt,oH=typeof global=="object"&&global&&global.Object===Object&&global,NY=typeof self=="object"&&self&&self.Object===Object&&self,EG=oH||NY||Function("return this")(),CD=typeof E_A=="object"&&E_A&&!E_A.nodeType&&E_A,NK=CD&&typeof D_A=="object"&&D_A&&!D_A.nodeType&&D_A,FO=NK&&NK.exports===CD,rH=FO&&oH.process,v0=function(){try{var t1=NK&&NK.require&&NK.require("util").types;if(t1)return t1;return rH&&rH.binding&&rH.binding("util")}catch(c0){}}(),FB=v0&&v0.isArrayBuffer,K2=v0&&v0.isDate,J6=v0&&v0.isMap,M3=v0&&v0.isRegExp,g2=v0&&v0.isSet,g3=v0&&v0.isTypedArray;function A4(t1,c0,R0){switch(R0.length){case 0:return t1.call(c0);case 1:return t1.call(c0,R0[0]);case 2:return t1.call(c0,R0[0],R0[1]);case 3:return t1.call(c0,R0[0],R0[1],R0[2])}return t1.apply(c0,R0)}function bB(t1,c0,R0,Z2){var z4=-1,O6=t1==null?0:t1.length;while(++z4<O6){var w5=t1[z4];c0(Z2,w5,R0(w5),t1)}return Z2}function W9(t1,c0){var R0=-1,Z2=t1==null?0:t1.length;while(++R0<Z2)if(c0(t1[R0],R0,t1)===!1)break;return t1}function t8(t1,c0){var R0=t1==null?0:t1.length;while(R0--)if(c0(t1[R0],R0,t1)===!1)break;return t1}function LX(t1,c0){var R0=-1,Z2=t1==null?0:t1.length;while(++R0<Z2)if(!c0(t1[R0],R0,t1))return!1;return!0}function HZ(t1,c0){var R0=-1,Z2=t1==null?0:t1.length,z4=0,O6=[];while(++R0<Z2){var w5=t1[R0];if(c0(w5,R0,t1))O6[z4++]=w5}return O6}function DG(t1,c0){var R0=t1==null?0:t1.length;return!!R0&&F$(t1,c0,0)>-1}function uG(t1,c0,R0){var Z2=-1,z4=t1==null?0:t1.length;while(++Z2<z4)if(R0(c0,t1[Z2]))return!0;return!1}function a3(t1,c0){var R0=-1,Z2=t1==null?0:t1.length,z4=Array(Z2);while(++R0<Z2)z4[R0]=c0(t1[R0],R0,t1);return z4}function qY(t1,c0){var R0=-1,Z2=c0.length,z4=t1.length;while(++R0<Z2)t1[z4+R0]=c0[R0];return t1}function bJ(t1,c0,R0,Z2){var z4=-1,O6=t1==null?0:t1.length;if(Z2&&O6)R0=t1[++z4];while(++z4<O6)R0=c0(R0,t1[z4],z4,t1);return R0}function lN(t1,c0,R0,Z2){var z4=t1==null?0:t1.length;if(Z2&&z4)R0=t1[--z4];while(z4--)R0=c0(R0,t1[z4],z4,t1);return R0}function sH(t1,c0){var R0=-1,Z2=t1==null?0:t1.length;while(++R0<Z2)if(c0(t1[R0],R0,t1))return!0;return!1}var eV=U0("length");function CO(t1){return t1.split("")}function nn(t1){return t1.match(A0)||[]}function an(t1,c0,R0){var Z2;return R0(t1,function(z4,O6,w5){if(c0(z4,O6,w5))return Z2=O6,!1}),Z2}function mZ(t1,c0,R0,Z2){var z4=t1.length,O6=R0+(Z2?1:-1);while(Z2?O6--:++O6<z4)if(c0(t1[O6],O6,t1))return O6;return-1}function F$(t1,c0,R0){return c0===c0?sn(t1,c0,R0):mZ(t1,RA,R0)}function wA(t1,c0,R0,Z2){var z4=R0-1,O6=t1.length;while(++z4<O6)if(Z2(t1[z4],c0))return z4;return-1}function RA(t1){return t1!==t1}function $1(t1,c0){var R0=t1==null?0:t1.length;return R0?v4(t1,c0)/R0:VA}function U0(t1){return function(c0){return c0==null?A:c0[t1]}}function y0(t1){return function(c0){return t1==null?A:t1[c0]}}function zB(t1,c0,R0,Z2,z4){return z4(t1,function(O6,w5,f5){R0=Z2?(Z2=!1,O6):c0(R0,O6,w5,f5)}),R0}function a2(t1,c0){var R0=t1.length;t1.sort(c0);while(R0--)t1[R0]=t1[R0].value;return t1}function v4(t1,c0){var R0,Z2=-1,z4=t1.length;while(++Z2<z4){var O6=c0(t1[Z2]);if(O6!==A)R0=R0===A?O6:R0+O6}return R0}function b8(t1,c0){var R0=-1,Z2=Array(t1);while(++R0<t1)Z2[R0]=c0(R0);return Z2}function FZ(t1,c0){return a3(c0,function(R0){return[R0,t1[R0]]})}function LY(t1){return t1?t1.slice(0,aN(t1)+1).replace(z9,""):t1}function I6(t1){return function(c0){return t1(c0)}}function V3(t1,c0){return a3(c0,function(R0){return t1[R0]})}function MX(t1,c0){return t1.has(c0)}function tH(t1,c0){var R0=-1,Z2=t1.length;while(++R0<Z2&&F$(c0,t1[R0],0)>-1);return R0}function ey(t1,c0){var R0=t1.length;while(R0--&&F$(c0,t1[R0],0)>-1);return R0}function eH(t1,c0){var R0=t1.length,Z2=0;while(R0--)if(t1[R0]===c0)++Z2;return Z2}var t6=y0(aH),rT=y0(H$);function Av(t1){return"\\"+DO[t1]}function zO(t1,c0){return t1==null?A:t1[c0]}function sT(t1){return DZ.test(t1)}function iN(t1){return OI.test(t1)}function pg(t1){var c0,R0=[];while(!(c0=t1.next()).done)R0.push(c0.value);return R0}function on(t1){var c0=-1,R0=Array(t1.size);return t1.forEach(function(Z2,z4){R0[++c0]=[z4,Z2]}),R0}function rn(t1,c0){return function(R0){return t1(c0(R0))}}function f7(t1,c0){var R0=-1,Z2=t1.length,z4=0,O6=[];while(++R0<Z2){var w5=t1[R0];if(w5===c0||w5===X)t1[R0]=X,O6[z4++]=R0}return O6}function nN(t1){var c0=-1,R0=Array(t1.size);return t1.forEach(function(Z2){R0[++c0]=Z2}),R0}function qQA(t1){var c0=-1,R0=Array(t1.size);return t1.forEach(function(Z2){R0[++c0]=[Z2,Z2]}),R0}function sn(t1,c0,R0){var Z2=R0-1,z4=t1.length;while(++Z2<z4)if(t1[Z2]===c0)return Z2;return-1}function LQA(t1,c0,R0){var Z2=R0+1;while(Z2--)if(t1[Z2]===c0)return Z2;return Z2}function UO(t1){return sT(t1)?tT(t1):eV(t1)}function RW(t1){return sT(t1)?Qv(t1):CO(t1)}function aN(t1){var c0=t1.length;while(c0--&&JB.test(t1.charAt(c0)));return c0}var tn=y0(wK);function tT(t1){var c0=qX.lastIndex=0;while(qX.test(t1))++c0;return c0}function Qv(t1){return t1.match(qX)||[]}function b7(t1){return t1.match($K)||[]}var jXA=function t1(c0){c0=c0==null?EG:_W.defaults(EG.Object(),c0,_W.pick(EG,pN));var{Array:R0,Date:Z2,Error:z4,Function:O6,Math:w5,Object:f5,RegExp:eT,String:oN,TypeError:qK}=c0,rN=R0.prototype,Aj=O6.prototype,C$=f5.prototype,$O=c0["__core-js_shared__"],lg=Aj.toString,q8=C$.hasOwnProperty,PXA=0,AF=function(){var R=/[^.]+$/.exec($O&&$O.keys&&$O.keys.IE_PROTO||"");return R?"Symbol(src)_1."+R:""}(),Bv=C$.toString,SXA=lg.call(f5),MQA=EG._,xXA=eT("^"+lg.call(q8).replace(NQ,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Qj=FO?c0.Buffer:A,CZ=c0.Symbol,ig=c0.Uint8Array,TW=Qj?Qj.allocUnsafe:A,Gv=rn(f5.getPrototypeOf,f5),oC=f5.create,wO=C$.propertyIsEnumerable,QF=rN.splice,Zv=CZ?CZ.isConcatSpreadable:A,sN=CZ?CZ.iterator:A,IJ=CZ?CZ.toStringTag:A,NO=function(){try{var R=m1(f5,"defineProperty");return R({},"",{}),R}catch(S){}}(),Bj=c0.clearTimeout!==EG.clearTimeout&&c0.clearTimeout,Yv=Z2&&Z2.now!==EG.Date.now&&Z2.now,z$=c0.setTimeout!==EG.setTimeout&&c0.setTimeout,qO=w5.ceil,ng=w5.floor,Gj=f5.getOwnPropertySymbols,yXA=Qj?Qj.isBuffer:A,ag=c0.isFinite,vXA=rN.join,og=rn(f5.keys,f5),MY=w5.max,hJ=w5.min,kXA=Z2.now,en=c0.parseInt,LK=w5.random,OQA=rN.reverse,OX=m1(c0,"DataView"),Zj=m1(c0,"Map"),Yj=m1(c0,"Promise"),Jj=m1(c0,"Set"),MK=m1(c0,"WeakMap"),LO=m1(f5,"create"),Ij=MK&&new MK,rC={},fXA=TI(OX),bXA=TI(Zj),Aa=TI(Yj),hXA=TI(Jj),Qa=TI(MK),MO=CZ?CZ.prototype:A,Jv=MO?MO.valueOf:A,gXA=MO?MO.toString:A;function sA(R){if(e1(R)&&!hB(R)&&!(R instanceof E3)){if(R instanceof dZ)return R;if(q8.call(R,"__wrapped__"))return b5(R)}return new dZ(R)}var OY=function(){function R(){}return function(S){if(!U1(S))return{};if(oC)return oC(S);R.prototype=S;var d=new R;return R.prototype=A,d}}();function Iv(){}function dZ(R,S){this.__wrapped__=R,this.__actions__=[],this.__chain__=!!S,this.__index__=0,this.__values__=A}sA.templateSettings={escape:P0,evaluate:IQ,interpolate:fB,variable:"",imports:{_:sA}},sA.prototype=Iv.prototype,sA.prototype.constructor=sA,dZ.prototype=OY(Iv.prototype),dZ.prototype.constructor=dZ;function E3(R){this.__wrapped__=R,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=OA,this.__views__=[]}function Ba(){var R=new E3(this.__wrapped__);return R.__actions__=_K(this.__actions__),R.__dir__=this.__dir__,R.__filtered__=this.__filtered__,R.__iteratees__=_K(this.__iteratees__),R.__takeCount__=this.__takeCount__,R.__views__=_K(this.__views__),R}function Ga(){if(this.__filtered__){var R=new E3(this);R.__dir__=-1,R.__filtered__=!0}else R=this.clone(),R.__dir__*=-1;return R}function Za(){var R=this.__wrapped__.value(),S=this.__dir__,d=hB(R),XA=S<0,vA=d?R.length:0,Z1=F2(0,vA,this.__views__),M1=Z1.start,b1=Z1.end,I0=b1-M1,KQ=XA?b1:M1-1,HQ=this.__iteratees__,yQ=HQ.length,nB=0,G9=hJ(I0,this.__takeCount__);if(!d||!XA&&vA==I0&&G9==I0)return Na(R,this.__actions__);var U4=[];A:while(I0--&&nB<G9){KQ+=S;var K6=-1,$4=R[KQ];while(++K6<yQ){var G8=HQ[K6],u8=G8.iteratee,P$=G8.type,DF=u8($4);if(P$==p)$4=DF;else if(!DF)if(P$==e)continue A;else break A}U4[nB++]=$4}return U4}E3.prototype=OY(Iv.prototype),E3.prototype.constructor=E3;function U$(R){var S=-1,d=R==null?0:R.length;this.clear();while(++S<d){var XA=R[S];this.set(XA[0],XA[1])}}function Ya(){this.__data__=LO?LO(null):{},this.size=0}function Ja(R){var S=this.has(R)&&delete this.__data__[R];return this.size-=S?1:0,S}function Xj(R){var S=this.__data__;if(LO){var d=S[R];return d===J?A:d}return q8.call(S,R)?S[R]:A}function RQA(R){var S=this.__data__;return LO?S[R]!==A:q8.call(S,R)}function _QA(R,S){var d=this.__data__;return this.size+=this.has(R)?0:1,d[R]=LO&&S===A?J:S,this}U$.prototype.clear=Ya,U$.prototype.delete=Ja,U$.prototype.get=Xj,U$.prototype.has=RQA,U$.prototype.set=_QA;function k4(R){var S=-1,d=R==null?0:R.length;this.clear();while(++S<d){var XA=R[S];this.set(XA[0],XA[1])}}function Xv(){this.__data__=[],this.size=0}function tN(R){var S=this.__data__,d=Aq(S,R);if(d<0)return!1;var XA=S.length-1;if(d==XA)S.pop();else QF.call(S,d,1);return--this.size,!0}function rg(R){var S=this.__data__,d=Aq(S,R);return d<0?A:S[d][1]}function qjA(R){return Aq(this.__data__,R)>-1}function LjA(R,S){var d=this.__data__,XA=Aq(d,R);if(XA<0)++this.size,d.push([R,S]);else d[XA][1]=S;return this}k4.prototype.clear=Xv,k4.prototype.delete=tN,k4.prototype.get=rg,k4.prototype.has=qjA,k4.prototype.set=LjA;function BF(R){var S=-1,d=R==null?0:R.length;this.clear();while(++S<d){var XA=R[S];this.set(XA[0],XA[1])}}function uXA(){this.size=0,this.__data__={hash:new U$,map:new(Zj||k4),string:new U$}}function Wv(R){var S=G1(this,R).delete(R);return this.size-=S?1:0,S}function $$(R){return G1(this,R).get(R)}function Ia(R){return G1(this,R).has(R)}function Kv(R,S){var d=G1(this,R),XA=d.size;return d.set(R,S),this.size+=d.size==XA?0:1,this}BF.prototype.clear=uXA,BF.prototype.delete=Wv,BF.prototype.get=$$,BF.prototype.has=Ia,BF.prototype.set=Kv;function AE(R){var S=-1,d=R==null?0:R.length;this.__data__=new BF;while(++S<d)this.add(R[S])}function sg(R){return this.__data__.set(R,J),this}function TQA(R){return this.__data__.has(R)}AE.prototype.add=AE.prototype.push=sg,AE.prototype.has=TQA;function QE(R){var S=this.__data__=new k4(R);this.size=S.size}function jQA(){this.__data__=new k4,this.size=0}function PQA(R){var S=this.__data__,d=S.delete(R);return this.size=S.size,d}function SQA(R){return this.__data__.get(R)}function Wj(R){return this.__data__.has(R)}function Xa(R,S){var d=this.__data__;if(d instanceof k4){var XA=d.__data__;if(!Zj||XA.length<B-1)return XA.push([R,S]),this.size=++d.size,this;d=this.__data__=new BF(XA)}return d.set(R,S),this.size=d.size,this}QE.prototype.clear=jQA,QE.prototype.delete=PQA,QE.prototype.get=SQA,QE.prototype.has=Wj,QE.prototype.set=Xa;function Kj(R,S){var d=hB(R),XA=!d&&V9(R),vA=!d&&!XA&&Rj(R),Z1=!d&&!XA&&!vA&&vX(R),M1=d||XA||vA||Z1,b1=M1?b8(R.length,oN):[],I0=b1.length;for(var KQ in R)if((S||q8.call(R,KQ))&&!(M1&&(KQ=="length"||vA&&(KQ=="offset"||KQ=="parent")||Z1&&(KQ=="buffer"||KQ=="byteLength"||KQ=="byteOffset")||m4(KQ,I0))))b1.push(KQ);return b1}function Vv(R){var S=R.length;return S?R[Ua(0,S-1)]:A}function kB(R,S){return N5(_K(R),w$(S,0,R.length))}function tg(R){return N5(_K(R))}function eg(R,S,d){if(d!==A&&!zQ(R[S],d)||d===A&&!(S in R))GF(R,S,d)}function eN(R,S,d){var XA=R[S];if(!(q8.call(R,S)&&zQ(XA,d))||d===A&&!(S in R))GF(R,S,d)}function Aq(R,S){var d=R.length;while(d--)if(zQ(R[d][0],S))return d;return-1}function Vj(R,S,d,XA){return Qq(R,function(vA,Z1,M1){S(XA,vA,d(vA),M1)}),XA}function Wa(R,S){return R&&Az(S,kK(S),R)}function Ka(R,S){return R&&Az(S,Zz(S),R)}function GF(R,S,d){if(S=="__proto__"&&NO)NO(R,S,{configurable:!0,enumerable:!0,value:d,writable:!0});else R[S]=d}function zD(R,S){var d=-1,XA=S.length,vA=R0(XA),Z1=R==null;while(++d<XA)vA[d]=Z1?A:m71(R,S[d]);return vA}function w$(R,S,d){if(R===R){if(d!==A)R=R<=d?R:d;if(S!==A)R=R>=S?R:S}return R}function jW(R,S,d,XA,vA,Z1){var M1,b1=S&W,I0=S&K,KQ=S&V;if(d)M1=vA?d(R,XA,vA,Z1):d(R);if(M1!==A)return M1;if(!U1(R))return R;var HQ=hB(R);if(HQ){if(M1=O4(R),!b1)return _K(R,M1)}else{var yQ=gQ(R),nB=yQ==CA||yQ==MA;if(Rj(R))return u4(R,b1);if(yQ==nA||yQ==YA||nB&&!vA){if(M1=I0||nB?{}:e6(R),!b1)return I0?cQA(R,Ka(M1,R)):tXA(R,Wa(M1,R))}else{if(!Y6[yQ])return vA?R:{};M1=iB(R,yQ,b1)}}Z1||(Z1=new QE);var G9=Z1.get(R);if(G9)return G9;if(Z1.set(R,M1),vK(R))R.forEach(function($4){M1.add(jW($4,S,d,$4,R,Z1))});else if(t0(R))R.forEach(function($4,G8){M1.set(G8,jW($4,S,d,G8,R,Z1))});var U4=KQ?I0?DA:a:I0?Zz:kK,K6=HQ?A:U4(R);return W9(K6||R,function($4,G8){if(K6)G8=$4,$4=R[G8];eN(M1,G8,jW($4,S,d,G8,R,Z1))}),M1}function Va(R){var S=kK(R);return function(d){return Au(d,R,S)}}function Au(R,S,d){var XA=d.length;if(R==null)return!XA;R=f5(R);while(XA--){var vA=d[XA],Z1=S[vA],M1=R[vA];if(M1===A&&!(vA in R)||!Z1(M1))return!1}return!0}function N$(R,S,d){if(typeof R!="function")throw new qK(Z);return u6(function(){R.apply(A,d)},S)}function q$(R,S,d,XA){var vA=-1,Z1=DG,M1=!0,b1=R.length,I0=[],KQ=S.length;if(!b1)return I0;if(d)S=a3(S,I6(d));if(XA)Z1=uG,M1=!1;else if(S.length>=B)Z1=MX,M1=!1,S=new AE(S);A:while(++vA<b1){var HQ=R[vA],yQ=d==null?HQ:d(HQ);if(HQ=XA||HQ!==0?HQ:0,M1&&yQ===yQ){var nB=KQ;while(nB--)if(S[nB]===yQ)continue A;I0.push(HQ)}else if(!Z1(S,yQ,XA))I0.push(HQ)}return I0}var Qq=TO(YF),Ea=TO(RX,!0);function mXA(R,S){var d=!0;return Qq(R,function(XA,vA,Z1){return d=!!S(XA,vA,Z1),d}),d}function ZF(R,S,d){var XA=-1,vA=R.length;while(++XA<vA){var Z1=R[XA],M1=S(Z1);if(M1!=null&&(b1===A?M1===M1&&!wZ(M1):d(M1,b1)))var b1=M1,I0=Z1}return I0}function U9(R,S,d,XA){var vA=R.length;if(d=H3(d),d<0)d=-d>vA?0:vA+d;if(XA=XA===A||XA>vA?vA:H3(XA),XA<0)XA+=vA;XA=d>XA?0:tQA(XA);while(d<XA)R[d++]=S;return R}function Qu(R,S){var d=[];return Qq(R,function(XA,vA,Z1){if(S(XA,vA,Z1))d.push(XA)}),d}function mG(R,S,d,XA,vA){var Z1=-1,M1=R.length;d||(d=e8),vA||(vA=[]);while(++Z1<M1){var b1=R[Z1];if(S>0&&d(b1))if(S>1)mG(b1,S-1,d,XA,vA);else qY(vA,b1);else if(!XA)vA[vA.length]=b1}return vA}var Bu=pQA(),Bq=pQA(!0);function YF(R,S){return R&&Bu(R,S,kK)}function RX(R,S){return R&&Bq(R,S,kK)}function gJ(R,S){return HZ(S,function(d){return mA(R[d])})}function OO(R,S){S=eC(S,R);var d=0,XA=S.length;while(R!=null&&d<XA)R=R[t5(S[d++])];return d&&d==XA?R:A}function xQA(R,S,d){var XA=S(R);return hB(R)?XA:qY(XA,d(R))}function RI(R){if(R==null)return R===A?_1:LA;return IJ&&IJ in f5(R)?D0(R):U2(R)}function Gu(R,S){return R>S}function Zu(R,S){return R!=null&&q8.call(R,S)}function yQA(R,S){return R!=null&&S in f5(R)}function vQA(R,S,d){return R>=hJ(S,d)&&R<MY(S,d)}function Ev(R,S,d){var XA=d?uG:DG,vA=R[0].length,Z1=R.length,M1=Z1,b1=R0(Z1),I0=1/0,KQ=[];while(M1--){var HQ=R[M1];if(M1&&S)HQ=a3(HQ,I6(S));I0=hJ(HQ.length,I0),b1[M1]=!d&&(S||vA>=120&&HQ.length>=120)?new AE(M1&&HQ):A}HQ=R[0];var yQ=-1,nB=b1[0];A:while(++yQ<vA&&KQ.length<I0){var G9=HQ[yQ],U4=S?S(G9):G9;if(G9=d||G9!==0?G9:0,!(nB?MX(nB,U4):XA(KQ,U4,d))){M1=Z1;while(--M1){var K6=b1[M1];if(!(K6?MX(K6,U4):XA(R[M1],U4,d)))continue A}if(nB)nB.push(U4);KQ.push(G9)}}return KQ}function RO(R,S,d,XA){return YF(R,function(vA,Z1,M1){S(XA,d(vA),Z1,M1)}),XA}function BE(R,S,d){S=eC(S,R),R=L8(R,S);var XA=R==null?R:R[t5(M8(S))];return XA==null?A:A4(XA,R,d)}function _I(R){return e1(R)&&RI(R)==YA}function sC(R){return e1(R)&&RI(R)==n0}function _X(R){return e1(R)&&RI(R)==TA}function Dv(R,S,d,XA,vA){if(R===S)return!0;if(R==null||S==null||!e1(R)&&!e1(S))return R!==R&&S!==S;return dXA(R,S,d,XA,Dv,vA)}function dXA(R,S,d,XA,vA,Z1){var M1=hB(R),b1=hB(S),I0=M1?ZA:gQ(R),KQ=b1?ZA:gQ(S);I0=I0==YA?nA:I0,KQ=KQ==YA?nA:KQ;var HQ=I0==nA,yQ=KQ==nA,nB=I0==KQ;if(nB&&Rj(R)){if(!Rj(S))return!1;M1=!0,HQ=!1}if(nB&&!HQ)return Z1||(Z1=new QE),M1||vX(R)?zj(R,S,d,XA,vA,Z1):oQA(R,S,I0,d,XA,vA,Z1);if(!(d&E)){var G9=HQ&&q8.call(R,"__wrapped__"),U4=yQ&&q8.call(S,"__wrapped__");if(G9||U4){var K6=G9?R.value():R,$4=U4?S.value():S;return Z1||(Z1=new QE),vA(K6,$4,d,XA,Z1)}}if(!nB)return!1;return Z1||(Z1=new QE),h(R,S,d,XA,vA,Z1)}function XJ(R){return e1(R)&&gQ(R)==NA}function UD(R,S,d,XA){var vA=d.length,Z1=vA,M1=!XA;if(R==null)return!Z1;R=f5(R);while(vA--){var b1=d[vA];if(M1&&b1[2]?b1[1]!==R[b1[0]]:!(b1[0]in R))return!1}while(++vA<Z1){b1=d[vA];var I0=b1[0],KQ=R[I0],HQ=b1[1];if(M1&&b1[2]){if(KQ===A&&!(I0 in R))return!1}else{var yQ=new QE;if(XA)var nB=XA(KQ,HQ,I0,R,S,yQ);if(!(nB===A?Dv(HQ,KQ,E|D,XA,yQ):nB))return!1}}return!0}function GE(R){if(!U1(R)||HG(R))return!1;var S=mA(R)?xXA:B9;return S.test(TI(R))}function Da(R){return e1(R)&&RI(R)==q1}function kQA(R){return e1(R)&&gQ(R)==_A}function Hv(R){return e1(R)&&L1(R.length)&&!!h6[RI(R)]}function Ha(R){if(typeof R=="function")return R;if(R==null)return Yz;if(typeof R=="object")return hB(R)?JF(R[0],R[1]):fQA(R);return sJ0(R)}function Yu(R){if(!D3(R))return og(R);var S=[];for(var d in f5(R))if(q8.call(R,d)&&d!="constructor")S.push(d);return S}function Fa(R){if(!U1(R))return qB(R);var S=D3(R),d=[];for(var XA in R)if(!(XA=="constructor"&&(S||!q8.call(R,XA))))d.push(XA);return d}function OK(R,S){return R<S}function Ju(R,S){var d=-1,XA=Q4(R)?R0(R.length):[];return Qq(R,function(vA,Z1,M1){XA[++d]=S(vA,Z1,M1)}),XA}function fQA(R){var S=P1(R);if(S.length==1&&S[0][2])return A5(S[0][0],S[0][1]);return function(d){return d===R||UD(d,R,S)}}function JF(R,S){if(h8(R)&&y9(S))return A5(t5(R),S);return function(d){var XA=m71(d,R);return XA===A&&XA===S?d71(d,R):Dv(S,XA,E|D)}}function tC(R,S,d,XA,vA){if(R===S)return;Bu(S,function(Z1,M1){if(vA||(vA=new QE),U1(Z1))cXA(R,S,M1,d,tC,XA,vA);else{var b1=XA?XA(Q5(R,M1),Z1,M1+"",R,S,vA):A;if(b1===A)b1=Z1;eg(R,M1,b1)}},Zz)}function cXA(R,S,d,XA,vA,Z1,M1){var b1=Q5(R,d),I0=Q5(S,d),KQ=M1.get(I0);if(KQ){eg(R,d,KQ);return}var HQ=Z1?Z1(b1,I0,d+"",R,S,M1):A,yQ=HQ===A;if(yQ){var nB=hB(I0),G9=!nB&&Rj(I0),U4=!nB&&!G9&&vX(I0);if(HQ=I0,nB||G9||U4)if(hB(b1))HQ=b1;else if(B8(b1))HQ=_K(b1);else if(G9)yQ=!1,HQ=u4(I0,!0);else if(U4)yQ=!1,HQ=uQA(I0,!0);else HQ=[];else if(e5(I0)||V9(I0)){if(HQ=b1,V9(b1))HQ=GWA(b1);else if(!U1(b1)||mA(b1))HQ=e6(I0)}else yQ=!1}if(yQ)M1.set(I0,HQ),vA(HQ,I0,XA,Z1,M1),M1.delete(I0);eg(R,d,HQ)}function Ca(R,S){var d=R.length;if(!d)return;return S+=S<0?d:0,m4(S,d)?R[S]:A}function bQA(R,S,d){if(S.length)S=a3(S,function(Z1){if(hB(Z1))return function(M1){return OO(M1,Z1.length===1?Z1[0]:Z1)};return Z1});else S=[Yz];var XA=-1;S=a3(S,I6(E1()));var vA=Ju(R,function(Z1,M1,b1){var I0=a3(S,function(KQ){return KQ(Z1)});return{criteria:I0,index:++XA,value:Z1}});return a2(vA,function(Z1,M1){return sXA(Z1,M1,d)})}function Fv(R,S){return Cv(R,S,function(d,XA){return d71(R,XA)})}function Cv(R,S,d){var XA=-1,vA=S.length,Z1={};while(++XA<vA){var M1=S[XA],b1=OO(R,M1);if(d(b1,M1))Uv(Z1,eC(M1,R),b1)}return Z1}function pXA(R){return function(S){return OO(S,R)}}function za(R,S,d,XA){var vA=XA?wA:F$,Z1=-1,M1=S.length,b1=R;if(R===S)S=_K(S);if(d)b1=a3(R,I6(d));while(++Z1<M1){var I0=0,KQ=S[Z1],HQ=d?d(KQ):KQ;while((I0=vA(b1,HQ,I0,XA))>-1){if(b1!==R)QF.call(b1,I0,1);QF.call(R,I0,1)}}return R}function Ej(R,S){var d=R?S.length:0,XA=d-1;while(d--){var vA=S[d];if(d==XA||vA!==Z1){var Z1=vA;if(m4(vA))QF.call(R,vA,1);else wa(R,vA)}}return R}function Ua(R,S){return R+ng(LK()*(S-R+1))}function lXA(R,S,d,XA){var vA=-1,Z1=MY(qO((S-R)/(d||1)),0),M1=R0(Z1);while(Z1--)M1[XA?Z1:++vA]=R,R+=d;return M1}function zv(R,S){var d="";if(!R||S<1||S>t)return d;do{if(S%2)d+=R;if(S=ng(S/2),S)R+=R}while(S);return d}function O3(R,S){return mJ(y2(R,S,Yz),R+"")}function hQA(R){return Vv(QBA(R))}function iXA(R,S){var d=QBA(R);return N5(d,w$(S,0,d.length))}function Uv(R,S,d,XA){if(!U1(R))return R;S=eC(S,R);var vA=-1,Z1=S.length,M1=Z1-1,b1=R;while(b1!=null&&++vA<Z1){var I0=t5(S[vA]),KQ=d;if(I0==="__proto__"||I0==="constructor"||I0==="prototype")return R;if(vA!=M1){var HQ=b1[I0];if(KQ=XA?XA(HQ,I0,b1):A,KQ===A)KQ=U1(HQ)?HQ:m4(S[vA+1])?[]:{}}eN(b1,I0,KQ),b1=b1[I0]}return R}var Iu=!Ij?Yz:function(R,S){return Ij.set(R,S),R},nXA=!NO?Yz:function(R,S){return NO(R,"toString",{configurable:!0,enumerable:!1,value:p71(S),writable:!0})};function aXA(R){return N5(QBA(R))}function WJ(R,S,d){var XA=-1,vA=R.length;if(S<0)S=-S>vA?0:vA+S;if(d=d>vA?vA:d,d<0)d+=vA;vA=S>d?0:d-S>>>0,S>>>=0;var Z1=R0(vA);while(++XA<vA)Z1[XA]=R[XA+S];return Z1}function oXA(R,S){var d;return Qq(R,function(XA,vA,Z1){return d=S(XA,vA,Z1),!d}),!!d}function Gq(R,S,d){var XA=0,vA=R==null?XA:R.length;if(typeof S=="number"&&S===S&&vA<=PA){while(XA<vA){var Z1=XA+vA>>>1,M1=R[Z1];if(M1!==null&&!wZ(M1)&&(d?M1<=S:M1<S))XA=Z1+1;else vA=Z1}return vA}return Zq(R,S,Yz,d)}function Zq(R,S,d,XA){var vA=0,Z1=R==null?0:R.length;if(Z1===0)return 0;S=d(S);var M1=S!==S,b1=S===null,I0=wZ(S),KQ=S===A;while(vA<Z1){var HQ=ng((vA+Z1)/2),yQ=d(R[HQ]),nB=yQ!==A,G9=yQ===null,U4=yQ===yQ,K6=wZ(yQ);if(M1)var $4=XA||U4;else if(KQ)$4=U4&&(XA||nB);else if(b1)$4=U4&&nB&&(XA||!G9);else if(I0)$4=U4&&nB&&!G9&&(XA||!K6);else if(G9||K6)$4=!1;else $4=XA?yQ<=S:yQ<S;if($4)vA=HQ+1;else Z1=HQ}return hJ(Z1,IA)}function gQA(R,S){var d=-1,XA=R.length,vA=0,Z1=[];while(++d<XA){var M1=R[d],b1=S?S(M1):M1;if(!d||!zQ(b1,I0)){var I0=b1;Z1[vA++]=M1===0?0:M1}}return Z1}function $a(R){if(typeof R=="number")return R;if(wZ(R))return VA;return+R}function RK(R){if(typeof R=="string")return R;if(hB(R))return a3(R,RK)+"";if(wZ(R))return gXA?gXA.call(R):"";var S=R+"";return S=="0"&&1/R==-c?"-0":S}function Yq(R,S,d){var XA=-1,vA=DG,Z1=R.length,M1=!0,b1=[],I0=b1;if(d)M1=!1,vA=uG;else if(Z1>=B){var KQ=S?null:nQA(R);if(KQ)return nN(KQ);M1=!1,vA=MX,I0=new AE}else I0=S?[]:b1;A:while(++XA<Z1){var HQ=R[XA],yQ=S?S(HQ):HQ;if(HQ=d||HQ!==0?HQ:0,M1&&yQ===yQ){var nB=I0.length;while(nB--)if(I0[nB]===yQ)continue A;if(S)I0.push(yQ);b1.push(HQ)}else if(!vA(I0,yQ,d)){if(I0!==b1)I0.push(yQ);b1.push(HQ)}}return b1}function wa(R,S){return S=eC(S,R),R=L8(R,S),R==null||delete R[t5(M8(S))]}function Dj(R,S,d,XA){return Uv(R,S,d(OO(R,S)),XA)}function $v(R,S,d,XA){var vA=R.length,Z1=XA?vA:-1;while((XA?Z1--:++Z1<vA)&&S(R[Z1],Z1,R));return d?WJ(R,XA?0:Z1,XA?Z1+1:vA):WJ(R,XA?Z1+1:0,XA?vA:Z1)}function Na(R,S){var d=R;if(d instanceof E3)d=d.value();return bJ(S,function(XA,vA){return vA.func.apply(vA.thisArg,qY([XA],vA.args))},d)}function Xu(R,S,d){var XA=R.length;if(XA<2)return XA?Yq(R[0]):[];var vA=-1,Z1=R0(XA);while(++vA<XA){var M1=R[vA],b1=-1;while(++b1<XA)if(b1!=vA)Z1[vA]=q$(Z1[vA]||M1,R[b1],S,d)}return Yq(mG(Z1,1),S,d)}function qa(R,S,d){var XA=-1,vA=R.length,Z1=S.length,M1={};while(++XA<vA){var b1=XA<Z1?S[XA]:A;d(M1,R[XA],b1)}return M1}function Hj(R){return B8(R)?R:[]}function wv(R){return typeof R=="function"?R:Yz}function eC(R,S){if(hB(R))return R;return h8(R,S)?[R]:TX(g8(R))}var M4=O3;function Jq(R,S,d){var XA=R.length;return d=d===A?XA:d,!S&&d>=XA?R:WJ(R,S,d)}var Nv=Bj||function(R){return EG.clearTimeout(R)};function u4(R,S){if(S)return R.slice();var d=R.length,XA=TW?TW(d):new R.constructor(d);return R.copy(XA),XA}function qv(R){var S=new R.constructor(R.byteLength);return new ig(S).set(new ig(R)),S}function rXA(R,S){var d=S?qv(R.buffer):R.buffer;return new R.constructor(d,R.byteOffset,R.byteLength)}function Wu(R){var S=new R.constructor(R.source,X9.exec(R));return S.lastIndex=R.lastIndex,S}function La(R){return Jv?f5(Jv.call(R)):{}}function uQA(R,S){var d=S?qv(R.buffer):R.buffer;return new R.constructor(d,R.byteOffset,R.length)}function mQA(R,S){if(R!==S){var d=R!==A,XA=R===null,vA=R===R,Z1=wZ(R),M1=S!==A,b1=S===null,I0=S===S,KQ=wZ(S);if(!b1&&!KQ&&!Z1&&R>S||Z1&&M1&&I0&&!b1&&!KQ||XA&&M1&&I0||!d&&I0||!vA)return 1;if(!XA&&!Z1&&!KQ&&R<S||KQ&&d&&vA&&!XA&&!Z1||b1&&d&&vA||!M1&&vA||!I0)return-1}return 0}function sXA(R,S,d){var XA=-1,vA=R.criteria,Z1=S.criteria,M1=vA.length,b1=d.length;while(++XA<M1){var I0=mQA(vA[XA],Z1[XA]);if(I0){if(XA>=b1)return I0;var KQ=d[XA];return I0*(KQ=="desc"?-1:1)}}return R.index-S.index}function dQA(R,S,d,XA){var vA=-1,Z1=R.length,M1=d.length,b1=-1,I0=S.length,KQ=MY(Z1-M1,0),HQ=R0(I0+KQ),yQ=!XA;while(++b1<I0)HQ[b1]=S[b1];while(++vA<M1)if(yQ||vA<Z1)HQ[d[vA]]=R[vA];while(KQ--)HQ[b1++]=R[vA++];return HQ}function Ku(R,S,d,XA){var vA=-1,Z1=R.length,M1=-1,b1=d.length,I0=-1,KQ=S.length,HQ=MY(Z1-b1,0),yQ=R0(HQ+KQ),nB=!XA;while(++vA<HQ)yQ[vA]=R[vA];var G9=vA;while(++I0<KQ)yQ[G9+I0]=S[I0];while(++M1<b1)if(nB||vA<Z1)yQ[G9+d[M1]]=R[vA++];return yQ}function _K(R,S){var d=-1,XA=R.length;S||(S=R0(XA));while(++d<XA)S[d]=R[d];return S}function Az(R,S,d,XA){var vA=!d;d||(d={});var Z1=-1,M1=S.length;while(++Z1<M1){var b1=S[Z1],I0=XA?XA(d[b1],R[b1],b1,d,R):A;if(I0===A)I0=R[b1];if(vA)GF(d,b1,I0);else eN(d,b1,I0)}return d}function tXA(R,S){return Az(R,X0(R),S)}function cQA(R,S){return Az(R,$Q(R),S)}function $D(R,S){return function(d,XA){var vA=hB(d)?bB:Vj,Z1=S?S():{};return vA(d,R,E1(XA,2),Z1)}}function _O(R){return O3(function(S,d){var XA=-1,vA=d.length,Z1=vA>1?d[vA-1]:A,M1=vA>2?d[2]:A;if(Z1=R.length>3&&typeof Z1=="function"?(vA--,Z1):A,M1&&f4(d[0],d[1],M1))Z1=vA<3?A:Z1,vA=1;S=f5(S);while(++XA<vA){var b1=d[XA];if(b1)R(S,b1,XA,Z1)}return S})}function TO(R,S){return function(d,XA){if(d==null)return d;if(!Q4(d))return R(d,XA);var vA=d.length,Z1=S?vA:-1,M1=f5(d);while(S?Z1--:++Z1<vA)if(XA(M1[Z1],Z1,M1)===!1)break;return d}}function pQA(R){return function(S,d,XA){var vA=-1,Z1=f5(S),M1=XA(S),b1=M1.length;while(b1--){var I0=M1[R?b1:++vA];if(d(Z1[I0],I0,Z1)===!1)break}return S}}function Lv(R,S,d){var XA=S&H,vA=L$(R);function Z1(){var M1=this&&this!==EG&&this instanceof Z1?vA:R;return M1.apply(XA?d:this,arguments)}return Z1}function Fj(R){return function(S){S=g8(S);var d=sT(S)?RW(S):A,XA=d?d[0]:S.charAt(0),vA=d?Jq(d,1).join(""):S.slice(1);return XA[R]()+vA}}function PW(R){return function(S){return bJ(oJ0(aJ0(S).replace(UK,"")),R,"")}}function L$(R){return function(){var S=arguments;switch(S.length){case 0:return new R;case 1:return new R(S[0]);case 2:return new R(S[0],S[1]);case 3:return new R(S[0],S[1],S[2]);case 4:return new R(S[0],S[1],S[2],S[3]);case 5:return new R(S[0],S[1],S[2],S[3],S[4]);case 6:return new R(S[0],S[1],S[2],S[3],S[4],S[5]);case 7:return new R(S[0],S[1],S[2],S[3],S[4],S[5],S[6])}var d=OY(R.prototype),XA=R.apply(d,S);return U1(XA)?XA:d}}function eXA(R,S,d){var XA=L$(R);function vA(){var Z1=arguments.length,M1=R0(Z1),b1=Z1,I0=R1(vA);while(b1--)M1[b1]=arguments[b1];var KQ=Z1<3&&M1[0]!==I0&&M1[Z1-1]!==I0?[]:f7(M1,I0);if(Z1-=KQ.length,Z1<d)return Vu(R,S,Mv,vA.placeholder,A,M1,KQ,A,A,d-Z1);var HQ=this&&this!==EG&&this instanceof vA?XA:R;return A4(HQ,this,M1)}return vA}function lQA(R){return function(S,d,XA){var vA=f5(S);if(!Q4(S)){var Z1=E1(d,3);S=kK(S),d=function(b1){return Z1(vA[b1],b1,vA)}}var M1=R(S,d,XA);return M1>-1?vA[Z1?S[M1]:M1]:A}}function iQA(R){return n(function(S){var d=S.length,XA=d,vA=dZ.prototype.thru;if(R)S.reverse();while(XA--){var Z1=S[XA];if(typeof Z1!="function")throw new qK(Z);if(vA&&!M1&&Y1(Z1)=="wrapper")var M1=new dZ([],!0)}XA=M1?XA:d;while(++XA<d){Z1=S[XA];var b1=Y1(Z1),I0=b1=="wrapper"?EA(Z1):A;if(I0&&J4(I0[0])&&I0[1]==(_|$|M|T)&&!I0[4].length&&I0[9]==1)M1=M1[Y1(I0[0])].apply(M1,I0[3]);else M1=Z1.length==1&&J4(Z1)?M1[b1]():M1.thru(Z1)}return function(){var KQ=arguments,HQ=KQ[0];if(M1&&KQ.length==1&&hB(HQ))return M1.plant(HQ).value();var yQ=0,nB=d?S[yQ].apply(this,KQ):HQ;while(++yQ<d)nB=S[yQ].call(this,nB);return nB}})}function Mv(R,S,d,XA,vA,Z1,M1,b1,I0,KQ){var HQ=S&_,yQ=S&H,nB=S&F,G9=S&($|O),U4=S&x,K6=nB?A:L$(R);function $4(){var G8=arguments.length,u8=R0(G8),P$=G8;while(P$--)u8[P$]=arguments[P$];if(G9)var DF=R1($4),S$=eH(u8,DF);if(XA)u8=dQA(u8,XA,vA,G9);if(Z1)u8=Ku(u8,Z1,M1,G9);if(G8-=S$,G9&&G8<KQ){var SI=f7(u8,DF);return Vu(R,S,Mv,$4.placeholder,d,u8,SI,b1,I0,KQ-G8)}var dO=yQ?d:this,vv=nB?dO[R]:R;if(G8=u8.length,b1)u8=h7(u8,b1);else if(U4&&G8>1)u8.reverse();if(HQ&&I0<G8)u8.length=I0;if(this&&this!==EG&&this instanceof $4)vv=K6||L$(vv);return vv.apply(dO,u8)}return $4}function jO(R,S){return function(d,XA){return RO(d,R,S(XA),{})}}function PO(R,S){return function(d,XA){var vA;if(d===A&&XA===A)return S;if(d!==A)vA=d;if(XA!==A){if(vA===A)return XA;if(typeof d=="string"||typeof XA=="string")d=RK(d),XA=RK(XA);else d=$a(d),XA=$a(XA);vA=R(d,XA)}return vA}}function Ov(R){return n(function(S){return S=a3(S,I6(E1())),O3(function(d){var XA=this;return R(S,function(vA){return A4(vA,XA,d)})})})}function Rv(R,S){S=S===A?" ":RK(S);var d=S.length;if(d<2)return d?zv(S,R):S;var XA=zv(S,qO(R/UO(S)));return sT(S)?Jq(RW(XA),0,R).join(""):XA.slice(0,R)}function _v(R,S,d,XA){var vA=S&H,Z1=L$(R);function M1(){var b1=-1,I0=arguments.length,KQ=-1,HQ=XA.length,yQ=R0(HQ+I0),nB=this&&this!==EG&&this instanceof M1?Z1:R;while(++KQ<HQ)yQ[KQ]=XA[KQ];while(I0--)yQ[KQ++]=arguments[++b1];return A4(nB,vA?d:this,yQ)}return M1}function TK(R){return function(S,d,XA){if(XA&&typeof XA!="number"&&f4(S,d,XA))d=XA=A;if(S=Gz(S),d===A)d=S,S=0;else d=Gz(d);return XA=XA===A?S<d?1:-1:Gz(XA),lXA(S,d,XA,R)}}function Cj(R){return function(S,d){if(!(typeof S=="string"&&typeof d=="string"))S=_D(S),d=_D(d);return R(S,d)}}function Vu(R,S,d,XA,vA,Z1,M1,b1,I0,KQ){var HQ=S&$,yQ=HQ?M1:A,nB=HQ?A:M1,G9=HQ?Z1:A,U4=HQ?A:Z1;if(S|=HQ?M:L,S&=~(HQ?L:M),!(S&C))S&=~(H|F);var K6=[R,S,vA,G9,yQ,U4,nB,b1,I0,KQ],$4=d.apply(A,K6);if(J4(R))g6($4,K6);return $4.placeholder=XA,dG($4,R,S)}function Eu(R){var S=w5[R];return function(d,XA){if(d=_D(d),XA=XA==null?0:hJ(H3(XA),292),XA&&ag(d)){var vA=(g8(d)+"e").split("e"),Z1=S(vA[0]+"e"+(+vA[1]+XA));return vA=(g8(Z1)+"e").split("e"),+(vA[0]+"e"+(+vA[1]-XA))}return S(d)}}var nQA=!(Jj&&1/nN(new Jj([,-0]))[1]==c)?n71:function(R){return new Jj(R)};function Ma(R){return function(S){var d=gQ(S);if(d==NA)return on(S);if(d==_A)return qQA(S);return FZ(S,R(S))}}function M$(R,S,d,XA,vA,Z1,M1,b1){var I0=S&F;if(!I0&&typeof R!="function")throw new qK(Z);var KQ=XA?XA.length:0;if(!KQ)S&=~(M|L),XA=vA=A;if(M1=M1===A?M1:MY(H3(M1),0),b1=b1===A?b1:H3(b1),KQ-=vA?vA.length:0,S&L){var HQ=XA,yQ=vA;XA=vA=A}var nB=I0?A:EA(R),G9=[R,S,d,XA,vA,HQ,yQ,Z1,M1,b1];if(nB)uJ(G9,nB);if(R=G9[0],S=G9[1],d=G9[2],XA=G9[3],vA=G9[4],b1=G9[9]=G9[9]===A?I0?0:R.length:MY(G9[9]-KQ,0),!b1&&S&($|O))S&=~($|O);if(!S||S==H)var U4=Lv(R,S,d);else if(S==$||S==O)U4=eXA(R,S,b1);else if((S==M||S==(H|M))&&!vA.length)U4=_v(R,S,d,XA);else U4=Mv.apply(A,G9);var K6=nB?Iu:g6;return dG(K6(U4,G9),R,S)}function Oa(R,S,d,XA){if(R===A||zQ(R,C$[d])&&!q8.call(XA,d))return S;return R}function wD(R,S,d,XA,vA,Z1){if(U1(R)&&U1(S))Z1.set(S,R),tC(R,S,A,wD,Z1),Z1.delete(S);return R}function aQA(R){return e5(R)?A:R}function zj(R,S,d,XA,vA,Z1){var M1=d&E,b1=R.length,I0=S.length;if(b1!=I0&&!(M1&&I0>b1))return!1;var KQ=Z1.get(R),HQ=Z1.get(S);if(KQ&&HQ)return KQ==S&&HQ==R;var yQ=-1,nB=!0,G9=d&D?new AE:A;Z1.set(R,S),Z1.set(S,R);while(++yQ<b1){var U4=R[yQ],K6=S[yQ];if(XA)var $4=M1?XA(K6,U4,yQ,S,R,Z1):XA(U4,K6,yQ,R,S,Z1);if($4!==A){if($4)continue;nB=!1;break}if(G9){if(!sH(S,function(G8,u8){if(!MX(G9,u8)&&(U4===G8||vA(U4,G8,d,XA,Z1)))return G9.push(u8)})){nB=!1;break}}else if(!(U4===K6||vA(U4,K6,d,XA,Z1))){nB=!1;break}}return Z1.delete(R),Z1.delete(S),nB}function oQA(R,S,d,XA,vA,Z1,M1){switch(d){case JQ:if(R.byteLength!=S.byteLength||R.byteOffset!=S.byteOffset)return!1;R=R.buffer,S=S.buffer;case n0:if(R.byteLength!=S.byteLength||!Z1(new ig(R),new ig(S)))return!1;return!0;case bA:case TA:case UA:return zQ(+R,+S);case JA:return R.name==S.name&&R.message==S.message;case q1:case Q1:return R==S+"";case NA:var b1=on;case _A:var I0=XA&E;if(b1||(b1=nN),R.size!=S.size&&!I0)return!1;var KQ=M1.get(R);if(KQ)return KQ==S;XA|=D,M1.set(R,S);var HQ=zj(b1(R),b1(S),XA,vA,Z1,M1);return M1.delete(R),HQ;case h1:if(Jv)return Jv.call(R)==Jv.call(S)}return!1}function h(R,S,d,XA,vA,Z1){var M1=d&E,b1=a(R),I0=b1.length,KQ=a(S),HQ=KQ.length;if(I0!=HQ&&!M1)return!1;var yQ=I0;while(yQ--){var nB=b1[yQ];if(!(M1?nB in S:q8.call(S,nB)))return!1}var G9=Z1.get(R),U4=Z1.get(S);if(G9&&U4)return G9==S&&U4==R;var K6=!0;Z1.set(R,S),Z1.set(S,R);var $4=M1;while(++yQ<I0){nB=b1[yQ];var G8=R[nB],u8=S[nB];if(XA)var P$=M1?XA(u8,G8,nB,S,R,Z1):XA(G8,u8,nB,R,S,Z1);if(!(P$===A?G8===u8||vA(G8,u8,d,XA,Z1):P$)){K6=!1;break}$4||($4=nB=="constructor")}if(K6&&!$4){var DF=R.constructor,S$=S.constructor;if(DF!=S$&&(("constructor"in R)&&("constructor"in S))&&!(typeof DF=="function"&&DF instanceof DF&&typeof S$=="function"&&S$ instanceof S$))K6=!1}return Z1.delete(R),Z1.delete(S),K6}function n(R){return mJ(y2(R,A,GQ),R+"")}function a(R){return xQA(R,kK,X0)}function DA(R){return xQA(R,Zz,$Q)}var EA=!Ij?n71:function(R){return Ij.get(R)};function Y1(R){var S=R.name+"",d=rC[S],XA=q8.call(rC,S)?d.length:0;while(XA--){var vA=d[XA],Z1=vA.func;if(Z1==null||Z1==R)return vA.name}return S}function R1(R){var S=q8.call(sA,"placeholder")?sA:R;return S.placeholder}function E1(){var R=sA.iteratee||l71;return R=R===l71?Ha:R,arguments.length?R(arguments[0],arguments[1]):R}function G1(R,S){var d=R.__data__;return cZ(S)?d[typeof S=="string"?"string":"hash"]:d.map}function P1(R){var S=kK(R),d=S.length;while(d--){var XA=S[d],vA=R[XA];S[d]=[XA,vA,y9(vA)]}return S}function m1(R,S){var d=zO(R,S);return GE(d)?d:A}function D0(R){var S=q8.call(R,IJ),d=R[IJ];try{R[IJ]=A;var XA=!0}catch(Z1){}var vA=Bv.call(R);if(XA)if(S)R[IJ]=d;else delete R[IJ];return vA}var X0=!Gj?a71:function(R){if(R==null)return[];return R=f5(R),HZ(Gj(R),function(S){return wO.call(R,S)})},$Q=!Gj?a71:function(R){var S=[];while(R)qY(S,X0(R)),R=Gv(R);return S},gQ=RI;if(OX&&gQ(new OX(new ArrayBuffer(1)))!=JQ||Zj&&gQ(new Zj)!=NA||Yj&&gQ(Yj.resolve())!=gA||Jj&&gQ(new Jj)!=_A||MK&&gQ(new MK)!=V0)gQ=function(R){var S=RI(R),d=S==nA?R.constructor:A,XA=d?TI(d):"";if(XA)switch(XA){case fXA:return JQ;case bXA:return NA;case Aa:return gA;case hXA:return _A;case Qa:return V0}return S};function F2(R,S,d){var XA=-1,vA=d.length;while(++XA<vA){var Z1=d[XA],M1=Z1.size;switch(Z1.type){case"drop":R+=M1;break;case"dropRight":S-=M1;break;case"take":S=hJ(S,R+M1);break;case"takeRight":R=MY(R,S-M1);break}}return{start:R,end:S}}function GB(R){var S=R.match(iA);return S?S[1].split(z1):[]}function c2(R,S,d){S=eC(S,R);var XA=-1,vA=S.length,Z1=!1;while(++XA<vA){var M1=t5(S[XA]);if(!(Z1=R!=null&&d(R,M1)))break;R=R[M1]}if(Z1||++XA!=vA)return Z1;return vA=R==null?0:R.length,!!vA&&L1(vA)&&m4(M1,vA)&&(hB(R)||V9(R))}function O4(R){var S=R.length,d=new R.constructor(S);if(S&&typeof R[0]=="string"&&q8.call(R,"index"))d.index=R.index,d.input=R.input;return d}function e6(R){return typeof R.constructor=="function"&&!D3(R)?OY(Gv(R)):{}}function iB(R,S,d){var XA=R.constructor;switch(S){case n0:return qv(R);case bA:case TA:return new XA(+R);case JQ:return rXA(R,d);case BQ:case F1:case eA:case K1:case O1:case G0:case $0:case F0:case HA:return uQA(R,d);case NA:return new XA;case UA:case Q1:return new XA(R);case q1:return Wu(R);case _A:return new XA;case h1:return La(R)}}function Y4(R,S){var d=S.length;if(!d)return R;var XA=d-1;return S[XA]=(d>1?"& ":"")+S[XA],S=S.join(d>2?", ":" "),R.replace(V1,`{
bundles/ClaudeAgentSDKCode/cli.js:4696:`)),process.exit(1)}}function vD5(){w9("eagerLoadSettings_start");let A=process.argv.findIndex((B)=>B==="--settings");if(A!==-1&&A+1<process.argv.length){let B=process.argv[A+1];if(B)xD5(B)}let Q=process.argv.findIndex((B)=>B==="--setting-sources");if(Q!==-1&&Q+1<process.argv.length){let B=process.argv[Q+1];if(B!==void 0)yD5(B)}w9("eagerLoadSettings_end")}function kD5(A){if(process.env.CLAUDE_CODE_ENTRYPOINT)return;let Q=process.argv.slice(2),B=Q.indexOf("mcp");if(B!==-1&&Q[B+1]==="serve"){process.env.CLAUDE_CODE_ENTRYPOINT="mcp";return}if(C0(process.env.CLAUDE_CODE_ACTION)){process.env.CLAUDE_CODE_ENTRYPOINT="claude-code-github-action";return}process.env.CLAUDE_CODE_ENTRYPOINT=A?"sdk-cli":"cli"}async function fD5(){w9("main_function_start"),process.env.NoDefaultCurrentDirectoryInExePath="1",Tu2(),process.on("exit",()=>{mD5()}),process.on("SIGINT",()=>{process.exit(0)}),w9("main_warning_handler_initialized");let A=process.argv.slice(2),Q=A.includes("-p")||A.includes("--print"),B=A.some((J)=>J.startsWith("--sdk-url")),G=Q||B||!process.stdout.isTTY;QK0(!G),kD5(G);let Y=(()=>{if(process.env.GITHUB_ACTIONS==="true")return"github-action";if(process.env.CLAUDE_CODE_ENTRYPOINT==="sdk-ts")return"sdk-typescript";if(process.env.CLAUDE_CODE_ENTRYPOINT==="sdk-py")return"sdk-python";if(process.env.CLAUDE_CODE_ENTRYPOINT==="sdk-cli")return"sdk-cli";if(process.env.CLAUDE_CODE_ENTRYPOINT==="claude-vscode")return"claude-vscode";if(process.env.CLAUDE_CODE_SESSION_ACCESS_TOKEN||process.env.CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR)return"remote";return"cli"})();BK0(Y),w9("main_client_type_determined"),vD5(),w9("main_before_run"),process.title="claude",await gD5(),w9("main_after_run")}function bD5(A){let Q=0,B={exitOnCtrlC:A,onFlicker:(G,Z,Y,J)=>{if(J==="resize")return;let I=Date.now();if(I-Q<1000)s("tengu_flicker",{desiredHeight:G,actualHeight:Z,ink2Enabled:Y,reason:J});Q=I}};if(!process.stdin.isTTY&&!C0(!1)&&!process.argv.includes("mcp")){if(s("tengu_stdin_interactive",{}),process.platform!=="win32")try{let G=LD5("/dev/tty","r");B={...B,stdin:new qD5(G)}}catch(G){r(G)}}return B}async function hD5(A,Q){if(!process.stdin.isTTY&&!process.argv.includes("mcp")){if(Q==="stream-json")return process.stdin;process.stdin.setEncoding("utf8");let B="";return process.stdin.on("data",(G)=>{B+=G}),await new Promise((G)=>{process.stdin.on("end",G)}),[A,B].filter(Boolean).join(`[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "nl -ba src/platform/node/host.ts | sed -n '260,460p'"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 51ms:[0m
[2m   260	      const stored: StoredFile = { version, value, updatedAtMs: Date.now() };
   261	      await atomicWriteFile(filePath, JSON.stringify(stored), 0o600);
   262	      return { version };
   263	    },
   264	    delete: async (ns, key, opts) => {
   265	      const filePath = storageKeyPath(rootDir, ns, key);
   266	      if (opts?.expectedVersion !== undefined) {
   267	        const existing = await (async () => {
   268	          try {
   269	            const raw = await fs.readFile(filePath, { encoding: "utf8" });
   270	            const parsed = JSON.parse(raw) as StoredFile;
   271	            if (!parsed || typeof parsed.version !== "string") return null;
   272	            return parsed;
   273	          } catch (error) {
   274	            if ((error as NodeJS.ErrnoException).code === "ENOENT") return null;
   275	            return null;
   276	          }
   277	        })();
   278	        const actualVersion = existing?.version ?? null;
   279	        const expected = opts.expectedVersion;[0m

[35m[3mthinking[0m[0m
**Updating implementation files**

I need to update the file in the implementation directory. I also want to add a changelog, probably creating a new directory under changelogs/implementation-20251217-093335. However, I see there‚Äôs already a previous phase changelog in that folder. Hmm, should I follow that pattern or create a new folder with a timestamp instead? It might help to list the existing changelogs to make a more informed decision.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'ls -la changelogs'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 59ms:[0m
[2mtotal 24
drwxr-xr-x  11 ronaldeddings  staff    352 Dec 17 09:33 .
drwxr-xr-x  22 ronaldeddings  staff    704 Dec 17 09:11 ..
-rw-r--r--@  1 ronaldeddings  staff  10244 Dec 17 05:50 .DS_Store
drwxr-xr-x   7 ronaldeddings  staff    224 Dec 16 08:35 1-rewrite-plan-20251216-074742
drwxr-xr-x   2 ronaldeddings  staff     64 Dec 16 11:22 implementation-20251216-112218
drwxr-xr-x   7 ronaldeddings  staff    224 Dec 16 12:37 implementation-20251216-112501
drwxr-xr-x   3 ronaldeddings  staff     96 Dec 16 12:54 implementation-20251216-125408
drwxr-xr-x   3 ronaldeddings  staff     96 Dec 16 13:43 implementation-20251216-134333
drwxr-xr-x   3 ronaldeddings  staff     96 Dec 17 05:57 implementation-20251217-052000
drwxr-xr-x   5 ronaldeddings  staff    160 Dec 17 09:43 implementation-20251217-092658
drwxr-xr-x   7 ronaldeddings  staff    224 Dec 17 09:43 implementation-20251217-093335[0m

[35m[3mthinking[0m[0m
**Considering changelog implementation**

I‚Äôve noticed that there's a new folder from December 17, 2025, which contains the phase 5 changelog. I'm thinking it would make sense to create a new file named `phase-6-changelog.md` in the same folder. That seems like a logical step! Let's go ahead and list the contents of that folder to confirm everything is in place.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'ls -la changelogs/implementation-20251217-093335'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 51ms:[0m
[2mtotal 10624
drwxr-xr-x   7 ronaldeddings  staff      224 Dec 17 09:43 .
drwxr-xr-x  11 ronaldeddings  staff      352 Dec 17 09:33 ..
-rw-r--r--   1 ronaldeddings  staff  2544685 Dec 17 09:43 phase-5-attempt-1.md
-rw-r--r--   1 ronaldeddings  staff  2546064 Dec 17 09:43 phase-5-changelog.md
-rw-r--r--   1 ronaldeddings  staff     8587 Dec 17 09:43 phase-5-validation-attempt-1.txt
-rw-r--r--   1 ronaldeddings  staff   279634 Dec 17 09:47 phase-6-attempt-1.md
-rw-r--r--   1 ronaldeddings  staff        0 Dec 17 09:43 phase-6-changelog.md[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "ls -la tests && find tests -maxdepth 1 -type f -name '*.test.ts' -print | sort"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 61ms:[0m
[2mtotal 168
drwxr-xr-x  17 ronaldeddings  staff   544 Dec 17 09:40 .
drwxr-xr-x  22 ronaldeddings  staff   704 Dec 17 09:11 ..
-rw-r--r--   1 ronaldeddings  staff  1621 Dec 17 06:26 phase1-fixtures.test.ts
-rw-r--r--   1 ronaldeddings  staff  5730 Dec 17 06:28 phase1-legacy-spec.test.ts
-rw-r--r--   1 ronaldeddings  staff  3870 Dec 17 06:02 phase2-architecture-boundaries.test.ts
-rw-r--r--   1 ronaldeddings  staff  3530 Dec 17 06:53 phase3-determinism.test.ts
-rw-r--r--   1 ronaldeddings  staff  4244 Dec 17 06:51 phase3-event-bus.test.ts
-rw-r--r--   1 ronaldeddings  staff  3331 Dec 17 06:58 phase3-replay-adapters.test.ts
-rw-r--r--   1 ronaldeddings  staff  2034 Dec 17 06:35 phase3-replay-conformance.test.ts
-rw-r--r--   1 ronaldeddings  staff  8174 Dec 17 07:01 phase3-runtime.test.ts
-rw-r--r--   1 ronaldeddings  staff  1775 Dec 17 07:08 phase3-shutdown-summary.test.ts
-rw-r--r--   1 ronaldeddings  staff  6102 Dec 17 05:56 phase4-capabilities.test.ts
-rw-r--r--   1 ronaldeddings  staff  1249 Dec 17 07:16 phase4-leak-prevention.test.ts
-rw-r--r--   1 ronaldeddings  staff  4623 Dec 17 07:16 phase4-mobile-safe-conformance.test.ts
-rw-r--r--   1 ronaldeddings  staff  3515 Dec 17 09:40 phase5-notifications-and-redaction.test.ts
-rw-r--r--   1 ronaldeddings  staff  6536 Dec 17 07:24 phase5-queues-and-viewmodels.test.ts
-rw-r--r--   1 ronaldeddings  staff  2931 Dec 17 05:57 phase5-state.test.ts
tests/phase1-fixtures.test.ts
tests/phase1-legacy-spec.test.ts[0m

[35m[3mthinking[0m[0m
**Planning phase 6 tests**

I‚Äôm thinking about the Phase 6 tests, which will probably be in a file named `phase6-settings.test.ts`. I wonder if we should follow the bun:test style for consistency. I should really take a look at the existing test file to identify any patterns that we could mimic. This will help ensure we're on the right track with our testing approach!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,220p' tests/phase4-capabilities.test.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 44ms:[0m
[2mimport { describe, expect, test } from "bun:test";
import os from "node:os";
import path from "node:path";
import { mkdtemp, rm } from "node:fs/promises";
import {
  CapabilityPolicyDeniedError,
  CapabilityUnavailableError,
  availableCapability,
  requireCapability,
  unavailableCapability
} from "../src/core/types/host.js";
import { normalizePortablePath } from "../src/core/filesystem/path.js";
import { computeBackoffDelayMs, retryWithBackoff } from "../src/core/network/retry.js";
import { allowAllCapabilitiesPolicy } from "../src/core/capabilities/policy.js";
import { createCapabilityView } from "../src/core/capabilities/view.js";
import { buildCapabilityComplianceReport } from "../src/core/capabilities/compliance.js";
import { createNodeHostCapabilities } from "../src/platform/node/host.js";

describe("Phase 4: host capabilities", () => {
  test("requireCapability throws typed errors", () => {[0m





[35m[3mthinking[0m[0m
**Analyzing legacy merge behavior**

I'm thinking about how legacy merging iterates through enabled sources and merges settings using a deep merge. It's essential to clarify whether later sources override earlier ones or vice versa. If I use lodash for merging, it seems that the merge would assign properties from later sources to earlier ones. For instance, if the sources are ordered [user, project, local, flag, policy], policies might take precedence. However, I'll confirm this behavior from the old cli.js.
[35m[3mthinking[0m[0m
**Evaluating merge order and permission rules**

I'm considering the order of merging settings and how it relates to allowed sources. It seems the order would typically be user, project, and local, and I found that `LEGACY_SETTINGS_SOURCE_ORDER` lists these plus flag and policy. This implies that later sources, like policy, will override earlier ones. However, permission rules work differently; they favor earlier sources. I need to ensure our system can handle both permission rule lists and merged settings effectively, even if Phase6 doesn't implement the permission engine yet.
[35m[3mthinking[0m[0m
**Implementing settings context**

I'm focusing on how we need to ensure both merge and overlays for settings based on precedence. To achieve this, I'll create a `SettingsContext` that provides results per source. The function `getEnabledFileSettingsSources(allowedSettingSources)` will produce a deduplicated list of sources while preserving order, ideally maintaining a stable order: user, project, local, flag, and policy. Although the input order may vary, I'll ensure a consistent output by iterating through `LEGACY_SETTINGS_SOURCE_ORDER`. I just need to confirm how `allowedSettingSources` is stored.
[35m[3mthinking[0m[0m
**Determining merge order in settings**

The user likely wants the default order to be user, project, and local, but they can also specify this using the CLI flag `--setting-sources`. The parser might return a list in a specific order, like "local,user" resulting in [localSettings, userSettings], which can influence merging. It seems that legacy systems honor this order, and it makes sense for us to do the same. I'll ensure we keep the user-specified order and add policy and flag at the end, preserving the overall legacy structure.
[35m[3mthinking[0m[0m
**Clarifying settings source order**

I need to examine how we add policy and flag in the settings process since Step 2 mentions adding them but doesn‚Äôt specify an order. It seems like I could add policy first and then flag, but their order could vary depending on the context of the allowed settings. It's essential to check the implementation details in the bundle, specifically in the cli.js file, to observe how `allowedSettingSources` and associated methods are structured. I‚Äôll use a search tool to locate relevant code snippets and clarify this.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "allowedSettingSources" bundles/ClaudeCodeCode/cli.js | head -n 20'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 78ms:[0m
[2m9:`);Y=W[0]||"";for(let K=W.length-1;K>=1;K--){let V=W[K];if(V)yield V}}if(Y)yield Y}finally{await B.close()}}var qn2=5,Ln2,Mn2;var XQ=L(()=>{Y0();Ln2={cwd(){return process.cwd()},existsSync(A){return hI("existsSync",()=>k9.existsSync(A))},async stat(A){return wn2(A)},statSync(A){return hI("statSync",()=>k9.statSync(A))},lstatSync(A){return hI("lstatSync",()=>k9.lstatSync(A))},readFileSync(A,Q){return hI("readFileSync",()=>k9.readFileSync(A,{encoding:Q.encoding}))},readFileBytesSync(A){return hI("readFileBytesSync",()=>k9.readFileSync(A))},readSync(A,Q){return hI("readSync",()=>{let B=void 0;try{B=k9.openSync(A,"r");let G=Buffer.alloc(Q.length),Z=k9.readSync(B,G,0,Q.length,0);return{buffer:G,bytesRead:Z}}finally{if(B)k9.closeSync(B)}})},writeFileSync(A,Q,B){return hI("writeFileSync",()=>{let G=k9.existsSync(A);if(!B.flush){let Y={encoding:B.encoding};if(!G)Y.mode=B.mode??384;else if(B.mode!==void 0)Y.mode=B.mode;k9.writeFileSync(A,Q,Y);return}let Z;try{let Y=!G?B.mode??384:B.mode;Z=k9.openSync(A,"w",Y),k9.writeFileSync(Z,Q,{encoding:B.encoding}),k9.fsyncSync(Z)}finally{if(Z)k9.closeSync(Z)}})},appendFileSync(A,Q,B){return hI("appendFileSync",()=>{if(!k9.existsSync(A)){let G=B?.mode??384,Z=k9.openSync(A,"a",G);try{k9.appendFileSync(Z,Q)}finally{k9.closeSync(Z)}}else k9.appendFileSync(A,Q)})},copyFileSync(A,Q){return hI("copyFileSync",()=>k9.copyFileSync(A,Q))},unlinkSync(A){return hI("unlinkSync",()=>k9.unlinkSync(A))},renameSync(A,Q){return hI("renameSync",()=>k9.renameSync(A,Q))},linkSync(A,Q){return hI("linkSync",()=>k9.linkSync(A,Q))},symlinkSync(A,Q){return hI("symlinkSync",()=>k9.symlinkSync(A,Q))},readlinkSync(A){return hI("readlinkSync",()=>k9.readlinkSync(A))},realpathSync(A){return hI("realpathSync",()=>k9.realpathSync(A))},mkdirSync(A){return hI("mkdirSync",()=>{if(!k9.existsSync(A))k9.mkdirSync(A,{recursive:!0,mode:448})})},readdirSync(A){return hI("readdirSync",()=>k9.readdirSync(A,{withFileTypes:!0}))},readdirStringSync(A){return hI("readdirStringSync",()=>k9.readdirSync(A))},isDirEmptySync(A){return hI("isDirEmptySync",()=>{return this.readdirSync(A).length===0})},rmdirSync(A){return hI("rmdirSync",()=>k9.rmdirSync(A))},rmSync(A,Q){return hI("rmSync",()=>k9.rmSync(A,Q))},createWriteStream(A){return k9.createWriteStream(A)}},Mn2=Ln2});import{join as On2}from"path";import{homedir as Rn2}from"os";function mQ(){return process.env.CLAUDE_CONFIG_DIR??On2(Rn2(),".claude")}function z0(A){if(!A)return!1;if(typeof A==="boolean")return A;let Q=A.toLowerCase().trim();return["1","true","yes","on"].includes(Q)}function rC(A){if(A===void 0)return!1;if(typeof A==="boolean")return!A;if(!A)return!1;let Q=A.toLowerCase().trim();return["0","false","no","off"].includes(Q)}function UX0(A){let Q={};if(A)for(let B of A){let[G,...Z]=B.split("=");if(!G||Z.length===0)throw Error(`Invalid environment variable format: ${B}, environment variables should be added as: -e KEY1=value1 -e KEY2=value2`);Q[G]=Z.join("=")}return Q}function Na(){return process.env.AWS_REGION||process.env.AWS_DEFAULT_REGION||"us-east-1"}function vO(){return process.env.CLOUD_ML_REGION||"us-east5"}function CG1(){return z0(process.env.CLAUDE_BASH_MAINTAIN_PROJECT_WORKING_DIR)}function PjA(A){if(A?.startsWith("claude-haiku-4-5"))return process.env.VERTEX_REGION_CLAUDE_HAIKU_4_5||vO();if(A?.startsWith("claude-3-5-haiku"))return process.env.VERTEX_REGION_CLAUDE_3_5_HAIKU||vO();if(A?.startsWith("claude-3-5-sonnet"))return process.env.VERTEX_REGION_CLAUDE_3_5_SONNET||vO();if(A?.startsWith("claude-3-7-sonnet"))return process.env.VERTEX_REGION_CLAUDE_3_7_SONNET||vO();if(A?.startsWith("claude-opus-4-1"))return process.env.VERTEX_REGION_CLAUDE_4_1_OPUS||vO();if(A?.startsWith("claude-opus-4"))return process.env.VERTEX_REGION_CLAUDE_4_0_OPUS||vO();if(A?.startsWith("claude-sonnet-4-5"))return process.env.VERTEX_REGION_CLAUDE_4_5_SONNET||vO();if(A?.startsWith("claude-sonnet-4"))return process.env.VERTEX_REGION_CLAUDE_4_0_SONNET||vO();return vO()}var rQ=()=>{};function _n2(){this.__data__=new Ku,this.size=0}var $X0;var wX0=L(()=>{BWA();$X0=_n2});function Tn2(A){var Q=this.__data__,B=Q.delete(A);return this.size=Q.size,B}var NX0;var qX0=L(()=>{NX0=Tn2});function jn2(A){return this.__data__.get(A)}var LX0;var MX0=L(()=>{LX0=jn2});function Pn2(A){return this.__data__.has(A)}var OX0;var RX0=L(()=>{OX0=Pn2});function xn2(A,Q){var B=this.__data__;if(B instanceof Ku){var G=B.__data__;if(!Vu||G.length<Sn2-1)return G.push([A,Q]),this.size=++B.size,this;B=this.__data__=new $a(G)}return B.set(A,Q),this.size=B.size,this}var Sn2=200,_X0;var TX0=L(()=>{BWA();TjA();jjA();_X0=xn2});function XBA(A){var Q=this.__data__=new Ku(A);this.size=Q.size}var Dj;var ZWA=L(()=>{BWA();wX0();qX0();MX0();RX0();TX0();XBA.prototype.clear=$X0;XBA.prototype.delete=NX0;XBA.prototype.get=LX0;XBA.prototype.has=OX0;XBA.prototype.set=_X0;Dj=XBA});function vn2(A){return this.__data__.set(A,yn2),this}var yn2="__lodash_hash_undefined__",jX0;var PX0=L(()=>{jX0=vn2});function kn2(A){return this.__data__.has(A)}var SX0;var xX0=L(()=>{SX0=kn2});function SjA(A){var Q=-1,B=A==null?0:A.length;this.__data__=new $a;while(++Q<B)this.add(A[Q])}var xjA;var zG1=L(()=>{jjA();PX0();xX0();SjA.prototype.add=SjA.prototype.push=jX0;SjA.prototype.has=SX0;xjA=SjA});function fn2(A,Q){var B=-1,G=A==null?0:A.length;while(++B<G)if(Q(A[B],B,A))return!0;return!1}var yX0;var vX0=L(()=>{yX0=fn2});function bn2(A,Q){return A.has(Q)}var yjA;var UG1=L(()=>{yjA=bn2});function un2(A,Q,B,G,Z,Y){var J=B&hn2,I=A.length,X=Q.length;if(I!=X&&!(J&&X>I))return!1;var W=Y.get(A),K=Y.get(Q);if(W&&K)return W==Q&&K==A;var V=-1,E=!0,D=B&gn2?new xjA:void 0;Y.set(A,Q),Y.set(Q,A);while(++V<I){var H=A[V],F=Q[V];if(G)var C=J?G(F,H,V,Q,A,Y):G(H,F,V,A,Q,Y);if(C!==void 0){if(C)continue;E=!1;break}if(D){if(!yX0(Q,function(U,O){if(!yjA(D,O)&&(H===U||Z(H,U,B,G,Y)))return D.push(O)})){E=!1;break}}else if(!(H===F||Z(H,F,B,G,Y))){E=!1;break}}return Y.delete(A),Y.delete(Q),E}var hn2=1,gn2=2,vjA;var $G1=L(()=>{zG1();vX0();UG1();vjA=un2});var mn2,WBA;var wG1=L(()=>{yO();mn2=fX.Uint8Array,WBA=mn2});function dn2(A){var Q=-1,B=Array(A.size);return A.forEach(function(G,Z){B[++Q]=[Z,G]}),B}var kX0;var fX0=L(()=>{kX0=dn2});function cn2(A){var Q=-1,B=Array(A.size);return A.forEach(function(G){B[++Q]=G}),B}var KBA;var kjA=L(()=>{KBA=cn2});function Ga2(A,Q,B,G,Z,Y,J){switch(B){case Ba2:if(A.byteLength!=Q.byteLength||A.byteOffset!=Q.byteOffset)return!1;A=A.buffer,Q=Q.buffer;case Qa2:if(A.byteLength!=Q.byteLength||!Y(new WBA(A),new WBA(Q)))return!1;return!0;case in2:case nn2:case rn2:return Ej(+A,+Q);case an2:return A.name==Q.name&&A.message==Q.message;case sn2:case en2:return A==Q+"";case on2:var I=kX0;case tn2:var X=G&pn2;if(I||(I=KBA),A.size!=Q.size&&!X)return!1;var W=J.get(A);if(W)return W==Q;G|=ln2,J.set(A,Q);var K=vjA(I(A),I(Q),G,Z,Y,J);return J.delete(A),K;case Aa2:if(NG1)return NG1.call(A)==NG1.call(Q)}return!1}var pn2=1,ln2=2,in2="[object Boolean]",nn2="[object Date]",an2="[object Error]",on2="[object Map]",rn2="[object Number]",sn2="[object RegExp]",tn2="[object Set]",en2="[object String]",Aa2="[object Symbol]",Qa2="[object ArrayBuffer]",Ba2="[object DataView]",bX0,NG1,hX0;var gX0=L(()=>{za();wG1();YBA();$G1();fX0();kjA();bX0=SK?SK.prototype:void 0,NG1=bX0?bX0.valueOf:void 0;hX0=Ga2});function Za2(A,Q){var B=-1,G=Q.length,Z=A.length;while(++B<G)A[Z+B]=Q[B];return A}var VBA;var fjA=L(()=>{VBA=Za2});var Ya2,V7;var ZF=L(()=>{Ya2=Array.isArray,V7=Ya2});function Ja2(A,Q,B){var G=Q(A);return V7(A)?G:VBA(G,B(A))}var bjA;var qG1=L(()=>{fjA();ZF();bjA=Ja2});function Ia2(A,Q){var B=-1,G=A==null?0:A.length,Z=0,Y=[];while(++B<G){var J=A[B];if(Q(J,B,A))Y[Z++]=J}return Y}var hjA;var LG1=L(()=>{hjA=Ia2});function Xa2(){return[]}var gjA;var MG1=L(()=>{gjA=Xa2});var Wa2,Ka2,uX0,Va2,EBA;var ujA=L(()=>{LG1();MG1();Wa2=Object.prototype,Ka2=Wa2.propertyIsEnumerable,uX0=Object.getOwnPropertySymbols,Va2=!uX0?gjA:function(A){if(A==null)return[];return A=Object(A),hjA(uX0(A),function(Q){return Ka2.call(A,Q)})},EBA=Va2});function Ea2(A,Q){var B=-1,G=Array(A);while(++B<A)G[B]=Q(B);return G}var mX0;var dX0=L(()=>{mX0=Ea2});function Da2(A){return A!=null&&typeof A=="object"}var fW;var Hj=L(()=>{fW=Da2});function Fa2(A){return fW(A)&&V$(A)==Ha2}var Ha2="[object Arguments]",OG1;var cX0=L(()=>{Ua();Hj();OG1=Fa2});var pX0,Ca2,za2,Ua2,$v;var YWA=L(()=>{cX0();Hj();pX0=Object.prototype,Ca2=pX0.hasOwnProperty,za2=pX0.propertyIsEnumerable,Ua2=OG1(function(){return arguments}())?OG1:function(A){return fW(A)&&Ca2.call(A,"callee")&&!za2.call(A,"callee")},$v=Ua2});function $a2(){return!1}var lX0;var iX0=L(()=>{lX0=$a2});var djA={};EG(djA,{default:()=>Fj});var oX0,nX0,wa2,aX0,Na2,qa2,Fj;var JWA=L(()=>{yO();iX0();oX0=typeof djA=="object"&&djA&&!djA.nodeType&&djA,nX0=oX0&&typeof mjA=="object"&&mjA&&!mjA.nodeType&&mjA,wa2=nX0&&nX0.exports===oX0,aX0=wa2?fX.Buffer:void 0,Na2=aX0?aX0.isBuffer:void 0,qa2=Na2||lX0,Fj=qa2});function Oa2(A,Q){var B=typeof A;return Q=Q==null?La2:Q,!!Q&&(B=="number"||B!="symbol"&&Ma2.test(A))&&(A>-1&&A%1==0&&A<Q)}var La2=9007199254740991,Ma2,Du;var IWA=L(()=>{Ma2=/^(?:0|[1-9]\d*)$/;Du=Oa2});function _a2(A){return typeof A=="number"&&A>-1&&A%1==0&&A<=Ra2}var Ra2=9007199254740991,DBA;var cjA=L(()=>{DBA=_a2});function ta2(A){return fW(A)&&DBA(A.length)&&!!oZ[V$(A)]}var Ta2="[object Arguments]",ja2="[object Array]",Pa2="[object Boolean]",Sa2="[object Date]",xa2="[object Error]",ya2="[object Function]",va2="[object Map]",ka2="[object Number]",fa2="[object Object]",ba2="[object RegExp]",ha2="[object Set]",ga2="[object String]",ua2="[object WeakMap]",ma2="[object ArrayBuffer]",da2="[object DataView]",ca2="[object Float32Array]",pa2="[object Float64Array]",la2="[object Int8Array]",ia2="[object Int16Array]",na2="[object Int32Array]",aa2="[object Uint8Array]",oa2="[object Uint8ClampedArray]",ra2="[object Uint16Array]",sa2="[object Uint32Array]",oZ,rX0;var sX0=L(()=>{Ua();cjA();Hj();oZ={};oZ[ca2]=oZ[pa2]=oZ[la2]=oZ[ia2]=oZ[na2]=oZ[aa2]=oZ[oa2]=oZ[ra2]=oZ[sa2]=!0;oZ[Ta2]=oZ[ja2]=oZ[ma2]=oZ[Pa2]=oZ[da2]=oZ[Sa2]=oZ[xa2]=oZ[ya2]=oZ[va2]=oZ[ka2]=oZ[fa2]=oZ[ba2]=oZ[ha2]=oZ[ga2]=oZ[ua2]=!1;rX0=ta2});function ea2(A){return function(Q){return A(Q)}}var HBA;var pjA=L(()=>{HBA=ea2});var ijA={};EG(ijA,{default:()=>Cj});var tX0,XWA,Ao2,RG1,Qo2,Cj;var njA=L(()=>{EG1();tX0=typeof ijA=="object"&&ijA&&!ijA.nodeType&&ijA,XWA=tX0&&typeof ljA=="object"&&ljA&&!ljA.nodeType&&ljA,Ao2=XWA&&XWA.exports===tX0,RG1=Ao2&&OjA.process,Qo2=function(){try{var A=XWA&&XWA.require&&XWA.require("util").types;if(A)return A;return RG1&&RG1.binding&&RG1.binding("util")}catch(Q){}}(),Cj=Qo2});var eX0,Bo2,FBA;var ajA=L(()=>{sX0();pjA();njA();eX0=Cj&&Cj.isTypedArray,Bo2=eX0?HBA(eX0):rX0,FBA=Bo2});function Yo2(A,Q){var B=V7(A),G=!B&&$v(A),Z=!B&&!G&&Fj(A),Y=!B&&!G&&!Z&&FBA(A),J=B||G||Z||Y,I=J?mX0(A.length,String):[],X=I.length;for(var W in A)if((Q||Zo2.call(A,W))&&!(J&&(W=="length"||Z&&(W=="offset"||W=="parent")||Y&&(W=="buffer"||W=="byteLength"||W=="byteOffset")||Du(W,X))))I.push(W);return I}var Go2,Zo2,ojA;var _G1=L(()=>{dX0();YWA();ZF();JWA();IWA();ajA();Go2=Object.prototype,Zo2=Go2.hasOwnProperty;ojA=Yo2});function Io2(A){var Q=A&&A.constructor,B=typeof Q=="function"&&Q.prototype||Jo2;return A===B}var Jo2,CBA;var rjA=L(()=>{Jo2=Object.prototype;CBA=Io2});function Xo2(A,Q){return function(B){return A(Q(B))}}var sjA;var TG1=L(()=>{sjA=Xo2});var Wo2,AW0;var QW0=L(()=>{TG1();Wo2=sjA(Object.keys,Object),AW0=Wo2});function Eo2(A){if(!CBA(A))return AW0(A);var Q=[];for(var B in Object(A))if(Vo2.call(A,B)&&B!="constructor")Q.push(B);return Q}var Ko2,Vo2,BW0;var GW0=L(()=>{rjA();QW0();Ko2=Object.prototype,Vo2=Ko2.hasOwnProperty;BW0=Eo2});function Do2(A){return A!=null&&DBA(A.length)&&!GBA(A)}var zj;var zBA=L(()=>{RjA();cjA();zj=Do2});function Ho2(A){return zj(A)?ojA(A):BW0(A)}var oN;var qa=L(()=>{_G1();GW0();zBA();oN=Ho2});function Fo2(A){return bjA(A,oN,EBA)}var WWA;var jG1=L(()=>{qG1();ujA();qa();WWA=Fo2});function $o2(A,Q,B,G,Z,Y){var J=B&Co2,I=WWA(A),X=I.length,W=WWA(Q),K=W.length;if(X!=K&&!J)return!1;var V=X;while(V--){var E=I[V];if(!(J?E in Q:Uo2.call(Q,E)))return!1}var D=Y.get(A),H=Y.get(Q);if(D&&H)return D==Q&&H==A;var F=!0;Y.set(A,Q),Y.set(Q,A);var C=J;while(++V<X){E=I[V];var U=A[E],O=Q[E];if(G)var q=J?G(O,U,E,Q,A,Y):G(U,O,E,A,Q,Y);if(!(q===void 0?U===O||Z(U,O,B,G,Y):q)){F=!1;break}C||(C=E=="constructor")}if(F&&!C){var M=A.constructor,_=Q.constructor;if(M!=_&&(("constructor"in A)&&("constructor"in Q))&&!(typeof M=="function"&&M instanceof M&&typeof _=="function"&&_ instanceof _))F=!1}return Y.delete(A),Y.delete(Q),F}var Co2=1,zo2,Uo2,ZW0;var YW0=L(()=>{jG1();zo2=Object.prototype,Uo2=zo2.hasOwnProperty;ZW0=$o2});var wo2,tjA;var JW0=L(()=>{Xu();yO();wo2=oC(fX,"DataView"),tjA=wo2});var No2,ejA;var IW0=L(()=>{Xu();yO();No2=oC(fX,"Promise"),ejA=No2});var qo2,Hu;var PG1=L(()=>{Xu();yO();qo2=oC(fX,"Set"),Hu=qo2});var Lo2,APA;var XW0=L(()=>{Xu();yO();Lo2=oC(fX,"WeakMap"),APA=Lo2});var WW0="[object Map]",Mo2="[object Object]",KW0="[object Promise]",VW0="[object Set]",EW0="[object WeakMap]",DW0="[object DataView]",Oo2,Ro2,_o2,To2,jo2,La,wv;var KWA=L(()=>{JW0();TjA();IW0();PG1();XW0();Ua();DG1();Oo2=Cv(tjA),Ro2=Cv(Vu),_o2=Cv(ejA),To2=Cv(Hu),jo2=Cv(APA),La=V$;if(tjA&&La(new tjA(new ArrayBuffer(1)))!=DW0||Vu&&La(new Vu)!=WW0||ejA&&La(ejA.resolve())!=KW0||Hu&&La(new Hu)!=VW0||APA&&La(new APA)!=EW0)La=function(A){var Q=V$(A),B=Q==Mo2?A.constructor:void 0,G=B?Cv(B):"";if(G)switch(G){case Oo2:return DW0;case Ro2:return WW0;case _o2:return KW0;case To2:return VW0;case jo2:return EW0}return Q};wv=La});function xo2(A,Q,B,G,Z,Y){var J=V7(A),I=V7(Q),X=J?FW0:wv(A),W=I?FW0:wv(Q);X=X==HW0?QPA:X,W=W==HW0?QPA:W;var K=X==QPA,V=W==QPA,E=X==W;if(E&&Fj(A)){if(!Fj(Q))return!1;J=!0,K=!1}if(E&&!K)return Y||(Y=new Dj),J||FBA(A)?vjA(A,Q,B,G,Z,Y):hX0(A,Q,X,B,G,Z,Y);if(!(B&Po2)){var D=K&&CW0.call(A,"__wrapped__"),H=V&&CW0.call(Q,"__wrapped__");if(D||H){var F=D?A.value():A,C=H?Q.value():Q;return Y||(Y=new Dj),Z(F,C,B,G,Y)}}if(!E)return!1;return Y||(Y=new Dj),ZW0(A,Q,B,G,Z,Y)}var Po2=1,HW0="[object Arguments]",FW0="[object Array]",QPA="[object Object]",So2,CW0,zW0;var UW0=L(()=>{ZWA();$G1();gX0();YW0();KWA();ZF();JWA();ajA();So2=Object.prototype,CW0=So2.hasOwnProperty;zW0=xo2});function $W0(A,Q,B,G,Z){if(A===Q)return!0;if(A==null||Q==null||!fW(A)&&!fW(Q))return A!==A&&Q!==Q;return zW0(A,Q,B,G,$W0,Z)}var UBA;var BPA=L(()=>{UW0();Hj();UBA=$W0});function ko2(A,Q,B,G){var Z=B.length,Y=Z,J=!G;if(A==null)return!Y;A=Object(A);while(Z--){var I=B[Z];if(J&&I[2]?I[1]!==A[I[0]]:!(I[0]in A))return!1}while(++Z<Y){I=B[Z];var X=I[0],W=A[X],K=I[1];if(J&&I[2]){if(W===void 0&&!(X in A))return!1}else{var V=new Dj;if(G)var E=G(W,K,X,A,Q,V);if(!(E===void 0?UBA(K,W,yo2|vo2,G,V):E))return!1}}return!0}var yo2=1,vo2=2,wW0;var NW0=L(()=>{ZWA();BPA();wW0=ko2});function fo2(A){return A===A&&!FJ(A)}var GPA;var SG1=L(()=>{aN();GPA=fo2});function bo2(A){var Q=oN(A),B=Q.length;while(B--){var G=Q[B],Z=A[G];Q[B]=[G,Z,GPA(Z)]}return Q}var qW0;var LW0=L(()=>{SG1();qa();qW0=bo2});function ho2(A,Q){return function(B){if(B==null)return!1;return B[A]===Q&&(Q!==void 0||(A in Object(B)))}}var ZPA;var xG1=L(()=>{ZPA=ho2});function go2(A){var Q=qW0(A);if(Q.length==1&&Q[0][2])return ZPA(Q[0][0],Q[0][1]);return function(B){return B===A||wW0(B,A,Q)}}var MW0;var OW0=L(()=>{NW0();LW0();xG1();MW0=go2});function mo2(A){return typeof A=="symbol"||fW(A)&&V$(A)==uo2}var uo2="[object Symbol]",$BA;var YPA=L(()=>{Ua();Hj();$BA=mo2});function po2(A,Q){if(V7(A))return!1;var B=typeof A;if(B=="number"||B=="symbol"||B=="boolean"||A==null||$BA(A))return!0;return co2.test(A)||!do2.test(A)||Q!=null&&A in Object(Q)}var do2,co2,wBA;var JPA=L(()=>{ZF();YPA();do2=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,co2=/^\w*$/;wBA=po2});function io2(A){var Q=Z0(A,function(G){if(B.size===lo2)B.clear();return G}),B=Q.cache;return Q}var lo2=500,RW0;var _W0=L(()=>{o2();RW0=io2});var no2,ao2,oo2,TW0;var jW0=L(()=>{_W0();no2=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,ao2=/\\(\\)?/g,oo2=RW0(function(A){var Q=[];if(A.charCodeAt(0)===46)Q.push("");return A.replace(no2,function(B,G,Z,Y){Q.push(Z?Y.replace(ao2,"$1"):G||B)}),Q}),TW0=oo2});function ro2(A,Q){var B=-1,G=A==null?0:A.length,Z=Array(G);while(++B<G)Z[B]=Q(A[B],B,A);return Z}var NBA;var IPA=L(()=>{NBA=ro2});function xW0(A){if(typeof A=="string")return A;if(V7(A))return NBA(A,xW0)+"";if($BA(A))return SW0?SW0.call(A):"";var Q=A+"";return Q=="0"&&1/A==-so2?"-0":Q}var so2=1/0,PW0,SW0,yW0;var vW0=L(()=>{za();IPA();ZF();YPA();PW0=SK?SK.prototype:void 0,SW0=PW0?PW0.toString:void 0;yW0=xW0});function to2(A){return A==null?"":yW0(A)}var qBA;var XPA=L(()=>{vW0();qBA=to2});function eo2(A,Q){if(V7(A))return A;return wBA(A,Q)?[A]:TW0(qBA(A))}var Uj;var LBA=L(()=>{ZF();JPA();jW0();XPA();Uj=eo2});function Qr2(A){if(typeof A=="string"||$BA(A))return A;var Q=A+"";return Q=="0"&&1/A==-Ar2?"-0":Q}var Ar2=1/0,rN;var Ma=L(()=>{YPA();rN=Qr2});function Br2(A,Q){Q=Uj(Q,A);var B=0,G=Q.length;while(A!=null&&B<G)A=A[rN(Q[B++])];return B&&B==G?A:void 0}var MBA;var WPA=L(()=>{LBA();Ma();MBA=Br2});function Gr2(A,Q,B){var G=A==null?void 0:MBA(A,Q);return G===void 0?B:G}var kW0;var fW0=L(()=>{WPA();kW0=Gr2});function Zr2(A,Q){return A!=null&&Q in Object(A)}var bW0;var hW0=L(()=>{bW0=Zr2});function Yr2(A,Q,B){Q=Uj(Q,A);var G=-1,Z=Q.length,Y=!1;while(++G<Z){var J=rN(Q[G]);if(!(Y=A!=null&&B(A,J)))break;A=A[J]}if(Y||++G!=Z)return Y;return Z=A==null?0:A.length,!!Z&&DBA(Z)&&Du(J,Z)&&(V7(A)||$v(A))}var gW0;var uW0=L(()=>{LBA();YWA();ZF();IWA();cjA();Ma();gW0=Yr2});function Jr2(A,Q){return A!=null&&gW0(A,Q,bW0)}var mW0;var dW0=L(()=>{hW0();uW0();mW0=Jr2});function Wr2(A,Q){if(wBA(A)&&GPA(Q))return ZPA(rN(A),Q);return function(B){var G=kW0(B,A);return G===void 0&&G===Q?mW0(B,A):UBA(Q,G,Ir2|Xr2)}}var Ir2=1,Xr2=2,cW0;var pW0=L(()=>{BPA();fW0();dW0();JPA();SG1();xG1();Ma();cW0=Wr2});function Kr2(A){return A}var OBA;var KPA=L(()=>{OBA=Kr2});function Vr2(A){return function(Q){return Q==null?void 0:Q[A]}}var lW0;var iW0=L(()=>{lW0=Vr2});function Er2(A){return function(Q){return MBA(Q,A)}}var nW0;var aW0=L(()=>{WPA();nW0=Er2});function Dr2(A){return wBA(A)?lW0(rN(A)):nW0(A)}var oW0;var rW0=L(()=>{iW0();aW0();JPA();Ma();oW0=Dr2});function Hr2(A){if(typeof A=="function")return A;if(A==null)return OBA;if(typeof A=="object")return V7(A)?cW0(A[0],A[1]):MW0(A);return oW0(A)}var $j;var RBA=L(()=>{OW0();pW0();KPA();ZF();rW0();$j=Hr2});function Fr2(A,Q){var B,G=-1,Z=A.length;while(++G<Z){var Y=Q(A[G]);if(Y!==void 0)B=B===void 0?Y:B+Y}return B}var sW0;var tW0=L(()=>{sW0=Fr2});function Cr2(A,Q){return A&&A.length?sW0(A,$j(Q,2)):0}var _BA;var eW0=L(()=>{RBA();tW0();_BA=Cr2});var VPA,EPA;var DPA=L(()=>{VPA={name:"BASH_MAX_OUTPUT_LENGTH",default:30000,validate:(A)=>{if(!A)return{effective:30000,status:"valid"};let G=parseInt(A,10);if(isNaN(G)||G<=0)return{effective:30000,status:"invalid",message:`Invalid value "${A}" (using default: 30000)`};if(G>150000)return{effective:150000,status:"capped",message:`Capped from ${G} to 150000`};return{effective:G,status:"valid"}}},EPA={name:"CLAUDE_CODE_MAX_OUTPUT_TOKENS",default:32000,validate:(A)=>{if(!A)return{effective:32000,status:"valid"};let G=parseInt(A,10);if(isNaN(G)||G<=0)return{effective:32000,status:"invalid",message:`Invalid value "${A}" (using default: 32000)`};if(G>64000)return{effective:64000,status:"capped",message:`Capped from ${G} to 64000`};return{effective:G,status:"valid"}}}});function sN(A){if(A.includes("[2m]"))return 2000000;if(A.includes("[1m]"))return 1e6;return 200000}var yG1=20000;import{cwd as zr2}from"process";import{realpathSync as Ur2}from"fs";import{randomUUID as AK0}from"crypto";function $r2(){let A="";if(typeof process<"u"&&typeof process.cwd==="function")A=Ur2(zr2());return{originalCwd:A,totalCostUSD:0,totalAPIDuration:0,totalAPIDurationWithoutRetries:0,totalToolDuration:0,startTime:Date.now(),lastInteractionTime:Date.now(),totalLinesAdded:0,totalLinesRemoved:0,hasUnknownModelCost:!1,cwd:A,modelUsage:{},mainLoopModelOverride:void 0,initialMainLoopModel:null,modelStrings:null,isInteractive:!1,clientType:"cli",sessionIngressToken:void 0,oauthTokenFromFd:void 0,apiKeyFromFd:void 0,flagSettingsPath:void 0,allowedSettingSources:["userSettings","projectSettings","localSettings","flagSettings","policySettings"],meter:null,sessionCounter:null,locCounter:null,prCounter:null,commitCounter:null,costCounter:null,tokenCounter:null,codeEditToolDecisionCounter:null,activeTimeCounter:null,sessionId:AK0(),loggerProvider:null,eventLogger:null,meterProvider:null,tracerProvider:null,agentColorMap:new Map,agentColorIndex:0,envVarValidators:[VPA,EPA],lastAPIRequest:null,inMemoryErrorLog:[],inlinePlugins:[],sessionBypassPermissionsMode:!1,sessionPersistenceDisabled:!1,hasExitedPlanMode:!1,needsPlanModeExitAttachment:!1,initJsonSchema:null,registeredHooks:null,planSlugCache:new Map}}function W0(){return QQ.sessionId}function QK0(){return QQ.sessionId=AK0(),QQ.sessionId}function E$(A){if(QQ.sessionId=A,process.env.CLAUDE_CODE_SESSION_ID!==void 0)process.env.CLAUDE_CODE_SESSION_ID=A}function pQ(){return QQ.originalCwd}function BK0(A){QQ.originalCwd=A}function TBA(){return QQ.cwd}function GK0(A){QQ.cwd=A}function ZK0(A,Q){QQ.totalAPIDuration+=A,QQ.totalAPIDurationWithoutRetries+=Q}function YK0(A,Q,B){QQ.totalCostUSD+=A;let G=QQ.modelUsage[B]??{inputTokens:0,outputTokens:0,cacheReadInputTokens:0,cacheCreationInputTokens:0,webSearchRequests:0,costUSD:0,contextWindow:0};G.inputTokens+=Q.input_tokens,G.outputTokens+=Q.output_tokens,G.cacheReadInputTokens+=Q.cache_read_input_tokens??0,G.cacheCreationInputTokens+=Q.cache_creation_input_tokens??0,G.webSearchRequests+=Q.server_tool_use?.web_search_requests??0,G.costUSD+=A,G.contextWindow=sN(B),QQ.modelUsage[B]=G}function sV(){return QQ.totalCostUSD}function tN(){return QQ.totalAPIDuration}function VWA(){return Date.now()-QQ.startTime}function JK0(){return QQ.totalAPIDurationWithoutRetries}function IK0(){return QQ.totalToolDuration}function vG1(A){QQ.totalToolDuration+=A}function EWA(){QQ.lastInteractionTime=Date.now()}function kG1(A,Q){QQ.totalLinesAdded+=A,QQ.totalLinesRemoved+=Q}function jBA(){return QQ.totalLinesAdded}function PBA(){return QQ.totalLinesRemoved}function HPA(){return _BA(Object.values(QQ.modelUsage),"inputTokens")}function FPA(){return _BA(Object.values(QQ.modelUsage),"outputTokens")}function XK0(){return _BA(Object.values(QQ.modelUsage),"cacheReadInputTokens")}function WK0(){return _BA(Object.values(QQ.modelUsage),"cacheCreationInputTokens")}function KK0(){return _BA(Object.values(QQ.modelUsage),"webSearchRequests")}function fG1(){QQ.hasUnknownModelCost=!0}function VK0(){return QQ.hasUnknownModelCost}function CPA(){return QQ.lastInteractionTime}function Nv(){return QQ.modelUsage}function bG1(){return QQ.mainLoopModelOverride}function zPA(){return QQ.initialMainLoopModel}function Oa(A){QQ.mainLoopModelOverride=A}function EK0(A){QQ.initialMainLoopModel=A}function DWA(){QQ.totalCostUSD=0,QQ.totalAPIDuration=0,QQ.totalAPIDurationWithoutRetries=0,QQ.totalToolDuration=0,QQ.startTime=Date.now(),QQ.totalLinesAdded=0,QQ.totalLinesRemoved=0,QQ.hasUnknownModelCost=!1,QQ.modelUsage={}}function UPA({totalCostUSD:A,totalAPIDuration:Q,totalAPIDurationWithoutRetries:B,totalToolDuration:G,totalLinesAdded:Z,totalLinesRemoved:Y,lastDuration:J,modelUsage:I}){if(QQ.totalCostUSD=A,QQ.totalAPIDuration=Q,QQ.totalAPIDurationWithoutRetries=B,QQ.totalToolDuration=G,QQ.totalLinesAdded=Z,QQ.totalLinesRemoved=Y,I)QQ.modelUsage=I;if(J)QQ.startTime=Date.now()-J}function $PA(){return QQ.modelStrings}function hG1(A){QQ.modelStrings=A}function DK0(A,Q){QQ.meter=A,QQ.sessionCounter=Q("claude_code.session.count",{description:"Count of CLI sessions started"}),QQ.locCounter=Q("claude_code.lines_of_code.count",{description:"Count of lines of code modified, with the 'type' attribute indicating whether lines were added or removed"}),QQ.prCounter=Q("claude_code.pull_request.count",{description:"Number of pull requests created"}),QQ.commitCounter=Q("claude_code.commit.count",{description:"Number of git commits created"}),QQ.costCounter=Q("claude_code.cost.usage",{description:"Cost of the Claude Code session",unit:"USD"}),QQ.tokenCounter=Q("claude_code.token.usage",{description:"Number of tokens used",unit:"tokens"}),QQ.codeEditToolDecisionCounter=Q("claude_code.code_edit_tool.decision",{description:"Count of code editing tool permission decisions (accept/reject) for Edit, Write, and NotebookEdit tools"}),QQ.activeTimeCounter=Q("claude_code.active_time.total",{description:"Total active time in seconds",unit:"s"})}function HK0(){return QQ.sessionCounter}function gG1(){return QQ.locCounter}function uG1(){return QQ.prCounter}function FK0(){return QQ.commitCounter}function CK0(){return QQ.costCounter}function HWA(){return QQ.tokenCounter}function FWA(){return QQ.codeEditToolDecisionCounter}function mG1(){return QQ.activeTimeCounter}function dG1(){return QQ.loggerProvider}function zK0(A){QQ.loggerProvider=A}function UK0(){return QQ.eventLogger}function $K0(A){QQ.eventLogger=A}function wK0(){return QQ.meterProvider}function NK0(A){QQ.meterProvider=A}function cG1(){return QQ.tracerProvider}function qK0(A){QQ.tracerProvider=A}function D4(){return!QQ.isInteractive}function SBA(){return QQ.isInteractive}function LK0(A){QQ.isInteractive=A}function wPA(){return QQ.clientType}function MK0(A){QQ.clientType=A}function pG1(){return QQ.agentColorMap}function NPA(){return QQ.flagSettingsPath}function OK0(A){QQ.flagSettingsPath=A}function RK0(){return QQ.sessionIngressToken}function xBA(A){QQ.sessionIngressToken=A}function _K0(){return QQ.oauthTokenFromFd}function yBA(A){QQ.oauthTokenFromFd=A}function TK0(){return QQ.apiKeyFromFd}function vBA(A){QQ.apiKeyFromFd=A}function jK0(){return QQ.envVarValidators}function PK0(A){QQ.lastAPIRequest=A}function qPA(){return QQ.lastAPIRequest}function SK0(){return[...QQ.inMemoryErrorLog]}function xK0(A){if(QQ.inMemoryErrorLog.length>=100)QQ.inMemoryErrorLog.shift();QQ.inMemoryErrorLog.push(A)}function yK0(){return QQ.allowedSettingSources}function vK0(A){QQ.allowedSettingSources=A}function kK0(){return D4()&&QQ.clientType!=="claude-vscode"}function fK0(A){QQ.inlinePlugins=A}function lG1(){return QQ.inlinePlugins}function bK0(A){QQ.sessionBypassPermissionsMode=A}function hK0(A){QQ.sessionPersistenceDisabled=A}function Ra(){return QQ.sessionPersistenceDisabled}function gK0(){return QQ.hasExitedPlanMode}function wj(A){QQ.hasExitedPlanMode=A}function uK0(){return QQ.needsPlanModeExitAttachment}function Nj(A){QQ.needsPlanModeExitAttachment=A}function mK0(A){QQ.initJsonSchema=A}function iG1(){return QQ.initJsonSchema}function LPA(A){if(!QQ.registeredHooks)QQ.registeredHooks={};for(let[Q,B]of Object.entries(A)){let G=Q;if(!QQ.registeredHooks[G])QQ.registeredHooks[G]=[];QQ.registeredHooks[G].push(...B)}}function MPA(){return QQ.registeredHooks}function CWA(){return QQ.planSlugCache}var QQ;var g0=L(()=>{eW0();DPA();QQ=$r2()});function OPA({writeFn:A,flushIntervalMs:Q=1000,maxBufferSize:B=100,immediateMode:G=!1}){let Z=[],Y=null;function J(){if(Y)clearTimeout(Y),Y=null}function I(){if(Z.length===0)return;A(Z.join("")),Z=[],J()}function X(){if(!Y)Y=setTimeout(I,Q)}return{write(W){if(G){A(W);return}if(Z.push(W),X(),Z.length>=B)I()},flush:I,dispose(){I()}}}function U8(A){return nG1.add(A),()=>nG1.delete(A)}async function dK0(){await Promise.all(Array.from(nG1).map((A)=>A()))}var nG1;var bW=L(()=>{nG1=new Set});import{dirname as aG1,join as cK0}from"path";function Nr2(A){if(typeof process>"u"||typeof process.versions>"u"||typeof process.versions.node>"u")return!1;let Q=wr2();return FX0(A,Q)}function lK0(A){pK0=A}function qr2(){if(!RPA)RPA=OPA({writeFn:(A)=>{let Q=_a();if(!jA().existsSync(aG1(Q)))jA().mkdirSync(aG1(Q));jA().appendFileSync(Q,A),Lr2()},flushIntervalMs:1000,maxBufferSize:100,immediateMode:kBA()}),U8(async()=>RPA?.dispose());return RPA}function f(A,{level:Q}={level:"debug"}){if(!Nr2(A))return;if(pK0&&A.includes(`[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"function Os\\(\" bundles/ClaudeCodeCode/cli.js | head -n 20"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 97ms:[0m
[2m396:`);ok=[],B.appendFileSync(Q,G.join(""),{mode:384})}catch(Q){f(`Failed to write prompt history: ${Q}`)}finally{if(A)await A()}}async function slQ(A){if(Px1||ok.length===0)return;if(A>5)return;Px1=!0;try{await rlQ()}finally{if(Px1=!1,ok.length>0)await new Promise((Q)=>setTimeout(Q,500)),slQ(A+1)}}async function tt6(A){let Q=typeof A==="string"?{display:A,pastedContents:{}}:A,B={};if(Q.pastedContents){for(let[Z,Y]of Object.entries(Q.pastedContents))if(Y.type!=="image"&&Y.content.length<=rt6)B[Number(Z)]=Y}let G={...Q,pastedContents:B,timestamp:Date.now(),project:pQ(),sessionId:W0()};ok.push(G),xcA=slQ(0)}function Ns(A){if(!plQ)plQ=!0,U8(async()=>{if(xcA)await xcA;if(ok.length>0)await rlQ()});tt6(A)}var ilQ,ot6=100,rt6=1024,ok,Px1=!1,xcA=null,plQ=!1;var nd=L(()=>{rQ();XQ();g0();Y0();bW();ilQ=o(Gm(),1);ok=[]});var xx1,et6,yz,qs,kcA;var ad=L(()=>{k3();xx1=o(zR(),1),et6=dQ()!=="windows"||(ga()?xx1.default.satisfies(process.versions.bun,">=1.2.23"):xx1.default.satisfies(process.versions.node,">=22.17.0 <23.0.0 || >=24.2.0")),yz=!et6?{displayText:"alt+m",check:(A,Q)=>Q.meta&&(A==="m"||A==="M")}:{displayText:"shift+tab",check:(A,Q)=>Q.tab&&Q.shift},qs=dQ()==="windows"?{displayText:"alt+v",check:(A,Q)=>Q.meta&&(A==="v"||A==="V")}:{displayText:"ctrl+v",check:(A,Q)=>Q.ctrl&&(A==="v"||A==="V")},kcA={displayText:"alt+p",check:(A,Q)=>Q.meta&&(A==="p"||A==="P")}});function tlQ(A,Q){switch(Q){case"bash":return`!${A}`;case"memorySelect":return`#${A}`;case"background":return`&${A}`;default:return A}}function rk(A){if(A.startsWith("!"))return"bash";if(A.startsWith("#"))return"memory";if(A.startsWith("&"))return"background";return"prompt"}function Ls(A){if(rk(A)==="prompt")return A;return A.slice(1)}function elQ(A){return A==="!"||A==="#"||A==="&"}function od(A){return A.filter((Q)=>Q.data?.type!=="hook_progress")}function Ae6(A,Q){return A.name===Q||(A.aliases?.includes(Q)??!1)}function AiQ(A,Q){return A.find((B)=>Ae6(B,Q))}var s$=()=>({mode:"default",additionalWorkingDirectories:new Map,alwaysAllowRules:{},alwaysDenyRules:{},alwaysAskRules:{},isBypassPermissionsModeAvailable:!1});import{stat as Qe6,lstat as QiQ,readdir as Be6,realpath as Ge6}from"node:fs/promises";import{Readable as Ze6}from"node:stream";import{resolve as BiQ,relative as Ye6,join as Je6,sep as Ie6}from"node:path";function XiQ(A,Q={}){let B=Q.entryType||Q.type;if(B==="both")B=t$.FILE_DIR_TYPE;if(B)Q.type=B;if(!A)throw Error("readdirp: root argument is required. Usage: readdirp(root, options)");else if(typeof A!=="string")throw TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");else if(B&&!GiQ.includes(B))throw Error(`readdirp: Invalid type passed. Use one of ${GiQ.join(", ")}`);return Q.root=A,new IiQ(Q)}var t$,yx1,JiQ="READDIRP_RECURSIVE_ERROR",Xe6,GiQ,We6,Ke6,Ve6=(A)=>Xe6.has(A.code),Ee6,ZiQ=(A)=>!0,YiQ=(A)=>{if(A===void 0)return ZiQ;if(typeof A==="function")return A;if(typeof A==="string"){let Q=A.trim();return(B)=>B.basename===Q}if(Array.isArray(A)){let Q=A.map((B)=>B.trim());return(B)=>Q.some((G)=>B.basename===G)}return ZiQ},IiQ;var WiQ=L(()=>{t$={FILE_TYPE:"files",DIR_TYPE:"directories",FILE_DIR_TYPE:"files_directories",EVERYTHING_TYPE:"all"},yx1={root:".",fileFilter:(A)=>!0,directoryFilter:(A)=>!0,type:t$.FILE_TYPE,lstat:!1,depth:2147483648,alwaysStat:!1,highWaterMark:4096};Object.freeze(yx1);Xe6=new Set(["ENOENT","EPERM","EACCES","ELOOP",JiQ]),GiQ=[t$.DIR_TYPE,t$.EVERYTHING_TYPE,t$.FILE_DIR_TYPE,t$.FILE_TYPE],We6=new Set([t$.DIR_TYPE,t$.EVERYTHING_TYPE,t$.FILE_DIR_TYPE]),Ke6=new Set([t$.EVERYTHING_TYPE,t$.FILE_DIR_TYPE,t$.FILE_TYPE]),Ee6=process.platform==="win32";IiQ=class IiQ extends Ze6{constructor(A={}){super({objectMode:!0,autoDestroy:!0,highWaterMark:A.highWaterMark});let Q={...yx1,...A},{root:B,type:G}=Q;this._fileFilter=YiQ(Q.fileFilter),this._directoryFilter=YiQ(Q.directoryFilter);let Z=Q.lstat?QiQ:Qe6;if(Ee6)this._stat=(Y)=>Z(Y,{bigint:!0});else this._stat=Z;this._maxDepth=Q.depth??yx1.depth,this._wantsDir=G?We6.has(G):!1,this._wantsFile=G?Ke6.has(G):!1,this._wantsEverything=G===t$.EVERYTHING_TYPE,this._root=BiQ(B),this._isDirent=!Q.alwaysStat,this._statsProp=this._isDirent?"dirent":"stats",this._rdOptions={encoding:"utf8",withFileTypes:this._isDirent},this.parents=[this._exploreDir(B,1)],this.reading=!1,this.parent=void 0}async _read(A){if(this.reading)return;this.reading=!0;try{while(!this.destroyed&&A>0){let Q=this.parent,B=Q&&Q.files;if(B&&B.length>0){let{path:G,depth:Z}=Q,Y=B.splice(0,A).map((I)=>this._formatEntry(I,G)),J=await Promise.all(Y);for(let I of J){if(!I)continue;if(this.destroyed)return;let X=await this._getEntryType(I);if(X==="directory"&&this._directoryFilter(I)){if(Z<=this._maxDepth)this.parents.push(this._exploreDir(I.fullPath,Z+1));if(this._wantsDir)this.push(I),A--}else if((X==="file"||this._includeAsFile(I))&&this._fileFilter(I)){if(this._wantsFile)this.push(I),A--}}}else{let G=this.parents.pop();if(!G){this.push(null);break}if(this.parent=await G,this.destroyed)return}}}catch(Q){this.destroy(Q)}finally{this.reading=!1}}async _exploreDir(A,Q){let B;try{B=await Be6(A,this._rdOptions)}catch(G){this._onError(G)}return{files:B,depth:Q,path:A}}async _formatEntry(A,Q){let B,G=this._isDirent?A.name:A;try{let Z=BiQ(Je6(Q,G));B={path:Ye6(this._root,Z),fullPath:Z,basename:G},B[this._statsProp]=this._isDirent?A:await this._stat(Z)}catch(Z){this._onError(Z);return}return B}_onError(A){if(Ve6(A)&&!this.destroyed)this.emit("warn",A);else this.destroy(A)}async _getEntryType(A){if(!A&&this._statsProp in A)return"";let Q=A[this._statsProp];if(Q.isFile())return"file";if(Q.isDirectory())return"directory";if(Q&&Q.isSymbolicLink()){let B=A.fullPath;try{let G=await Ge6(B),Z=await QiQ(G);if(Z.isFile())return"file";if(Z.isDirectory()){let Y=G.length;if(B.startsWith(G)&&B.substr(Y,1)===Ie6){let J=Error(`Circular symlink detected: "${B}" points to "${G}"`);return J.code=JiQ,this._onError(J)}return"directory"}}catch(G){return this._onError(G),""}}}_includeAsFile(A){let Q=A&&A[this._statsProp];return Q&&this._wantsEverything&&!Q.isDirectory()}}});import{watchFile as De6,unwatchFile as KiQ,watch as He6}from"fs";import{open as Fe6,stat as EiQ,lstat as Ce6,realpath as vx1}from"fs/promises";import*as dY from"path";import{type as ze6}from"os";function ViQ(A,Q,B,G,Z){let Y=(J,I)=>{if(B(A),Z(J,I,{watchedPath:A}),I&&A!==I)hcA(dY.resolve(A,I),Ms,dY.join(A,I))};try{return He6(A,{persistent:Q.persistent},Y)}catch(J){G(J);return}}class gx1{constructor(A){this.fsw=A,this._boundHandleError=(Q)=>A._handleError(Q)}_watchWithNodeFs(A,Q){let B=this.fsw.options,G=dY.dirname(A),Z=dY.basename(A);this.fsw._getWatchedDir(G).add(Z);let J=dY.resolve(A),I={persistent:B.persistent};if(!Q)Q=gcA;let X;if(B.usePolling){let W=B.interval!==B.binaryInterval;I.interval=W&&Re6(Z)?B.binaryInterval:B.interval,X=je6(A,J,I,{listener:Q,rawEmitter:this.fsw._emitRaw})}else X=Te6(A,J,I,{listener:Q,errHandler:this._boundHandleError,rawEmitter:this.fsw._emitRaw});return X}_handleFile(A,Q,B){if(this.fsw.closed)return;let G=dY.dirname(A),Z=dY.basename(A),Y=this.fsw._getWatchedDir(G),J=Q;if(Y.has(Z))return;let I=async(W,K)=>{if(!this.fsw._throttle(qe6,A,5))return;if(!K||K.mtimeMs===0)try{let V=await EiQ(A);if(this.fsw.closed)return;let{atimeMs:E,mtimeMs:D}=V;if(!E||E<=D||D!==J.mtimeMs)this.fsw._emit(_R.CHANGE,A,V);if(($e6||we6||Ne6)&&J.ino!==V.ino){this.fsw._closeFile(W),J=V;let H=this._watchWithNodeFs(A,I);if(H)this.fsw._addPathCloser(W,H)}else J=V}catch(V){this.fsw._remove(G,Z)}else if(Y.has(Z)){let{atimeMs:V,mtimeMs:E}=K;if(!V||V<=E||E!==J.mtimeMs)this.fsw._emit(_R.CHANGE,A,K);J=K}},X=this._watchWithNodeFs(A,I);if(!(B&&this.fsw.options.ignoreInitial)&&this.fsw._isntIgnored(A)){if(!this.fsw._throttle(_R.ADD,A,0))return;this.fsw._emit(_R.ADD,A,Q)}return X}async _handleSymlink(A,Q,B,G){if(this.fsw.closed)return;let Z=A.fullPath,Y=this.fsw._getWatchedDir(Q);if(!this.fsw.options.followSymlinks){this.fsw._incrReadyCount();let J;try{J=await vx1(B)}catch(I){return this.fsw._emitReady(),!0}if(this.fsw.closed)return;if(Y.has(G)){if(this.fsw._symlinkPaths.get(Z)!==J)this.fsw._symlinkPaths.set(Z,J),this.fsw._emit(_R.CHANGE,B,A.stats)}else Y.add(G),this.fsw._symlinkPaths.set(Z,J),this.fsw._emit(_R.ADD,B,A.stats);return this.fsw._emitReady(),!0}if(this.fsw._symlinkPaths.has(Z))return!0;this.fsw._symlinkPaths.set(Z,!0)}_handleRead(A,Q,B,G,Z,Y,J){if(A=dY.join(A,""),J=this.fsw._throttle("readdir",A,1000),!J)return;let I=this.fsw._getWatchedDir(B.path),X=new Set,W=this.fsw._readdirp(A,{fileFilter:(K)=>B.filterPath(K),directoryFilter:(K)=>B.filterDir(K)});if(!W)return;return W.on(Ue6,async(K)=>{if(this.fsw.closed){W=void 0;return}let V=K.path,E=dY.join(A,V);if(X.add(V),K.stats.isSymbolicLink()&&await this._handleSymlink(K,A,E,V))return;if(this.fsw.closed){W=void 0;return}if(V===G||!G&&!I.has(V))this.fsw._incrReadyCount(),E=dY.join(Z,dY.relative(Z,E)),this._addToNodeFs(E,Q,B,Y+1)}).on(_R.ERROR,this._boundHandleError),new Promise((K,V)=>{if(!W)return V();W.once(bx1,()=>{if(this.fsw.closed){W=void 0;return}let E=J?J.clear():!1;if(K(void 0),I.getChildren().filter((D)=>{return D!==A&&!X.has(D)}).forEach((D)=>{this.fsw._remove(A,D)}),W=void 0,E)this._handleRead(A,!1,B,G,Z,Y,J)})})}async _handleDir(A,Q,B,G,Z,Y,J){let I=this.fsw._getWatchedDir(dY.dirname(A)),X=I.has(dY.basename(A));if(!(B&&this.fsw.options.ignoreInitial)&&!Z&&!X)this.fsw._emit(_R.ADD_DIR,A,Q);I.add(dY.basename(A)),this.fsw._getWatchedDir(A);let W,K,V=this.fsw.options.depth;if((V==null||G<=V)&&!this.fsw._symlinkPaths.has(J)){if(!Z){if(await this._handleRead(A,B,Y,Z,A,G,W),this.fsw.closed)return}K=this._watchWithNodeFs(A,(E,D)=>{if(D&&D.mtimeMs===0)return;this._handleRead(E,!1,Y,Z,A,G,W)})}return K}async _addToNodeFs(A,Q,B,G,Z){let Y=this.fsw._emitReady;if(this.fsw._isIgnored(A)||this.fsw.closed)return Y(),!1;let J=this.fsw._getWatchHelpers(A);if(B)J.filterPath=(I)=>B.filterPath(I),J.filterDir=(I)=>B.filterDir(I);try{let I=await Le6[J.statMethod](J.watchPath);if(this.fsw.closed)return;if(this.fsw._isIgnored(J.watchPath,I))return Y(),!1;let X=this.fsw.options.followSymlinks,W;if(I.isDirectory()){let K=dY.resolve(A),V=X?await vx1(A):A;if(this.fsw.closed)return;if(W=await this._handleDir(J.watchPath,I,Q,G,Z,J,V),this.fsw.closed)return;if(K!==V&&V!==void 0)this.fsw._symlinkPaths.set(K,V)}else if(I.isSymbolicLink()){let K=X?await vx1(A):A;if(this.fsw.closed)return;let V=dY.dirname(J.watchPath);if(this.fsw._getWatchedDir(V).add(J.watchPath),this.fsw._emit(_R.ADD,J.watchPath,I),W=await this._handleDir(V,I,Q,G,A,J,K),this.fsw.closed)return;if(K!==void 0)this.fsw._symlinkPaths.set(dY.resolve(A),K)}else W=this._handleFile(J.watchPath,I,Q);if(Y(),W)this.fsw._addPathCloser(A,W);return!1}catch(I){if(this.fsw._handleError(I))return Y(),A}}}var Ue6="data",bx1="end",DiQ="close",gcA=()=>{},ucA,hx1,$e6,we6,Ne6,HiQ,JY,_R,qe6="watch",Le6,Ms="listeners",fcA="errHandlers",X8A="rawEmitters",Me6,Oe6,Re6=(A)=>Oe6.has(dY.extname(A).slice(1).toLowerCase()),fx1=(A,Q)=>{if(A instanceof Set)A.forEach(Q);else Q(A)},DCA=(A,Q,B)=>{let G=A[Q];if(!(G instanceof Set))A[Q]=G=new Set([G]);G.add(B)},_e6=(A)=>(Q)=>{let B=A[Q];if(B instanceof Set)B.clear();else delete A[Q]},HCA=(A,Q,B)=>{let G=A[Q];if(G instanceof Set)G.delete(B);else if(G===B)delete A[Q]},FiQ=(A)=>A instanceof Set?A.size===0:!A,bcA,hcA=(A,Q,B,G,Z)=>{let Y=bcA.get(A);if(!Y)return;fx1(Y[Q],(J)=>{J(B,G,Z)})},Te6=(A,Q,B,G)=>{let{listener:Z,errHandler:Y,rawEmitter:J}=G,I=bcA.get(Q),X;if(!B.persistent){if(X=ViQ(A,B,Z,Y,J),!X)return;return X.close.bind(X)}if(I)DCA(I,Ms,Z),DCA(I,fcA,Y),DCA(I,X8A,J);else{if(X=ViQ(A,B,hcA.bind(null,Q,Ms),Y,hcA.bind(null,Q,X8A)),!X)return;X.on(_R.ERROR,async(W)=>{let K=hcA.bind(null,Q,fcA);if(I)I.watcherUnusable=!0;if(hx1&&W.code==="EPERM")try{await(await Fe6(A,"r")).close(),K(W)}catch(V){}else K(W)}),I={listeners:Z,errHandlers:Y,rawEmitters:J,watcher:X},bcA.set(Q,I)}return()=>{if(HCA(I,Ms,Z),HCA(I,fcA,Y),HCA(I,X8A,J),FiQ(I.listeners))I.watcher.close(),bcA.delete(Q),Me6.forEach(_e6(I)),I.watcher=void 0,Object.freeze(I)}},kx1,je6=(A,Q,B,G)=>{let{listener:Z,rawEmitter:Y}=G,J=kx1.get(Q),I=J&&J.options;if(I&&(I.persistent<B.persistent||I.interval>B.interval))KiQ(Q),J=void 0;if(J)DCA(J,Ms,Z),DCA(J,X8A,Y);else J={listeners:Z,rawEmitters:Y,options:B,watcher:De6(Q,B,(X,W)=>{fx1(J.rawEmitters,(V)=>{V(_R.CHANGE,Q,{curr:X,prev:W})});let K=X.mtimeMs;if(X.size!==W.size||K>W.mtimeMs||K===0)fx1(J.listeners,(V)=>V(A,X))})},kx1.set(Q,J);return()=>{if(HCA(J,Ms,Z),HCA(J,X8A,Y),FiQ(J.listeners))kx1.delete(Q),KiQ(Q),J.options=J.watcher=void 0,Object.freeze(J)}};var CiQ=L(()=>{ucA=process.platform,hx1=ucA==="win32",$e6=ucA==="darwin",we6=ucA==="linux",Ne6=ucA==="freebsd",HiQ=ze6()==="OS400",JY={ALL:"all",READY:"ready",ADD:"add",CHANGE:"change",ADD_DIR:"addDir",UNLINK:"unlink",UNLINK_DIR:"unlinkDir",RAW:"raw",ERROR:"error"},_R=JY,Le6={lstat:Ce6,stat:EiQ},Me6=[Ms,fcA,X8A],Oe6=new Set(["3dm","3ds","3g2","3gp","7z","a","aac","adp","afdesign","afphoto","afpub","ai","aif","aiff","alz","ape","apk","appimage","ar","arj","asf","au","avi","bak","baml","bh","bin","bk","bmp","btif","bz2","bzip2","cab","caf","cgm","class","cmx","cpio","cr2","cur","dat","dcm","deb","dex","djvu","dll","dmg","dng","doc","docm","docx","dot","dotm","dra","DS_Store","dsk","dts","dtshd","dvb","dwg","dxf","ecelp4800","ecelp7470","ecelp9600","egg","eol","eot","epub","exe","f4v","fbs","fh","fla","flac","flatpak","fli","flv","fpx","fst","fvt","g3","gh","gif","graffle","gz","gzip","h261","h263","h264","icns","ico","ief","img","ipa","iso","jar","jpeg","jpg","jpgv","jpm","jxr","key","ktx","lha","lib","lvp","lz","lzh","lzma","lzo","m3u","m4a","m4v","mar","mdi","mht","mid","midi","mj2","mka","mkv","mmr","mng","mobi","mov","movie","mp3","mp4","mp4a","mpeg","mpg","mpga","mxu","nef","npx","numbers","nupkg","o","odp","ods","odt","oga","ogg","ogv","otf","ott","pages","pbm","pcx","pdb","pdf","pea","pgm","pic","png","pnm","pot","potm","potx","ppa","ppam","ppm","pps","ppsm","ppsx","ppt","pptm","pptx","psd","pya","pyc","pyo","pyv","qt","rar","ras","raw","resources","rgb","rip","rlc","rmf","rmvb","rpm","rtf","rz","s3m","s7z","scpt","sgi","shar","snap","sil","sketch","slk","smv","snk","so","stl","suo","sub","swf","tar","tbz","tbz2","tga","tgz","thmx","tif","tiff","tlz","ttc","ttf","txz","udf","uvh","uvi","uvm","uvp","uvs","uvu","viv","vob","war","wav","wax","wbmp","wdp","weba","webm","webp","whl","wim","wm","wma","wmv","wmx","woff","woff2","wrm","wvx","xbm","xif","xla","xlam","xls","xlsb","xlsm","xlsx","xlt","xltm","xltx","xm","xmind","xpi","xpm","xwd","xz","z","zip","zipx"]),bcA=new Map;kx1=new Map});import{stat as Pe6}from"fs";import{stat as Se6,readdir as xe6}from"fs/promises";import{EventEmitter as ye6}from"events";import*as B8 from"path";function mcA(A){return Array.isArray(A)?A:[A]}function ue6(A){if(typeof A==="function")return A;if(typeof A==="string")return(Q)=>A===Q;if(A instanceof RegExp)return(Q)=>A.test(Q);if(typeof A==="object"&&A!==null)return(Q)=>{if(A.path===Q)return!0;if(A.recursive){let B=B8.relative(A.path,Q);if(!B)return!1;return!B.startsWith("..")&&!B8.isAbsolute(B)}return!1};return()=>!1}function me6(A){if(typeof A!=="string")throw Error("string expected");A=B8.normalize(A),A=A.replace(/\\/g,"/");let Q=!1;if(A.startsWith("//"))Q=!0;let B=/\/\//;while(A.match(B))A=A.replace(B,"/");if(Q)A="/"+A;return A}function UiQ(A,Q,B){let G=me6(Q);for(let Z=0;Z<A.length;Z++){let Y=A[Z];if(Y(G,B))return!0}return!1}function de6(A,Q){if(A==null)throw TypeError("anymatch: specify first argument");let G=mcA(A).map((Z)=>ue6(Z));if(Q==null)return(Z,Y)=>{return UiQ(G,Z,Y)};return UiQ(G,Q)}class MiQ{constructor(A,Q){this.path=A,this._removeWatcher=Q,this.items=new Set}add(A){let{items:Q}=this;if(!Q)return;if(A!==qiQ&&A!==ke6)Q.add(A)}async remove(A){let{items:Q}=this;if(!Q)return;if(Q.delete(A),Q.size>0)return;let B=this.path;try{await xe6(B)}catch(G){if(this._removeWatcher)this._removeWatcher(B8.dirname(B),B8.basename(B))}}has(A){let{items:Q}=this;if(!Q)return;return Q.has(A)}getChildren(){let{items:A}=this;if(!A)return[];return[...A.values()]}dispose(){this.items.clear(),this.path="",this._removeWatcher=gcA,this.items=pe6,Object.freeze(this)}}class OiQ{constructor(A,Q,B){this.fsw=B;let G=A;this.path=A=A.replace(ge6,""),this.watchPath=G,this.fullWatchPath=B8.resolve(G),this.dirParts=[],this.dirParts.forEach((Z)=>{if(Z.length>1)Z.pop()}),this.followSymlinks=Q,this.statMethod=Q?le6:ie6}entryPath(A){return B8.join(this.watchPath,B8.relative(this.watchPath,A.fullPath))}filterPath(A){let{stats:Q}=A;if(Q&&Q.isSymbolicLink())return this.filterDir(A);let B=this.entryPath(A);return this.fsw._isntIgnored(B,Q)&&this.fsw._hasReadPermissions(Q)}filterDir(A){return this.fsw._isntIgnored(this.entryPath(A),A.stats)}}function ne6(A,Q={}){let B=new dx1(Q);return B.add(A),B}var ux1="/",ve6="//",qiQ=".",ke6="..",fe6="string",be6,ziQ,he6,ge6,mx1=(A)=>typeof A==="object"&&A!==null&&!(A instanceof RegExp),$iQ=(A)=>{let Q=mcA(A).flat();if(!Q.every((B)=>typeof B===fe6))throw TypeError(`Non-string provided as watch path: ${Q}`);return Q.map(LiQ)},wiQ=(A)=>{let Q=A.replace(be6,ux1),B=!1;if(Q.startsWith(ve6))B=!0;while(Q.match(ziQ))Q=Q.replace(ziQ,ux1);if(B)Q=ux1+Q;return Q},LiQ=(A)=>wiQ(B8.normalize(wiQ(A))),NiQ=(A="")=>(Q)=>{if(typeof Q==="string")return LiQ(B8.isAbsolute(Q)?Q:B8.join(A,Q));else return Q},ce6=(A,Q)=>{if(B8.isAbsolute(A))return A;return B8.join(Q,A)},pe6,le6="stat",ie6="lstat",dx1,RiQ;var _iQ=L(()=>{WiQ();CiQ();/*! chokidar - MIT License (c) 2012 Paul Miller (paulmillr.com) */be6=/\\/g,ziQ=/\/\//,he6=/\..*\.(sw[px])$|~$|\.subl.*\.tmp/,ge6=/^\.[/\\]/;pe6=Object.freeze(new Set);dx1=class dx1 extends ye6{constructor(A={}){super();this.closed=!1,this._closers=new Map,this._ignoredPaths=new Set,this._throttled=new Map,this._streams=new Set,this._symlinkPaths=new Map,this._watched=new Map,this._pendingWrites=new Map,this._pendingUnlinks=new Map,this._readyCount=0,this._readyEmitted=!1;let Q=A.awaitWriteFinish,B={stabilityThreshold:2000,pollInterval:100},G={persistent:!0,ignoreInitial:!1,ignorePermissionErrors:!1,interval:100,binaryInterval:300,followSymlinks:!0,usePolling:!1,atomic:!0,...A,ignored:A.ignored?mcA(A.ignored):mcA([]),awaitWriteFinish:Q===!0?B:typeof Q==="object"?{...B,...Q}:!1};if(HiQ)G.usePolling=!0;if(G.atomic===void 0)G.atomic=!G.usePolling;let Z=process.env.CHOKIDAR_USEPOLLING;if(Z!==void 0){let I=Z.toLowerCase();if(I==="false"||I==="0")G.usePolling=!1;else if(I==="true"||I==="1")G.usePolling=!0;else G.usePolling=!!I}let Y=process.env.CHOKIDAR_INTERVAL;if(Y)G.interval=Number.parseInt(Y,10);let J=0;this._emitReady=()=>{if(J++,J>=this._readyCount)this._emitReady=gcA,this._readyEmitted=!0,process.nextTick(()=>this.emit(JY.READY))},this._emitRaw=(...I)=>this.emit(JY.RAW,...I),this._boundRemove=this._remove.bind(this),this.options=G,this._nodeFsHandler=new gx1(this),Object.freeze(G)}_addIgnoredPath(A){if(mx1(A)){for(let Q of this._ignoredPaths)if(mx1(Q)&&Q.path===A.path&&Q.recursive===A.recursive)return}this._ignoredPaths.add(A)}_removeIgnoredPath(A){if(this._ignoredPaths.delete(A),typeof A==="string"){for(let Q of this._ignoredPaths)if(mx1(Q)&&Q.path===A)this._ignoredPaths.delete(Q)}}add(A,Q,B){let{cwd:G}=this.options;this.closed=!1,this._closePromise=void 0;let Z=$iQ(A);if(G)Z=Z.map((Y)=>{return ce6(Y,G)});if(Z.forEach((Y)=>{this._removeIgnoredPath(Y)}),this._userIgnored=void 0,!this._readyCount)this._readyCount=0;return this._readyCount+=Z.length,Promise.all(Z.map(async(Y)=>{let J=await this._nodeFsHandler._addToNodeFs(Y,!B,void 0,0,Q);if(J)this._emitReady();return J})).then((Y)=>{if(this.closed)return;Y.forEach((J)=>{if(J)this.add(B8.dirname(J),B8.basename(Q||J))})}),this}unwatch(A){if(this.closed)return this;let Q=$iQ(A),{cwd:B}=this.options;return Q.forEach((G)=>{if(!B8.isAbsolute(G)&&!this._closers.has(G)){if(B)G=B8.join(B,G);G=B8.resolve(G)}if(this._closePath(G),this._addIgnoredPath(G),this._watched.has(G))this._addIgnoredPath({path:G,recursive:!0});this._userIgnored=void 0}),this}close(){if(this._closePromise)return this._closePromise;this.closed=!0,this.removeAllListeners();let A=[];return this._closers.forEach((Q)=>Q.forEach((B)=>{let G=B();if(G instanceof Promise)A.push(G)})),this._streams.forEach((Q)=>Q.destroy()),this._userIgnored=void 0,this._readyCount=0,this._readyEmitted=!1,this._watched.forEach((Q)=>Q.dispose()),this._closers.clear(),this._watched.clear(),this._streams.clear(),this._symlinkPaths.clear(),this._throttled.clear(),this._closePromise=A.length?Promise.all(A).then(()=>{return}):Promise.resolve(),this._closePromise}getWatched(){let A={};return this._watched.forEach((Q,B)=>{let Z=(this.options.cwd?B8.relative(this.options.cwd,B):B)||qiQ;A[Z]=Q.getChildren().sort()}),A}emitWithAll(A,Q){if(this.emit(A,...Q),A!==JY.ERROR)this.emit(JY.ALL,A,...Q)}async _emit(A,Q,B){if(this.closed)return;let G=this.options;if(hx1)Q=B8.normalize(Q);if(G.cwd)Q=B8.relative(G.cwd,Q);let Z=[Q];if(B!=null)Z.push(B);let Y=G.awaitWriteFinish,J;if(Y&&(J=this._pendingWrites.get(Q)))return J.lastChange=new Date,this;if(G.atomic){if(A===JY.UNLINK)return this._pendingUnlinks.set(Q,[A,...Z]),setTimeout(()=>{this._pendingUnlinks.forEach((I,X)=>{this.emit(...I),this.emit(JY.ALL,...I),this._pendingUnlinks.delete(X)})},typeof G.atomic==="number"?G.atomic:100),this;if(A===JY.ADD&&this._pendingUnlinks.has(Q))A=JY.CHANGE,this._pendingUnlinks.delete(Q)}if(Y&&(A===JY.ADD||A===JY.CHANGE)&&this._readyEmitted){let I=(X,W)=>{if(X)A=JY.ERROR,Z[0]=X,this.emitWithAll(A,Z);else if(W){if(Z.length>1)Z[1]=W;else Z.push(W);this.emitWithAll(A,Z)}};return this._awaitWriteFinish(Q,Y.stabilityThreshold,A,I),this}if(A===JY.CHANGE){if(!this._throttle(JY.CHANGE,Q,50))return this}if(G.alwaysStat&&B===void 0&&(A===JY.ADD||A===JY.ADD_DIR||A===JY.CHANGE)){let I=G.cwd?B8.join(G.cwd,Q):Q,X;try{X=await Se6(I)}catch(W){}if(!X||this.closed)return;Z.push(X)}return this.emitWithAll(A,Z),this}_handleError(A){let Q=A&&A.code;if(A&&Q!=="ENOENT"&&Q!=="ENOTDIR"&&(!this.options.ignorePermissionErrors||Q!=="EPERM"&&Q!=="EACCES"))this.emit(JY.ERROR,A);return A||this.closed}_throttle(A,Q,B){if(!this._throttled.has(A))this._throttled.set(A,new Map);let G=this._throttled.get(A);if(!G)throw Error("invalid throttle");let Z=G.get(Q);if(Z)return Z.count++,!1;let Y,J=()=>{let X=G.get(Q),W=X?X.count:0;if(G.delete(Q),clearTimeout(Y),X)clearTimeout(X.timeoutObject);return W};Y=setTimeout(J,B);let I={timeoutObject:Y,clear:J,count:0};return G.set(Q,I),I}_incrReadyCount(){return this._readyCount++}_awaitWriteFinish(A,Q,B,G){let Z=this.options.awaitWriteFinish;if(typeof Z!=="object")return;let Y=Z.pollInterval,J,I=A;if(this.options.cwd&&!B8.isAbsolute(A))I=B8.join(this.options.cwd,A);let X=new Date,W=this._pendingWrites;function K(V){Pe6(I,(E,D)=>{if(E||!W.has(A)){if(E&&E.code!=="ENOENT")G(E);return}let H=Number(new Date);if(V&&D.size!==V.size)W.get(A).lastChange=H;let F=W.get(A);if(H-F.lastChange>=Q)W.delete(A),G(void 0,D);else J=setTimeout(K,Y,D)})}if(!W.has(A))W.set(A,{lastChange:X,cancelWait:()=>{return W.delete(A),clearTimeout(J),B}}),J=setTimeout(K,Y)}_isIgnored(A,Q){if(this.options.atomic&&he6.test(A))return!0;if(!this._userIgnored){let{cwd:B}=this.options,Z=(this.options.ignored||[]).map(NiQ(B)),J=[...[...this._ignoredPaths].map(NiQ(B)),...Z];this._userIgnored=de6(J,void 0)}return this._userIgnored(A,Q)}_isntIgnored(A,Q){return!this._isIgnored(A,Q)}_getWatchHelpers(A){return new OiQ(A,this.options.followSymlinks,this)}_getWatchedDir(A){let Q=B8.resolve(A);if(!this._watched.has(Q))this._watched.set(Q,new MiQ(Q,this._boundRemove));return this._watched.get(Q)}_hasReadPermissions(A){if(this.options.ignorePermissionErrors)return!0;return Boolean(Number(A.mode)&256)}_remove(A,Q,B){let G=B8.join(A,Q),Z=B8.resolve(G);if(B=B!=null?B:this._watched.has(G)||this._watched.has(Z),!this._throttle("remove",G,100))return;if(!B&&this._watched.size===1)this.add(A,Q,!0);this._getWatchedDir(G).getChildren().forEach((V)=>this._remove(G,V));let I=this._getWatchedDir(A),X=I.has(Q);if(I.remove(Q),this._symlinkPaths.has(Z))this._symlinkPaths.delete(Z);let W=G;if(this.options.cwd)W=B8.relative(this.options.cwd,G);if(this.options.awaitWriteFinish&&this._pendingWrites.has(W)){if(this._pendingWrites.get(W).cancelWait()===JY.ADD)return}this._watched.delete(G),this._watched.delete(Z);let K=B?JY.UNLINK_DIR:JY.UNLINK;if(X&&!this._isIgnored(G))this._emit(K,G);this._closePath(G)}_closePath(A){this._closeFile(A);let Q=B8.dirname(A);this._getWatchedDir(Q).remove(B8.basename(A))}_closeFile(A){let Q=this._closers.get(A);if(!Q)return;Q.forEach((B)=>B()),this._closers.delete(A)}_addPathCloser(A,Q){if(!Q)return;let B=this._closers.get(A);if(!B)B=[],this._closers.set(A,B);B.push(Q)}_readdirp(A,Q){if(this.closed)return;let B={type:JY.ALL,alwaysStat:!0,lstat:!0,...Q,depth:0},G=XiQ(A,B);return this._streams.add(G),G.once(DiQ,()=>{G=void 0}),G.once(bx1,()=>{if(G)this._streams.delete(G),G=void 0}),G}};RiQ={watch:ne6,FSWatcher:dx1}});function rd(A){switch(A){case"userSettings":return"user";case"projectSettings":return"project";case"localSettings":return"project, gitignored";case"flagSettings":return"cli flag";case"policySettings":return"managed"}}function dcA(A){switch(A){case"userSettings":return"user settings";case"projectSettings":return"shared project settings";case"localSettings":return"project local settings";case"flagSettings":return"command line arguments";case"policySettings":return"enterprise managed settings";case"cliArg":return"CLI argument";case"command":return"command configuration";case"session":return"current session"}}function TiQ(A){switch(A){case"userSettings":return"User settings";case"projectSettings":return"Shared project settings";case"localSettings":return"Project local settings";case"flagSettings":return"Command line arguments";case"policySettings":return"Enterprise managed settings";case"cliArg":return"CLI argument";case"command":return"Command configuration";case"session":return"Current session"}}function jiQ(A){if(A==="")return[];let Q=A.split(",").map((G)=>G.trim()),B=[];for(let G of Q)switch(G){case"user":B.push("userSettings");break;case"project":B.push("projectSettings");break;case"local":B.push("localSettings");break;default:throw Error(`Invalid setting source: ${G}. Valid options are: user, project, local`)}return B}function Os(){let A=yK0(),Q=new Set(A);return Q.add("policySettings"),Q.add("flagSettings"),Array.from(Q)}function sK(A){return Os().includes(A)}var JL,PiQ="https://json.schemastore.org/claude-code-settings.json";var tI=L(()=>{g0();JL=["userSettings","projectSettings","localSettings","flagSettings","policySettings"]});import*as xiQ from"path";function se6(){if(SiQ||yiQ)return;SiQ=!0;let A=AA3();if(A.length===0)return;f(`Watching for changes in setting files ${A.join(", ")}...`),W8A=RiQ.watch(A,{persistent:!0,ignoreInitial:!0,awaitWriteFinish:{stabilityThreshold:ae6,pollInterval:oe6},ignored:(Q)=>Q.split(xiQ.sep).some((B)=>B===".git"),ignorePermissionErrors:!0,usePolling:!1,atomic:!0}),W8A.on("change",QA3),W8A.on("unlink",BA3),U8(async()=>viQ())}function viQ(){if(yiQ=!0,W8A)W8A.close(),W8A=null;ccA.clear(),K8A.clear()}function te6(A){return K8A.add(A),()=>{K8A.delete(A)}}function ee6(A){let Q=qF(A);if(Q)ccA.set(Q,Date.now())}function AA3(){let A=jA();return JL.map((Q)=>{let B=qF(Q);if(!B)return;try{if(!A.statSync(B).isFile())return}catch{return}return B}).filter((Q)=>Q!==void 0)}function QA3(A){let Q=kiQ(A);if(!Q)return;let B=ccA.get(A);if(B&&Date.now()-B<re6){ccA.delete(A);return}f(`Detected change to ${A}`),K8A.forEach((G)=>G(Q))}function BA3(A){let Q=kiQ(A);if(!Q)return;f(`Detected deletion of ${A}`),K8A.forEach((B)=>B(Q))}function kiQ(A){return JL.find((Q)=>qF(Q)===A)}function GA3(A){f(`Programmatic settings change notification for ${A}`),K8A.forEach((Q)=>Q(A))}var ae6=1000,oe6=500,re6=5000,W8A=null,SiQ=!1,yiQ=!1,ccA,K8A,NF;var Rs=L(()=>{_iQ();Y0();XQ();jB();tI();bW();ccA=new Map,K8A=new Set;NF={initialize:se6,dispose:viQ,subscribe:te6,markInternalWrite:ee6,notifyChange:GA3}});function V8A(A){let Q=pcA.useCallback((B)=>{TR();let G=NQ();A(B,G)},[A]);pcA.useEffect(()=>NF.subscribe(Q),[Q])}var pcA;var lcA=L(()=>{Rs();jB();pcA=o(WA(),1)});function YA3(A){let Q=qF(A);if(!Q||!jA().existsSync(Q))return null;try{let{resolvedPath:B}=gI(jA(),Q),G=wE(B);if(G.trim()==="")return{};let Z=h8(G,!1);return Z&&typeof Z==="object"?Z:null}catch{return null}}function JA3(A,Q){if(!A||!A.permissions)return[];let{permissions:B}=A,G=[];for(let Z of ZA3){let Y=B[Z];if(Y)for(let J of Y)G.push({source:Q,ruleBehavior:Z,ruleValue:IL(J)})}return G}function icA(){let A=[];for(let Q of Os())A.push(...ncA(Q));return A}function ncA(A){let Q=uB(A);return JA3(Q,A)}function fiQ(A){if(!IA3.includes(A.source))return!1;let Q=B5(A.ruleValue),B=uB(A.source);if(!B||!B.permissions)return!1;let G=B.permissions[A.ruleBehavior];if(!G||!G.includes(Q))return!1;try{let Z={...B,permissions:{...B.permissions,[A.ruleBehavior]:G.filter((J)=>J!==Q)}},{error:Y}=E2(A.source,Z);if(Y)return!1;return!0}catch(Z){return s(Z instanceof Error?Z:Error(String(Z))),!1}}function XA3(){return{permissions:{}}}function acA({ruleValues:A,ruleBehavior:Q},B){if(A.length<1)return!0;let G=A.map(B5),Z=uB(B)||YA3(B)||XA3();try{let Y=Z.permissions||{},J=Y[Q]||[],I=new Set(J),X=G.filter((V)=>!I.has(V));if(X.length===0)return!0;let W={...Z,permissions:{...Y,[Q]:[...J,...X]}},K=E2(B,W);if(K.error)throw K.error;return!0}catch(Y){return s(Y instanceof Error?Y:Error(String(Y))),!1}}var ZA3,IA3;var _s=L(()=>{h1();oG();tI();jB();XQ();M9();uI();ZA3=["allow","deny","ask"];IA3=["userSettings","projectSettings","localSettings"]});import{posix as WA3}from"path";function E8A(A){if(!A)return[];return A.flatMap((Q)=>{switch(Q.type){case"addRules":return Q.rules;default:return[]}})}function eI(A,Q){switch(Q.type){case"setMode":return f(`Applying permission update: Setting mode to '${Q.mode}'`),{...A,mode:Q.mode};case"addRules":{let B=Q.rules.map((Z)=>B5(Z));f(`Applying permission update: Adding ${Q.rules.length} ${Q.behavior} rule(s) to destination '${Q.destination}': ${JSON.stringify(B)}`);let G=Q.behavior==="allow"?"alwaysAllowRules":Q.behavior==="deny"?"alwaysDenyRules":"alwaysAskRules";return{...A,[G]:{...A[G],[Q.destination]:[...A[G][Q.destination]||[],...B]}}}case"replaceRules":{let B=Q.rules.map((Z)=>B5(Z));f(`Replacing all ${Q.behavior} rules for destination '${Q.destination}' with ${Q.rules.length} rule(s): ${JSON.stringify(B)}`);let G=Q.behavior==="allow"?"alwaysAllowRules":Q.behavior==="deny"?"alwaysDenyRules":"alwaysAskRules";return{...A,[G]:{...A[G],[Q.destination]:B}}}case"addDirectories":{f(`Applying permission update: Adding ${Q.directories.length} director${Q.directories.length===1?"y":"ies"} with destination '${Q.destination}': ${JSON.stringify(Q.directories)}`);let B=new Map(A.additionalWorkingDirectories);for(let G of Q.directories)B.set(G,{path:G,source:Q.destination});return{...A,additionalWorkingDirectories:B}}case"removeRules":{let B=Q.rules.map((I)=>B5(I));f(`Applying permission update: Removing ${Q.rules.length} ${Q.behavior} rule(s) from source '${Q.destination}': ${JSON.stringify(B)}`);let G=Q.behavior==="allow"?"alwaysAllowRules":Q.behavior==="deny"?"alwaysDenyRules":"alwaysAskRules",Z=A[G][Q.destination]||[],Y=new Set(B),J=Z.filter((I)=>!Y.has(I));return{...A,[G]:{...A[G],[Q.destination]:J}}}case"removeDirectories":{f(`Applying permission update: Removing ${Q.directories.length} director${Q.directories.length===1?"y":"ies"}: ${JSON.stringify(Q.directories)}`);let B=new Map(A.additionalWorkingDirectories);for(let G of Q.directories)B.delete(G);return{...A,additionalWorkingDirectories:B}}default:return A}}function sk(A,Q){let B=A;for(let G of Q)B=eI(B,G);return B}function FCA(A){return A==="localSettings"||A==="userSettings"||A==="projectSettings"}function eP(A){if(!FCA(A.destination))return;switch(f(`Persisting permission update: ${A.type} to source '${A.destination}'`),A.type){case"addRules":{f(`Persisting ${A.rules.length} ${A.behavior} rule(s) to ${A.destination}`),acA({ruleValues:A.rules,ruleBehavior:A.behavior},A.destination);break}case"addDirectories":{f(`Persisting ${A.directories.length} director${A.directories.length===1?"y":"ies"} to ${A.destination}`);let B=uB(A.destination)?.permissions?.additionalDirectories||[],G=A.directories.filter((Z)=>!B.includes(Z));if(G.length>0){let Z=[...B,...G];E2(A.destination,{permissions:{additionalDirectories:Z}})}break}case"removeRules":{f(`Removing ${A.rules.length} ${A.behavior} rule(s) from ${A.destination}`);let G=(uB(A.destination)?.permissions||{})[A.behavior]||[],Z=new Set(A.rules.map(B5)),Y=G.filter((J)=>!Z.has(J));E2(A.destination,{permissions:{[A.behavior]:Y}});break}case"removeDirectories":{f(`Removing ${A.directories.length} director${A.directories.length===1?"y":"ies"} from ${A.destination}`);let B=uB(A.destination)?.permissions?.additionalDirectories||[],G=new Set(A.directories),Z=B.filter((Y)=>!G.has(Y));E2(A.destination,{permissions:{additionalDirectories:Z}});break}case"setMode":{f(`Persisting mode '${A.mode}' to ${A.destination}`),E2(A.destination,{permissions:{defaultMode:A.mode}});break}case"replaceRules":{f(`Replacing all ${A.behavior} rules in ${A.destination} with ${A.rules.length} rule(s)`);let Q=A.rules.map(B5);E2(A.destination,{permissions:{[A.behavior]:Q}});break}}}function D8A(A){for(let Q of A)eP(Q)}function ocA(A,Q="session"){try{if(jA().statSync(A).isDirectory()){let G=rcA(A);if(G==="/")return;return{type:"addRules",rules:[{toolName:"Read",ruleContent:WA3.isAbsolute(G)?`/${G}/**`:`${G}/**`}],behavior:"allow",destination:Q}}}catch{}return}var tK=L(()=>{oG();Y0();jB();_s();XQ();cY()});var e9="Bash";function JB(A,Q){if(!process.env.SRT_DEBUG)return;let B=Q?.level||"info",G="[SandboxDebug]";switch(B){case"error":console.error(`${G} ${A}`);break;case"warn":console.warn(`${G} ${A}`);break;default:console.error(`${G} ${A}`)}}import{createServer as KA3}from"node:http";import{request as VA3}from"node:http";import{request as EA3}from"node:https";import{connect as DA3}from"node:net";import{URL as HA3}from"node:url";function biQ(A){let Q=KA3();return Q.on("connect",async(B,G)=>{G.on("error",(Z)=>{JB(`Client socket error: ${Z.message}`,{level:"error"})});try{let[Z,Y]=B.url.split(":"),J=Y===void 0?void 0:parseInt(Y,10);if(!Z||!J){JB(`Invalid CONNECT request: ${B.url}`,{level:"error"}),G.end(`HTTP/1.1 400 Bad Request\r[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"jiQ\\(\" bundles/ClaudeCodeCode/cli.js | head -n 20"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 234ms:[0m
[2m396:`);ok=[],B.appendFileSync(Q,G.join(""),{mode:384})}catch(Q){f(`Failed to write prompt history: ${Q}`)}finally{if(A)await A()}}async function slQ(A){if(Px1||ok.length===0)return;if(A>5)return;Px1=!0;try{await rlQ()}finally{if(Px1=!1,ok.length>0)await new Promise((Q)=>setTimeout(Q,500)),slQ(A+1)}}async function tt6(A){let Q=typeof A==="string"?{display:A,pastedContents:{}}:A,B={};if(Q.pastedContents){for(let[Z,Y]of Object.entries(Q.pastedContents))if(Y.type!=="image"&&Y.content.length<=rt6)B[Number(Z)]=Y}let G={...Q,pastedContents:B,timestamp:Date.now(),project:pQ(),sessionId:W0()};ok.push(G),xcA=slQ(0)}function Ns(A){if(!plQ)plQ=!0,U8(async()=>{if(xcA)await xcA;if(ok.length>0)await rlQ()});tt6(A)}var ilQ,ot6=100,rt6=1024,ok,Px1=!1,xcA=null,plQ=!1;var nd=L(()=>{rQ();XQ();g0();Y0();bW();ilQ=o(Gm(),1);ok=[]});var xx1,et6,yz,qs,kcA;var ad=L(()=>{k3();xx1=o(zR(),1),et6=dQ()!=="windows"||(ga()?xx1.default.satisfies(process.versions.bun,">=1.2.23"):xx1.default.satisfies(process.versions.node,">=22.17.0 <23.0.0 || >=24.2.0")),yz=!et6?{displayText:"alt+m",check:(A,Q)=>Q.meta&&(A==="m"||A==="M")}:{displayText:"shift+tab",check:(A,Q)=>Q.tab&&Q.shift},qs=dQ()==="windows"?{displayText:"alt+v",check:(A,Q)=>Q.meta&&(A==="v"||A==="V")}:{displayText:"ctrl+v",check:(A,Q)=>Q.ctrl&&(A==="v"||A==="V")},kcA={displayText:"alt+p",check:(A,Q)=>Q.meta&&(A==="p"||A==="P")}});function tlQ(A,Q){switch(Q){case"bash":return`!${A}`;case"memorySelect":return`#${A}`;case"background":return`&${A}`;default:return A}}function rk(A){if(A.startsWith("!"))return"bash";if(A.startsWith("#"))return"memory";if(A.startsWith("&"))return"background";return"prompt"}function Ls(A){if(rk(A)==="prompt")return A;return A.slice(1)}function elQ(A){return A==="!"||A==="#"||A==="&"}function od(A){return A.filter((Q)=>Q.data?.type!=="hook_progress")}function Ae6(A,Q){return A.name===Q||(A.aliases?.includes(Q)??!1)}function AiQ(A,Q){return A.find((B)=>Ae6(B,Q))}var s$=()=>({mode:"default",additionalWorkingDirectories:new Map,alwaysAllowRules:{},alwaysDenyRules:{},alwaysAskRules:{},isBypassPermissionsModeAvailable:!1});import{stat as Qe6,lstat as QiQ,readdir as Be6,realpath as Ge6}from"node:fs/promises";import{Readable as Ze6}from"node:stream";import{resolve as BiQ,relative as Ye6,join as Je6,sep as Ie6}from"node:path";function XiQ(A,Q={}){let B=Q.entryType||Q.type;if(B==="both")B=t$.FILE_DIR_TYPE;if(B)Q.type=B;if(!A)throw Error("readdirp: root argument is required. Usage: readdirp(root, options)");else if(typeof A!=="string")throw TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");else if(B&&!GiQ.includes(B))throw Error(`readdirp: Invalid type passed. Use one of ${GiQ.join(", ")}`);return Q.root=A,new IiQ(Q)}var t$,yx1,JiQ="READDIRP_RECURSIVE_ERROR",Xe6,GiQ,We6,Ke6,Ve6=(A)=>Xe6.has(A.code),Ee6,ZiQ=(A)=>!0,YiQ=(A)=>{if(A===void 0)return ZiQ;if(typeof A==="function")return A;if(typeof A==="string"){let Q=A.trim();return(B)=>B.basename===Q}if(Array.isArray(A)){let Q=A.map((B)=>B.trim());return(B)=>Q.some((G)=>B.basename===G)}return ZiQ},IiQ;var WiQ=L(()=>{t$={FILE_TYPE:"files",DIR_TYPE:"directories",FILE_DIR_TYPE:"files_directories",EVERYTHING_TYPE:"all"},yx1={root:".",fileFilter:(A)=>!0,directoryFilter:(A)=>!0,type:t$.FILE_TYPE,lstat:!1,depth:2147483648,alwaysStat:!1,highWaterMark:4096};Object.freeze(yx1);Xe6=new Set(["ENOENT","EPERM","EACCES","ELOOP",JiQ]),GiQ=[t$.DIR_TYPE,t$.EVERYTHING_TYPE,t$.FILE_DIR_TYPE,t$.FILE_TYPE],We6=new Set([t$.DIR_TYPE,t$.EVERYTHING_TYPE,t$.FILE_DIR_TYPE]),Ke6=new Set([t$.EVERYTHING_TYPE,t$.FILE_DIR_TYPE,t$.FILE_TYPE]),Ee6=process.platform==="win32";IiQ=class IiQ extends Ze6{constructor(A={}){super({objectMode:!0,autoDestroy:!0,highWaterMark:A.highWaterMark});let Q={...yx1,...A},{root:B,type:G}=Q;this._fileFilter=YiQ(Q.fileFilter),this._directoryFilter=YiQ(Q.directoryFilter);let Z=Q.lstat?QiQ:Qe6;if(Ee6)this._stat=(Y)=>Z(Y,{bigint:!0});else this._stat=Z;this._maxDepth=Q.depth??yx1.depth,this._wantsDir=G?We6.has(G):!1,this._wantsFile=G?Ke6.has(G):!1,this._wantsEverything=G===t$.EVERYTHING_TYPE,this._root=BiQ(B),this._isDirent=!Q.alwaysStat,this._statsProp=this._isDirent?"dirent":"stats",this._rdOptions={encoding:"utf8",withFileTypes:this._isDirent},this.parents=[this._exploreDir(B,1)],this.reading=!1,this.parent=void 0}async _read(A){if(this.reading)return;this.reading=!0;try{while(!this.destroyed&&A>0){let Q=this.parent,B=Q&&Q.files;if(B&&B.length>0){let{path:G,depth:Z}=Q,Y=B.splice(0,A).map((I)=>this._formatEntry(I,G)),J=await Promise.all(Y);for(let I of J){if(!I)continue;if(this.destroyed)return;let X=await this._getEntryType(I);if(X==="directory"&&this._directoryFilter(I)){if(Z<=this._maxDepth)this.parents.push(this._exploreDir(I.fullPath,Z+1));if(this._wantsDir)this.push(I),A--}else if((X==="file"||this._includeAsFile(I))&&this._fileFilter(I)){if(this._wantsFile)this.push(I),A--}}}else{let G=this.parents.pop();if(!G){this.push(null);break}if(this.parent=await G,this.destroyed)return}}}catch(Q){this.destroy(Q)}finally{this.reading=!1}}async _exploreDir(A,Q){let B;try{B=await Be6(A,this._rdOptions)}catch(G){this._onError(G)}return{files:B,depth:Q,path:A}}async _formatEntry(A,Q){let B,G=this._isDirent?A.name:A;try{let Z=BiQ(Je6(Q,G));B={path:Ye6(this._root,Z),fullPath:Z,basename:G},B[this._statsProp]=this._isDirent?A:await this._stat(Z)}catch(Z){this._onError(Z);return}return B}_onError(A){if(Ve6(A)&&!this.destroyed)this.emit("warn",A);else this.destroy(A)}async _getEntryType(A){if(!A&&this._statsProp in A)return"";let Q=A[this._statsProp];if(Q.isFile())return"file";if(Q.isDirectory())return"directory";if(Q&&Q.isSymbolicLink()){let B=A.fullPath;try{let G=await Ge6(B),Z=await QiQ(G);if(Z.isFile())return"file";if(Z.isDirectory()){let Y=G.length;if(B.startsWith(G)&&B.substr(Y,1)===Ie6){let J=Error(`Circular symlink detected: "${B}" points to "${G}"`);return J.code=JiQ,this._onError(J)}return"directory"}}catch(G){return this._onError(G),""}}}_includeAsFile(A){let Q=A&&A[this._statsProp];return Q&&this._wantsEverything&&!Q.isDirectory()}}});import{watchFile as De6,unwatchFile as KiQ,watch as He6}from"fs";import{open as Fe6,stat as EiQ,lstat as Ce6,realpath as vx1}from"fs/promises";import*as dY from"path";import{type as ze6}from"os";function ViQ(A,Q,B,G,Z){let Y=(J,I)=>{if(B(A),Z(J,I,{watchedPath:A}),I&&A!==I)hcA(dY.resolve(A,I),Ms,dY.join(A,I))};try{return He6(A,{persistent:Q.persistent},Y)}catch(J){G(J);return}}class gx1{constructor(A){this.fsw=A,this._boundHandleError=(Q)=>A._handleError(Q)}_watchWithNodeFs(A,Q){let B=this.fsw.options,G=dY.dirname(A),Z=dY.basename(A);this.fsw._getWatchedDir(G).add(Z);let J=dY.resolve(A),I={persistent:B.persistent};if(!Q)Q=gcA;let X;if(B.usePolling){let W=B.interval!==B.binaryInterval;I.interval=W&&Re6(Z)?B.binaryInterval:B.interval,X=je6(A,J,I,{listener:Q,rawEmitter:this.fsw._emitRaw})}else X=Te6(A,J,I,{listener:Q,errHandler:this._boundHandleError,rawEmitter:this.fsw._emitRaw});return X}_handleFile(A,Q,B){if(this.fsw.closed)return;let G=dY.dirname(A),Z=dY.basename(A),Y=this.fsw._getWatchedDir(G),J=Q;if(Y.has(Z))return;let I=async(W,K)=>{if(!this.fsw._throttle(qe6,A,5))return;if(!K||K.mtimeMs===0)try{let V=await EiQ(A);if(this.fsw.closed)return;let{atimeMs:E,mtimeMs:D}=V;if(!E||E<=D||D!==J.mtimeMs)this.fsw._emit(_R.CHANGE,A,V);if(($e6||we6||Ne6)&&J.ino!==V.ino){this.fsw._closeFile(W),J=V;let H=this._watchWithNodeFs(A,I);if(H)this.fsw._addPathCloser(W,H)}else J=V}catch(V){this.fsw._remove(G,Z)}else if(Y.has(Z)){let{atimeMs:V,mtimeMs:E}=K;if(!V||V<=E||E!==J.mtimeMs)this.fsw._emit(_R.CHANGE,A,K);J=K}},X=this._watchWithNodeFs(A,I);if(!(B&&this.fsw.options.ignoreInitial)&&this.fsw._isntIgnored(A)){if(!this.fsw._throttle(_R.ADD,A,0))return;this.fsw._emit(_R.ADD,A,Q)}return X}async _handleSymlink(A,Q,B,G){if(this.fsw.closed)return;let Z=A.fullPath,Y=this.fsw._getWatchedDir(Q);if(!this.fsw.options.followSymlinks){this.fsw._incrReadyCount();let J;try{J=await vx1(B)}catch(I){return this.fsw._emitReady(),!0}if(this.fsw.closed)return;if(Y.has(G)){if(this.fsw._symlinkPaths.get(Z)!==J)this.fsw._symlinkPaths.set(Z,J),this.fsw._emit(_R.CHANGE,B,A.stats)}else Y.add(G),this.fsw._symlinkPaths.set(Z,J),this.fsw._emit(_R.ADD,B,A.stats);return this.fsw._emitReady(),!0}if(this.fsw._symlinkPaths.has(Z))return!0;this.fsw._symlinkPaths.set(Z,!0)}_handleRead(A,Q,B,G,Z,Y,J){if(A=dY.join(A,""),J=this.fsw._throttle("readdir",A,1000),!J)return;let I=this.fsw._getWatchedDir(B.path),X=new Set,W=this.fsw._readdirp(A,{fileFilter:(K)=>B.filterPath(K),directoryFilter:(K)=>B.filterDir(K)});if(!W)return;return W.on(Ue6,async(K)=>{if(this.fsw.closed){W=void 0;return}let V=K.path,E=dY.join(A,V);if(X.add(V),K.stats.isSymbolicLink()&&await this._handleSymlink(K,A,E,V))return;if(this.fsw.closed){W=void 0;return}if(V===G||!G&&!I.has(V))this.fsw._incrReadyCount(),E=dY.join(Z,dY.relative(Z,E)),this._addToNodeFs(E,Q,B,Y+1)}).on(_R.ERROR,this._boundHandleError),new Promise((K,V)=>{if(!W)return V();W.once(bx1,()=>{if(this.fsw.closed){W=void 0;return}let E=J?J.clear():!1;if(K(void 0),I.getChildren().filter((D)=>{return D!==A&&!X.has(D)}).forEach((D)=>{this.fsw._remove(A,D)}),W=void 0,E)this._handleRead(A,!1,B,G,Z,Y,J)})})}async _handleDir(A,Q,B,G,Z,Y,J){let I=this.fsw._getWatchedDir(dY.dirname(A)),X=I.has(dY.basename(A));if(!(B&&this.fsw.options.ignoreInitial)&&!Z&&!X)this.fsw._emit(_R.ADD_DIR,A,Q);I.add(dY.basename(A)),this.fsw._getWatchedDir(A);let W,K,V=this.fsw.options.depth;if((V==null||G<=V)&&!this.fsw._symlinkPaths.has(J)){if(!Z){if(await this._handleRead(A,B,Y,Z,A,G,W),this.fsw.closed)return}K=this._watchWithNodeFs(A,(E,D)=>{if(D&&D.mtimeMs===0)return;this._handleRead(E,!1,Y,Z,A,G,W)})}return K}async _addToNodeFs(A,Q,B,G,Z){let Y=this.fsw._emitReady;if(this.fsw._isIgnored(A)||this.fsw.closed)return Y(),!1;let J=this.fsw._getWatchHelpers(A);if(B)J.filterPath=(I)=>B.filterPath(I),J.filterDir=(I)=>B.filterDir(I);try{let I=await Le6[J.statMethod](J.watchPath);if(this.fsw.closed)return;if(this.fsw._isIgnored(J.watchPath,I))return Y(),!1;let X=this.fsw.options.followSymlinks,W;if(I.isDirectory()){let K=dY.resolve(A),V=X?await vx1(A):A;if(this.fsw.closed)return;if(W=await this._handleDir(J.watchPath,I,Q,G,Z,J,V),this.fsw.closed)return;if(K!==V&&V!==void 0)this.fsw._symlinkPaths.set(K,V)}else if(I.isSymbolicLink()){let K=X?await vx1(A):A;if(this.fsw.closed)return;let V=dY.dirname(J.watchPath);if(this.fsw._getWatchedDir(V).add(J.watchPath),this.fsw._emit(_R.ADD,J.watchPath,I),W=await this._handleDir(V,I,Q,G,A,J,K),this.fsw.closed)return;if(K!==void 0)this.fsw._symlinkPaths.set(dY.resolve(A),K)}else W=this._handleFile(J.watchPath,I,Q);if(Y(),W)this.fsw._addPathCloser(A,W);return!1}catch(I){if(this.fsw._handleError(I))return Y(),A}}}var Ue6="data",bx1="end",DiQ="close",gcA=()=>{},ucA,hx1,$e6,we6,Ne6,HiQ,JY,_R,qe6="watch",Le6,Ms="listeners",fcA="errHandlers",X8A="rawEmitters",Me6,Oe6,Re6=(A)=>Oe6.has(dY.extname(A).slice(1).toLowerCase()),fx1=(A,Q)=>{if(A instanceof Set)A.forEach(Q);else Q(A)},DCA=(A,Q,B)=>{let G=A[Q];if(!(G instanceof Set))A[Q]=G=new Set([G]);G.add(B)},_e6=(A)=>(Q)=>{let B=A[Q];if(B instanceof Set)B.clear();else delete A[Q]},HCA=(A,Q,B)=>{let G=A[Q];if(G instanceof Set)G.delete(B);else if(G===B)delete A[Q]},FiQ=(A)=>A instanceof Set?A.size===0:!A,bcA,hcA=(A,Q,B,G,Z)=>{let Y=bcA.get(A);if(!Y)return;fx1(Y[Q],(J)=>{J(B,G,Z)})},Te6=(A,Q,B,G)=>{let{listener:Z,errHandler:Y,rawEmitter:J}=G,I=bcA.get(Q),X;if(!B.persistent){if(X=ViQ(A,B,Z,Y,J),!X)return;return X.close.bind(X)}if(I)DCA(I,Ms,Z),DCA(I,fcA,Y),DCA(I,X8A,J);else{if(X=ViQ(A,B,hcA.bind(null,Q,Ms),Y,hcA.bind(null,Q,X8A)),!X)return;X.on(_R.ERROR,async(W)=>{let K=hcA.bind(null,Q,fcA);if(I)I.watcherUnusable=!0;if(hx1&&W.code==="EPERM")try{await(await Fe6(A,"r")).close(),K(W)}catch(V){}else K(W)}),I={listeners:Z,errHandlers:Y,rawEmitters:J,watcher:X},bcA.set(Q,I)}return()=>{if(HCA(I,Ms,Z),HCA(I,fcA,Y),HCA(I,X8A,J),FiQ(I.listeners))I.watcher.close(),bcA.delete(Q),Me6.forEach(_e6(I)),I.watcher=void 0,Object.freeze(I)}},kx1,je6=(A,Q,B,G)=>{let{listener:Z,rawEmitter:Y}=G,J=kx1.get(Q),I=J&&J.options;if(I&&(I.persistent<B.persistent||I.interval>B.interval))KiQ(Q),J=void 0;if(J)DCA(J,Ms,Z),DCA(J,X8A,Y);else J={listeners:Z,rawEmitters:Y,options:B,watcher:De6(Q,B,(X,W)=>{fx1(J.rawEmitters,(V)=>{V(_R.CHANGE,Q,{curr:X,prev:W})});let K=X.mtimeMs;if(X.size!==W.size||K>W.mtimeMs||K===0)fx1(J.listeners,(V)=>V(A,X))})},kx1.set(Q,J);return()=>{if(HCA(J,Ms,Z),HCA(J,X8A,Y),FiQ(J.listeners))kx1.delete(Q),KiQ(Q),J.options=J.watcher=void 0,Object.freeze(J)}};var CiQ=L(()=>{ucA=process.platform,hx1=ucA==="win32",$e6=ucA==="darwin",we6=ucA==="linux",Ne6=ucA==="freebsd",HiQ=ze6()==="OS400",JY={ALL:"all",READY:"ready",ADD:"add",CHANGE:"change",ADD_DIR:"addDir",UNLINK:"unlink",UNLINK_DIR:"unlinkDir",RAW:"raw",ERROR:"error"},_R=JY,Le6={lstat:Ce6,stat:EiQ},Me6=[Ms,fcA,X8A],Oe6=new Set(["3dm","3ds","3g2","3gp","7z","a","aac","adp","afdesign","afphoto","afpub","ai","aif","aiff","alz","ape","apk","appimage","ar","arj","asf","au","avi","bak","baml","bh","bin","bk","bmp","btif","bz2","bzip2","cab","caf","cgm","class","cmx","cpio","cr2","cur","dat","dcm","deb","dex","djvu","dll","dmg","dng","doc","docm","docx","dot","dotm","dra","DS_Store","dsk","dts","dtshd","dvb","dwg","dxf","ecelp4800","ecelp7470","ecelp9600","egg","eol","eot","epub","exe","f4v","fbs","fh","fla","flac","flatpak","fli","flv","fpx","fst","fvt","g3","gh","gif","graffle","gz","gzip","h261","h263","h264","icns","ico","ief","img","ipa","iso","jar","jpeg","jpg","jpgv","jpm","jxr","key","ktx","lha","lib","lvp","lz","lzh","lzma","lzo","m3u","m4a","m4v","mar","mdi","mht","mid","midi","mj2","mka","mkv","mmr","mng","mobi","mov","movie","mp3","mp4","mp4a","mpeg","mpg","mpga","mxu","nef","npx","numbers","nupkg","o","odp","ods","odt","oga","ogg","ogv","otf","ott","pages","pbm","pcx","pdb","pdf","pea","pgm","pic","png","pnm","pot","potm","potx","ppa","ppam","ppm","pps","ppsm","ppsx","ppt","pptm","pptx","psd","pya","pyc","pyo","pyv","qt","rar","ras","raw","resources","rgb","rip","rlc","rmf","rmvb","rpm","rtf","rz","s3m","s7z","scpt","sgi","shar","snap","sil","sketch","slk","smv","snk","so","stl","suo","sub","swf","tar","tbz","tbz2","tga","tgz","thmx","tif","tiff","tlz","ttc","ttf","txz","udf","uvh","uvi","uvm","uvp","uvs","uvu","viv","vob","war","wav","wax","wbmp","wdp","weba","webm","webp","whl","wim","wm","wma","wmv","wmx","woff","woff2","wrm","wvx","xbm","xif","xla","xlam","xls","xlsb","xlsm","xlsx","xlt","xltm","xltx","xm","xmind","xpi","xpm","xwd","xz","z","zip","zipx"]),bcA=new Map;kx1=new Map});import{stat as Pe6}from"fs";import{stat as Se6,readdir as xe6}from"fs/promises";import{EventEmitter as ye6}from"events";import*as B8 from"path";function mcA(A){return Array.isArray(A)?A:[A]}function ue6(A){if(typeof A==="function")return A;if(typeof A==="string")return(Q)=>A===Q;if(A instanceof RegExp)return(Q)=>A.test(Q);if(typeof A==="object"&&A!==null)return(Q)=>{if(A.path===Q)return!0;if(A.recursive){let B=B8.relative(A.path,Q);if(!B)return!1;return!B.startsWith("..")&&!B8.isAbsolute(B)}return!1};return()=>!1}function me6(A){if(typeof A!=="string")throw Error("string expected");A=B8.normalize(A),A=A.replace(/\\/g,"/");let Q=!1;if(A.startsWith("//"))Q=!0;let B=/\/\//;while(A.match(B))A=A.replace(B,"/");if(Q)A="/"+A;return A}function UiQ(A,Q,B){let G=me6(Q);for(let Z=0;Z<A.length;Z++){let Y=A[Z];if(Y(G,B))return!0}return!1}function de6(A,Q){if(A==null)throw TypeError("anymatch: specify first argument");let G=mcA(A).map((Z)=>ue6(Z));if(Q==null)return(Z,Y)=>{return UiQ(G,Z,Y)};return UiQ(G,Q)}class MiQ{constructor(A,Q){this.path=A,this._removeWatcher=Q,this.items=new Set}add(A){let{items:Q}=this;if(!Q)return;if(A!==qiQ&&A!==ke6)Q.add(A)}async remove(A){let{items:Q}=this;if(!Q)return;if(Q.delete(A),Q.size>0)return;let B=this.path;try{await xe6(B)}catch(G){if(this._removeWatcher)this._removeWatcher(B8.dirname(B),B8.basename(B))}}has(A){let{items:Q}=this;if(!Q)return;return Q.has(A)}getChildren(){let{items:A}=this;if(!A)return[];return[...A.values()]}dispose(){this.items.clear(),this.path="",this._removeWatcher=gcA,this.items=pe6,Object.freeze(this)}}class OiQ{constructor(A,Q,B){this.fsw=B;let G=A;this.path=A=A.replace(ge6,""),this.watchPath=G,this.fullWatchPath=B8.resolve(G),this.dirParts=[],this.dirParts.forEach((Z)=>{if(Z.length>1)Z.pop()}),this.followSymlinks=Q,this.statMethod=Q?le6:ie6}entryPath(A){return B8.join(this.watchPath,B8.relative(this.watchPath,A.fullPath))}filterPath(A){let{stats:Q}=A;if(Q&&Q.isSymbolicLink())return this.filterDir(A);let B=this.entryPath(A);return this.fsw._isntIgnored(B,Q)&&this.fsw._hasReadPermissions(Q)}filterDir(A){return this.fsw._isntIgnored(this.entryPath(A),A.stats)}}function ne6(A,Q={}){let B=new dx1(Q);return B.add(A),B}var ux1="/",ve6="//",qiQ=".",ke6="..",fe6="string",be6,ziQ,he6,ge6,mx1=(A)=>typeof A==="object"&&A!==null&&!(A instanceof RegExp),$iQ=(A)=>{let Q=mcA(A).flat();if(!Q.every((B)=>typeof B===fe6))throw TypeError(`Non-string provided as watch path: ${Q}`);return Q.map(LiQ)},wiQ=(A)=>{let Q=A.replace(be6,ux1),B=!1;if(Q.startsWith(ve6))B=!0;while(Q.match(ziQ))Q=Q.replace(ziQ,ux1);if(B)Q=ux1+Q;return Q},LiQ=(A)=>wiQ(B8.normalize(wiQ(A))),NiQ=(A="")=>(Q)=>{if(typeof Q==="string")return LiQ(B8.isAbsolute(Q)?Q:B8.join(A,Q));else return Q},ce6=(A,Q)=>{if(B8.isAbsolute(A))return A;return B8.join(Q,A)},pe6,le6="stat",ie6="lstat",dx1,RiQ;var _iQ=L(()=>{WiQ();CiQ();/*! chokidar - MIT License (c) 2012 Paul Miller (paulmillr.com) */be6=/\\/g,ziQ=/\/\//,he6=/\..*\.(sw[px])$|~$|\.subl.*\.tmp/,ge6=/^\.[/\\]/;pe6=Object.freeze(new Set);dx1=class dx1 extends ye6{constructor(A={}){super();this.closed=!1,this._closers=new Map,this._ignoredPaths=new Set,this._throttled=new Map,this._streams=new Set,this._symlinkPaths=new Map,this._watched=new Map,this._pendingWrites=new Map,this._pendingUnlinks=new Map,this._readyCount=0,this._readyEmitted=!1;let Q=A.awaitWriteFinish,B={stabilityThreshold:2000,pollInterval:100},G={persistent:!0,ignoreInitial:!1,ignorePermissionErrors:!1,interval:100,binaryInterval:300,followSymlinks:!0,usePolling:!1,atomic:!0,...A,ignored:A.ignored?mcA(A.ignored):mcA([]),awaitWriteFinish:Q===!0?B:typeof Q==="object"?{...B,...Q}:!1};if(HiQ)G.usePolling=!0;if(G.atomic===void 0)G.atomic=!G.usePolling;let Z=process.env.CHOKIDAR_USEPOLLING;if(Z!==void 0){let I=Z.toLowerCase();if(I==="false"||I==="0")G.usePolling=!1;else if(I==="true"||I==="1")G.usePolling=!0;else G.usePolling=!!I}let Y=process.env.CHOKIDAR_INTERVAL;if(Y)G.interval=Number.parseInt(Y,10);let J=0;this._emitReady=()=>{if(J++,J>=this._readyCount)this._emitReady=gcA,this._readyEmitted=!0,process.nextTick(()=>this.emit(JY.READY))},this._emitRaw=(...I)=>this.emit(JY.RAW,...I),this._boundRemove=this._remove.bind(this),this.options=G,this._nodeFsHandler=new gx1(this),Object.freeze(G)}_addIgnoredPath(A){if(mx1(A)){for(let Q of this._ignoredPaths)if(mx1(Q)&&Q.path===A.path&&Q.recursive===A.recursive)return}this._ignoredPaths.add(A)}_removeIgnoredPath(A){if(this._ignoredPaths.delete(A),typeof A==="string"){for(let Q of this._ignoredPaths)if(mx1(Q)&&Q.path===A)this._ignoredPaths.delete(Q)}}add(A,Q,B){let{cwd:G}=this.options;this.closed=!1,this._closePromise=void 0;let Z=$iQ(A);if(G)Z=Z.map((Y)=>{return ce6(Y,G)});if(Z.forEach((Y)=>{this._removeIgnoredPath(Y)}),this._userIgnored=void 0,!this._readyCount)this._readyCount=0;return this._readyCount+=Z.length,Promise.all(Z.map(async(Y)=>{let J=await this._nodeFsHandler._addToNodeFs(Y,!B,void 0,0,Q);if(J)this._emitReady();return J})).then((Y)=>{if(this.closed)return;Y.forEach((J)=>{if(J)this.add(B8.dirname(J),B8.basename(Q||J))})}),this}unwatch(A){if(this.closed)return this;let Q=$iQ(A),{cwd:B}=this.options;return Q.forEach((G)=>{if(!B8.isAbsolute(G)&&!this._closers.has(G)){if(B)G=B8.join(B,G);G=B8.resolve(G)}if(this._closePath(G),this._addIgnoredPath(G),this._watched.has(G))this._addIgnoredPath({path:G,recursive:!0});this._userIgnored=void 0}),this}close(){if(this._closePromise)return this._closePromise;this.closed=!0,this.removeAllListeners();let A=[];return this._closers.forEach((Q)=>Q.forEach((B)=>{let G=B();if(G instanceof Promise)A.push(G)})),this._streams.forEach((Q)=>Q.destroy()),this._userIgnored=void 0,this._readyCount=0,this._readyEmitted=!1,this._watched.forEach((Q)=>Q.dispose()),this._closers.clear(),this._watched.clear(),this._streams.clear(),this._symlinkPaths.clear(),this._throttled.clear(),this._closePromise=A.length?Promise.all(A).then(()=>{return}):Promise.resolve(),this._closePromise}getWatched(){let A={};return this._watched.forEach((Q,B)=>{let Z=(this.options.cwd?B8.relative(this.options.cwd,B):B)||qiQ;A[Z]=Q.getChildren().sort()}),A}emitWithAll(A,Q){if(this.emit(A,...Q),A!==JY.ERROR)this.emit(JY.ALL,A,...Q)}async _emit(A,Q,B){if(this.closed)return;let G=this.options;if(hx1)Q=B8.normalize(Q);if(G.cwd)Q=B8.relative(G.cwd,Q);let Z=[Q];if(B!=null)Z.push(B);let Y=G.awaitWriteFinish,J;if(Y&&(J=this._pendingWrites.get(Q)))return J.lastChange=new Date,this;if(G.atomic){if(A===JY.UNLINK)return this._pendingUnlinks.set(Q,[A,...Z]),setTimeout(()=>{this._pendingUnlinks.forEach((I,X)=>{this.emit(...I),this.emit(JY.ALL,...I),this._pendingUnlinks.delete(X)})},typeof G.atomic==="number"?G.atomic:100),this;if(A===JY.ADD&&this._pendingUnlinks.has(Q))A=JY.CHANGE,this._pendingUnlinks.delete(Q)}if(Y&&(A===JY.ADD||A===JY.CHANGE)&&this._readyEmitted){let I=(X,W)=>{if(X)A=JY.ERROR,Z[0]=X,this.emitWithAll(A,Z);else if(W){if(Z.length>1)Z[1]=W;else Z.push(W);this.emitWithAll(A,Z)}};return this._awaitWriteFinish(Q,Y.stabilityThreshold,A,I),this}if(A===JY.CHANGE){if(!this._throttle(JY.CHANGE,Q,50))return this}if(G.alwaysStat&&B===void 0&&(A===JY.ADD||A===JY.ADD_DIR||A===JY.CHANGE)){let I=G.cwd?B8.join(G.cwd,Q):Q,X;try{X=await Se6(I)}catch(W){}if(!X||this.closed)return;Z.push(X)}return this.emitWithAll(A,Z),this}_handleError(A){let Q=A&&A.code;if(A&&Q!=="ENOENT"&&Q!=="ENOTDIR"&&(!this.options.ignorePermissionErrors||Q!=="EPERM"&&Q!=="EACCES"))this.emit(JY.ERROR,A);return A||this.closed}_throttle(A,Q,B){if(!this._throttled.has(A))this._throttled.set(A,new Map);let G=this._throttled.get(A);if(!G)throw Error("invalid throttle");let Z=G.get(Q);if(Z)return Z.count++,!1;let Y,J=()=>{let X=G.get(Q),W=X?X.count:0;if(G.delete(Q),clearTimeout(Y),X)clearTimeout(X.timeoutObject);return W};Y=setTimeout(J,B);let I={timeoutObject:Y,clear:J,count:0};return G.set(Q,I),I}_incrReadyCount(){return this._readyCount++}_awaitWriteFinish(A,Q,B,G){let Z=this.options.awaitWriteFinish;if(typeof Z!=="object")return;let Y=Z.pollInterval,J,I=A;if(this.options.cwd&&!B8.isAbsolute(A))I=B8.join(this.options.cwd,A);let X=new Date,W=this._pendingWrites;function K(V){Pe6(I,(E,D)=>{if(E||!W.has(A)){if(E&&E.code!=="ENOENT")G(E);return}let H=Number(new Date);if(V&&D.size!==V.size)W.get(A).lastChange=H;let F=W.get(A);if(H-F.lastChange>=Q)W.delete(A),G(void 0,D);else J=setTimeout(K,Y,D)})}if(!W.has(A))W.set(A,{lastChange:X,cancelWait:()=>{return W.delete(A),clearTimeout(J),B}}),J=setTimeout(K,Y)}_isIgnored(A,Q){if(this.options.atomic&&he6.test(A))return!0;if(!this._userIgnored){let{cwd:B}=this.options,Z=(this.options.ignored||[]).map(NiQ(B)),J=[...[...this._ignoredPaths].map(NiQ(B)),...Z];this._userIgnored=de6(J,void 0)}return this._userIgnored(A,Q)}_isntIgnored(A,Q){return!this._isIgnored(A,Q)}_getWatchHelpers(A){return new OiQ(A,this.options.followSymlinks,this)}_getWatchedDir(A){let Q=B8.resolve(A);if(!this._watched.has(Q))this._watched.set(Q,new MiQ(Q,this._boundRemove));return this._watched.get(Q)}_hasReadPermissions(A){if(this.options.ignorePermissionErrors)return!0;return Boolean(Number(A.mode)&256)}_remove(A,Q,B){let G=B8.join(A,Q),Z=B8.resolve(G);if(B=B!=null?B:this._watched.has(G)||this._watched.has(Z),!this._throttle("remove",G,100))return;if(!B&&this._watched.size===1)this.add(A,Q,!0);this._getWatchedDir(G).getChildren().forEach((V)=>this._remove(G,V));let I=this._getWatchedDir(A),X=I.has(Q);if(I.remove(Q),this._symlinkPaths.has(Z))this._symlinkPaths.delete(Z);let W=G;if(this.options.cwd)W=B8.relative(this.options.cwd,G);if(this.options.awaitWriteFinish&&this._pendingWrites.has(W)){if(this._pendingWrites.get(W).cancelWait()===JY.ADD)return}this._watched.delete(G),this._watched.delete(Z);let K=B?JY.UNLINK_DIR:JY.UNLINK;if(X&&!this._isIgnored(G))this._emit(K,G);this._closePath(G)}_closePath(A){this._closeFile(A);let Q=B8.dirname(A);this._getWatchedDir(Q).remove(B8.basename(A))}_closeFile(A){let Q=this._closers.get(A);if(!Q)return;Q.forEach((B)=>B()),this._closers.delete(A)}_addPathCloser(A,Q){if(!Q)return;let B=this._closers.get(A);if(!B)B=[],this._closers.set(A,B);B.push(Q)}_readdirp(A,Q){if(this.closed)return;let B={type:JY.ALL,alwaysStat:!0,lstat:!0,...Q,depth:0},G=XiQ(A,B);return this._streams.add(G),G.once(DiQ,()=>{G=void 0}),G.once(bx1,()=>{if(G)this._streams.delete(G),G=void 0}),G}};RiQ={watch:ne6,FSWatcher:dx1}});function rd(A){switch(A){case"userSettings":return"user";case"projectSettings":return"project";case"localSettings":return"project, gitignored";case"flagSettings":return"cli flag";case"policySettings":return"managed"}}function dcA(A){switch(A){case"userSettings":return"user settings";case"projectSettings":return"shared project settings";case"localSettings":return"project local settings";case"flagSettings":return"command line arguments";case"policySettings":return"enterprise managed settings";case"cliArg":return"CLI argument";case"command":return"command configuration";case"session":return"current session"}}function TiQ(A){switch(A){case"userSettings":return"User settings";case"projectSettings":return"Shared project settings";case"localSettings":return"Project local settings";case"flagSettings":return"Command line arguments";case"policySettings":return"Enterprise managed settings";case"cliArg":return"CLI argument";case"command":return"Command configuration";case"session":return"Current session"}}function jiQ(A){if(A==="")return[];let Q=A.split(",").map((G)=>G.trim()),B=[];for(let G of Q)switch(G){case"user":B.push("userSettings");break;case"project":B.push("projectSettings");break;case"local":B.push("localSettings");break;default:throw Error(`Invalid setting source: ${G}. Valid options are: user, project, local`)}return B}function Os(){let A=yK0(),Q=new Set(A);return Q.add("policySettings"),Q.add("flagSettings"),Array.from(Q)}function sK(A){return Os().includes(A)}var JL,PiQ="https://json.schemastore.org/claude-code-settings.json";var tI=L(()=>{g0();JL=["userSettings","projectSettings","localSettings","flagSettings","policySettings"]});import*as xiQ from"path";function se6(){if(SiQ||yiQ)return;SiQ=!0;let A=AA3();if(A.length===0)return;f(`Watching for changes in setting files ${A.join(", ")}...`),W8A=RiQ.watch(A,{persistent:!0,ignoreInitial:!0,awaitWriteFinish:{stabilityThreshold:ae6,pollInterval:oe6},ignored:(Q)=>Q.split(xiQ.sep).some((B)=>B===".git"),ignorePermissionErrors:!0,usePolling:!1,atomic:!0}),W8A.on("change",QA3),W8A.on("unlink",BA3),U8(async()=>viQ())}function viQ(){if(yiQ=!0,W8A)W8A.close(),W8A=null;ccA.clear(),K8A.clear()}function te6(A){return K8A.add(A),()=>{K8A.delete(A)}}function ee6(A){let Q=qF(A);if(Q)ccA.set(Q,Date.now())}function AA3(){let A=jA();return JL.map((Q)=>{let B=qF(Q);if(!B)return;try{if(!A.statSync(B).isFile())return}catch{return}return B}).filter((Q)=>Q!==void 0)}function QA3(A){let Q=kiQ(A);if(!Q)return;let B=ccA.get(A);if(B&&Date.now()-B<re6){ccA.delete(A);return}f(`Detected change to ${A}`),K8A.forEach((G)=>G(Q))}function BA3(A){let Q=kiQ(A);if(!Q)return;f(`Detected deletion of ${A}`),K8A.forEach((B)=>B(Q))}function kiQ(A){return JL.find((Q)=>qF(Q)===A)}function GA3(A){f(`Programmatic settings change notification for ${A}`),K8A.forEach((Q)=>Q(A))}var ae6=1000,oe6=500,re6=5000,W8A=null,SiQ=!1,yiQ=!1,ccA,K8A,NF;var Rs=L(()=>{_iQ();Y0();XQ();jB();tI();bW();ccA=new Map,K8A=new Set;NF={initialize:se6,dispose:viQ,subscribe:te6,markInternalWrite:ee6,notifyChange:GA3}});function V8A(A){let Q=pcA.useCallback((B)=>{TR();let G=NQ();A(B,G)},[A]);pcA.useEffect(()=>NF.subscribe(Q),[Q])}var pcA;var lcA=L(()=>{Rs();jB();pcA=o(WA(),1)});function YA3(A){let Q=qF(A);if(!Q||!jA().existsSync(Q))return null;try{let{resolvedPath:B}=gI(jA(),Q),G=wE(B);if(G.trim()==="")return{};let Z=h8(G,!1);return Z&&typeof Z==="object"?Z:null}catch{return null}}function JA3(A,Q){if(!A||!A.permissions)return[];let{permissions:B}=A,G=[];for(let Z of ZA3){let Y=B[Z];if(Y)for(let J of Y)G.push({source:Q,ruleBehavior:Z,ruleValue:IL(J)})}return G}function icA(){let A=[];for(let Q of Os())A.push(...ncA(Q));return A}function ncA(A){let Q=uB(A);return JA3(Q,A)}function fiQ(A){if(!IA3.includes(A.source))return!1;let Q=B5(A.ruleValue),B=uB(A.source);if(!B||!B.permissions)return!1;let G=B.permissions[A.ruleBehavior];if(!G||!G.includes(Q))return!1;try{let Z={...B,permissions:{...B.permissions,[A.ruleBehavior]:G.filter((J)=>J!==Q)}},{error:Y}=E2(A.source,Z);if(Y)return!1;return!0}catch(Z){return s(Z instanceof Error?Z:Error(String(Z))),!1}}function XA3(){return{permissions:{}}}function acA({ruleValues:A,ruleBehavior:Q},B){if(A.length<1)return!0;let G=A.map(B5),Z=uB(B)||YA3(B)||XA3();try{let Y=Z.permissions||{},J=Y[Q]||[],I=new Set(J),X=G.filter((V)=>!I.has(V));if(X.length===0)return!0;let W={...Z,permissions:{...Y,[Q]:[...J,...X]}},K=E2(B,W);if(K.error)throw K.error;return!0}catch(Y){return s(Y instanceof Error?Y:Error(String(Y))),!1}}var ZA3,IA3;var _s=L(()=>{h1();oG();tI();jB();XQ();M9();uI();ZA3=["allow","deny","ask"];IA3=["userSettings","projectSettings","localSettings"]});import{posix as WA3}from"path";function E8A(A){if(!A)return[];return A.flatMap((Q)=>{switch(Q.type){case"addRules":return Q.rules;default:return[]}})}function eI(A,Q){switch(Q.type){case"setMode":return f(`Applying permission update: Setting mode to '${Q.mode}'`),{...A,mode:Q.mode};case"addRules":{let B=Q.rules.map((Z)=>B5(Z));f(`Applying permission update: Adding ${Q.rules.length} ${Q.behavior} rule(s) to destination '${Q.destination}': ${JSON.stringify(B)}`);let G=Q.behavior==="allow"?"alwaysAllowRules":Q.behavior==="deny"?"alwaysDenyRules":"alwaysAskRules";return{...A,[G]:{...A[G],[Q.destination]:[...A[G][Q.destination]||[],...B]}}}case"replaceRules":{let B=Q.rules.map((Z)=>B5(Z));f(`Replacing all ${Q.behavior} rules for destination '${Q.destination}' with ${Q.rules.length} rule(s): ${JSON.stringify(B)}`);let G=Q.behavior==="allow"?"alwaysAllowRules":Q.behavior==="deny"?"alwaysDenyRules":"alwaysAskRules";return{...A,[G]:{...A[G],[Q.destination]:B}}}case"addDirectories":{f(`Applying permission update: Adding ${Q.directories.length} director${Q.directories.length===1?"y":"ies"} with destination '${Q.destination}': ${JSON.stringify(Q.directories)}`);let B=new Map(A.additionalWorkingDirectories);for(let G of Q.directories)B.set(G,{path:G,source:Q.destination});return{...A,additionalWorkingDirectories:B}}case"removeRules":{let B=Q.rules.map((I)=>B5(I));f(`Applying permission update: Removing ${Q.rules.length} ${Q.behavior} rule(s) from source '${Q.destination}': ${JSON.stringify(B)}`);let G=Q.behavior==="allow"?"alwaysAllowRules":Q.behavior==="deny"?"alwaysDenyRules":"alwaysAskRules",Z=A[G][Q.destination]||[],Y=new Set(B),J=Z.filter((I)=>!Y.has(I));return{...A,[G]:{...A[G],[Q.destination]:J}}}case"removeDirectories":{f(`Applying permission update: Removing ${Q.directories.length} director${Q.directories.length===1?"y":"ies"}: ${JSON.stringify(Q.directories)}`);let B=new Map(A.additionalWorkingDirectories);for(let G of Q.directories)B.delete(G);return{...A,additionalWorkingDirectories:B}}default:return A}}function sk(A,Q){let B=A;for(let G of Q)B=eI(B,G);return B}function FCA(A){return A==="localSettings"||A==="userSettings"||A==="projectSettings"}function eP(A){if(!FCA(A.destination))return;switch(f(`Persisting permission update: ${A.type} to source '${A.destination}'`),A.type){case"addRules":{f(`Persisting ${A.rules.length} ${A.behavior} rule(s) to ${A.destination}`),acA({ruleValues:A.rules,ruleBehavior:A.behavior},A.destination);break}case"addDirectories":{f(`Persisting ${A.directories.length} director${A.directories.length===1?"y":"ies"} to ${A.destination}`);let B=uB(A.destination)?.permissions?.additionalDirectories||[],G=A.directories.filter((Z)=>!B.includes(Z));if(G.length>0){let Z=[...B,...G];E2(A.destination,{permissions:{additionalDirectories:Z}})}break}case"removeRules":{f(`Removing ${A.rules.length} ${A.behavior} rule(s) from ${A.destination}`);let G=(uB(A.destination)?.permissions||{})[A.behavior]||[],Z=new Set(A.rules.map(B5)),Y=G.filter((J)=>!Z.has(J));E2(A.destination,{permissions:{[A.behavior]:Y}});break}case"removeDirectories":{f(`Removing ${A.directories.length} director${A.directories.length===1?"y":"ies"} from ${A.destination}`);let B=uB(A.destination)?.permissions?.additionalDirectories||[],G=new Set(A.directories),Z=B.filter((Y)=>!G.has(Y));E2(A.destination,{permissions:{additionalDirectories:Z}});break}case"setMode":{f(`Persisting mode '${A.mode}' to ${A.destination}`),E2(A.destination,{permissions:{defaultMode:A.mode}});break}case"replaceRules":{f(`Replacing all ${A.behavior} rules in ${A.destination} with ${A.rules.length} rule(s)`);let Q=A.rules.map(B5);E2(A.destination,{permissions:{[A.behavior]:Q}});break}}}function D8A(A){for(let Q of A)eP(Q)}function ocA(A,Q="session"){try{if(jA().statSync(A).isDirectory()){let G=rcA(A);if(G==="/")return;return{type:"addRules",rules:[{toolName:"Read",ruleContent:WA3.isAbsolute(G)?`/${G}/**`:`${G}/**`}],behavior:"allow",destination:Q}}}catch{}return}var tK=L(()=>{oG();Y0();jB();_s();XQ();cY()});var e9="Bash";function JB(A,Q){if(!process.env.SRT_DEBUG)return;let B=Q?.level||"info",G="[SandboxDebug]";switch(B){case"error":console.error(`${G} ${A}`);break;case"warn":console.warn(`${G} ${A}`);break;default:console.error(`${G} ${A}`)}}import{createServer as KA3}from"node:http";import{request as VA3}from"node:http";import{request as EA3}from"node:https";import{connect as DA3}from"node:net";import{URL as HA3}from"node:url";function biQ(A){let Q=KA3();return Q.on("connect",async(B,G)=>{G.on("error",(Z)=>{JB(`Client socket error: ${Z.message}`,{level:"error"})});try{let[Z,Y]=B.url.split(":"),J=Y===void 0?void 0:parseInt(Y,10);if(!Z||!J){JB(`Invalid CONNECT request: ${B.url}`,{level:"error"}),G.end(`HTTP/1.1 400 Bad Request\r
4685:`)),process.exit(1)}}function eH5(A){try{let Q=jiQ(A);vK0(Q),TR()}catch(Q){if(Q instanceof Error)s(Q);process.stderr.write(cA.red(`Error processing --setting-sources: ${Q instanceof Error?Q.message:String(Q)}[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"function jiQ\\b\" bundles/ClaudeCodeCode/cli.js | head -n 20"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 58ms:[0m
[2m396:`);ok=[],B.appendFileSync(Q,G.join(""),{mode:384})}catch(Q){f(`Failed to write prompt history: ${Q}`)}finally{if(A)await A()}}async function slQ(A){if(Px1||ok.length===0)return;if(A>5)return;Px1=!0;try{await rlQ()}finally{if(Px1=!1,ok.length>0)await new Promise((Q)=>setTimeout(Q,500)),slQ(A+1)}}async function tt6(A){let Q=typeof A==="string"?{display:A,pastedContents:{}}:A,B={};if(Q.pastedContents){for(let[Z,Y]of Object.entries(Q.pastedContents))if(Y.type!=="image"&&Y.content.length<=rt6)B[Number(Z)]=Y}let G={...Q,pastedContents:B,timestamp:Date.now(),project:pQ(),sessionId:W0()};ok.push(G),xcA=slQ(0)}function Ns(A){if(!plQ)plQ=!0,U8(async()=>{if(xcA)await xcA;if(ok.length>0)await rlQ()});tt6(A)}var ilQ,ot6=100,rt6=1024,ok,Px1=!1,xcA=null,plQ=!1;var nd=L(()=>{rQ();XQ();g0();Y0();bW();ilQ=o(Gm(),1);ok=[]});var xx1,et6,yz,qs,kcA;var ad=L(()=>{k3();xx1=o(zR(),1),et6=dQ()!=="windows"||(ga()?xx1.default.satisfies(process.versions.bun,">=1.2.23"):xx1.default.satisfies(process.versions.node,">=22.17.0 <23.0.0 || >=24.2.0")),yz=!et6?{displayText:"alt+m",check:(A,Q)=>Q.meta&&(A==="m"||A==="M")}:{displayText:"shift+tab",check:(A,Q)=>Q.tab&&Q.shift},qs=dQ()==="windows"?{displayText:"alt+v",check:(A,Q)=>Q.meta&&(A==="v"||A==="V")}:{displayText:"ctrl+v",check:(A,Q)=>Q.ctrl&&(A==="v"||A==="V")},kcA={displayText:"alt+p",check:(A,Q)=>Q.meta&&(A==="p"||A==="P")}});function tlQ(A,Q){switch(Q){case"bash":return`!${A}`;case"memorySelect":return`#${A}`;case"background":return`&${A}`;default:return A}}function rk(A){if(A.startsWith("!"))return"bash";if(A.startsWith("#"))return"memory";if(A.startsWith("&"))return"background";return"prompt"}function Ls(A){if(rk(A)==="prompt")return A;return A.slice(1)}function elQ(A){return A==="!"||A==="#"||A==="&"}function od(A){return A.filter((Q)=>Q.data?.type!=="hook_progress")}function Ae6(A,Q){return A.name===Q||(A.aliases?.includes(Q)??!1)}function AiQ(A,Q){return A.find((B)=>Ae6(B,Q))}var s$=()=>({mode:"default",additionalWorkingDirectories:new Map,alwaysAllowRules:{},alwaysDenyRules:{},alwaysAskRules:{},isBypassPermissionsModeAvailable:!1});import{stat as Qe6,lstat as QiQ,readdir as Be6,realpath as Ge6}from"node:fs/promises";import{Readable as Ze6}from"node:stream";import{resolve as BiQ,relative as Ye6,join as Je6,sep as Ie6}from"node:path";function XiQ(A,Q={}){let B=Q.entryType||Q.type;if(B==="both")B=t$.FILE_DIR_TYPE;if(B)Q.type=B;if(!A)throw Error("readdirp: root argument is required. Usage: readdirp(root, options)");else if(typeof A!=="string")throw TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");else if(B&&!GiQ.includes(B))throw Error(`readdirp: Invalid type passed. Use one of ${GiQ.join(", ")}`);return Q.root=A,new IiQ(Q)}var t$,yx1,JiQ="READDIRP_RECURSIVE_ERROR",Xe6,GiQ,We6,Ke6,Ve6=(A)=>Xe6.has(A.code),Ee6,ZiQ=(A)=>!0,YiQ=(A)=>{if(A===void 0)return ZiQ;if(typeof A==="function")return A;if(typeof A==="string"){let Q=A.trim();return(B)=>B.basename===Q}if(Array.isArray(A)){let Q=A.map((B)=>B.trim());return(B)=>Q.some((G)=>B.basename===G)}return ZiQ},IiQ;var WiQ=L(()=>{t$={FILE_TYPE:"files",DIR_TYPE:"directories",FILE_DIR_TYPE:"files_directories",EVERYTHING_TYPE:"all"},yx1={root:".",fileFilter:(A)=>!0,directoryFilter:(A)=>!0,type:t$.FILE_TYPE,lstat:!1,depth:2147483648,alwaysStat:!1,highWaterMark:4096};Object.freeze(yx1);Xe6=new Set(["ENOENT","EPERM","EACCES","ELOOP",JiQ]),GiQ=[t$.DIR_TYPE,t$.EVERYTHING_TYPE,t$.FILE_DIR_TYPE,t$.FILE_TYPE],We6=new Set([t$.DIR_TYPE,t$.EVERYTHING_TYPE,t$.FILE_DIR_TYPE]),Ke6=new Set([t$.EVERYTHING_TYPE,t$.FILE_DIR_TYPE,t$.FILE_TYPE]),Ee6=process.platform==="win32";IiQ=class IiQ extends Ze6{constructor(A={}){super({objectMode:!0,autoDestroy:!0,highWaterMark:A.highWaterMark});let Q={...yx1,...A},{root:B,type:G}=Q;this._fileFilter=YiQ(Q.fileFilter),this._directoryFilter=YiQ(Q.directoryFilter);let Z=Q.lstat?QiQ:Qe6;if(Ee6)this._stat=(Y)=>Z(Y,{bigint:!0});else this._stat=Z;this._maxDepth=Q.depth??yx1.depth,this._wantsDir=G?We6.has(G):!1,this._wantsFile=G?Ke6.has(G):!1,this._wantsEverything=G===t$.EVERYTHING_TYPE,this._root=BiQ(B),this._isDirent=!Q.alwaysStat,this._statsProp=this._isDirent?"dirent":"stats",this._rdOptions={encoding:"utf8",withFileTypes:this._isDirent},this.parents=[this._exploreDir(B,1)],this.reading=!1,this.parent=void 0}async _read(A){if(this.reading)return;this.reading=!0;try{while(!this.destroyed&&A>0){let Q=this.parent,B=Q&&Q.files;if(B&&B.length>0){let{path:G,depth:Z}=Q,Y=B.splice(0,A).map((I)=>this._formatEntry(I,G)),J=await Promise.all(Y);for(let I of J){if(!I)continue;if(this.destroyed)return;let X=await this._getEntryType(I);if(X==="directory"&&this._directoryFilter(I)){if(Z<=this._maxDepth)this.parents.push(this._exploreDir(I.fullPath,Z+1));if(this._wantsDir)this.push(I),A--}else if((X==="file"||this._includeAsFile(I))&&this._fileFilter(I)){if(this._wantsFile)this.push(I),A--}}}else{let G=this.parents.pop();if(!G){this.push(null);break}if(this.parent=await G,this.destroyed)return}}}catch(Q){this.destroy(Q)}finally{this.reading=!1}}async _exploreDir(A,Q){let B;try{B=await Be6(A,this._rdOptions)}catch(G){this._onError(G)}return{files:B,depth:Q,path:A}}async _formatEntry(A,Q){let B,G=this._isDirent?A.name:A;try{let Z=BiQ(Je6(Q,G));B={path:Ye6(this._root,Z),fullPath:Z,basename:G},B[this._statsProp]=this._isDirent?A:await this._stat(Z)}catch(Z){this._onError(Z);return}return B}_onError(A){if(Ve6(A)&&!this.destroyed)this.emit("warn",A);else this.destroy(A)}async _getEntryType(A){if(!A&&this._statsProp in A)return"";let Q=A[this._statsProp];if(Q.isFile())return"file";if(Q.isDirectory())return"directory";if(Q&&Q.isSymbolicLink()){let B=A.fullPath;try{let G=await Ge6(B),Z=await QiQ(G);if(Z.isFile())return"file";if(Z.isDirectory()){let Y=G.length;if(B.startsWith(G)&&B.substr(Y,1)===Ie6){let J=Error(`Circular symlink detected: "${B}" points to "${G}"`);return J.code=JiQ,this._onError(J)}return"directory"}}catch(G){return this._onError(G),""}}}_includeAsFile(A){let Q=A&&A[this._statsProp];return Q&&this._wantsEverything&&!Q.isDirectory()}}});import{watchFile as De6,unwatchFile as KiQ,watch as He6}from"fs";import{open as Fe6,stat as EiQ,lstat as Ce6,realpath as vx1}from"fs/promises";import*as dY from"path";import{type as ze6}from"os";function ViQ(A,Q,B,G,Z){let Y=(J,I)=>{if(B(A),Z(J,I,{watchedPath:A}),I&&A!==I)hcA(dY.resolve(A,I),Ms,dY.join(A,I))};try{return He6(A,{persistent:Q.persistent},Y)}catch(J){G(J);return}}class gx1{constructor(A){this.fsw=A,this._boundHandleError=(Q)=>A._handleError(Q)}_watchWithNodeFs(A,Q){let B=this.fsw.options,G=dY.dirname(A),Z=dY.basename(A);this.fsw._getWatchedDir(G).add(Z);let J=dY.resolve(A),I={persistent:B.persistent};if(!Q)Q=gcA;let X;if(B.usePolling){let W=B.interval!==B.binaryInterval;I.interval=W&&Re6(Z)?B.binaryInterval:B.interval,X=je6(A,J,I,{listener:Q,rawEmitter:this.fsw._emitRaw})}else X=Te6(A,J,I,{listener:Q,errHandler:this._boundHandleError,rawEmitter:this.fsw._emitRaw});return X}_handleFile(A,Q,B){if(this.fsw.closed)return;let G=dY.dirname(A),Z=dY.basename(A),Y=this.fsw._getWatchedDir(G),J=Q;if(Y.has(Z))return;let I=async(W,K)=>{if(!this.fsw._throttle(qe6,A,5))return;if(!K||K.mtimeMs===0)try{let V=await EiQ(A);if(this.fsw.closed)return;let{atimeMs:E,mtimeMs:D}=V;if(!E||E<=D||D!==J.mtimeMs)this.fsw._emit(_R.CHANGE,A,V);if(($e6||we6||Ne6)&&J.ino!==V.ino){this.fsw._closeFile(W),J=V;let H=this._watchWithNodeFs(A,I);if(H)this.fsw._addPathCloser(W,H)}else J=V}catch(V){this.fsw._remove(G,Z)}else if(Y.has(Z)){let{atimeMs:V,mtimeMs:E}=K;if(!V||V<=E||E!==J.mtimeMs)this.fsw._emit(_R.CHANGE,A,K);J=K}},X=this._watchWithNodeFs(A,I);if(!(B&&this.fsw.options.ignoreInitial)&&this.fsw._isntIgnored(A)){if(!this.fsw._throttle(_R.ADD,A,0))return;this.fsw._emit(_R.ADD,A,Q)}return X}async _handleSymlink(A,Q,B,G){if(this.fsw.closed)return;let Z=A.fullPath,Y=this.fsw._getWatchedDir(Q);if(!this.fsw.options.followSymlinks){this.fsw._incrReadyCount();let J;try{J=await vx1(B)}catch(I){return this.fsw._emitReady(),!0}if(this.fsw.closed)return;if(Y.has(G)){if(this.fsw._symlinkPaths.get(Z)!==J)this.fsw._symlinkPaths.set(Z,J),this.fsw._emit(_R.CHANGE,B,A.stats)}else Y.add(G),this.fsw._symlinkPaths.set(Z,J),this.fsw._emit(_R.ADD,B,A.stats);return this.fsw._emitReady(),!0}if(this.fsw._symlinkPaths.has(Z))return!0;this.fsw._symlinkPaths.set(Z,!0)}_handleRead(A,Q,B,G,Z,Y,J){if(A=dY.join(A,""),J=this.fsw._throttle("readdir",A,1000),!J)return;let I=this.fsw._getWatchedDir(B.path),X=new Set,W=this.fsw._readdirp(A,{fileFilter:(K)=>B.filterPath(K),directoryFilter:(K)=>B.filterDir(K)});if(!W)return;return W.on(Ue6,async(K)=>{if(this.fsw.closed){W=void 0;return}let V=K.path,E=dY.join(A,V);if(X.add(V),K.stats.isSymbolicLink()&&await this._handleSymlink(K,A,E,V))return;if(this.fsw.closed){W=void 0;return}if(V===G||!G&&!I.has(V))this.fsw._incrReadyCount(),E=dY.join(Z,dY.relative(Z,E)),this._addToNodeFs(E,Q,B,Y+1)}).on(_R.ERROR,this._boundHandleError),new Promise((K,V)=>{if(!W)return V();W.once(bx1,()=>{if(this.fsw.closed){W=void 0;return}let E=J?J.clear():!1;if(K(void 0),I.getChildren().filter((D)=>{return D!==A&&!X.has(D)}).forEach((D)=>{this.fsw._remove(A,D)}),W=void 0,E)this._handleRead(A,!1,B,G,Z,Y,J)})})}async _handleDir(A,Q,B,G,Z,Y,J){let I=this.fsw._getWatchedDir(dY.dirname(A)),X=I.has(dY.basename(A));if(!(B&&this.fsw.options.ignoreInitial)&&!Z&&!X)this.fsw._emit(_R.ADD_DIR,A,Q);I.add(dY.basename(A)),this.fsw._getWatchedDir(A);let W,K,V=this.fsw.options.depth;if((V==null||G<=V)&&!this.fsw._symlinkPaths.has(J)){if(!Z){if(await this._handleRead(A,B,Y,Z,A,G,W),this.fsw.closed)return}K=this._watchWithNodeFs(A,(E,D)=>{if(D&&D.mtimeMs===0)return;this._handleRead(E,!1,Y,Z,A,G,W)})}return K}async _addToNodeFs(A,Q,B,G,Z){let Y=this.fsw._emitReady;if(this.fsw._isIgnored(A)||this.fsw.closed)return Y(),!1;let J=this.fsw._getWatchHelpers(A);if(B)J.filterPath=(I)=>B.filterPath(I),J.filterDir=(I)=>B.filterDir(I);try{let I=await Le6[J.statMethod](J.watchPath);if(this.fsw.closed)return;if(this.fsw._isIgnored(J.watchPath,I))return Y(),!1;let X=this.fsw.options.followSymlinks,W;if(I.isDirectory()){let K=dY.resolve(A),V=X?await vx1(A):A;if(this.fsw.closed)return;if(W=await this._handleDir(J.watchPath,I,Q,G,Z,J,V),this.fsw.closed)return;if(K!==V&&V!==void 0)this.fsw._symlinkPaths.set(K,V)}else if(I.isSymbolicLink()){let K=X?await vx1(A):A;if(this.fsw.closed)return;let V=dY.dirname(J.watchPath);if(this.fsw._getWatchedDir(V).add(J.watchPath),this.fsw._emit(_R.ADD,J.watchPath,I),W=await this._handleDir(V,I,Q,G,A,J,K),this.fsw.closed)return;if(K!==void 0)this.fsw._symlinkPaths.set(dY.resolve(A),K)}else W=this._handleFile(J.watchPath,I,Q);if(Y(),W)this.fsw._addPathCloser(A,W);return!1}catch(I){if(this.fsw._handleError(I))return Y(),A}}}var Ue6="data",bx1="end",DiQ="close",gcA=()=>{},ucA,hx1,$e6,we6,Ne6,HiQ,JY,_R,qe6="watch",Le6,Ms="listeners",fcA="errHandlers",X8A="rawEmitters",Me6,Oe6,Re6=(A)=>Oe6.has(dY.extname(A).slice(1).toLowerCase()),fx1=(A,Q)=>{if(A instanceof Set)A.forEach(Q);else Q(A)},DCA=(A,Q,B)=>{let G=A[Q];if(!(G instanceof Set))A[Q]=G=new Set([G]);G.add(B)},_e6=(A)=>(Q)=>{let B=A[Q];if(B instanceof Set)B.clear();else delete A[Q]},HCA=(A,Q,B)=>{let G=A[Q];if(G instanceof Set)G.delete(B);else if(G===B)delete A[Q]},FiQ=(A)=>A instanceof Set?A.size===0:!A,bcA,hcA=(A,Q,B,G,Z)=>{let Y=bcA.get(A);if(!Y)return;fx1(Y[Q],(J)=>{J(B,G,Z)})},Te6=(A,Q,B,G)=>{let{listener:Z,errHandler:Y,rawEmitter:J}=G,I=bcA.get(Q),X;if(!B.persistent){if(X=ViQ(A,B,Z,Y,J),!X)return;return X.close.bind(X)}if(I)DCA(I,Ms,Z),DCA(I,fcA,Y),DCA(I,X8A,J);else{if(X=ViQ(A,B,hcA.bind(null,Q,Ms),Y,hcA.bind(null,Q,X8A)),!X)return;X.on(_R.ERROR,async(W)=>{let K=hcA.bind(null,Q,fcA);if(I)I.watcherUnusable=!0;if(hx1&&W.code==="EPERM")try{await(await Fe6(A,"r")).close(),K(W)}catch(V){}else K(W)}),I={listeners:Z,errHandlers:Y,rawEmitters:J,watcher:X},bcA.set(Q,I)}return()=>{if(HCA(I,Ms,Z),HCA(I,fcA,Y),HCA(I,X8A,J),FiQ(I.listeners))I.watcher.close(),bcA.delete(Q),Me6.forEach(_e6(I)),I.watcher=void 0,Object.freeze(I)}},kx1,je6=(A,Q,B,G)=>{let{listener:Z,rawEmitter:Y}=G,J=kx1.get(Q),I=J&&J.options;if(I&&(I.persistent<B.persistent||I.interval>B.interval))KiQ(Q),J=void 0;if(J)DCA(J,Ms,Z),DCA(J,X8A,Y);else J={listeners:Z,rawEmitters:Y,options:B,watcher:De6(Q,B,(X,W)=>{fx1(J.rawEmitters,(V)=>{V(_R.CHANGE,Q,{curr:X,prev:W})});let K=X.mtimeMs;if(X.size!==W.size||K>W.mtimeMs||K===0)fx1(J.listeners,(V)=>V(A,X))})},kx1.set(Q,J);return()=>{if(HCA(J,Ms,Z),HCA(J,X8A,Y),FiQ(J.listeners))kx1.delete(Q),KiQ(Q),J.options=J.watcher=void 0,Object.freeze(J)}};var CiQ=L(()=>{ucA=process.platform,hx1=ucA==="win32",$e6=ucA==="darwin",we6=ucA==="linux",Ne6=ucA==="freebsd",HiQ=ze6()==="OS400",JY={ALL:"all",READY:"ready",ADD:"add",CHANGE:"change",ADD_DIR:"addDir",UNLINK:"unlink",UNLINK_DIR:"unlinkDir",RAW:"raw",ERROR:"error"},_R=JY,Le6={lstat:Ce6,stat:EiQ},Me6=[Ms,fcA,X8A],Oe6=new Set(["3dm","3ds","3g2","3gp","7z","a","aac","adp","afdesign","afphoto","afpub","ai","aif","aiff","alz","ape","apk","appimage","ar","arj","asf","au","avi","bak","baml","bh","bin","bk","bmp","btif","bz2","bzip2","cab","caf","cgm","class","cmx","cpio","cr2","cur","dat","dcm","deb","dex","djvu","dll","dmg","dng","doc","docm","docx","dot","dotm","dra","DS_Store","dsk","dts","dtshd","dvb","dwg","dxf","ecelp4800","ecelp7470","ecelp9600","egg","eol","eot","epub","exe","f4v","fbs","fh","fla","flac","flatpak","fli","flv","fpx","fst","fvt","g3","gh","gif","graffle","gz","gzip","h261","h263","h264","icns","ico","ief","img","ipa","iso","jar","jpeg","jpg","jpgv","jpm","jxr","key","ktx","lha","lib","lvp","lz","lzh","lzma","lzo","m3u","m4a","m4v","mar","mdi","mht","mid","midi","mj2","mka","mkv","mmr","mng","mobi","mov","movie","mp3","mp4","mp4a","mpeg","mpg","mpga","mxu","nef","npx","numbers","nupkg","o","odp","ods","odt","oga","ogg","ogv","otf","ott","pages","pbm","pcx","pdb","pdf","pea","pgm","pic","png","pnm","pot","potm","potx","ppa","ppam","ppm","pps","ppsm","ppsx","ppt","pptm","pptx","psd","pya","pyc","pyo","pyv","qt","rar","ras","raw","resources","rgb","rip","rlc","rmf","rmvb","rpm","rtf","rz","s3m","s7z","scpt","sgi","shar","snap","sil","sketch","slk","smv","snk","so","stl","suo","sub","swf","tar","tbz","tbz2","tga","tgz","thmx","tif","tiff","tlz","ttc","ttf","txz","udf","uvh","uvi","uvm","uvp","uvs","uvu","viv","vob","war","wav","wax","wbmp","wdp","weba","webm","webp","whl","wim","wm","wma","wmv","wmx","woff","woff2","wrm","wvx","xbm","xif","xla","xlam","xls","xlsb","xlsm","xlsx","xlt","xltm","xltx","xm","xmind","xpi","xpm","xwd","xz","z","zip","zipx"]),bcA=new Map;kx1=new Map});import{stat as Pe6}from"fs";import{stat as Se6,readdir as xe6}from"fs/promises";import{EventEmitter as ye6}from"events";import*as B8 from"path";function mcA(A){return Array.isArray(A)?A:[A]}function ue6(A){if(typeof A==="function")return A;if(typeof A==="string")return(Q)=>A===Q;if(A instanceof RegExp)return(Q)=>A.test(Q);if(typeof A==="object"&&A!==null)return(Q)=>{if(A.path===Q)return!0;if(A.recursive){let B=B8.relative(A.path,Q);if(!B)return!1;return!B.startsWith("..")&&!B8.isAbsolute(B)}return!1};return()=>!1}function me6(A){if(typeof A!=="string")throw Error("string expected");A=B8.normalize(A),A=A.replace(/\\/g,"/");let Q=!1;if(A.startsWith("//"))Q=!0;let B=/\/\//;while(A.match(B))A=A.replace(B,"/");if(Q)A="/"+A;return A}function UiQ(A,Q,B){let G=me6(Q);for(let Z=0;Z<A.length;Z++){let Y=A[Z];if(Y(G,B))return!0}return!1}function de6(A,Q){if(A==null)throw TypeError("anymatch: specify first argument");let G=mcA(A).map((Z)=>ue6(Z));if(Q==null)return(Z,Y)=>{return UiQ(G,Z,Y)};return UiQ(G,Q)}class MiQ{constructor(A,Q){this.path=A,this._removeWatcher=Q,this.items=new Set}add(A){let{items:Q}=this;if(!Q)return;if(A!==qiQ&&A!==ke6)Q.add(A)}async remove(A){let{items:Q}=this;if(!Q)return;if(Q.delete(A),Q.size>0)return;let B=this.path;try{await xe6(B)}catch(G){if(this._removeWatcher)this._removeWatcher(B8.dirname(B),B8.basename(B))}}has(A){let{items:Q}=this;if(!Q)return;return Q.has(A)}getChildren(){let{items:A}=this;if(!A)return[];return[...A.values()]}dispose(){this.items.clear(),this.path="",this._removeWatcher=gcA,this.items=pe6,Object.freeze(this)}}class OiQ{constructor(A,Q,B){this.fsw=B;let G=A;this.path=A=A.replace(ge6,""),this.watchPath=G,this.fullWatchPath=B8.resolve(G),this.dirParts=[],this.dirParts.forEach((Z)=>{if(Z.length>1)Z.pop()}),this.followSymlinks=Q,this.statMethod=Q?le6:ie6}entryPath(A){return B8.join(this.watchPath,B8.relative(this.watchPath,A.fullPath))}filterPath(A){let{stats:Q}=A;if(Q&&Q.isSymbolicLink())return this.filterDir(A);let B=this.entryPath(A);return this.fsw._isntIgnored(B,Q)&&this.fsw._hasReadPermissions(Q)}filterDir(A){return this.fsw._isntIgnored(this.entryPath(A),A.stats)}}function ne6(A,Q={}){let B=new dx1(Q);return B.add(A),B}var ux1="/",ve6="//",qiQ=".",ke6="..",fe6="string",be6,ziQ,he6,ge6,mx1=(A)=>typeof A==="object"&&A!==null&&!(A instanceof RegExp),$iQ=(A)=>{let Q=mcA(A).flat();if(!Q.every((B)=>typeof B===fe6))throw TypeError(`Non-string provided as watch path: ${Q}`);return Q.map(LiQ)},wiQ=(A)=>{let Q=A.replace(be6,ux1),B=!1;if(Q.startsWith(ve6))B=!0;while(Q.match(ziQ))Q=Q.replace(ziQ,ux1);if(B)Q=ux1+Q;return Q},LiQ=(A)=>wiQ(B8.normalize(wiQ(A))),NiQ=(A="")=>(Q)=>{if(typeof Q==="string")return LiQ(B8.isAbsolute(Q)?Q:B8.join(A,Q));else return Q},ce6=(A,Q)=>{if(B8.isAbsolute(A))return A;return B8.join(Q,A)},pe6,le6="stat",ie6="lstat",dx1,RiQ;var _iQ=L(()=>{WiQ();CiQ();/*! chokidar - MIT License (c) 2012 Paul Miller (paulmillr.com) */be6=/\\/g,ziQ=/\/\//,he6=/\..*\.(sw[px])$|~$|\.subl.*\.tmp/,ge6=/^\.[/\\]/;pe6=Object.freeze(new Set);dx1=class dx1 extends ye6{constructor(A={}){super();this.closed=!1,this._closers=new Map,this._ignoredPaths=new Set,this._throttled=new Map,this._streams=new Set,this._symlinkPaths=new Map,this._watched=new Map,this._pendingWrites=new Map,this._pendingUnlinks=new Map,this._readyCount=0,this._readyEmitted=!1;let Q=A.awaitWriteFinish,B={stabilityThreshold:2000,pollInterval:100},G={persistent:!0,ignoreInitial:!1,ignorePermissionErrors:!1,interval:100,binaryInterval:300,followSymlinks:!0,usePolling:!1,atomic:!0,...A,ignored:A.ignored?mcA(A.ignored):mcA([]),awaitWriteFinish:Q===!0?B:typeof Q==="object"?{...B,...Q}:!1};if(HiQ)G.usePolling=!0;if(G.atomic===void 0)G.atomic=!G.usePolling;let Z=process.env.CHOKIDAR_USEPOLLING;if(Z!==void 0){let I=Z.toLowerCase();if(I==="false"||I==="0")G.usePolling=!1;else if(I==="true"||I==="1")G.usePolling=!0;else G.usePolling=!!I}let Y=process.env.CHOKIDAR_INTERVAL;if(Y)G.interval=Number.parseInt(Y,10);let J=0;this._emitReady=()=>{if(J++,J>=this._readyCount)this._emitReady=gcA,this._readyEmitted=!0,process.nextTick(()=>this.emit(JY.READY))},this._emitRaw=(...I)=>this.emit(JY.RAW,...I),this._boundRemove=this._remove.bind(this),this.options=G,this._nodeFsHandler=new gx1(this),Object.freeze(G)}_addIgnoredPath(A){if(mx1(A)){for(let Q of this._ignoredPaths)if(mx1(Q)&&Q.path===A.path&&Q.recursive===A.recursive)return}this._ignoredPaths.add(A)}_removeIgnoredPath(A){if(this._ignoredPaths.delete(A),typeof A==="string"){for(let Q of this._ignoredPaths)if(mx1(Q)&&Q.path===A)this._ignoredPaths.delete(Q)}}add(A,Q,B){let{cwd:G}=this.options;this.closed=!1,this._closePromise=void 0;let Z=$iQ(A);if(G)Z=Z.map((Y)=>{return ce6(Y,G)});if(Z.forEach((Y)=>{this._removeIgnoredPath(Y)}),this._userIgnored=void 0,!this._readyCount)this._readyCount=0;return this._readyCount+=Z.length,Promise.all(Z.map(async(Y)=>{let J=await this._nodeFsHandler._addToNodeFs(Y,!B,void 0,0,Q);if(J)this._emitReady();return J})).then((Y)=>{if(this.closed)return;Y.forEach((J)=>{if(J)this.add(B8.dirname(J),B8.basename(Q||J))})}),this}unwatch(A){if(this.closed)return this;let Q=$iQ(A),{cwd:B}=this.options;return Q.forEach((G)=>{if(!B8.isAbsolute(G)&&!this._closers.has(G)){if(B)G=B8.join(B,G);G=B8.resolve(G)}if(this._closePath(G),this._addIgnoredPath(G),this._watched.has(G))this._addIgnoredPath({path:G,recursive:!0});this._userIgnored=void 0}),this}close(){if(this._closePromise)return this._closePromise;this.closed=!0,this.removeAllListeners();let A=[];return this._closers.forEach((Q)=>Q.forEach((B)=>{let G=B();if(G instanceof Promise)A.push(G)})),this._streams.forEach((Q)=>Q.destroy()),this._userIgnored=void 0,this._readyCount=0,this._readyEmitted=!1,this._watched.forEach((Q)=>Q.dispose()),this._closers.clear(),this._watched.clear(),this._streams.clear(),this._symlinkPaths.clear(),this._throttled.clear(),this._closePromise=A.length?Promise.all(A).then(()=>{return}):Promise.resolve(),this._closePromise}getWatched(){let A={};return this._watched.forEach((Q,B)=>{let Z=(this.options.cwd?B8.relative(this.options.cwd,B):B)||qiQ;A[Z]=Q.getChildren().sort()}),A}emitWithAll(A,Q){if(this.emit(A,...Q),A!==JY.ERROR)this.emit(JY.ALL,A,...Q)}async _emit(A,Q,B){if(this.closed)return;let G=this.options;if(hx1)Q=B8.normalize(Q);if(G.cwd)Q=B8.relative(G.cwd,Q);let Z=[Q];if(B!=null)Z.push(B);let Y=G.awaitWriteFinish,J;if(Y&&(J=this._pendingWrites.get(Q)))return J.lastChange=new Date,this;if(G.atomic){if(A===JY.UNLINK)return this._pendingUnlinks.set(Q,[A,...Z]),setTimeout(()=>{this._pendingUnlinks.forEach((I,X)=>{this.emit(...I),this.emit(JY.ALL,...I),this._pendingUnlinks.delete(X)})},typeof G.atomic==="number"?G.atomic:100),this;if(A===JY.ADD&&this._pendingUnlinks.has(Q))A=JY.CHANGE,this._pendingUnlinks.delete(Q)}if(Y&&(A===JY.ADD||A===JY.CHANGE)&&this._readyEmitted){let I=(X,W)=>{if(X)A=JY.ERROR,Z[0]=X,this.emitWithAll(A,Z);else if(W){if(Z.length>1)Z[1]=W;else Z.push(W);this.emitWithAll(A,Z)}};return this._awaitWriteFinish(Q,Y.stabilityThreshold,A,I),this}if(A===JY.CHANGE){if(!this._throttle(JY.CHANGE,Q,50))return this}if(G.alwaysStat&&B===void 0&&(A===JY.ADD||A===JY.ADD_DIR||A===JY.CHANGE)){let I=G.cwd?B8.join(G.cwd,Q):Q,X;try{X=await Se6(I)}catch(W){}if(!X||this.closed)return;Z.push(X)}return this.emitWithAll(A,Z),this}_handleError(A){let Q=A&&A.code;if(A&&Q!=="ENOENT"&&Q!=="ENOTDIR"&&(!this.options.ignorePermissionErrors||Q!=="EPERM"&&Q!=="EACCES"))this.emit(JY.ERROR,A);return A||this.closed}_throttle(A,Q,B){if(!this._throttled.has(A))this._throttled.set(A,new Map);let G=this._throttled.get(A);if(!G)throw Error("invalid throttle");let Z=G.get(Q);if(Z)return Z.count++,!1;let Y,J=()=>{let X=G.get(Q),W=X?X.count:0;if(G.delete(Q),clearTimeout(Y),X)clearTimeout(X.timeoutObject);return W};Y=setTimeout(J,B);let I={timeoutObject:Y,clear:J,count:0};return G.set(Q,I),I}_incrReadyCount(){return this._readyCount++}_awaitWriteFinish(A,Q,B,G){let Z=this.options.awaitWriteFinish;if(typeof Z!=="object")return;let Y=Z.pollInterval,J,I=A;if(this.options.cwd&&!B8.isAbsolute(A))I=B8.join(this.options.cwd,A);let X=new Date,W=this._pendingWrites;function K(V){Pe6(I,(E,D)=>{if(E||!W.has(A)){if(E&&E.code!=="ENOENT")G(E);return}let H=Number(new Date);if(V&&D.size!==V.size)W.get(A).lastChange=H;let F=W.get(A);if(H-F.lastChange>=Q)W.delete(A),G(void 0,D);else J=setTimeout(K,Y,D)})}if(!W.has(A))W.set(A,{lastChange:X,cancelWait:()=>{return W.delete(A),clearTimeout(J),B}}),J=setTimeout(K,Y)}_isIgnored(A,Q){if(this.options.atomic&&he6.test(A))return!0;if(!this._userIgnored){let{cwd:B}=this.options,Z=(this.options.ignored||[]).map(NiQ(B)),J=[...[...this._ignoredPaths].map(NiQ(B)),...Z];this._userIgnored=de6(J,void 0)}return this._userIgnored(A,Q)}_isntIgnored(A,Q){return!this._isIgnored(A,Q)}_getWatchHelpers(A){return new OiQ(A,this.options.followSymlinks,this)}_getWatchedDir(A){let Q=B8.resolve(A);if(!this._watched.has(Q))this._watched.set(Q,new MiQ(Q,this._boundRemove));return this._watched.get(Q)}_hasReadPermissions(A){if(this.options.ignorePermissionErrors)return!0;return Boolean(Number(A.mode)&256)}_remove(A,Q,B){let G=B8.join(A,Q),Z=B8.resolve(G);if(B=B!=null?B:this._watched.has(G)||this._watched.has(Z),!this._throttle("remove",G,100))return;if(!B&&this._watched.size===1)this.add(A,Q,!0);this._getWatchedDir(G).getChildren().forEach((V)=>this._remove(G,V));let I=this._getWatchedDir(A),X=I.has(Q);if(I.remove(Q),this._symlinkPaths.has(Z))this._symlinkPaths.delete(Z);let W=G;if(this.options.cwd)W=B8.relative(this.options.cwd,G);if(this.options.awaitWriteFinish&&this._pendingWrites.has(W)){if(this._pendingWrites.get(W).cancelWait()===JY.ADD)return}this._watched.delete(G),this._watched.delete(Z);let K=B?JY.UNLINK_DIR:JY.UNLINK;if(X&&!this._isIgnored(G))this._emit(K,G);this._closePath(G)}_closePath(A){this._closeFile(A);let Q=B8.dirname(A);this._getWatchedDir(Q).remove(B8.basename(A))}_closeFile(A){let Q=this._closers.get(A);if(!Q)return;Q.forEach((B)=>B()),this._closers.delete(A)}_addPathCloser(A,Q){if(!Q)return;let B=this._closers.get(A);if(!B)B=[],this._closers.set(A,B);B.push(Q)}_readdirp(A,Q){if(this.closed)return;let B={type:JY.ALL,alwaysStat:!0,lstat:!0,...Q,depth:0},G=XiQ(A,B);return this._streams.add(G),G.once(DiQ,()=>{G=void 0}),G.once(bx1,()=>{if(G)this._streams.delete(G),G=void 0}),G}};RiQ={watch:ne6,FSWatcher:dx1}});function rd(A){switch(A){case"userSettings":return"user";case"projectSettings":return"project";case"localSettings":return"project, gitignored";case"flagSettings":return"cli flag";case"policySettings":return"managed"}}function dcA(A){switch(A){case"userSettings":return"user settings";case"projectSettings":return"shared project settings";case"localSettings":return"project local settings";case"flagSettings":return"command line arguments";case"policySettings":return"enterprise managed settings";case"cliArg":return"CLI argument";case"command":return"command configuration";case"session":return"current session"}}function TiQ(A){switch(A){case"userSettings":return"User settings";case"projectSettings":return"Shared project settings";case"localSettings":return"Project local settings";case"flagSettings":return"Command line arguments";case"policySettings":return"Enterprise managed settings";case"cliArg":return"CLI argument";case"command":return"Command configuration";case"session":return"Current session"}}function jiQ(A){if(A==="")return[];let Q=A.split(",").map((G)=>G.trim()),B=[];for(let G of Q)switch(G){case"user":B.push("userSettings");break;case"project":B.push("projectSettings");break;case"local":B.push("localSettings");break;default:throw Error(`Invalid setting source: ${G}. Valid options are: user, project, local`)}return B}function Os(){let A=yK0(),Q=new Set(A);return Q.add("policySettings"),Q.add("flagSettings"),Array.from(Q)}function sK(A){return Os().includes(A)}var JL,PiQ="https://json.schemastore.org/claude-code-settings.json";var tI=L(()=>{g0();JL=["userSettings","projectSettings","localSettings","flagSettings","policySettings"]});import*as xiQ from"path";function se6(){if(SiQ||yiQ)return;SiQ=!0;let A=AA3();if(A.length===0)return;f(`Watching for changes in setting files ${A.join(", ")}...`),W8A=RiQ.watch(A,{persistent:!0,ignoreInitial:!0,awaitWriteFinish:{stabilityThreshold:ae6,pollInterval:oe6},ignored:(Q)=>Q.split(xiQ.sep).some((B)=>B===".git"),ignorePermissionErrors:!0,usePolling:!1,atomic:!0}),W8A.on("change",QA3),W8A.on("unlink",BA3),U8(async()=>viQ())}function viQ(){if(yiQ=!0,W8A)W8A.close(),W8A=null;ccA.clear(),K8A.clear()}function te6(A){return K8A.add(A),()=>{K8A.delete(A)}}function ee6(A){let Q=qF(A);if(Q)ccA.set(Q,Date.now())}function AA3(){let A=jA();return JL.map((Q)=>{let B=qF(Q);if(!B)return;try{if(!A.statSync(B).isFile())return}catch{return}return B}).filter((Q)=>Q!==void 0)}function QA3(A){let Q=kiQ(A);if(!Q)return;let B=ccA.get(A);if(B&&Date.now()-B<re6){ccA.delete(A);return}f(`Detected change to ${A}`),K8A.forEach((G)=>G(Q))}function BA3(A){let Q=kiQ(A);if(!Q)return;f(`Detected deletion of ${A}`),K8A.forEach((B)=>B(Q))}function kiQ(A){return JL.find((Q)=>qF(Q)===A)}function GA3(A){f(`Programmatic settings change notification for ${A}`),K8A.forEach((Q)=>Q(A))}var ae6=1000,oe6=500,re6=5000,W8A=null,SiQ=!1,yiQ=!1,ccA,K8A,NF;var Rs=L(()=>{_iQ();Y0();XQ();jB();tI();bW();ccA=new Map,K8A=new Set;NF={initialize:se6,dispose:viQ,subscribe:te6,markInternalWrite:ee6,notifyChange:GA3}});function V8A(A){let Q=pcA.useCallback((B)=>{TR();let G=NQ();A(B,G)},[A]);pcA.useEffect(()=>NF.subscribe(Q),[Q])}var pcA;var lcA=L(()=>{Rs();jB();pcA=o(WA(),1)});function YA3(A){let Q=qF(A);if(!Q||!jA().existsSync(Q))return null;try{let{resolvedPath:B}=gI(jA(),Q),G=wE(B);if(G.trim()==="")return{};let Z=h8(G,!1);return Z&&typeof Z==="object"?Z:null}catch{return null}}function JA3(A,Q){if(!A||!A.permissions)return[];let{permissions:B}=A,G=[];for(let Z of ZA3){let Y=B[Z];if(Y)for(let J of Y)G.push({source:Q,ruleBehavior:Z,ruleValue:IL(J)})}return G}function icA(){let A=[];for(let Q of Os())A.push(...ncA(Q));return A}function ncA(A){let Q=uB(A);return JA3(Q,A)}function fiQ(A){if(!IA3.includes(A.source))return!1;let Q=B5(A.ruleValue),B=uB(A.source);if(!B||!B.permissions)return!1;let G=B.permissions[A.ruleBehavior];if(!G||!G.includes(Q))return!1;try{let Z={...B,permissions:{...B.permissions,[A.ruleBehavior]:G.filter((J)=>J!==Q)}},{error:Y}=E2(A.source,Z);if(Y)return!1;return!0}catch(Z){return s(Z instanceof Error?Z:Error(String(Z))),!1}}function XA3(){return{permissions:{}}}function acA({ruleValues:A,ruleBehavior:Q},B){if(A.length<1)return!0;let G=A.map(B5),Z=uB(B)||YA3(B)||XA3();try{let Y=Z.permissions||{},J=Y[Q]||[],I=new Set(J),X=G.filter((V)=>!I.has(V));if(X.length===0)return!0;let W={...Z,permissions:{...Y,[Q]:[...J,...X]}},K=E2(B,W);if(K.error)throw K.error;return!0}catch(Y){return s(Y instanceof Error?Y:Error(String(Y))),!1}}var ZA3,IA3;var _s=L(()=>{h1();oG();tI();jB();XQ();M9();uI();ZA3=["allow","deny","ask"];IA3=["userSettings","projectSettings","localSettings"]});import{posix as WA3}from"path";function E8A(A){if(!A)return[];return A.flatMap((Q)=>{switch(Q.type){case"addRules":return Q.rules;default:return[]}})}function eI(A,Q){switch(Q.type){case"setMode":return f(`Applying permission update: Setting mode to '${Q.mode}'`),{...A,mode:Q.mode};case"addRules":{let B=Q.rules.map((Z)=>B5(Z));f(`Applying permission update: Adding ${Q.rules.length} ${Q.behavior} rule(s) to destination '${Q.destination}': ${JSON.stringify(B)}`);let G=Q.behavior==="allow"?"alwaysAllowRules":Q.behavior==="deny"?"alwaysDenyRules":"alwaysAskRules";return{...A,[G]:{...A[G],[Q.destination]:[...A[G][Q.destination]||[],...B]}}}case"replaceRules":{let B=Q.rules.map((Z)=>B5(Z));f(`Replacing all ${Q.behavior} rules for destination '${Q.destination}' with ${Q.rules.length} rule(s): ${JSON.stringify(B)}`);let G=Q.behavior==="allow"?"alwaysAllowRules":Q.behavior==="deny"?"alwaysDenyRules":"alwaysAskRules";return{...A,[G]:{...A[G],[Q.destination]:B}}}case"addDirectories":{f(`Applying permission update: Adding ${Q.directories.length} director${Q.directories.length===1?"y":"ies"} with destination '${Q.destination}': ${JSON.stringify(Q.directories)}`);let B=new Map(A.additionalWorkingDirectories);for(let G of Q.directories)B.set(G,{path:G,source:Q.destination});return{...A,additionalWorkingDirectories:B}}case"removeRules":{let B=Q.rules.map((I)=>B5(I));f(`Applying permission update: Removing ${Q.rules.length} ${Q.behavior} rule(s) from source '${Q.destination}': ${JSON.stringify(B)}`);let G=Q.behavior==="allow"?"alwaysAllowRules":Q.behavior==="deny"?"alwaysDenyRules":"alwaysAskRules",Z=A[G][Q.destination]||[],Y=new Set(B),J=Z.filter((I)=>!Y.has(I));return{...A,[G]:{...A[G],[Q.destination]:J}}}case"removeDirectories":{f(`Applying permission update: Removing ${Q.directories.length} director${Q.directories.length===1?"y":"ies"}: ${JSON.stringify(Q.directories)}`);let B=new Map(A.additionalWorkingDirectories);for(let G of Q.directories)B.delete(G);return{...A,additionalWorkingDirectories:B}}default:return A}}function sk(A,Q){let B=A;for(let G of Q)B=eI(B,G);return B}function FCA(A){return A==="localSettings"||A==="userSettings"||A==="projectSettings"}function eP(A){if(!FCA(A.destination))return;switch(f(`Persisting permission update: ${A.type} to source '${A.destination}'`),A.type){case"addRules":{f(`Persisting ${A.rules.length} ${A.behavior} rule(s) to ${A.destination}`),acA({ruleValues:A.rules,ruleBehavior:A.behavior},A.destination);break}case"addDirectories":{f(`Persisting ${A.directories.length} director${A.directories.length===1?"y":"ies"} to ${A.destination}`);let B=uB(A.destination)?.permissions?.additionalDirectories||[],G=A.directories.filter((Z)=>!B.includes(Z));if(G.length>0){let Z=[...B,...G];E2(A.destination,{permissions:{additionalDirectories:Z}})}break}case"removeRules":{f(`Removing ${A.rules.length} ${A.behavior} rule(s) from ${A.destination}`);let G=(uB(A.destination)?.permissions||{})[A.behavior]||[],Z=new Set(A.rules.map(B5)),Y=G.filter((J)=>!Z.has(J));E2(A.destination,{permissions:{[A.behavior]:Y}});break}case"removeDirectories":{f(`Removing ${A.directories.length} director${A.directories.length===1?"y":"ies"} from ${A.destination}`);let B=uB(A.destination)?.permissions?.additionalDirectories||[],G=new Set(A.directories),Z=B.filter((Y)=>!G.has(Y));E2(A.destination,{permissions:{additionalDirectories:Z}});break}case"setMode":{f(`Persisting mode '${A.mode}' to ${A.destination}`),E2(A.destination,{permissions:{defaultMode:A.mode}});break}case"replaceRules":{f(`Replacing all ${A.behavior} rules in ${A.destination} with ${A.rules.length} rule(s)`);let Q=A.rules.map(B5);E2(A.destination,{permissions:{[A.behavior]:Q}});break}}}function D8A(A){for(let Q of A)eP(Q)}function ocA(A,Q="session"){try{if(jA().statSync(A).isDirectory()){let G=rcA(A);if(G==="/")return;return{type:"addRules",rules:[{toolName:"Read",ruleContent:WA3.isAbsolute(G)?`/${G}/**`:`${G}/**`}],behavior:"allow",destination:Q}}}catch{}return}var tK=L(()=>{oG();Y0();jB();_s();XQ();cY()});var e9="Bash";function JB(A,Q){if(!process.env.SRT_DEBUG)return;let B=Q?.level||"info",G="[SandboxDebug]";switch(B){case"error":console.error(`${G} ${A}`);break;case"warn":console.warn(`${G} ${A}`);break;default:console.error(`${G} ${A}`)}}import{createServer as KA3}from"node:http";import{request as VA3}from"node:http";import{request as EA3}from"node:https";import{connect as DA3}from"node:net";import{URL as HA3}from"node:url";function biQ(A){let Q=KA3();return Q.on("connect",async(B,G)=>{G.on("error",(Z)=>{JB(`Client socket error: ${Z.message}`,{level:"error"})});try{let[Z,Y]=B.url.split(":"),J=Y===void 0?void 0:parseInt(Y,10);if(!Z||!J){JB(`Invalid CONNECT request: ${B.url}`,{level:"error"}),G.end(`HTTP/1.1 400 Bad Request\r[0m


[35m[3mthinking[0m[0m
**Investigating code visibility**

It looks like my `rg` command isn‚Äôt displaying the expected output because the file is minified, resulting in code being presented as one long line. Although `rg -n` shows line numbers (like 396), these aren‚Äôt helpful since the code structure isn‚Äôt clear. There are newlines at import boundaries, but for the `jiQ` definition, I need to determine if it‚Äôs defined as `var jiQ =` instead of `function jiQ`. I might need to use `node` or `python` to extract the relevant substring.
[35m[3mthinking[0m[0m
**Searching for function definition**

In the minified code, I suspect that the function could be defined as `function jiQ(A){...}`. My `grep` command might not be detecting it if the line has some unusual character. The command `rg "function jiQ"` should ideally match it, but since it didn‚Äôt, the definition must be formatted differently. I think I should also search for the "jiQ=" assignment to see if it leads me to the correct definition.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"jiQ\\s*=\\s*\" bundles/ClaudeCodeCode/cli.js | head -n 20"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 72ms:[0m
[2m[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"jiQ\\([A-Za-z]\\)\\{\" bundles/ClaudeCodeCode/cli.js | head -n 20"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 61ms:[0m
[2m396:`);ok=[],B.appendFileSync(Q,G.join(""),{mode:384})}catch(Q){f(`Failed to write prompt history: ${Q}`)}finally{if(A)await A()}}async function slQ(A){if(Px1||ok.length===0)return;if(A>5)return;Px1=!0;try{await rlQ()}finally{if(Px1=!1,ok.length>0)await new Promise((Q)=>setTimeout(Q,500)),slQ(A+1)}}async function tt6(A){let Q=typeof A==="string"?{display:A,pastedContents:{}}:A,B={};if(Q.pastedContents){for(let[Z,Y]of Object.entries(Q.pastedContents))if(Y.type!=="image"&&Y.content.length<=rt6)B[Number(Z)]=Y}let G={...Q,pastedContents:B,timestamp:Date.now(),project:pQ(),sessionId:W0()};ok.push(G),xcA=slQ(0)}function Ns(A){if(!plQ)plQ=!0,U8(async()=>{if(xcA)await xcA;if(ok.length>0)await rlQ()});tt6(A)}var ilQ,ot6=100,rt6=1024,ok,Px1=!1,xcA=null,plQ=!1;var nd=L(()=>{rQ();XQ();g0();Y0();bW();ilQ=o(Gm(),1);ok=[]});var xx1,et6,yz,qs,kcA;var ad=L(()=>{k3();xx1=o(zR(),1),et6=dQ()!=="windows"||(ga()?xx1.default.satisfies(process.versions.bun,">=1.2.23"):xx1.default.satisfies(process.versions.node,">=22.17.0 <23.0.0 || >=24.2.0")),yz=!et6?{displayText:"alt+m",check:(A,Q)=>Q.meta&&(A==="m"||A==="M")}:{displayText:"shift+tab",check:(A,Q)=>Q.tab&&Q.shift},qs=dQ()==="windows"?{displayText:"alt+v",check:(A,Q)=>Q.meta&&(A==="v"||A==="V")}:{displayText:"ctrl+v",check:(A,Q)=>Q.ctrl&&(A==="v"||A==="V")},kcA={displayText:"alt+p",check:(A,Q)=>Q.meta&&(A==="p"||A==="P")}});function tlQ(A,Q){switch(Q){case"bash":return`!${A}`;case"memorySelect":return`#${A}`;case"background":return`&${A}`;default:return A}}function rk(A){if(A.startsWith("!"))return"bash";if(A.startsWith("#"))return"memory";if(A.startsWith("&"))return"background";return"prompt"}function Ls(A){if(rk(A)==="prompt")return A;return A.slice(1)}function elQ(A){return A==="!"||A==="#"||A==="&"}function od(A){return A.filter((Q)=>Q.data?.type!=="hook_progress")}function Ae6(A,Q){return A.name===Q||(A.aliases?.includes(Q)??!1)}function AiQ(A,Q){return A.find((B)=>Ae6(B,Q))}var s$=()=>({mode:"default",additionalWorkingDirectories:new Map,alwaysAllowRules:{},alwaysDenyRules:{},alwaysAskRules:{},isBypassPermissionsModeAvailable:!1});import{stat as Qe6,lstat as QiQ,readdir as Be6,realpath as Ge6}from"node:fs/promises";import{Readable as Ze6}from"node:stream";import{resolve as BiQ,relative as Ye6,join as Je6,sep as Ie6}from"node:path";function XiQ(A,Q={}){let B=Q.entryType||Q.type;if(B==="both")B=t$.FILE_DIR_TYPE;if(B)Q.type=B;if(!A)throw Error("readdirp: root argument is required. Usage: readdirp(root, options)");else if(typeof A!=="string")throw TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");else if(B&&!GiQ.includes(B))throw Error(`readdirp: Invalid type passed. Use one of ${GiQ.join(", ")}`);return Q.root=A,new IiQ(Q)}var t$,yx1,JiQ="READDIRP_RECURSIVE_ERROR",Xe6,GiQ,We6,Ke6,Ve6=(A)=>Xe6.has(A.code),Ee6,ZiQ=(A)=>!0,YiQ=(A)=>{if(A===void 0)return ZiQ;if(typeof A==="function")return A;if(typeof A==="string"){let Q=A.trim();return(B)=>B.basename===Q}if(Array.isArray(A)){let Q=A.map((B)=>B.trim());return(B)=>Q.some((G)=>B.basename===G)}return ZiQ},IiQ;var WiQ=L(()=>{t$={FILE_TYPE:"files",DIR_TYPE:"directories",FILE_DIR_TYPE:"files_directories",EVERYTHING_TYPE:"all"},yx1={root:".",fileFilter:(A)=>!0,directoryFilter:(A)=>!0,type:t$.FILE_TYPE,lstat:!1,depth:2147483648,alwaysStat:!1,highWaterMark:4096};Object.freeze(yx1);Xe6=new Set(["ENOENT","EPERM","EACCES","ELOOP",JiQ]),GiQ=[t$.DIR_TYPE,t$.EVERYTHING_TYPE,t$.FILE_DIR_TYPE,t$.FILE_TYPE],We6=new Set([t$.DIR_TYPE,t$.EVERYTHING_TYPE,t$.FILE_DIR_TYPE]),Ke6=new Set([t$.EVERYTHING_TYPE,t$.FILE_DIR_TYPE,t$.FILE_TYPE]),Ee6=process.platform==="win32";IiQ=class IiQ extends Ze6{constructor(A={}){super({objectMode:!0,autoDestroy:!0,highWaterMark:A.highWaterMark});let Q={...yx1,...A},{root:B,type:G}=Q;this._fileFilter=YiQ(Q.fileFilter),this._directoryFilter=YiQ(Q.directoryFilter);let Z=Q.lstat?QiQ:Qe6;if(Ee6)this._stat=(Y)=>Z(Y,{bigint:!0});else this._stat=Z;this._maxDepth=Q.depth??yx1.depth,this._wantsDir=G?We6.has(G):!1,this._wantsFile=G?Ke6.has(G):!1,this._wantsEverything=G===t$.EVERYTHING_TYPE,this._root=BiQ(B),this._isDirent=!Q.alwaysStat,this._statsProp=this._isDirent?"dirent":"stats",this._rdOptions={encoding:"utf8",withFileTypes:this._isDirent},this.parents=[this._exploreDir(B,1)],this.reading=!1,this.parent=void 0}async _read(A){if(this.reading)return;this.reading=!0;try{while(!this.destroyed&&A>0){let Q=this.parent,B=Q&&Q.files;if(B&&B.length>0){let{path:G,depth:Z}=Q,Y=B.splice(0,A).map((I)=>this._formatEntry(I,G)),J=await Promise.all(Y);for(let I of J){if(!I)continue;if(this.destroyed)return;let X=await this._getEntryType(I);if(X==="directory"&&this._directoryFilter(I)){if(Z<=this._maxDepth)this.parents.push(this._exploreDir(I.fullPath,Z+1));if(this._wantsDir)this.push(I),A--}else if((X==="file"||this._includeAsFile(I))&&this._fileFilter(I)){if(this._wantsFile)this.push(I),A--}}}else{let G=this.parents.pop();if(!G){this.push(null);break}if(this.parent=await G,this.destroyed)return}}}catch(Q){this.destroy(Q)}finally{this.reading=!1}}async _exploreDir(A,Q){let B;try{B=await Be6(A,this._rdOptions)}catch(G){this._onError(G)}return{files:B,depth:Q,path:A}}async _formatEntry(A,Q){let B,G=this._isDirent?A.name:A;try{let Z=BiQ(Je6(Q,G));B={path:Ye6(this._root,Z),fullPath:Z,basename:G},B[this._statsProp]=this._isDirent?A:await this._stat(Z)}catch(Z){this._onError(Z);return}return B}_onError(A){if(Ve6(A)&&!this.destroyed)this.emit("warn",A);else this.destroy(A)}async _getEntryType(A){if(!A&&this._statsProp in A)return"";let Q=A[this._statsProp];if(Q.isFile())return"file";if(Q.isDirectory())return"directory";if(Q&&Q.isSymbolicLink()){let B=A.fullPath;try{let G=await Ge6(B),Z=await QiQ(G);if(Z.isFile())return"file";if(Z.isDirectory()){let Y=G.length;if(B.startsWith(G)&&B.substr(Y,1)===Ie6){let J=Error(`Circular symlink detected: "${B}" points to "${G}"`);return J.code=JiQ,this._onError(J)}return"directory"}}catch(G){return this._onError(G),""}}}_includeAsFile(A){let Q=A&&A[this._statsProp];return Q&&this._wantsEverything&&!Q.isDirectory()}}});import{watchFile as De6,unwatchFile as KiQ,watch as He6}from"fs";import{open as Fe6,stat as EiQ,lstat as Ce6,realpath as vx1}from"fs/promises";import*as dY from"path";import{type as ze6}from"os";function ViQ(A,Q,B,G,Z){let Y=(J,I)=>{if(B(A),Z(J,I,{watchedPath:A}),I&&A!==I)hcA(dY.resolve(A,I),Ms,dY.join(A,I))};try{return He6(A,{persistent:Q.persistent},Y)}catch(J){G(J);return}}class gx1{constructor(A){this.fsw=A,this._boundHandleError=(Q)=>A._handleError(Q)}_watchWithNodeFs(A,Q){let B=this.fsw.options,G=dY.dirname(A),Z=dY.basename(A);this.fsw._getWatchedDir(G).add(Z);let J=dY.resolve(A),I={persistent:B.persistent};if(!Q)Q=gcA;let X;if(B.usePolling){let W=B.interval!==B.binaryInterval;I.interval=W&&Re6(Z)?B.binaryInterval:B.interval,X=je6(A,J,I,{listener:Q,rawEmitter:this.fsw._emitRaw})}else X=Te6(A,J,I,{listener:Q,errHandler:this._boundHandleError,rawEmitter:this.fsw._emitRaw});return X}_handleFile(A,Q,B){if(this.fsw.closed)return;let G=dY.dirname(A),Z=dY.basename(A),Y=this.fsw._getWatchedDir(G),J=Q;if(Y.has(Z))return;let I=async(W,K)=>{if(!this.fsw._throttle(qe6,A,5))return;if(!K||K.mtimeMs===0)try{let V=await EiQ(A);if(this.fsw.closed)return;let{atimeMs:E,mtimeMs:D}=V;if(!E||E<=D||D!==J.mtimeMs)this.fsw._emit(_R.CHANGE,A,V);if(($e6||we6||Ne6)&&J.ino!==V.ino){this.fsw._closeFile(W),J=V;let H=this._watchWithNodeFs(A,I);if(H)this.fsw._addPathCloser(W,H)}else J=V}catch(V){this.fsw._remove(G,Z)}else if(Y.has(Z)){let{atimeMs:V,mtimeMs:E}=K;if(!V||V<=E||E!==J.mtimeMs)this.fsw._emit(_R.CHANGE,A,K);J=K}},X=this._watchWithNodeFs(A,I);if(!(B&&this.fsw.options.ignoreInitial)&&this.fsw._isntIgnored(A)){if(!this.fsw._throttle(_R.ADD,A,0))return;this.fsw._emit(_R.ADD,A,Q)}return X}async _handleSymlink(A,Q,B,G){if(this.fsw.closed)return;let Z=A.fullPath,Y=this.fsw._getWatchedDir(Q);if(!this.fsw.options.followSymlinks){this.fsw._incrReadyCount();let J;try{J=await vx1(B)}catch(I){return this.fsw._emitReady(),!0}if(this.fsw.closed)return;if(Y.has(G)){if(this.fsw._symlinkPaths.get(Z)!==J)this.fsw._symlinkPaths.set(Z,J),this.fsw._emit(_R.CHANGE,B,A.stats)}else Y.add(G),this.fsw._symlinkPaths.set(Z,J),this.fsw._emit(_R.ADD,B,A.stats);return this.fsw._emitReady(),!0}if(this.fsw._symlinkPaths.has(Z))return!0;this.fsw._symlinkPaths.set(Z,!0)}_handleRead(A,Q,B,G,Z,Y,J){if(A=dY.join(A,""),J=this.fsw._throttle("readdir",A,1000),!J)return;let I=this.fsw._getWatchedDir(B.path),X=new Set,W=this.fsw._readdirp(A,{fileFilter:(K)=>B.filterPath(K),directoryFilter:(K)=>B.filterDir(K)});if(!W)return;return W.on(Ue6,async(K)=>{if(this.fsw.closed){W=void 0;return}let V=K.path,E=dY.join(A,V);if(X.add(V),K.stats.isSymbolicLink()&&await this._handleSymlink(K,A,E,V))return;if(this.fsw.closed){W=void 0;return}if(V===G||!G&&!I.has(V))this.fsw._incrReadyCount(),E=dY.join(Z,dY.relative(Z,E)),this._addToNodeFs(E,Q,B,Y+1)}).on(_R.ERROR,this._boundHandleError),new Promise((K,V)=>{if(!W)return V();W.once(bx1,()=>{if(this.fsw.closed){W=void 0;return}let E=J?J.clear():!1;if(K(void 0),I.getChildren().filter((D)=>{return D!==A&&!X.has(D)}).forEach((D)=>{this.fsw._remove(A,D)}),W=void 0,E)this._handleRead(A,!1,B,G,Z,Y,J)})})}async _handleDir(A,Q,B,G,Z,Y,J){let I=this.fsw._getWatchedDir(dY.dirname(A)),X=I.has(dY.basename(A));if(!(B&&this.fsw.options.ignoreInitial)&&!Z&&!X)this.fsw._emit(_R.ADD_DIR,A,Q);I.add(dY.basename(A)),this.fsw._getWatchedDir(A);let W,K,V=this.fsw.options.depth;if((V==null||G<=V)&&!this.fsw._symlinkPaths.has(J)){if(!Z){if(await this._handleRead(A,B,Y,Z,A,G,W),this.fsw.closed)return}K=this._watchWithNodeFs(A,(E,D)=>{if(D&&D.mtimeMs===0)return;this._handleRead(E,!1,Y,Z,A,G,W)})}return K}async _addToNodeFs(A,Q,B,G,Z){let Y=this.fsw._emitReady;if(this.fsw._isIgnored(A)||this.fsw.closed)return Y(),!1;let J=this.fsw._getWatchHelpers(A);if(B)J.filterPath=(I)=>B.filterPath(I),J.filterDir=(I)=>B.filterDir(I);try{let I=await Le6[J.statMethod](J.watchPath);if(this.fsw.closed)return;if(this.fsw._isIgnored(J.watchPath,I))return Y(),!1;let X=this.fsw.options.followSymlinks,W;if(I.isDirectory()){let K=dY.resolve(A),V=X?await vx1(A):A;if(this.fsw.closed)return;if(W=await this._handleDir(J.watchPath,I,Q,G,Z,J,V),this.fsw.closed)return;if(K!==V&&V!==void 0)this.fsw._symlinkPaths.set(K,V)}else if(I.isSymbolicLink()){let K=X?await vx1(A):A;if(this.fsw.closed)return;let V=dY.dirname(J.watchPath);if(this.fsw._getWatchedDir(V).add(J.watchPath),this.fsw._emit(_R.ADD,J.watchPath,I),W=await this._handleDir(V,I,Q,G,A,J,K),this.fsw.closed)return;if(K!==void 0)this.fsw._symlinkPaths.set(dY.resolve(A),K)}else W=this._handleFile(J.watchPath,I,Q);if(Y(),W)this.fsw._addPathCloser(A,W);return!1}catch(I){if(this.fsw._handleError(I))return Y(),A}}}var Ue6="data",bx1="end",DiQ="close",gcA=()=>{},ucA,hx1,$e6,we6,Ne6,HiQ,JY,_R,qe6="watch",Le6,Ms="listeners",fcA="errHandlers",X8A="rawEmitters",Me6,Oe6,Re6=(A)=>Oe6.has(dY.extname(A).slice(1).toLowerCase()),fx1=(A,Q)=>{if(A instanceof Set)A.forEach(Q);else Q(A)},DCA=(A,Q,B)=>{let G=A[Q];if(!(G instanceof Set))A[Q]=G=new Set([G]);G.add(B)},_e6=(A)=>(Q)=>{let B=A[Q];if(B instanceof Set)B.clear();else delete A[Q]},HCA=(A,Q,B)=>{let G=A[Q];if(G instanceof Set)G.delete(B);else if(G===B)delete A[Q]},FiQ=(A)=>A instanceof Set?A.size===0:!A,bcA,hcA=(A,Q,B,G,Z)=>{let Y=bcA.get(A);if(!Y)return;fx1(Y[Q],(J)=>{J(B,G,Z)})},Te6=(A,Q,B,G)=>{let{listener:Z,errHandler:Y,rawEmitter:J}=G,I=bcA.get(Q),X;if(!B.persistent){if(X=ViQ(A,B,Z,Y,J),!X)return;return X.close.bind(X)}if(I)DCA(I,Ms,Z),DCA(I,fcA,Y),DCA(I,X8A,J);else{if(X=ViQ(A,B,hcA.bind(null,Q,Ms),Y,hcA.bind(null,Q,X8A)),!X)return;X.on(_R.ERROR,async(W)=>{let K=hcA.bind(null,Q,fcA);if(I)I.watcherUnusable=!0;if(hx1&&W.code==="EPERM")try{await(await Fe6(A,"r")).close(),K(W)}catch(V){}else K(W)}),I={listeners:Z,errHandlers:Y,rawEmitters:J,watcher:X},bcA.set(Q,I)}return()=>{if(HCA(I,Ms,Z),HCA(I,fcA,Y),HCA(I,X8A,J),FiQ(I.listeners))I.watcher.close(),bcA.delete(Q),Me6.forEach(_e6(I)),I.watcher=void 0,Object.freeze(I)}},kx1,je6=(A,Q,B,G)=>{let{listener:Z,rawEmitter:Y}=G,J=kx1.get(Q),I=J&&J.options;if(I&&(I.persistent<B.persistent||I.interval>B.interval))KiQ(Q),J=void 0;if(J)DCA(J,Ms,Z),DCA(J,X8A,Y);else J={listeners:Z,rawEmitters:Y,options:B,watcher:De6(Q,B,(X,W)=>{fx1(J.rawEmitters,(V)=>{V(_R.CHANGE,Q,{curr:X,prev:W})});let K=X.mtimeMs;if(X.size!==W.size||K>W.mtimeMs||K===0)fx1(J.listeners,(V)=>V(A,X))})},kx1.set(Q,J);return()=>{if(HCA(J,Ms,Z),HCA(J,X8A,Y),FiQ(J.listeners))kx1.delete(Q),KiQ(Q),J.options=J.watcher=void 0,Object.freeze(J)}};var CiQ=L(()=>{ucA=process.platform,hx1=ucA==="win32",$e6=ucA==="darwin",we6=ucA==="linux",Ne6=ucA==="freebsd",HiQ=ze6()==="OS400",JY={ALL:"all",READY:"ready",ADD:"add",CHANGE:"change",ADD_DIR:"addDir",UNLINK:"unlink",UNLINK_DIR:"unlinkDir",RAW:"raw",ERROR:"error"},_R=JY,Le6={lstat:Ce6,stat:EiQ},Me6=[Ms,fcA,X8A],Oe6=new Set(["3dm","3ds","3g2","3gp","7z","a","aac","adp","afdesign","afphoto","afpub","ai","aif","aiff","alz","ape","apk","appimage","ar","arj","asf","au","avi","bak","baml","bh","bin","bk","bmp","btif","bz2","bzip2","cab","caf","cgm","class","cmx","cpio","cr2","cur","dat","dcm","deb","dex","djvu","dll","dmg","dng","doc","docm","docx","dot","dotm","dra","DS_Store","dsk","dts","dtshd","dvb","dwg","dxf","ecelp4800","ecelp7470","ecelp9600","egg","eol","eot","epub","exe","f4v","fbs","fh","fla","flac","flatpak","fli","flv","fpx","fst","fvt","g3","gh","gif","graffle","gz","gzip","h261","h263","h264","icns","ico","ief","img","ipa","iso","jar","jpeg","jpg","jpgv","jpm","jxr","key","ktx","lha","lib","lvp","lz","lzh","lzma","lzo","m3u","m4a","m4v","mar","mdi","mht","mid","midi","mj2","mka","mkv","mmr","mng","mobi","mov","movie","mp3","mp4","mp4a","mpeg","mpg","mpga","mxu","nef","npx","numbers","nupkg","o","odp","ods","odt","oga","ogg","ogv","otf","ott","pages","pbm","pcx","pdb","pdf","pea","pgm","pic","png","pnm","pot","potm","potx","ppa","ppam","ppm","pps","ppsm","ppsx","ppt","pptm","pptx","psd","pya","pyc","pyo","pyv","qt","rar","ras","raw","resources","rgb","rip","rlc","rmf","rmvb","rpm","rtf","rz","s3m","s7z","scpt","sgi","shar","snap","sil","sketch","slk","smv","snk","so","stl","suo","sub","swf","tar","tbz","tbz2","tga","tgz","thmx","tif","tiff","tlz","ttc","ttf","txz","udf","uvh","uvi","uvm","uvp","uvs","uvu","viv","vob","war","wav","wax","wbmp","wdp","weba","webm","webp","whl","wim","wm","wma","wmv","wmx","woff","woff2","wrm","wvx","xbm","xif","xla","xlam","xls","xlsb","xlsm","xlsx","xlt","xltm","xltx","xm","xmind","xpi","xpm","xwd","xz","z","zip","zipx"]),bcA=new Map;kx1=new Map});import{stat as Pe6}from"fs";import{stat as Se6,readdir as xe6}from"fs/promises";import{EventEmitter as ye6}from"events";import*as B8 from"path";function mcA(A){return Array.isArray(A)?A:[A]}function ue6(A){if(typeof A==="function")return A;if(typeof A==="string")return(Q)=>A===Q;if(A instanceof RegExp)return(Q)=>A.test(Q);if(typeof A==="object"&&A!==null)return(Q)=>{if(A.path===Q)return!0;if(A.recursive){let B=B8.relative(A.path,Q);if(!B)return!1;return!B.startsWith("..")&&!B8.isAbsolute(B)}return!1};return()=>!1}function me6(A){if(typeof A!=="string")throw Error("string expected");A=B8.normalize(A),A=A.replace(/\\/g,"/");let Q=!1;if(A.startsWith("//"))Q=!0;let B=/\/\//;while(A.match(B))A=A.replace(B,"/");if(Q)A="/"+A;return A}function UiQ(A,Q,B){let G=me6(Q);for(let Z=0;Z<A.length;Z++){let Y=A[Z];if(Y(G,B))return!0}return!1}function de6(A,Q){if(A==null)throw TypeError("anymatch: specify first argument");let G=mcA(A).map((Z)=>ue6(Z));if(Q==null)return(Z,Y)=>{return UiQ(G,Z,Y)};return UiQ(G,Q)}class MiQ{constructor(A,Q){this.path=A,this._removeWatcher=Q,this.items=new Set}add(A){let{items:Q}=this;if(!Q)return;if(A!==qiQ&&A!==ke6)Q.add(A)}async remove(A){let{items:Q}=this;if(!Q)return;if(Q.delete(A),Q.size>0)return;let B=this.path;try{await xe6(B)}catch(G){if(this._removeWatcher)this._removeWatcher(B8.dirname(B),B8.basename(B))}}has(A){let{items:Q}=this;if(!Q)return;return Q.has(A)}getChildren(){let{items:A}=this;if(!A)return[];return[...A.values()]}dispose(){this.items.clear(),this.path="",this._removeWatcher=gcA,this.items=pe6,Object.freeze(this)}}class OiQ{constructor(A,Q,B){this.fsw=B;let G=A;this.path=A=A.replace(ge6,""),this.watchPath=G,this.fullWatchPath=B8.resolve(G),this.dirParts=[],this.dirParts.forEach((Z)=>{if(Z.length>1)Z.pop()}),this.followSymlinks=Q,this.statMethod=Q?le6:ie6}entryPath(A){return B8.join(this.watchPath,B8.relative(this.watchPath,A.fullPath))}filterPath(A){let{stats:Q}=A;if(Q&&Q.isSymbolicLink())return this.filterDir(A);let B=this.entryPath(A);return this.fsw._isntIgnored(B,Q)&&this.fsw._hasReadPermissions(Q)}filterDir(A){return this.fsw._isntIgnored(this.entryPath(A),A.stats)}}function ne6(A,Q={}){let B=new dx1(Q);return B.add(A),B}var ux1="/",ve6="//",qiQ=".",ke6="..",fe6="string",be6,ziQ,he6,ge6,mx1=(A)=>typeof A==="object"&&A!==null&&!(A instanceof RegExp),$iQ=(A)=>{let Q=mcA(A).flat();if(!Q.every((B)=>typeof B===fe6))throw TypeError(`Non-string provided as watch path: ${Q}`);return Q.map(LiQ)},wiQ=(A)=>{let Q=A.replace(be6,ux1),B=!1;if(Q.startsWith(ve6))B=!0;while(Q.match(ziQ))Q=Q.replace(ziQ,ux1);if(B)Q=ux1+Q;return Q},LiQ=(A)=>wiQ(B8.normalize(wiQ(A))),NiQ=(A="")=>(Q)=>{if(typeof Q==="string")return LiQ(B8.isAbsolute(Q)?Q:B8.join(A,Q));else return Q},ce6=(A,Q)=>{if(B8.isAbsolute(A))return A;return B8.join(Q,A)},pe6,le6="stat",ie6="lstat",dx1,RiQ;var _iQ=L(()=>{WiQ();CiQ();/*! chokidar - MIT License (c) 2012 Paul Miller (paulmillr.com) */be6=/\\/g,ziQ=/\/\//,he6=/\..*\.(sw[px])$|~$|\.subl.*\.tmp/,ge6=/^\.[/\\]/;pe6=Object.freeze(new Set);dx1=class dx1 extends ye6{constructor(A={}){super();this.closed=!1,this._closers=new Map,this._ignoredPaths=new Set,this._throttled=new Map,this._streams=new Set,this._symlinkPaths=new Map,this._watched=new Map,this._pendingWrites=new Map,this._pendingUnlinks=new Map,this._readyCount=0,this._readyEmitted=!1;let Q=A.awaitWriteFinish,B={stabilityThreshold:2000,pollInterval:100},G={persistent:!0,ignoreInitial:!1,ignorePermissionErrors:!1,interval:100,binaryInterval:300,followSymlinks:!0,usePolling:!1,atomic:!0,...A,ignored:A.ignored?mcA(A.ignored):mcA([]),awaitWriteFinish:Q===!0?B:typeof Q==="object"?{...B,...Q}:!1};if(HiQ)G.usePolling=!0;if(G.atomic===void 0)G.atomic=!G.usePolling;let Z=process.env.CHOKIDAR_USEPOLLING;if(Z!==void 0){let I=Z.toLowerCase();if(I==="false"||I==="0")G.usePolling=!1;else if(I==="true"||I==="1")G.usePolling=!0;else G.usePolling=!!I}let Y=process.env.CHOKIDAR_INTERVAL;if(Y)G.interval=Number.parseInt(Y,10);let J=0;this._emitReady=()=>{if(J++,J>=this._readyCount)this._emitReady=gcA,this._readyEmitted=!0,process.nextTick(()=>this.emit(JY.READY))},this._emitRaw=(...I)=>this.emit(JY.RAW,...I),this._boundRemove=this._remove.bind(this),this.options=G,this._nodeFsHandler=new gx1(this),Object.freeze(G)}_addIgnoredPath(A){if(mx1(A)){for(let Q of this._ignoredPaths)if(mx1(Q)&&Q.path===A.path&&Q.recursive===A.recursive)return}this._ignoredPaths.add(A)}_removeIgnoredPath(A){if(this._ignoredPaths.delete(A),typeof A==="string"){for(let Q of this._ignoredPaths)if(mx1(Q)&&Q.path===A)this._ignoredPaths.delete(Q)}}add(A,Q,B){let{cwd:G}=this.options;this.closed=!1,this._closePromise=void 0;let Z=$iQ(A);if(G)Z=Z.map((Y)=>{return ce6(Y,G)});if(Z.forEach((Y)=>{this._removeIgnoredPath(Y)}),this._userIgnored=void 0,!this._readyCount)this._readyCount=0;return this._readyCount+=Z.length,Promise.all(Z.map(async(Y)=>{let J=await this._nodeFsHandler._addToNodeFs(Y,!B,void 0,0,Q);if(J)this._emitReady();return J})).then((Y)=>{if(this.closed)return;Y.forEach((J)=>{if(J)this.add(B8.dirname(J),B8.basename(Q||J))})}),this}unwatch(A){if(this.closed)return this;let Q=$iQ(A),{cwd:B}=this.options;return Q.forEach((G)=>{if(!B8.isAbsolute(G)&&!this._closers.has(G)){if(B)G=B8.join(B,G);G=B8.resolve(G)}if(this._closePath(G),this._addIgnoredPath(G),this._watched.has(G))this._addIgnoredPath({path:G,recursive:!0});this._userIgnored=void 0}),this}close(){if(this._closePromise)return this._closePromise;this.closed=!0,this.removeAllListeners();let A=[];return this._closers.forEach((Q)=>Q.forEach((B)=>{let G=B();if(G instanceof Promise)A.push(G)})),this._streams.forEach((Q)=>Q.destroy()),this._userIgnored=void 0,this._readyCount=0,this._readyEmitted=!1,this._watched.forEach((Q)=>Q.dispose()),this._closers.clear(),this._watched.clear(),this._streams.clear(),this._symlinkPaths.clear(),this._throttled.clear(),this._closePromise=A.length?Promise.all(A).then(()=>{return}):Promise.resolve(),this._closePromise}getWatched(){let A={};return this._watched.forEach((Q,B)=>{let Z=(this.options.cwd?B8.relative(this.options.cwd,B):B)||qiQ;A[Z]=Q.getChildren().sort()}),A}emitWithAll(A,Q){if(this.emit(A,...Q),A!==JY.ERROR)this.emit(JY.ALL,A,...Q)}async _emit(A,Q,B){if(this.closed)return;let G=this.options;if(hx1)Q=B8.normalize(Q);if(G.cwd)Q=B8.relative(G.cwd,Q);let Z=[Q];if(B!=null)Z.push(B);let Y=G.awaitWriteFinish,J;if(Y&&(J=this._pendingWrites.get(Q)))return J.lastChange=new Date,this;if(G.atomic){if(A===JY.UNLINK)return this._pendingUnlinks.set(Q,[A,...Z]),setTimeout(()=>{this._pendingUnlinks.forEach((I,X)=>{this.emit(...I),this.emit(JY.ALL,...I),this._pendingUnlinks.delete(X)})},typeof G.atomic==="number"?G.atomic:100),this;if(A===JY.ADD&&this._pendingUnlinks.has(Q))A=JY.CHANGE,this._pendingUnlinks.delete(Q)}if(Y&&(A===JY.ADD||A===JY.CHANGE)&&this._readyEmitted){let I=(X,W)=>{if(X)A=JY.ERROR,Z[0]=X,this.emitWithAll(A,Z);else if(W){if(Z.length>1)Z[1]=W;else Z.push(W);this.emitWithAll(A,Z)}};return this._awaitWriteFinish(Q,Y.stabilityThreshold,A,I),this}if(A===JY.CHANGE){if(!this._throttle(JY.CHANGE,Q,50))return this}if(G.alwaysStat&&B===void 0&&(A===JY.ADD||A===JY.ADD_DIR||A===JY.CHANGE)){let I=G.cwd?B8.join(G.cwd,Q):Q,X;try{X=await Se6(I)}catch(W){}if(!X||this.closed)return;Z.push(X)}return this.emitWithAll(A,Z),this}_handleError(A){let Q=A&&A.code;if(A&&Q!=="ENOENT"&&Q!=="ENOTDIR"&&(!this.options.ignorePermissionErrors||Q!=="EPERM"&&Q!=="EACCES"))this.emit(JY.ERROR,A);return A||this.closed}_throttle(A,Q,B){if(!this._throttled.has(A))this._throttled.set(A,new Map);let G=this._throttled.get(A);if(!G)throw Error("invalid throttle");let Z=G.get(Q);if(Z)return Z.count++,!1;let Y,J=()=>{let X=G.get(Q),W=X?X.count:0;if(G.delete(Q),clearTimeout(Y),X)clearTimeout(X.timeoutObject);return W};Y=setTimeout(J,B);let I={timeoutObject:Y,clear:J,count:0};return G.set(Q,I),I}_incrReadyCount(){return this._readyCount++}_awaitWriteFinish(A,Q,B,G){let Z=this.options.awaitWriteFinish;if(typeof Z!=="object")return;let Y=Z.pollInterval,J,I=A;if(this.options.cwd&&!B8.isAbsolute(A))I=B8.join(this.options.cwd,A);let X=new Date,W=this._pendingWrites;function K(V){Pe6(I,(E,D)=>{if(E||!W.has(A)){if(E&&E.code!=="ENOENT")G(E);return}let H=Number(new Date);if(V&&D.size!==V.size)W.get(A).lastChange=H;let F=W.get(A);if(H-F.lastChange>=Q)W.delete(A),G(void 0,D);else J=setTimeout(K,Y,D)})}if(!W.has(A))W.set(A,{lastChange:X,cancelWait:()=>{return W.delete(A),clearTimeout(J),B}}),J=setTimeout(K,Y)}_isIgnored(A,Q){if(this.options.atomic&&he6.test(A))return!0;if(!this._userIgnored){let{cwd:B}=this.options,Z=(this.options.ignored||[]).map(NiQ(B)),J=[...[...this._ignoredPaths].map(NiQ(B)),...Z];this._userIgnored=de6(J,void 0)}return this._userIgnored(A,Q)}_isntIgnored(A,Q){return!this._isIgnored(A,Q)}_getWatchHelpers(A){return new OiQ(A,this.options.followSymlinks,this)}_getWatchedDir(A){let Q=B8.resolve(A);if(!this._watched.has(Q))this._watched.set(Q,new MiQ(Q,this._boundRemove));return this._watched.get(Q)}_hasReadPermissions(A){if(this.options.ignorePermissionErrors)return!0;return Boolean(Number(A.mode)&256)}_remove(A,Q,B){let G=B8.join(A,Q),Z=B8.resolve(G);if(B=B!=null?B:this._watched.has(G)||this._watched.has(Z),!this._throttle("remove",G,100))return;if(!B&&this._watched.size===1)this.add(A,Q,!0);this._getWatchedDir(G).getChildren().forEach((V)=>this._remove(G,V));let I=this._getWatchedDir(A),X=I.has(Q);if(I.remove(Q),this._symlinkPaths.has(Z))this._symlinkPaths.delete(Z);let W=G;if(this.options.cwd)W=B8.relative(this.options.cwd,G);if(this.options.awaitWriteFinish&&this._pendingWrites.has(W)){if(this._pendingWrites.get(W).cancelWait()===JY.ADD)return}this._watched.delete(G),this._watched.delete(Z);let K=B?JY.UNLINK_DIR:JY.UNLINK;if(X&&!this._isIgnored(G))this._emit(K,G);this._closePath(G)}_closePath(A){this._closeFile(A);let Q=B8.dirname(A);this._getWatchedDir(Q).remove(B8.basename(A))}_closeFile(A){let Q=this._closers.get(A);if(!Q)return;Q.forEach((B)=>B()),this._closers.delete(A)}_addPathCloser(A,Q){if(!Q)return;let B=this._closers.get(A);if(!B)B=[],this._closers.set(A,B);B.push(Q)}_readdirp(A,Q){if(this.closed)return;let B={type:JY.ALL,alwaysStat:!0,lstat:!0,...Q,depth:0},G=XiQ(A,B);return this._streams.add(G),G.once(DiQ,()=>{G=void 0}),G.once(bx1,()=>{if(G)this._streams.delete(G),G=void 0}),G}};RiQ={watch:ne6,FSWatcher:dx1}});function rd(A){switch(A){case"userSettings":return"user";case"projectSettings":return"project";case"localSettings":return"project, gitignored";case"flagSettings":return"cli flag";case"policySettings":return"managed"}}function dcA(A){switch(A){case"userSettings":return"user settings";case"projectSettings":return"shared project settings";case"localSettings":return"project local settings";case"flagSettings":return"command line arguments";case"policySettings":return"enterprise managed settings";case"cliArg":return"CLI argument";case"command":return"command configuration";case"session":return"current session"}}function TiQ(A){switch(A){case"userSettings":return"User settings";case"projectSettings":return"Shared project settings";case"localSettings":return"Project local settings";case"flagSettings":return"Command line arguments";case"policySettings":return"Enterprise managed settings";case"cliArg":return"CLI argument";case"command":return"Command configuration";case"session":return"Current session"}}function jiQ(A){if(A==="")return[];let Q=A.split(",").map((G)=>G.trim()),B=[];for(let G of Q)switch(G){case"user":B.push("userSettings");break;case"project":B.push("projectSettings");break;case"local":B.push("localSettings");break;default:throw Error(`Invalid setting source: ${G}. Valid options are: user, project, local`)}return B}function Os(){let A=yK0(),Q=new Set(A);return Q.add("policySettings"),Q.add("flagSettings"),Array.from(Q)}function sK(A){return Os().includes(A)}var JL,PiQ="https://json.schemastore.org/claude-code-settings.json";var tI=L(()=>{g0();JL=["userSettings","projectSettings","localSettings","flagSettings","policySettings"]});import*as xiQ from"path";function se6(){if(SiQ||yiQ)return;SiQ=!0;let A=AA3();if(A.length===0)return;f(`Watching for changes in setting files ${A.join(", ")}...`),W8A=RiQ.watch(A,{persistent:!0,ignoreInitial:!0,awaitWriteFinish:{stabilityThreshold:ae6,pollInterval:oe6},ignored:(Q)=>Q.split(xiQ.sep).some((B)=>B===".git"),ignorePermissionErrors:!0,usePolling:!1,atomic:!0}),W8A.on("change",QA3),W8A.on("unlink",BA3),U8(async()=>viQ())}function viQ(){if(yiQ=!0,W8A)W8A.close(),W8A=null;ccA.clear(),K8A.clear()}function te6(A){return K8A.add(A),()=>{K8A.delete(A)}}function ee6(A){let Q=qF(A);if(Q)ccA.set(Q,Date.now())}function AA3(){let A=jA();return JL.map((Q)=>{let B=qF(Q);if(!B)return;try{if(!A.statSync(B).isFile())return}catch{return}return B}).filter((Q)=>Q!==void 0)}function QA3(A){let Q=kiQ(A);if(!Q)return;let B=ccA.get(A);if(B&&Date.now()-B<re6){ccA.delete(A);return}f(`Detected change to ${A}`),K8A.forEach((G)=>G(Q))}function BA3(A){let Q=kiQ(A);if(!Q)return;f(`Detected deletion of ${A}`),K8A.forEach((B)=>B(Q))}function kiQ(A){return JL.find((Q)=>qF(Q)===A)}function GA3(A){f(`Programmatic settings change notification for ${A}`),K8A.forEach((Q)=>Q(A))}var ae6=1000,oe6=500,re6=5000,W8A=null,SiQ=!1,yiQ=!1,ccA,K8A,NF;var Rs=L(()=>{_iQ();Y0();XQ();jB();tI();bW();ccA=new Map,K8A=new Set;NF={initialize:se6,dispose:viQ,subscribe:te6,markInternalWrite:ee6,notifyChange:GA3}});function V8A(A){let Q=pcA.useCallback((B)=>{TR();let G=NQ();A(B,G)},[A]);pcA.useEffect(()=>NF.subscribe(Q),[Q])}var pcA;var lcA=L(()=>{Rs();jB();pcA=o(WA(),1)});function YA3(A){let Q=qF(A);if(!Q||!jA().existsSync(Q))return null;try{let{resolvedPath:B}=gI(jA(),Q),G=wE(B);if(G.trim()==="")return{};let Z=h8(G,!1);return Z&&typeof Z==="object"?Z:null}catch{return null}}function JA3(A,Q){if(!A||!A.permissions)return[];let{permissions:B}=A,G=[];for(let Z of ZA3){let Y=B[Z];if(Y)for(let J of Y)G.push({source:Q,ruleBehavior:Z,ruleValue:IL(J)})}return G}function icA(){let A=[];for(let Q of Os())A.push(...ncA(Q));return A}function ncA(A){let Q=uB(A);return JA3(Q,A)}function fiQ(A){if(!IA3.includes(A.source))return!1;let Q=B5(A.ruleValue),B=uB(A.source);if(!B||!B.permissions)return!1;let G=B.permissions[A.ruleBehavior];if(!G||!G.includes(Q))return!1;try{let Z={...B,permissions:{...B.permissions,[A.ruleBehavior]:G.filter((J)=>J!==Q)}},{error:Y}=E2(A.source,Z);if(Y)return!1;return!0}catch(Z){return s(Z instanceof Error?Z:Error(String(Z))),!1}}function XA3(){return{permissions:{}}}function acA({ruleValues:A,ruleBehavior:Q},B){if(A.length<1)return!0;let G=A.map(B5),Z=uB(B)||YA3(B)||XA3();try{let Y=Z.permissions||{},J=Y[Q]||[],I=new Set(J),X=G.filter((V)=>!I.has(V));if(X.length===0)return!0;let W={...Z,permissions:{...Y,[Q]:[...J,...X]}},K=E2(B,W);if(K.error)throw K.error;return!0}catch(Y){return s(Y instanceof Error?Y:Error(String(Y))),!1}}var ZA3,IA3;var _s=L(()=>{h1();oG();tI();jB();XQ();M9();uI();ZA3=["allow","deny","ask"];IA3=["userSettings","projectSettings","localSettings"]});import{posix as WA3}from"path";function E8A(A){if(!A)return[];return A.flatMap((Q)=>{switch(Q.type){case"addRules":return Q.rules;default:return[]}})}function eI(A,Q){switch(Q.type){case"setMode":return f(`Applying permission update: Setting mode to '${Q.mode}'`),{...A,mode:Q.mode};case"addRules":{let B=Q.rules.map((Z)=>B5(Z));f(`Applying permission update: Adding ${Q.rules.length} ${Q.behavior} rule(s) to destination '${Q.destination}': ${JSON.stringify(B)}`);let G=Q.behavior==="allow"?"alwaysAllowRules":Q.behavior==="deny"?"alwaysDenyRules":"alwaysAskRules";return{...A,[G]:{...A[G],[Q.destination]:[...A[G][Q.destination]||[],...B]}}}case"replaceRules":{let B=Q.rules.map((Z)=>B5(Z));f(`Replacing all ${Q.behavior} rules for destination '${Q.destination}' with ${Q.rules.length} rule(s): ${JSON.stringify(B)}`);let G=Q.behavior==="allow"?"alwaysAllowRules":Q.behavior==="deny"?"alwaysDenyRules":"alwaysAskRules";return{...A,[G]:{...A[G],[Q.destination]:B}}}case"addDirectories":{f(`Applying permission update: Adding ${Q.directories.length} director${Q.directories.length===1?"y":"ies"} with destination '${Q.destination}': ${JSON.stringify(Q.directories)}`);let B=new Map(A.additionalWorkingDirectories);for(let G of Q.directories)B.set(G,{path:G,source:Q.destination});return{...A,additionalWorkingDirectories:B}}case"removeRules":{let B=Q.rules.map((I)=>B5(I));f(`Applying permission update: Removing ${Q.rules.length} ${Q.behavior} rule(s) from source '${Q.destination}': ${JSON.stringify(B)}`);let G=Q.behavior==="allow"?"alwaysAllowRules":Q.behavior==="deny"?"alwaysDenyRules":"alwaysAskRules",Z=A[G][Q.destination]||[],Y=new Set(B),J=Z.filter((I)=>!Y.has(I));return{...A,[G]:{...A[G],[Q.destination]:J}}}case"removeDirectories":{f(`Applying permission update: Removing ${Q.directories.length} director${Q.directories.length===1?"y":"ies"}: ${JSON.stringify(Q.directories)}`);let B=new Map(A.additionalWorkingDirectories);for(let G of Q.directories)B.delete(G);return{...A,additionalWorkingDirectories:B}}default:return A}}function sk(A,Q){let B=A;for(let G of Q)B=eI(B,G);return B}function FCA(A){return A==="localSettings"||A==="userSettings"||A==="projectSettings"}function eP(A){if(!FCA(A.destination))return;switch(f(`Persisting permission update: ${A.type} to source '${A.destination}'`),A.type){case"addRules":{f(`Persisting ${A.rules.length} ${A.behavior} rule(s) to ${A.destination}`),acA({ruleValues:A.rules,ruleBehavior:A.behavior},A.destination);break}case"addDirectories":{f(`Persisting ${A.directories.length} director${A.directories.length===1?"y":"ies"} to ${A.destination}`);let B=uB(A.destination)?.permissions?.additionalDirectories||[],G=A.directories.filter((Z)=>!B.includes(Z));if(G.length>0){let Z=[...B,...G];E2(A.destination,{permissions:{additionalDirectories:Z}})}break}case"removeRules":{f(`Removing ${A.rules.length} ${A.behavior} rule(s) from ${A.destination}`);let G=(uB(A.destination)?.permissions||{})[A.behavior]||[],Z=new Set(A.rules.map(B5)),Y=G.filter((J)=>!Z.has(J));E2(A.destination,{permissions:{[A.behavior]:Y}});break}case"removeDirectories":{f(`Removing ${A.directories.length} director${A.directories.length===1?"y":"ies"} from ${A.destination}`);let B=uB(A.destination)?.permissions?.additionalDirectories||[],G=new Set(A.directories),Z=B.filter((Y)=>!G.has(Y));E2(A.destination,{permissions:{additionalDirectories:Z}});break}case"setMode":{f(`Persisting mode '${A.mode}' to ${A.destination}`),E2(A.destination,{permissions:{defaultMode:A.mode}});break}case"replaceRules":{f(`Replacing all ${A.behavior} rules in ${A.destination} with ${A.rules.length} rule(s)`);let Q=A.rules.map(B5);E2(A.destination,{permissions:{[A.behavior]:Q}});break}}}function D8A(A){for(let Q of A)eP(Q)}function ocA(A,Q="session"){try{if(jA().statSync(A).isDirectory()){let G=rcA(A);if(G==="/")return;return{type:"addRules",rules:[{toolName:"Read",ruleContent:WA3.isAbsolute(G)?`/${G}/**`:`${G}/**`}],behavior:"allow",destination:Q}}}catch{}return}var tK=L(()=>{oG();Y0();jB();_s();XQ();cY()});var e9="Bash";function JB(A,Q){if(!process.env.SRT_DEBUG)return;let B=Q?.level||"info",G="[SandboxDebug]";switch(B){case"error":console.error(`${G} ${A}`);break;case"warn":console.warn(`${G} ${A}`);break;default:console.error(`${G} ${A}`)}}import{createServer as KA3}from"node:http";import{request as VA3}from"node:http";import{request as EA3}from"node:https";import{connect as DA3}from"node:net";import{URL as HA3}from"node:url";function biQ(A){let Q=KA3();return Q.on("connect",async(B,G)=>{G.on("error",(Z)=>{JB(`Client socket error: ${Z.message}`,{level:"error"})});try{let[Z,Y]=B.url.split(":"),J=Y===void 0?void 0:parseInt(Y,10);if(!Z||!J){JB(`Invalid CONNECT request: ${B.url}`,{level:"error"}),G.end(`HTTP/1.1 400 Bad Request\r[0m

[35m[3mthinking[0m[0m
**Planning script execution**

I‚Äôm setting up to read a file as text and searching for occurrences of `jiQ`. For each occurrence, I‚Äôll check the preceding 30 characters to see if they include keywords like `function` or `=`, which can help identify likely definitions. I‚Äôll make sure to limit the output to the first five findings. It‚Äôs all about keeping it neat and focused! I‚Äôm ready to dive in now.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "python - <<'PY'
import re
p='bundles/ClaudeCodeCode/cli.js'
text=open(p,'r',encoding='utf-8',errors='ignore').read()
# find all occurrences of 'jiQ'
idxs=[m.start() for m in re.finditer('jiQ', text)]
print('occurrences', len(idxs))
# rank candidates by whether definition-like nearby
cands=[]
for i in idxs:
    before=text[max(0,i-80):i]
    after=text[i:i+120]
    score=0
    if 'function ' in before: score+=3
    if '=' in before[-10:]: score+=2
    if 'var ' in before: score+=1
    if 'const ' in before: score+=1
    if after.startswith('jiQ='): score+=5
    if after.startswith('jiQ('): score+=0
    cands.append((score,i,before,after))
# take top unique scores
cands.sort(reverse=True)
seen=0
for score,i,before,after in cands:
    if score==0: break
    print('--- score',score,'idx',i)
    print(before.replace('\\n','\\\\n')[-80:])
    print(after[:120].replace('\\n','\\\\n'))
    seen+=1
    if seen>=8: break
PY"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 145ms:[0m
[2moccurrences 2
--- score 5 idx 10231788
ceof Error?Q.message:String(Q)}\n`)),process.exit(1)}}function eH5(A){try{let Q=
jiQ(A);vK0(Q),TR()}catch(Q){if(Q instanceof Error)s(Q);process.stderr.write(cA.red(`Error processing --setting-sources: 
--- score 3 idx 3989158
":return"Command configuration";case"session":return"Current session"}}function 
jiQ(A){if(A==="")return[];let Q=A.split(",").map((G)=>G.trim()),B=[];for(let G of Q)switch(G){case"user":B.push("userSet[0m

[35m[3mthinking[0m[0m
**Extracting definitions**

I'm noting that there are only 2 occurrences of the term I‚Äôm interested in. One definition is at index 3989158, and I have a snippet of it. Now, I'll extract the full definition by printing everything from that index to the closing brace. I think using Python to find the matching curly brace will be helpful. It might be a good idea to print around 400 characters to get a decent context. Let‚Äôs proceed with that!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "python - <<'PY'
import re
p='bundles/ClaudeCodeCode/cli.js'
text=open(p,'r',encoding='utf-8',errors='ignore').read()
start=text.find('function jiQ')
print('start',start)
print(text[start:start+600])
PY"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 111ms:[0m
[2mstart 3989149
function jiQ(A){if(A==="")return[];let Q=A.split(",").map((G)=>G.trim()),B=[];for(let G of Q)switch(G){case"user":B.push("userSettings");break;case"project":B.push("projectSettings");break;case"local":B.push("localSettings");break;default:throw Error(`Invalid setting source: ${G}. Valid options are: user, project, local`)}return B}function Os(){let A=yK0(),Q=new Set(A);return Q.add("policySettings"),Q.add("flagSettings"),Array.from(Q)}function sK(A){return Os().includes(A)}var JL,PiQ="https://json.schemastore.org/claude-code-settings.json";var tI=L(()=>{g0();JL=["userSettings","projectSettings[0m






[35m[3mthinking[0m[0m
**Analyzing enabled sources order**

I'm looking at the Os() function, which creates a Set from allowed sources and adds policySettings, then flagSettings. This results in an order of allowedSettingSources first, followed by policy and flag. It seems Set preserves insertion order‚Äîso policy comes before flag. However, there's a discrepancy with wL, where the order is user, project, local, flag, and policy, differing from how Os adds them. It looks like wL is associated with permission rules, not the enabled sources.
[35m[3mthinking[0m[0m
**Examining settings merge order**

I'm looking at how Os() returns the enabled sources list, which is based on allowedSettingSources, always including policy and flag at the end of that order. When merging settings, they iterate through Os(), treating policy specially and reading from a file. The order goes from the allowed list to policy, then flag, meaning if flag is last, it could override policy settings. This feels opposite to the wL order. I wonder if flag settings are read-only and explicit or if they should override everything, including policy settings.
[35m[3mthinking[0m[0m
**Clarifying flag and policy order**

In the enabled sources list, placing flag settings after policy indeed ensures that flag settings from the --settings file override policy settings, which makes sense. For permissions, since the wL list checks flag before policy, this consistent order allows flag rules to override policy rules. Great! So, when merging enabled sources, I should append policySettings followed by flagSettings, rather than following the wL order. However, the spec/legacy settings define a consistent order: [user, project, local, flag, policy]. That's the wL.
[35m[3mthinking[0m[0m
**Revising settings merge order**

For merging settings, it seems beneficial to compute the enabled sources order from the allowed list, followed by policy and then flag, as legacy does. However, the current spec/legacy defines LEGACY_SETTINGS_SOURCE_ORDER as [user, project, local, flag, policy], which may represent the base list, but not necessarily the merge order. I see that JL is labeled as a constant for file-backed sources, and for permission rules, wL prioritizes user over project, local, flag, and policy. So, it looks like for settings merge, the iteration would follow the order of user, project, local, policy, and then flag.
[35m[3mthinking[0m[0m
**Implementing settings manager**

For the settings merge, I need to ensure that both the `SETTINGS_FILE_SOURCES` list and the `getEnabledSettingsSources` function are properly implemented. The CLI argument parser lists sources in the order of "user, project, local," making that user-defined. In our rewrite, we'll focus on file path mapping, but only for the Node platform. Given the compatibility with legacy files, we can create a settings adapter to read and store settings appropriately. 

Using HostStorage simplifies things for non-filesystem hosts and allows us to maintain compatibility with legacy files on Node while avoiding direct filesystem dependencies in the core module. This way, our settings manager can operate efficiently across different hosts, prioritizing portability while still adhering to the need for layered, watchable settings.
[35m[3mthinking[0m[0m
**Details on settings migration**

For Node and desktop, I‚Äôm considering using HostStorage backed by the filesystem, which keeps structured keys for portability. This way, migrating legacy settings files will involve reading from old paths and importing them into the new storage, but I‚Äôm not sure if it's fully in the scope yet. Since it's in Phase 6, I see the need to implement it.

I‚Äôll create a Node-only importer for settings files, allowing read/write functionality. It‚Äôs also crucial to maintain the same file experience, as immediate adoption of new paths would disrupt things. Still, we‚Äôll need to define the mapping and implement both file-based and storage-based systems to fulfill the requirements while ensuring atomic write semantics and path mapping are covered in TypeScript tests.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"managed-settings\\.json|settings\\.local\\.json|flagSettingsPath|--settings\" -S src/spec/legacy src | head -n 100"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 65ms:[0m
[2m[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "nl -ba CLI_ENCYCLOPEDIA.md | sed -n '1000,1055p' | fold -w 140"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 43ms:[0m
[2m  1000	
  1001	In both builds, the mapping from source ‚Üí file path is explicit and stable.
  1002	
  1003	### Policy settings path (managed settings)
  1004	
  1005	- 2.0.67:
  1006	  - `VM = Z0(() => platformSwitch(...))` in `gB` module (see `ClaudeAgentSDKCode/cli.js:4401`)
  1007	  - `ig2()` returns `join(VM(), "managed-settings.json")`
  1008	- 2.0.69:
  1009	  - `sL = Z0(() => platformSwitch(...))` in `jB` module (see `ClaudeCodeCode/cli.js:4391`)
  1010	  - `ru2()` returns `join(sL(), "managed-settings.json")`
  1011	
  1012	The platform defaults are:
  1013	
  1014	- macOS: `"/Library/Application Support/ClaudeCode"`
  1015	- Windows: `"C:\\Program Files\\ClaudeCode"` if it exists, else `"C:\\ProgramData\\ClaudeCode"`
  1016	- Linux/other: `"/etc/claude-code"`
  1017	
  1018	### Per-source base directories
  1019	[0m

[35m[3mthinking[0m[0m
**Implementing path resolution**

I‚Äôve got the full path mapping now, which is good! So for Phase 6, I think I should implement the path resolution functions in a way that‚Äôs portable. I might want to use host capabilities like process (cwd) for the project root and config directory. But I realize the project root isn‚Äôt always the cwd; it could be derived from the workspace concept. I‚Äôve already incorporated the workspace concept in platform/node/workspace.ts, so I‚Äôll need to look into that next!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,220p' src/platform/node/workspace.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 40ms:[0m
[2mimport crypto from "node:crypto";
import path from "node:path";
import type { WorkspaceId } from "../../core/types/workspace.js";
import { asWorkspaceId } from "../../core/types/workspace.js";

export function deriveWorkspaceIdFromPath(inputPath: string): WorkspaceId {
  const resolved = path.resolve(inputPath);
  const hash = crypto.createHash("sha256").update(resolved, "utf8").digest("hex").slice(0, 16);
  return asWorkspaceId(`ws_path_${hash}`);
}
[0m







[35m[3mthinking[0m[0m
**Implementing path resolution**

I‚Äôm working on implementing OS-specific paths that use Node-specific platform detection, like using HostProcess.platform. It returns a string, which we can utilize in portable code. I realize that HostProcess might not exist on web/rn, but this path resolver will be used only if HostFilesystem is available. I‚Äôll also implement the function `resolveLegacySystemPolicySettingsDir`, and assess the existence of Program Files on Windows. Since our tests run on macOS, I‚Äôll still ensure cross-platform functionality, especially for reading and validating settings files.
[35m[3mthinking[0m[0m
**Deciding on settings schema**

I'm aiming to use TypeScript first and implement runtime validation through small custom shape validators while minimizing dependencies. I'll keep records of our decisions. For the types, I'll define a `SettingsSchemaVersion` as 1, and initially set `ClaudeCodeSettings` as `JsonObject`. We need known fields for computed configurations while allowing additional unknown properties. 

I'll define a partial typed interface for known toggles and provide helpful accessors with runtime checks. This will include implementing `getBooleanSetting(settings, path, defaultValue)` for effective configuration management.
[35m[3mthinking[0m[0m
**Defining settings patch type**

I‚Äôm defining the patch type as `SettingsPatch`, which may be `JsonValue`. To support deep partials and deletes when values are undefined, I'll represent the patch as `JsonValue | undefined`, but TypeScript doesn‚Äôt allow undefined in JSON directly. So I‚Äôll create `SettingsPatchValue`, which includes `JsonValue`, `SettingsPatchObject`, `SettingsPatchArray`, or `undefined`. 

I'll implement the function `applySettingsPatch(base, patch, options)`, following legacy methods. It seems patch arrays should merge using array behavior rather than element-wise merges, so maybe union them in applying patches as well.
[35m[3mthinking[0m[0m
**Understanding array behavior in patches**

The encyclopedia suggests that when a patch value is an array, it should replace or merge using array behavior instead of an element-wise object merge. This implies that the custom merge likely uses array union to deduplicate items when both are arrays. I‚Äôll implement union-dedupe for arrays in patches, but I‚Äôm pondering whether patches should simply replace arrays instead. 

In the legacy system, a patch may set `permissions.allow` to a new array, potentially merging with existing entries. However, it sounds like when a full new array is provided, it should override the previous one.
[35m[3mthinking[0m[0m
**Clarifying patch behaviors and operations**

I've thought about how the permission update for adding directories combines existing arrays. If I use array union for patches, it could introduce elements back that were removed. So, for remove operations, patches must replace the arrays rather than just merging them. The encyclopedia‚Äôs guidance seems to support that replacement behavior rather than union.

I‚Äôll ensure that the patch applies changes correctly and define methods like `updateSourceSettings` with version checks. We‚Äôll also implement UI prompts to confirm actions, and I‚Äôll focus on compatibility in migrating old file paths into the new structure.
[35m[3mthinking[0m[0m
**Defining settings and policies**

In section 6.6, I need to specify settings that require non-default merging behavior. For invalid policy settings, my current inclination is to fail-closed, meaning risky capabilities should be disabled rather than ignored. If the policy settings are invalid, I'll treat them as empty and generate an error, ensuring that critical features are appropriately controlled.

I‚Äôm also planning to accurately represent policy origins and errors within the doctor report. Moving to section 6.7, I‚Äôll implement a mapping for storage keys and documents, and handle namespaces for different settings effectively, taking into account mobile and web contexts and ensuring proper error logging. 

For section 6.8, I‚Äôll compute the effective configuration from merged settings, policy, and capabilities while defining which features are safe for persistence. Overall, I‚Äôm focusing on making clear distinctions in settings behaviors and ensuring robust error handling.
[35m[3mthinking[0m[0m
**Implementing settings and secrets**

I‚Äôm adding golden tests to ensure that `EffectiveConfig` computes similarly across hosts, depending on available capabilities. For secret references in settings, I‚Äôll represent them with an object like `{ __secretRef: "name" }`, as it‚Äôs essential to be JSON-compatible for effective redaction. 

I will implement a resolver function to replace secret references with their actual values without keeping those values persisted. Additionally, I'm defining how to handle scenarios where secrets cannot be resolved and determining the propagation of changes in settings updates via a `SettingsManager`. 

I plan to break this down into a comprehensive module suite for better management.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,220p' src/core/engine/index.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 46ms:[0m
[2mexport type { Engine, EngineCommand, EngineCreateOptions, EngineEventHandler, EngineFactory } from "../types/engine.js";
[0m






[35m[3mthinking[0m[0m
**Considering settings integration**

It looks like there's no engine implementation, which means the settings manager doesn't need to integrate with the store just yet. However, we still need to define how settings changes trigger updates in the engine store, perhaps by implementing a typed event like `HostEvent`. 

Since the engine isn't in place, I could focus on creating a `createSettingsStoreBinding` helper in the settings module. This would return a function to dispatch updates like `app/settings-updated`. But I'll need to ensure the state store can handle these actions. It might be unnecessary without the engine, but defining how this works is essential. I'll look into implementing a `SettingsDerivedState` type and corresponding action functions. I'll also consider documenting our required capabilities, but I'll hold off on finalizing the schema tooling.
[35m[3mthinking[0m[0m
**Planning schema validation**

The plan requires us to decide on a schema strategy and validation. I can create our own internal runtime validator for now, but I should keep it modular so we can easily swap in Zod later. I‚Äôll document everything in the changelog and the plan.

Next, I need to check off every completed item in Phase 6 of the plan and update our checklist file accordingly. There are many items to tackle, specifically from 6.1 to 6.9, totaling about 39 tasks, each with sub-items. I'll implement the necessary types, functions, and tests as efficiently as I can.
[35m[3mthinking[0m[0m
**Implementing schema strategy**

I‚Äôll implement this step systematically. For the schema strategy, I want to establish a TypeScript-first approach with an internal runtime validation library. The plan includes defining a versioned settings schema, complete with migration steps and a strict error model for parse/validate processes. 

I also need to create a `SettingsSchemaStrategy` enum and `SettingsSchemaCapabilities` that describe our requirements. The `SettingsDocumentV1` interface will help structure our settings, and I‚Äôll define a `parseSettingsDocument` function to handle raw JSON strings. Since legacy settings are stored as plain objects, my system should accommodate reading those and parsing them into our new settings model while maintaining migration capabilities.
[35m[3mthinking[0m[0m
**Defining settings and migration process**

I'm going to define `SettingsEnvelopeV1`, which will wrap our settings and include the schema version. To maintain compatibility, I'll also support the `LegacySettingsFileFormat` for unwrapped objects. The parsing function will be able to handle both formats‚Äîif the object has a kind and schema version, it will be treated as version 1; otherwise, I'll wrap it as legacy.

I'll outline a migration function to ensure we can upgrade settings from legacy formats to the new envelope version. If we store settings in HostStorage, we can easily manage versions. I'll plan explicit migrations, such as transitioning from legacy to envelope V1 without changes. 

Next, I will define sources for settings, allowing for a type union and enabling selection based on user/project/local contexts while ensuring the inclusion of policies and flags. The merging behavior will be key; objects will be deep merged, while arrays may seem to either union or replace. I'll implement `mergeSettingsTrees` to reflect this strategy accurately.
[35m[3mthinking[0m[0m
**Implementing merging and settings propagation**

For merging settings, I will implement a `MergePolicy` that allows for path overrides, especially for arrays like `permissions.allow/deny/ask` which should union when merging from different sources. Even though permission rules use raw lists, it‚Äôs safe to union these arrays. The `mergeSettingsValue(base, next)` function will handle merging: recursively for objects and unioning while preserving order for arrays. 

Next, I‚Äôll define `PolicySettingsOrigin`, which will represent different sources like remote, local, or absent. For command configurations and overlays, I plan to treat them as `SettingsOverlay` in memory without persisting them.

Moving on to watchers, I‚Äôll create an event bus to facilitate change propagation without relying on filesystem timestamps. The `SettingsEventBus` class will manage subscriptions. I need to ensure recently written versions are tracked to suppress internal write events. Each storage change will interact with a version map to prevent unnecessary triggers. 

For settings patching, the `SettingsPatch` format will support deep partial updates, and I‚Äôll ensure atomic updates align with the storage backend. I'll create a conflict resolution policy for concurrent updates.

Lastly, I'll develop a migration plan for legacy file paths into the new storage model and craft a `SettingsDoctorReport` that captures parse errors and invalid fields for future health checks.
[35m[3mthinking[0m[0m
**Implementing settings and error handling**

I'll start by implementing a file reader that attempts to get the real path. If it fails due to errors like ENOENT or ELOOP, I‚Äôll return null instead of throwing an error. Next, I need to define how legacy sources are parsed and mapped in a way that‚Äôs suitable for portable selection.

For merging settings, I‚Äôll identify fields needing special merge behavior and document those. I also plan to establish explicit merge semantics for various settings, including permission rules. I'll create mechanisms to represent any validation errors from multiple sources.

Regarding policy settings, if they‚Äôre invalid, I‚Äôll set the effective configuration to block all features dependent on that policy. This will help ensure safety but might impact tests. I‚Äôll implement a configuration that disables features when the policy is invalid. 

For portable storage mapping, I‚Äôll define storage keys and scoping methods, especially for mobile and web contexts. I also want to implement settings import/export functionalities, ensuring that sensitive information is excluded during these operations.

Next, I'll manage feature availability through computed EffectiveConfig snapshots derived from settings and capabilities. I'll define what is safe to persist versus ephemeral. Plus, I‚Äôll develop UI adapters that rely on EffectiveConfig instead of raw settings.

Lastly, the management of secrets and credentials will need to follow strict boundaries. I'll define schema boundaries and how secret references are handled, including their resolution process. It will be essential to ensure that exports don‚Äôt contain any resolved secret values while integrating everything with existing modules.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,200p' src/core/index.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 48ms:[0m
[2mexport * from "./types/index.js";
export * from "./engine/index.js";
export * from "./events/index.js";
export * from "./runtime/index.js";
export * from "./state/index.js";
export * from "./settings/index.js";
export * from "./permissions/index.js";
export * from "./hooks/index.js";
export * from "./tools/index.js";
export * from "./mcp/index.js";
export * from "./agents/index.js";
export * from "./capabilities/index.js";
export * from "./network/index.js";
export * from "./filesystem/index.js";[0m







[35m[3mthinking[0m[0m
**Exploring watcher functionality**

I'm looking into how suppressing change events in watchers works to prevent loops. Even though internal writes initiated by settings updates may not trigger extra notifications, I think it's important to emit updates after a patch within the manager. Internal patches expect effective settings changes, which should be communicated to subscribers. In the legacy system, after updating the settings file, they seem to invalidate the cache, but it's unclear if they also notify watchers. I'll need to check if manual notifications occur after internal writes.
[35m[3mthinking[0m[0m
**Clarifying internal write mechanics**

I think the internal write suppression is specifically designed to suppress events from the watcher for that file, but after writing, they might manually call `notifyChange` to deliver updates. It's possible they selectively suppress internal writes within a certain time-to-live (TTL) frame to avoid infinite loops. They still need to notify when changes occur. I believe `X2/E2` might write then explicitly trigger `notifyChange`, which would recompute and notify subscribers without causing a double response. I'll implement this method.
[35m[3mthinking[0m[0m
**Implementing settings manager**

In our manager patch function, after a write, I'll recompute and emit an update event while internal suppression will prevent the following storage event from causing extra recompute. Since the set operation triggers subscribe events synchronously, I need to ensure that internal suppression handles that, and we'll emit notifications manually. I plan to implement `SettingsManager` methods for initializing, subscribing, notifying changes, marking internal writes, applying patches, and unsubscribing. We'll also handle ephemeral updates without storage, and ensure proper storage mapping for settings documents.
[35m[3mthinking[0m[0m
**Defining settings source and merging logic**

I‚Äôm arranging the order for enabled sources as [user, policy, flag] and merging them accordingly. This way, the flags correctly override previous values. For instance, merging results in {a:3} after processing ‚Äî nice! I also need to verify the arrays‚Äô union function, ensuring it combines elements appropriately. The `computeEffectiveConfig` should handle various flags like disableAllHooks for testing purposes. Additionally, I‚Äôll store settings using `StoredSettingsSourceRecordV1`, ensuring we include fields like schema version and JSON format for effective storage. I‚Äôll also check for invalid JSON handling.
[35m[3mthinking[0m[0m
**Handling legacy settings and file operations**

I‚Äôm considering how to manage settings reading while treating missing settings as empty objects without errors. If we're dealing with legacy settings files, I'll implement a `legacySettingsToStorage` importer for reading file paths. This will ensure we can capture any IO errors. For reading legacy settings, I‚Äôm planning to create functions to read, parse, and validate settings while ensuring compatibility without integrating into the manager by default. I'll also explore how to handle atomic writes and leverage HostFilesystem to maintain file attributes like symlinks but decide to keep the implementation straightforward to avoid complications.
[35m[3mthinking[0m[0m
**Mapping legacy settings to the new model**

To address how legacy file paths map into the new storage model, I'll implement a mapping and importer, ensuring to handle broken symlinks appropriately. Additionally, I'll define golden tests for `EffectiveConfig` to ensure consistency across hosts. My module design includes various types and functions for settings management, parsing, merging, and storage mapping. The settings manager will maintain an `allowedSettingSources` list and utilize storage for reading settings. I'll categorize sources, ensuring non-file sources support permissions without impacting the effective settings merge, while preserving a clear structure for command configurations and overlays.
[35m[3mthinking[0m[0m
**Implementing write suppression and exports**

I need to define internal-write suppression to prevent write-watching loops without relying on filesystem timestamps. The plan is to implement version-based suppression and focus on exporting and importing settings for support and migration. For the `exportSettingsSnapshot`, I'll ensure that effective settings are produced without exposing secrets. We'll mask anything sensitive by targeting keys that contain words like "token" or "password." To address implementation, I‚Äôll also update the checklist and changelog before coding. I plan to explore bundled CLI behavior more and look into merge and patch semantics.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "python - <<'PY'
import re
p='bundles/ClaudeCodeCode/cli.js'
text=open(p,'r',encoding='utf-8',errors='ignore').read()
start=text.find('function E2(')
print('start',start)
print(text[start:start+1200])
PY"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 137ms:[0m
[2mstart 10040306
function E2(A,Q){if(A==="policySettings"||A==="flagSettings")return{error:null};let B=qF(A);if(!B)return{error:null};try{let G=ou2(B);if(!jA().existsSync(G))jA().mkdirSync(G);let Z=uB(A);if(!Z&&jA().existsSync(B)){let J=wE(B),I=h8(J);if(I===null)return{error:Error(`Invalid JSON syntax in settings file at ${B}`)};if(I&&typeof I==="object")Z=I,f(`Using raw settings from ${B} due to validation failure`)}let Y=gPA(Z||{},Q,(J,I,X,W)=>{if(I===void 0&&W&&typeof X==="string"){delete W[X];return}if(Array.isArray(I))return I;return});if(NF.markInternalWrite(A),rL(B,JSON.stringify(Y,null,2)+`
`),TR(),A==="localSettings")q80(iTA("localSettings"),pQ())}catch(G){let Z=Error(`Failed to read raw settings from ${B}: ${G}`);return s(Z),{error:Z}}return{error:null}}function hV5(A,Q){let B=[...A,...Q];return Array.from(new Set(B))}function au2(A,Q){if(Array.isArray(A)&&Array.isArray(Q))return hV5(A,Q);return}function su2(A){let Q=Jb.strip().parse(A),B=["permissions","sandbox","hooks"],G=[],Z={permissions:new Set(["allow","deny","ask","defaultMode","disableBypassPermissionsMode","additionalDirectories"]),sandbox:new Set(["network","ignoreViolations","excludedCommands","autoAllowBashIfSandboxed","enable[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "python - <<'PY'
import re
p='bundles/ClaudeCodeCode/cli.js'
text=open(p,'r',encoding='utf-8',errors='ignore').read()
for m in re.finditer('NF\\.notifyChange', text):
    i=m.start();
    print('idx',i)
    print(text[i-80:i+120])
    break
PY"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 119ms:[0m
[2m<stdin>:4: SyntaxWarning: "\." is an invalid escape sequence. Such sequences will not work in the future. Did you mean "\\."? A raw string is also an option.
idx 7259819
A=new Promise((A)=>{rb=A});try{let A=await CA0();if(sb())gY8();if(A!==null)TR(),NF.notifyChange("policySettings")}finally{if(rb)rb(),rb=null}}async function YnB(){if(FA0(),!sb()){TR(),NF.notifyChange([0m


[35m[3mthinking[0m[0m
**Considering event suppression logic**

I‚Äôm wondering if the suppression TTL is something very short, like 50ms. It's possible that events could come in later than the TTL because of awaitWriteFinish. So it‚Äôs likely not suppressed; maybe markInternalWrite sets a timestamp, and the watcher checks TTL around 100ms. If events arrive after the TTL has expired, they get processed instead. This suggests that suppression is primarily to ignore extremely fast watchers. Instead, I'll implement version-based suppression with a "notifyChangeAfterWrite" call to ensure updates are emitted safely.
[35m[3mthinking[0m[0m
**Updating implementation plan**

I‚Äôm planning to implement the patch method where, after a write, I‚Äôll recompute and emit changes. Internal suppression should stop processing the storage event to prevent duplicates, which seems good. I also think we might need remote policy update functions. Looking at my update plan, step 1, which involves reading the requirements, is completed. Now for step 2, I'm inspecting the bundled CLI behavior, so I‚Äôll mark it as in progress.
[35mPlan update[0m
  [32m‚úì[0m Read Phase 6 requirements
  [36m‚Üí[0m Inspect bundled CLI behavior
  [2m‚Ä¢[0m [2mImplement Phase 6 modules[0m
  [2m‚Ä¢[0m [2mAdd Phase 6 tests[0m
  [2m‚Ä¢[0m [2mRun required validations[0m
  [2m‚Ä¢[0m [2mUpdate plan checklist and changelog[0m

[35m[3mthinking[0m[0m
I need to inspect the bundle for merge semantics, particularly the array union function hV5. We‚Äôve checked out the E2 patch and the au2 merge union, which should be sufficient for now. For the watcher interface, it seems like I might need to look at a snippet too. I‚Äôll extract `NF={ initialize... }` from the bundle and then search for `NF={initialize` using Python to find it. Let's keep everything organized!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "python - <<'PY'
import re
p='bundles/ClaudeCodeCode/cli.js'
text=open(p,'r',encoding='utf-8',errors='ignore').read()
idx=text.find('NF={')
print('idx',idx)
print(text[idx:idx+500])
PY"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 208ms:[0m
[2midx 3991104
NF={initialize:se6,dispose:viQ,subscribe:te6,markInternalWrite:ee6,notifyChange:GA3}});function V8A(A){let Q=pcA.useCallback((B)=>{TR();let G=NQ();A(B,G)},[A]);pcA.useEffect(()=>NF.subscribe(Q),[Q])}var pcA;var lcA=L(()=>{Rs();jB();pcA=o(WA(),1)});function YA3(A){let Q=qF(A);if(!Q||!jA().existsSync(Q))return null;try{let{resolvedPath:B}=gI(jA(),Q),G=wE(B);if(G.trim()==="")return{};let Z=h8(G,!1);return Z&&typeof Z==="object"?Z:null}catch{return null}}function JA3(A,Q){if(!A||!A.permissions)retur[0m

[35m[3mthinking[0m[0m
**Inspecting bundle differences**

I think we have enough information for now. However, it might be wise to inspect the other bundle for any differences, even though I presume they'll be the same. The spec indicates that phase 6 should align with both bundles, so we should check the agent bundle for the `alQ` and `us` functions as well. I‚Äôll quickly extract those functions from `ClaudeAgentSDKCode/cli.js` and perform a Python search there.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "python - <<'PY'
import re
p='bundles/ClaudeAgentSDKCode/cli.js'
text=open(p,'r',encoding='utf-8',errors='ignore').read()
for name in ['function alQ','function us','function X2','function zK5']:
    idx=text.find(name)
    print(name,'idx',idx)
    if idx"'!=-1:
        print(text[idx:idx+300])
PY'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 135ms:[0m
[2mfunction alQ idx 3989176
function alQ(A){if(A==="")return[];let Q=A.split(",").map((G)=>G.trim()),B=[];for(let G of Q)switch(G){case"user":B.push("userSettings");break;case"project":B.push("projectSettings");break;case"local":B.push("localSettings");break;default:throw Error(`Invalid setting source: ${G}. Valid options are:
function us idx 3989509
function us(){let A=VK0(),Q=new Set(A);return Q.add("policySettings"),Q.add("flagSettings"),Array.from(Q)}function BV(A){return us().includes(A)}var wL,olQ="https://json.schemastore.org/claude-code-settings.json";var iI=q(()=>{u0();wL=["userSettings","projectSettings","localSettings","flagSettings",
function X2 idx 7919398
function X20(A,Q){R22.call(this),this.nodeType=SU8.COMMENT_NODE,this.ownerDocument=A,this._data=Q}var FOA={get:function(){return this._data},set:function(A){if(A===null||A===void 0)A="";else A=String(A);if(this._data=A,this.rooted)this.ownerDocument.mutateValue(this)}};X20.prototype=Object.create(R2
function zK5 idx 10034600
function zK5(A,Q){let B=[...A,...Q];return Array.from(new Set(B))}function pg2(A,Q){if(Array.isArray(A)&&Array.isArray(Q))return zK5(A,Q);return}function ng2(A){let Q=Pb.strip().parse(A),B=["permissions","sandbox","hooks"],G=[],Z={permissions:new Set(["allow","deny","ask","defaultMode","disableBypas[0m
[35mPlan update[0m
  [32m‚úì[0m Read Phase 6 requirements
  [32m‚úì[0m Inspect bundled CLI behavior
  [36m‚Üí[0m Implement Phase 6 modules
  [2m‚Ä¢[0m [2mAdd Phase 6 tests[0m
  [2m‚Ä¢[0m [2mRun required validations[0m
  [2m‚Ä¢[0m [2mUpdate plan checklist and changelog[0m

[35m[3mthinking[0m[0m
**Implementing modules**

I‚Äôm planning to implement the modules now and I‚Äôll use `apply_patch` to create the files needed. Before diving into editing, I need to check for any instructions related to AGENTS. It doesn‚Äôt seem like there‚Äôs anything mentioned yet, but I‚Äôll go ahead and search for the AGENTS.md file just to ensure I‚Äôm not missing anything important. It's essential to have clear guidance while I proceed!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'find .. -name AGENTS.md -print'[0m in /Users/ronaldeddings/ClaudeCodeTS[31m exited 124 in 10.02s:[0m
[2mfind: ../.fleet: Permission denied[0m

[35m[3mthinking[0m[0m
**Determining command access**

I‚Äôm trying to run a command, but it‚Äôs showing "permission denied" related to .fleet. Even though I have full access, the command still returned that error. It seems like I need to limit my search within the repository instead. So, I‚Äôll go ahead and use the command `find . -name AGENTS.md` to look for that specific file. Let's see if that works better!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'find . -name AGENTS.md -print'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 182ms:[0m
[2m[0m





[35m[3mthinking[0m[0m
**Implementing deduplication logic**

I‚Äôm thinking about how to implement deduplication using `===` for primitives while handling objects differently since they are always treated as unique. For array items, I could dedupe primitives with `Set`, but I'll keep objects and arrays intact to preserve order and avoid deduplication unless they are primitive types. This means that while primitives can be deduped, objects will be kept as is, ensuring stability across the parsed data.  Let's clarify that I want base items first, then subsequent items.
[35m[3mthinking[0m[0m
**Implementing union and merge functions**

I'm planning to implement a union function for `JsonArray`, where I take the base array and go through the next one. If the item is primitive and already in the set, I'll skip it; otherwise, I'll add it. For objects and arrays, I'll consistently append them, aligning with legacy behaviors for common cases.

Next, the `mergeJsonValues` function will handle object deep merges and array unions, along with scalar overrides. I'll also create a function to apply patches to settings without mutating the base object, ensuring a clean return.
[35m[3mthinking[0m[0m
**Implementing patch value handling**

I'm looking to create a helper function, `applyPatchValue(baseValue, patchValue)`, to deal with patching values. 

If `patchValue` is undefined, it signals a deletion that will be handled at a higher level. For arrays, I can simply return a deep clone, as this approach is deterministic. If `patchValue` is a plain object and `baseValue` is also an object, I‚Äôll merge them recursively; otherwise, I'll take `patchValue` as is. For any primitives or null, I'll use `patchValue`, but exclude functions as invalid. I need to define a patch format, too, incorporating TypeScript types for clarity.
[35m[3mthinking[0m[0m
**Setting up storage mapping**

I‚Äôm working on the storage mapping for sources and their corresponding namespaces and keys. I need a method called `getSettingsStorageKey(source)` to format it as `claude.settings.<source>`. Then I‚Äôll create `settingsNamespaceForSource(source, ctx)` to include workspaceId and sessionId.

I also need to handle reading and writing settings. For reading, `readSettingsSourceFromStorage(storage, namespace, key, source)` will return settings and any errors. For writing, it‚Äôs `writeSettingsSourceToStorage(storage, namespace, key, document)`. I should also define a conflict error type for settings and manage `SettingsSourceRecord` envelopes in storage. Lastly, I‚Äôll serialize `SettingsDocumentV1` as a JSON string with proper indentation.
[35m[3mthinking[0m[0m
**Designing the SettingsManager**

I‚Äôm setting up the `SettingsManager` to handle effective settings by merging enabled file sources. I'll create methods such as `getEffectiveSettings()` and `getSourceSettings(source)`, along with functions to handle errors and configure allowed sources. 

Additionally, I‚Äôll include patching abilities to update settings in storage. The manager will initialize watchers for various scopes, such as app and workspace, ensuring we only subscribe to relevant keys. I'll also define types for settings events and manage internal suppression semantics to prevent unnecessary updates. 

Next, I need to design the effective configuration system and report framework to track settings health and errors efficiently. For environmental settings, I‚Äôll create a parsing system while keeping legacy functionality intact, avoiding unnecessary redundancy. Finally, I‚Äôll implement secret detection and adjustments across the relevant files.
[3m[35mfile update[0m[0m
[35mD /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/index.ts[0m
[31mexport type SettingsPlaceholder = {[0m
[31m  phase: "2";[0m
[31m};[0m
[31m[0m
[32mapply_patch(auto_approved=true) exited 0 in 9ms:[0m
[2mSuccess. Updated the following files:[0m
[2mD src/core/settings/index.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
deleted file mode 100644
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..0000000000000000000000000000000000000000
--- a/src/core/settings/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-

[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
deleted file mode 100644
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..0000000000000000000000000000000000000000
--- a/src/core/settings/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-

[3m[35mfile update[0m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/effectiveConfig.ts[0m
[32mimport type { HostCapabilities } from "../types/host.js";[0m
[32mimport type { JsonObject } from "../types/json.js";[0m
[32mimport type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";[0m
[32m[0m
[32mexport type FeatureGateKind = "portable" | "host_only" | "env_alias";[0m
[32m[0m
[32mexport type FeatureGateDescriptor = {[0m
[32m  key: string;[0m
[32m  kind: FeatureGateKind;[0m
[32m  notes?: string;[0m
[32m};[0m
[32m[0m
[32mexport const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [[0m
[32m  { key: "disableAllHooks", kind: "portable" },[0m
[32m  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },[0m
[32m  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },[0m
[32m  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },[0m
[32m  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },[0m
[32m  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }[0m
[32m];[0m
[32m[0m
[32mexport type EffectiveConfig = {[0m
[32m  schemaVersion: 1;[0m
[32m  policy: { origin: SettingsPolicyOrigin };[0m
[32m  hooks: { disabled: boolean; managedOnly: boolean };[0m
[32m  mcpCli: {[0m
[32m    enableExperimentalMcpCli: boolean;[0m
[32m    enableMcpCliEndpoint: boolean;[0m
[32m    mcpToolTimeoutMs: number | null;[0m
[32m    maxMcpOutputTokens: number | null;[0m
[32m  };[0m
[32m  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };[0m
[32m};[0m
[32m[0m
[32mfunction isPlainObject(value: unknown): value is JsonObject {[0m
[32m  return typeof value === "object" && value !== null && !Array.isArray(value);[0m
[32m}[0m
[32m[0m
[32mfunction readBoolean(obj: JsonObject, key: string): boolean | null {[0m
[32m  const v = obj[key];[0m
[32m  return typeof v === "boolean" ? v : null;[0m
[32m}[0m
[32m[0m
[32mfunction readString(obj: JsonObject, key: string): string | null {[0m
[32m  const v = obj[key];[0m
[32m  return typeof v === "string" ? v : null;[0m
[32m}[0m
[32m[0m
[32mfunction parseIntEnv(value: string | undefined): number | null {[0m
[32m  if (!value) return null;[0m
[32m  const n = Number.parseInt(value, 10);[0m
[32m  if (!Number.isFinite(n)) return null;[0m
[32m  return n;[0m
[32m}[0m
[32m[0m
[32mexport function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {[0m
[32m  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";[0m
[32m  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";[0m
[32m  return {[0m
[32m    enableExperimentalMcpCli: experimental,[0m
[32m    enableMcpCliEndpoint: experimental && !endpointDisabled,[0m
[32m    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),[0m
[32m    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])[0m
[32m  };[0m
[32m}[0m
[32m[0m
[32mexport function computeEffectiveConfig(options: {[0m
[32m  effectiveSettings: JsonObject;[0m
[32m  policySource: SettingsSourceReadResult | undefined;[0m
[32m  policyOrigin: SettingsPolicyOrigin;[0m
[32m  host: HostCapabilities;[0m
[32m  env?: Record<string, string | undefined>;[0m
[32m}): EffectiveConfig {[0m
[32m  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;[0m
[32m[0m
[32m  const policySettings = options.policySource?.settings ?? null;[0m
[32m  const managedOnly =[0m
[32m    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;[0m
[32m[0m
[32m  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});[0m
[32m[0m
[32m  const hasFilesystem = options.host.filesystem.kind === "available";[0m
[32m  const hasNetwork = options.host.network.kind === "available";[0m
[32m  const hasSecrets = options.host.secrets.kind === "available";[0m
[32m[0m
[32m  const policyOrigin = options.policyOrigin;[0m
[32m  const failClosed = policyOrigin === "invalid";[0m
[32m[0m
[32m  return {[0m
[32m    schemaVersion: 1,[0m
[32m    policy: { origin: policyOrigin },[0m
[32m    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },[0m
[32m    mcpCli,[0m
[32m    capabilities: { hasFilesystem, hasNetwork, hasSecrets }[0m
[32m  };[0m
[32m}[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/manager.ts[0m
[32mimport type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";[0m
[32mimport { requireCapability } from "../types/host.js";[0m
[32mimport type { JsonObject } from "../types/json.js";[0m
[32mimport { applySettingsPatch, type SettingsPatchObject } from "./patch.js";[0m
[32mimport { parseSettingsJson } from "./schema.js";[0m
[32mimport { mergeSettingsObjectsInOrder } from "./merge.js";[0m
[32mimport { computeEnabledFileSettingsSources, type } from "./sources.js";[0m
[32mimport type {[0m
[32m  AllowedSettingSource,[0m
[32m  EffectiveSettingsResult,[0m
[32m  FileBackedSettingsSource,[0m
[32m  SettingsError,[0m
[32m  SettingsEventBus,[0m
[32m  SettingsPolicyOrigin,[0m
[32m  SettingsSource,[0m
[32m  SettingsSourceReadResult,[0m
[32m  SettingsUpdateEvent,[0m
[32m  SettingsUnsubscribe,[0m
[32m  WritableSettingsSource[0m
[32m} from "./types.js";[0m
[32mimport {[0m
[32m  createSettingsDocumentFromObject,[0m
[32m  namespaceForSettingsSource,[0m
[32m  readSettingsSourceFromStorage,[0m
[32m  settingsStorageKey,[0m
[32m  writeSettingsSourceToStorage,[0m
[32m  type SettingsStorageContext[0m
[32m} from "./storage.js";[0m
[32mimport { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";[0m
[32m[0m
[32mfunction createEventBus(): SettingsEventBus {[0m
[32m  const subs = new Set<(evt: SettingsUpdateEvent) => void>();[0m
[32m  return {[0m
[32m    subscribe: (handler) => {[0m
[32m      subs.add(handler);[0m
[32m      return () => subs.delete(handler);[0m
[32m    },[0m
[32m    emit: (evt) => {[0m
[32m      for (const h of subs) h(evt);[0m
[32m    },[0m
[32m    clear: () => subs.clear()[0m
[32m  };[0m
[32m}[0m
[32m[0m
[32mfunction isPlainObject(value: unknown): value is JsonObject {[0m
[32m  return typeof value === "object" && value !== null && !Array.isArray(value);[0m
[32m}[0m
[32m[0m
[32mexport type SettingsManager = {[0m
[32m  initialize: () => Promise<void>;[0m
[32m  dispose: () => void;[0m
[32m  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;[0m
[32m  notifyChange: (source: SettingsSource | null) => Promise<void>;[0m
[32m  getEffective: () => EffectiveSettingsResult;[0m
[32m  getEffectiveConfig: () => EffectiveConfig;[0m
[32m  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;[0m
[32m  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;[0m
[32m  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;[0m
[32m};[0m
[32m[0m
[32mtype InternalWriteKey = string;[0m
[32m[0m
[32mfunction internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {[0m
[32m  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;[0m
[32m}[0m
[32m[0m
[32mexport function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {[0m
[32m  const storage = requireCapability(host, "storage");[0m
[32m  const proc = host.process.kind === "available" ? host.process.value : null;[0m
[32m[0m
[32m  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];[0m
[32m  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);[0m
[32m[0m
[32m  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {};[0m
[32m  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};[0m
[32m  let effective: EffectiveSettingsResult = {[0m
[32m    settings: {},[0m
[32m    errors: [],[0m
[32m    enabledSources,[0m
[32m    perSource,[0m
[32m    policyOrigin: "absent"[0m
[32m  };[0m
[32m  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({[0m
[32m    effectiveSettings: effective.settings,[0m
[32m    policySource: perSource.policySettings,[0m
[32m    policyOrigin: effective.policyOrigin,[0m
[32m    host,[0m
[32m    env: proc ? { ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv?.("ENABLE_EXPERIMENTAL_MCP_CLI") } : {}[0m
[32m  });[0m
[32m[0m
[32m  const bus = createEventBus();[0m
[32m  const internalWrites = new Map<InternalWriteKey, string>();[0m
[32m  const unsubscribers: Array<() => void> = [];[0m
[32m[0m
[32m  async function loadAllFileBackedSources(): Promise<void> {[0m
[32m    enabledSources = computeEnabledFileSettingsSources(allowedSources);[0m
[32m[0m
[32m    const errors: SettingsError[] = [];[0m
[32m    const mergedInputs: JsonObject[] = [];[0m
[32m    let policyOrigin: SettingsPolicyOrigin = "absent";[0m
[32m[0m
[32m    for (const source of enabledSources) {[0m
[32m      const res = await readSettingsSourceFromStorage(storage, source, ctx);[0m
[32m      perSource[source] = res;[0m
[32m      errors.push(...res.errors);[0m
[32m      if (source === "policySettings") {[0m
[32m        if (res.origin) policyOrigin = res.origin;[0m
[32m        if (res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";[0m
[32m      }[0m
[32m      if (res.settings) mergedInputs.push(res.settings);[0m
[32m    }[0m
[32m[0m
[32m    const settings = mergeSettingsObjectsInOrder(mergedInputs);[0m
[32m    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };[0m
[32m    effectiveConfig = computeEffectiveConfig({[0m
[32m      effectiveSettings: settings,[0m
[32m      policySource: perSource.policySettings,[0m
[32m      policyOrigin,[0m
[32m      host,[0m
[32m      env: proc ? { ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv?.("ENABLE_EXPERIMENTAL_MCP_CLI") } : {}[0m
[32m    });[0m
[32m  }[0m
[32m[0m
[32m  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {[0m
[32m    await loadAllFileBackedSources();[0m
[32m    bus.emit({ type: "settings/updated", changedSource, effective });[0m
[32m  }[0m
[32m[0m
[32m  function markInternalWrite(source: SettingsSource, version: string): void {[0m
[32m    const ns = namespaceForSettingsSource(source, ctx);[0m
[32m    const key = settingsStorageKey(source);[0m
[32m    internalWrites.set(internalWriteKey(ns, key), version);[0m
[32m  }[0m
[32m[0m
[32m  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {[0m
[32m    if (event.kind !== "set") return false;[0m
[32m    if (!event.version) return false;[0m
[32m    const k = internalWriteKey(event.namespace as any, event.key);[0m
[32m    const expected = internalWrites.get(k);[0m
[32m    if (!expected) return false;[0m
[32m    if (expected !== event.version) return false;[0m
[32m    internalWrites.delete(k);[0m
[32m    return true;[0m
[32m  }[0m
[32m[0m
[32m  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {[0m
[32m    if (!event.key.startsWith("settings/source/")) return;[0m
[32m    if (shouldSuppressStorageEvent(event)) return;[0m
[32m    const source = event.key.slice("settings/source/".length) as SettingsSource;[0m
[32m    if (!source) return;[0m
[32m    await emitUpdate(source);[0m
[32m  }[0m
[32m[0m
[32m  function subscribeStorage(): void {[0m
[32m    if (!storage.subscribe) return;[0m
[32m    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {[0m
[32m      void handleStorageEvent(e);[0m
[32m    });[0m
[32m    unsubscribers.push(appUnsub);[0m
[32m[0m
[32m    if (ctx.workspaceId) {[0m
[32m      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {[0m
[32m        void handleStorageEvent(e);[0m
[32m      });[0m
[32m      unsubscribers.push(wsUnsub);[0m
[32m    }[0m
[32m[0m
[32m    if (ctx.sessionId) {[0m
[32m      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {[0m
[32m        void handleStorageEvent(e);[0m
[32m      });[0m
[32m      unsubscribers.push(sessUnsub);[0m
[32m    }[0m
[32m  }[0m
[32m[0m
[32m  return {[0m
[32m    initialize: async () => {[0m
[32m      subscribeStorage();[0m
[32m      await emitUpdate(null);[0m
[32m    },[0m
[32m    dispose: () => {[0m
[32m      for (const u of unsubscribers) u();[0m
[32m      unsubscribers.length = 0;[0m
[32m      bus.clear();[0m
[32m    },[0m
[32m    subscribe: (handler) => bus.subscribe(handler),[0m
[32m    notifyChange: async (source) => {[0m
[32m      await emitUpdate(source);[0m
[32m    },[0m
[32m    getEffective: () => effective,[0m
[32m    getEffectiveConfig: () => effectiveConfig,[0m
[32m    setAllowedSources: async (allowed) => {[0m
[32m      allowedSources = allowed;[0m
[32m      await emitUpdate(null);[0m
[32m    },[0m
[32m    setOverlay: async (source, settings) => {[0m
[32m      overlays[source] = settings;[0m
[32m      await emitUpdate(source);[0m
[32m    },[0m
[32m    patchSource: async (source, patch) => {[0m
[32m      const current = await readSettingsSourceFromStorage(storage, source, ctx);[0m
[32m      const currentSettings = current.settings ?? {};[0m
[32m      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};[0m
[32m      const next = applySettingsPatch(parsed, patch);[0m
[32m[0m
[32m      const doc = createSettingsDocumentFromObject(next);[0m
[32m      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });[0m
[32m      if (!res.ok) return { ok: false, errors: [res.error] };[0m
[32m      markInternalWrite(source, res.version);[0m
[32m      await emitUpdate(source);[0m
[32m      return { ok: true };[0m
[32m    }[0m
[32m  };[0m
[32m}[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/sources.ts[0m
[32mimport type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";[0m
[32m[0m
[32mexport const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [[0m
[32m  "userSettings",[0m
[32m  "projectSettings",[0m
[32m  "localSettings",[0m
[32m  "flagSettings",[0m
[32m  "policySettings"[0m
[32m];[0m
[32m[0m
[32mexport const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];[0m
[32m[0m
[32mexport function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {[0m
[32m  if (input === "") return [];[0m
[32m  const parts = input[0m
[32m    .split(",")[0m
[32m    .map((p) => p.trim())[0m
[32m    .filter((p) => p.length > 0);[0m
[32m[0m
[32m  const out: AllowedSettingSource[] = [];[0m
[32m  for (const p of parts) {[0m
[32m    switch (p) {[0m
[32m      case "user":[0m
[32m        out.push("userSettings");[0m
[32m        break;[0m
[32m      case "project":[0m
[32m        out.push("projectSettings");[0m
[32m        break;[0m
[32m      case "local":[0m
[32m        out.push("localSettings");[0m
[32m        break;[0m
[32m      default:[0m
[32m        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);[0m
[32m    }[0m
[32m  }[0m
[32m  return out;[0m
[32m}[0m
[32m[0m
[32mexport function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {[0m
[32m  const set = new Set<FileBackedSettingsSource>(allowed);[0m
[32m  set.add("policySettings");[0m
[32m  set.add("flagSettings");[0m
[32m  return Array.from(set);[0m
[32m}[0m
[32m[0m
[32mexport function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {[0m
[32m  return enabledSources.includes(source);[0m
[32m}[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/patch.ts[0m
[32mimport type { JsonObject, JsonValue } from "../types/json.js";[0m
[32m[0m
[32mexport type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;[0m
[32mexport type SettingsPatchObject = { [key: string]: SettingsPatchValue };[0m
[32m[0m
[32mfunction isPlainObject(value: unknown): value is Record<string, unknown> {[0m
[32m  return typeof value === "object" && value !== null && !Array.isArray(value);[0m
[32m}[0m
[32m[0m
[32mfunction cloneJsonObject(obj: JsonObject): JsonObject {[0m
[32m  const out: JsonObject = {};[0m
[32m  for (const [k, v] of Object.entries(obj)) out[k] = v;[0m
[32m  return out;[0m
[32m}[0m
[32m[0m
[32mexport function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {[0m
[32m  const out = cloneJsonObject(base);[0m
[32m  for (const [key, rawPatchValue] of Object.entries(patch)) {[0m
[32m    const patchValue = rawPatchValue as unknown;[0m
[32m[0m
[32m    if (patchValue === undefined) {[0m
[32m      delete out[key];[0m
[32m      continue;[0m
[32m    }[0m
[32m[0m
[32m    if (Array.isArray(patchValue)) {[0m
[32m      out[key] = patchValue as unknown as JsonValue;[0m
[32m      continue;[0m
[32m    }[0m
[32m[0m
[32m    if (isPlainObject(patchValue)) {[0m
[32m      const baseVal = out[key];[0m
[32m      if (isPlainObject(baseVal)) {[0m
[32m        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);[0m
[32m      } else {[0m
[32m        out[key] = patchValue as unknown as JsonValue;[0m
[32m      }[0m
[32m      continue;[0m
[32m    }[0m
[32m[0m
[32m    out[key] = patchValue as JsonValue;[0m
[32m  }[0m
[32m  return out;[0m
[32m}[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/doctor.ts[0m
[32mimport type { JsonObject } from "../types/json.js";[0m
[32mimport { mergeJsonObject } from "./merge.js";[0m
[32mimport type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";[0m
[32m[0m
[32mexport type SettingsDoctorReport = {[0m
[32m  policyOrigin: SettingsPolicyOrigin;[0m
[32m  hasErrors: boolean;[0m
[32m  errors: SettingsError[];[0m
[32m  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;[0m
[32m  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;[0m
[32m};[0m
[32m[0m
[32mfunction isPlainObject(value: unknown): value is JsonObject {[0m
[32m  return typeof value === "object" && value !== null && !Array.isArray(value);[0m
[32m}[0m
[32m[0m
[32mfunction enumeratePointers(obj: JsonObject, prefix = ""): string[] {[0m
[32m  const out: string[] = [];[0m
[32m  for (const [k, v] of Object.entries(obj)) {[0m
[32m    const pointer = `${prefix}/${k}`;[0m
[32m    out.push(pointer);[0m
[32m    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));[0m
[32m  }[0m
[32m  return out;[0m
[32m}[0m
[32m[0m
[32mfunction getPointerValue(obj: JsonObject, pointer: string): unknown {[0m
[32m  const parts = pointer.split("/").slice(1);[0m
[32m  let cur: unknown = obj;[0m
[32m  for (const part of parts) {[0m
[32m    if (!isPlainObject(cur)) return undefined;[0m
[32m    cur = cur[part];[0m
[32m  }[0m
[32m  return cur;[0m
[32m}[0m
[32m[0m
[32mfunction jsonStableStringify(value: unknown): string {[0m
[32m  return JSON.stringify(value, Object.keys(value as any).sort());[0m
[32m}[0m
[32m[0m
[32mexport function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {[0m
[32m  const errors = effective.errors;[0m
[32m  const perSource: SettingsDoctorReport["perSource"] = [];[0m
[32m  for (const src of Object.values(effective.perSource)) {[0m
[32m    if (!src) continue;[0m
[32m    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";[0m
[32m    perSource.push({ source: src.source, status, errorCount: src.errors.length });[0m
[32m  }[0m
[32m  perSource.sort((a, b) => a.source.localeCompare(b.source));[0m
[32m[0m
[32m  const policy = effective.perSource.policySettings?.settings ?? null;[0m
[32m  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];[0m
[32m  if (policy && effective.policyOrigin !== "invalid") {[0m
[32m    const pointers = enumeratePointers(policy);[0m
[32m    const overriddenByPointer = new Map<string, Set<string>>();[0m
[32m[0m
[32m    for (const pointer of pointers) {[0m
[32m      const policyValue = getPointerValue(policy, pointer);[0m
[32m      if (policyValue === undefined) continue;[0m
[32m      const overriddenSources = new Set<string>();[0m
[32m      for (const [source, src] of Object.entries(effective.perSource)) {[0m
[32m        if (!src?.settings) continue;[0m
[32m        if (source === "policySettings") continue;[0m
[32m        const srcValue = getPointerValue(src.settings, pointer);[0m
[32m        if (srcValue === undefined) continue;[0m
[32m        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);[0m
[32m      }[0m
[32m      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);[0m
[32m    }[0m
[32m[0m
[32m    for (const [pointer, sources] of overriddenByPointer) {[0m
[32m      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });[0m
[32m    }[0m
[32m    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));[0m
[32m  }[0m
[32m[0m
[32m  return {[0m
[32m    policyOrigin: effective.policyOrigin,[0m
[32m    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",[0m
[32m    errors,[0m
[32m    perSource,[0m
[32m    policyOverrides[0m
[32m  };[0m
[32m}[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/index.ts[0m
[32mexport type {[0m
[32m  AllowedSettingSource,[0m
[32m  EffectiveSettingsResult,[0m
[32m  FileBackedSettingsSource,[0m
[32m  SettingsError,[0m
[32m  SettingsPolicyOrigin,[0m
[32m  SettingsSource,[0m
[32m  SettingsSourceReadResult,[0m
[32m  SettingsUpdateEvent,[0m
[32m  WritableSettingsSource[0m
[32m} from "./types.js";[0m
[32mexport { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";[0m
[32mexport { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";[0m
[32mexport { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";[0m
[32mexport { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";[0m
[32mexport { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";[0m
[32mexport {[0m
[32m  SETTINGS_STORAGE_KEY_PREFIX,[0m
[32m  createSettingsDocumentFromObject,[0m
[32m  namespaceForSettingsSource,[0m
[32m  readSettingsSourceFromStorage,[0m
[32m  settingsStorageKey,[0m
[32m  writeSettingsSourceToStorage[0m
[32m} from "./storage.js";[0m
[32mexport { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";[0m
[32mexport { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";[0m
[32mexport { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";[0m
[32mexport { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";[0m
[32mexport { createSettingsManager, type SettingsManager } from "./manager.js";[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/secrets.ts[0m
[32mimport type { HostSecrets } from "../types/host.js";[0m
[32m[0m
[32mexport type SecretRefV1 = { __secretRef: string };[0m
[32m[0m
[32mexport function isSecretRefV1(value: unknown): value is SecretRefV1 {[0m
[32m  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";[0m
[32m}[0m
[32m[0m
[32mexport type SecretResolutionResult =[0m
[32m  | { status: "resolved"; name: string; value: string }[0m
[32m  | { status: "missing"; name: string }[0m
[32m  | { status: "error"; name: string; error: unknown };[0m
[32m[0m
[32mexport async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {[0m
[32m  try {[0m
[32m    const value = await secrets.getSecret(ref.__secretRef);[0m
[32m    if (value === null) return { status: "missing", name: ref.__secretRef };[0m
[32m    return { status: "resolved", name: ref.__secretRef, value };[0m
[32m  } catch (error) {[0m
[32m    return { status: "error", name: ref.__secretRef, error };[0m
[32m  }[0m
[32m}[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/merge.ts[0m
[32mimport type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";[0m
[32m[0m
[32mfunction isPlainObject(value: unknown): value is JsonObject {[0m
[32m  return typeof value === "object" && value !== null && !Array.isArray(value);[0m
[32m}[0m
[32m[0m
[32mfunction isPrimitive(value: JsonValue): value is JsonPrimitive {[0m
[32m  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";[0m
[32m}[0m
[32m[0m
[32mexport function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {[0m
[32m  const out: JsonArray = [...a];[0m
[32m  const seen = new Set<string | number | boolean | null>();[0m
[32m  for (const item of a) {[0m
[32m    if (isPrimitive(item)) seen.add(item);[0m
[32m  }[0m
[32m  for (const item of b) {[0m
[32m    if (isPrimitive(item)) {[0m
[32m      if (seen.has(item)) continue;[0m
[32m      seen.add(item);[0m
[32m      out.push(item);[0m
[32m    } else {[0m
[32m      out.push(item);[0m
[32m    }[0m
[32m  }[0m
[32m  return out;[0m
[32m}[0m
[32m[0m
[32mexport function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {[0m
[32m  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);[0m
[32m  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);[0m
[32m  return next;[0m
[32m}[0m
[32m[0m
[32mexport function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {[0m
[32m  const out: JsonObject = { ...base };[0m
[32m  for (const [key, nextVal] of Object.entries(next)) {[0m
[32m    const baseVal = out[key];[0m
[32m    if (baseVal === undefined) {[0m
[32m      out[key] = nextVal;[0m
[32m      continue;[0m
[32m    }[0m
[32m    out[key] = mergeJsonValue(baseVal, nextVal);[0m
[32m  }[0m
[32m  return out;[0m
[32m}[0m
[32m[0m
[32mexport function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {[0m
[32m  let out: JsonObject = {};[0m
[32m  for (const obj of objects) out = mergeJsonObject(out, obj);[0m
[32m  return out;[0m
[32m}[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/bundle.ts[0m
[32mimport type { HostStorage } from "../types/host.js";[0m
[32mimport type { JsonObject } from "../types/json.js";[0m
[32mimport { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";[0m
[32mimport type { SettingsError, SettingsSource, SettingsStorageContext } from "./types.js";[0m
[32m[0m
[32mexport type ExportedSettingsBundleV1 = {[0m
[32m  schemaVersion: 1;[0m
[32m  exportedAtWallMs: number;[0m
[32m  sources: Partial<Record<SettingsSource, JsonObject>>;[0m
[32m};[0m
[32m[0m
[32mexport async function exportSettingsBundleV1([0m
[32m  storage: HostStorage,[0m
[32m  ctx: SettingsStorageContext,[0m
[32m  sources: readonly SettingsSource[],[0m
[32m  exportedAtWallMs: number[0m
[32m): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {[0m
[32m  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };[0m
[32m  const errors: SettingsError[] = [];[0m
[32m[0m
[32m  for (const source of sources) {[0m
[32m    const res = await readSettingsSourceFromStorage(storage, source, ctx);[0m
[32m    errors.push(...res.errors);[0m
[32m    if (res.settings) out.sources[source] = res.settings;[0m
[32m  }[0m
[32m[0m
[32m  return { bundle: out, errors };[0m
[32m}[0m
[32m[0m
[32mexport async function importSettingsBundleV1([0m
[32m  storage: HostStorage,[0m
[32m  ctx: SettingsStorageContext,[0m
[32m  bundle: ExportedSettingsBundleV1[0m
[32m): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {[0m
[32m  const errors: SettingsError[] = [];[0m
[32m  if (bundle.schemaVersion !== 1) {[0m
[32m    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };[0m
[32m  }[0m
[32m[0m
[32m  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {[0m
[32m    const doc = createSettingsDocumentFromObject(settings);[0m
[32m    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });[0m
[32m    if (!res.ok) errors.push(res.error);[0m
[32m  }[0m
[32m[0m
[32m  if (errors.length > 0) return { ok: false, errors };[0m
[32m  return { ok: true };[0m
[32m}[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/storage.ts[0m
[32mimport type { JsonObject } from "../types/json.js";[0m
[32mimport type { HostStorage, StorageNamespace } from "../types/host.js";[0m
[32mimport { StorageConflictError } from "../types/host.js";[0m
[32mimport type { WorkspaceId } from "../types/workspace.js";[0m
[32mimport { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";[0m
[32mimport type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";[0m
[32m[0m
[32mexport type SettingsStorageContext = {[0m
[32m  workspaceId?: WorkspaceId;[0m
[32m  sessionId?: string;[0m
[32m};[0m
[32m[0m
[32mexport const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";[0m
[32m[0m
[32mexport function settingsStorageKey(source: SettingsSource): string {[0m
[32m  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;[0m
[32m}[0m
[32m[0m
[32mexport function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {[0m
[32m  switch (source) {[0m
[32m    case "userSettings":[0m
[32m    case "policySettings":[0m
[32m      return { scope: "app" };[0m
[32m    case "projectSettings":[0m
[32m    case "localSettings":[0m
[32m      return { scope: "workspace", workspaceId: ctx.workspaceId };[0m
[32m    case "flagSettings":[0m
[32m      return { scope: "session", sessionId: ctx.sessionId };[0m
[32m    case "cliArg":[0m
[32m    case "command":[0m
[32m    case "session":[0m
[32m      return { scope: "session", sessionId: ctx.sessionId };[0m
[32m  }[0m
[32m}[0m
[32m[0m
[32mfunction originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {[0m
[32m  if (source !== "policySettings") return undefined;[0m
[32m  const origin = doc?.meta?.origin;[0m
[32m  if (origin === "remote") return "remote";[0m
[32m  if (origin === "local") return "local";[0m
[32m  return "absent";[0m
[32m}[0m
[32m[0m
[32mexport async function readSettingsSourceFromStorage([0m
[32m  storage: HostStorage,[0m
[32m  source: SettingsSource,[0m
[32m  ctx: SettingsStorageContext[0m
[32m): Promise<SettingsSourceReadResult> {[0m
[32m  const ns = namespaceForSettingsSource(source, ctx);[0m
[32m  const key = settingsStorageKey(source);[0m
[32m[0m
[32m  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {[0m
[32m    return {[0m
[32m      source,[0m
[32m      settings: null,[0m
[32m      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }][0m
[32m    };[0m
[32m  }[0m
[32m[0m
[32m  try {[0m
[32m    const rec = await storage.get(ns, key);[0m
[32m    if (!rec) {[0m
[32m      const doc: SettingsDocumentV1 | null = null;[0m
[32m      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };[0m
[32m    }[0m
[32m[0m
[32m    const parsed = parseSettingsJson(rec.value, source);[0m
[32m    const origin = originFromDoc(parsed.document, source);[0m
[32m    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };[0m
[32m  } catch (cause) {[0m
[32m    return {[0m
[32m      source,[0m
[32m      settings: null,[0m
[32m      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }][0m
[32m    };[0m
[32m  }[0m
[32m}[0m
[32m[0m
[32mexport async function writeSettingsSourceToStorage([0m
[32m  storage: HostStorage,[0m
[32m  source: SettingsSource,[0m
[32m  ctx: SettingsStorageContext,[0m
[32m  doc: SettingsDocumentV1,[0m
[32m  options?: { expectedVersion?: string | null }[0m
[32m): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {[0m
[32m  const ns = namespaceForSettingsSource(source, ctx);[0m
[32m  const key = settingsStorageKey(source);[0m
[32m[0m
[32m  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {[0m
[32m    return {[0m
[32m      ok: false,[0m
[32m      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }[0m
[32m    };[0m
[32m  }[0m
[32m[0m
[32m  try {[0m
[32m    const value = serializeSettingsDocument(doc);[0m
[32m    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });[0m
[32m    return { ok: true, version: res.version };[0m
[32m  } catch (error) {[0m
[32m    if (error instanceof StorageConflictError) {[0m
[32m      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };[0m
[32m    }[0m
[32m    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };[0m
[32m  }[0m
[32m}[0m
[32m[0m
[32mexport function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {[0m
[32m  return {[0m
[32m    kind: "settings_document",[0m
[32m    schemaVersion: 1,[0m
[32m    settings,[0m
[32m    ...(meta ? { meta } : {})[0m
[32m  };[0m
[32m}[0m
[32m[0m
[32mexport function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {[0m
[32m  return ([0m
[32m    source === "userSettings" ||[0m
[32m    source === "projectSettings" ||[0m
[32m    source === "localSettings" ||[0m
[32m    source === "policySettings" ||[0m
[32m    source === "flagSettings"[0m
[32m  );[0m
[32m}[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/types.ts[0m
[32mimport type { JsonObject } from "../types/json.js";[0m
[32m[0m
[32mexport type SettingsSource =[0m
[32m  | "userSettings"[0m
[32m  | "projectSettings"[0m
[32m  | "localSettings"[0m
[32m  | "policySettings"[0m
[32m  | "flagSettings"[0m
[32m  | "cliArg"[0m
[32m  | "command"[0m
[32m  | "session";[0m
[32m[0m
[32mexport type FileBackedSettingsSource = Extract<[0m
[32m  SettingsSource,[0m
[32m  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"[0m
[32m>;[0m
[32m[0m
[32mexport type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;[0m
[32m[0m
[32mexport type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;[0m
[32m[0m
[32mexport type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;[0m
[32m[0m
[32mexport type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";[0m
[32m[0m
[32mexport type SettingsErrorKind =[0m
[32m  | "parse_error"[0m
[32m  | "validation_error"[0m
[32m  | "io_error"[0m
[32m  | "conflict"[0m
[32m  | "capability_missing"[0m
[32m  | "unsupported";[0m
[32m[0m
[32mexport type SettingsError = {[0m
[32m  kind: SettingsErrorKind;[0m
[32m  source: SettingsSource;[0m
[32m  message: string;[0m
[32m  filePath?: string;[0m
[32m  pointer?: string;[0m
[32m  cause?: unknown;[0m
[32m  severity?: "warning" | "error";[0m
[32m};[0m
[32m[0m
[32mexport type SettingsSourceReadResult = {[0m
[32m  source: SettingsSource;[0m
[32m  settings: JsonObject | null;[0m
[32m  errors: SettingsError[];[0m
[32m  origin?: SettingsPolicyOrigin;[0m
[32m  storageVersion?: string | null;[0m
[32m};[0m
[32m[0m
[32mexport type EffectiveSettingsResult = {[0m
[32m  settings: JsonObject;[0m
[32m  errors: SettingsError[];[0m
[32m  enabledSources: FileBackedSettingsSource[];[0m
[32m  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;[0m
[32m  policyOrigin: SettingsPolicyOrigin;[0m
[32m};[0m
[32m[0m
[32mexport type SettingsUpdateEvent = {[0m
[32m  type: "settings/updated";[0m
[32m  changedSource: SettingsSource | null;[0m
[32m  effective: EffectiveSettingsResult;[0m
[32m};[0m
[32m[0m
[32mexport type SettingsUnsubscribe = () => void;[0m
[32m[0m
[32mexport type SettingsEventBus = {[0m
[32m  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;[0m
[32m  emit: (evt: SettingsUpdateEvent) => void;[0m
[32m  clear: () => void;[0m
[32m};[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/legacyPaths.ts[0m
[32mimport type { HostFilesystem, HostProcess } from "../types/host.js";[0m
[32mimport type { FileBackedSettingsSource } from "./types.js";[0m
[32m[0m
[32mexport type LegacySettingsPathContext = {[0m
[32m  process?: HostProcess;[0m
[32m  filesystem?: HostFilesystem;[0m
[32m  configDir?: string;[0m
[32m  projectRoot?: string;[0m
[32m  flagSettingsPath?: string | null;[0m
[32m};[0m
[32m[0m
[32mexport function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {[0m
[32m  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");[0m
[32m  if (viaEnv) return viaEnv;[0m
[32m  return null;[0m
[32m}[0m
[32m[0m
[32mexport async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {[0m
[32m  const platform = ctx.process?.platform?.() ?? "unknown";[0m
[32m  if (platform === "win32") {[0m
[32m    return "C:\\\\ProgramData\\\\ClaudeCode";[0m
[32m  }[0m
[32m  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";[0m
[32m  return "/etc/claude-code";[0m
[32m}[0m
[32m[0m
[32mexport function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {[0m
[32m  switch (source) {[0m
[32m    case "userSettings":[0m
[32m      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);[0m
[32m    case "projectSettings":[0m
[32m    case "localSettings":[0m
[32m      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;[0m
[32m    case "policySettings":[0m
[32m      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;[0m
[32m    case "flagSettings": {[0m
[32m      const flagPath = ctx.flagSettingsPath ?? null;[0m
[32m      if (flagPath) {[0m
[32m        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators[0m
[32m        return idx >= 0 ? flagPath.slice(0, idx) : ".";[0m
[32m      }[0m
[32m      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;[0m
[32m    }[0m
[32m  }[0m
[32m}[0m
[32m[0m
[32mexport async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {[0m
[32m  const base = resolveLegacySettingsBaseDir(source, ctx);[0m
[32m  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;[0m
[32m  if (!base) return null;[0m
[32m[0m
[32m  switch (source) {[0m
[32m    case "userSettings":[0m
[32m      return `${base}/settings.json`;[0m
[32m    case "projectSettings":[0m
[32m      return `${base}/.claude/settings.json`;[0m
[32m    case "localSettings":[0m
[32m      return `${base}/.claude/settings.local.json`;[0m
[32m    case "policySettings": {[0m
[32m      const sys = await resolveLegacyPolicySystemDir(ctx);[0m
[32m      return `${sys}/managed-settings.json`;[0m
[32m    }[0m
[32m    case "flagSettings":[0m
[32m      return ctx.flagSettingsPath ?? null;[0m
[32m  }[0m
[32m}[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/schema.ts[0m
[32mimport type { JsonObject } from "../types/json.js";[0m
[32mimport { SCHEMA_VERSION } from "../types/schema.js";[0m
[32mimport type { SettingsError, SettingsSource } from "./types.js";[0m
[32m[0m
[32mexport const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";[0m
[32m[0m
[32mexport type SettingsDocumentV1 = {[0m
[32m  kind: "settings_document";[0m
[32m  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;[0m
[32m  settings: JsonObject;[0m
[32m  meta?: {[0m
[32m    schemaUrl?: string;[0m
[32m    origin?: "local" | "remote";[0m
[32m    updatedAtWallMs?: number;[0m
[32m  };[0m
[32m};[0m
[32m[0m
[32mexport type ParsedSettingsDocument = {[0m
[32m  document: SettingsDocumentV1 | null;[0m
[32m  errors: SettingsError[];[0m
[32m  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";[0m
[32m};[0m
[32m[0m
[32mfunction isPlainObject(value: unknown): value is Record<string, unknown> {[0m
[32m  return typeof value === "object" && value !== null && !Array.isArray(value);[0m
[32m}[0m
[32m[0m
[32mexport function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {[0m
[32m  const trimmed = raw.trim();[0m
[32m  if (trimmed === "") {[0m
[32m    return {[0m
[32m      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },[0m
[32m      errors: [],[0m
[32m      format: "empty"[0m
[32m    };[0m
[32m  }[0m
[32m[0m
[32m  let parsed: unknown;[0m
[32m  try {[0m
[32m    parsed = JSON.parse(trimmed);[0m
[32m  } catch (cause) {[0m
[32m    return {[0m
[32m      document: null,[0m
[32m      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],[0m
[32m      format: "invalid"[0m
[32m    };[0m
[32m  }[0m
[32m[0m
[32m  if (!isPlainObject(parsed)) {[0m
[32m    return {[0m
[32m      document: null,[0m
[32m      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],[0m
[32m      format: "invalid"[0m
[32m    };[0m
[32m  }[0m
[32m[0m
[32m  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {[0m
[32m    const settings = (parsed as Record<string, unknown>).settings;[0m
[32m    if (!isPlainObject(settings)) {[0m
[32m      return {[0m
[32m        document: null,[0m
[32m        errors: [[0m
[32m          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }[0m
[32m        ],[0m
[32m        format: "invalid"[0m
[32m      };[0m
[32m    }[0m
[32m    const meta = (parsed as Record<string, unknown>).meta;[0m
[32m    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;[0m
[32m    return {[0m
[32m      document: {[0m
[32m        kind: "settings_document",[0m
[32m        schemaVersion: SCHEMA_VERSION.settingsDocument,[0m
[32m        settings: settings as JsonObject,[0m
[32m        ...(normalizedMeta ? { meta: normalizedMeta } : {})[0m
[32m      },[0m
[32m      errors: [],[0m
[32m      format: "envelope_v1"[0m
[32m    };[0m
[32m  }[0m
[32m[0m
[32m  return {[0m
[32m    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },[0m
[32m    errors: [],[0m
[32m    format: "legacy_object"[0m
[32m  };[0m
[32m}[0m
[32m[0m
[32mexport function serializeSettingsDocument(doc: SettingsDocumentV1): string {[0m
[32m  return `${JSON.stringify(doc, null, 2)}\n`;[0m
[32m}[0m
[32m[0m
[32mapply_patch(auto_approved=true) exited 0 in 128ms:[0m
[2mSuccess. Updated the following files:[0m
[2mA src/core/settings/types.ts[0m
[2mA src/core/settings/schema.ts[0m
[2mA src/core/settings/sources.ts[0m
[2mA src/core/settings/merge.ts[0m
[2mA src/core/settings/patch.ts[0m
[2mA src/core/settings/secrets.ts[0m
[2mA src/core/settings/storage.ts[0m
[2mA src/core/settings/legacyPaths.ts[0m
[2mA src/core/settings/doctor.ts[0m
[2mA src/core/settings/effectiveConfig.ts[0m
[2mA src/core/settings/bundle.ts[0m
[2mA src/core/settings/manager.ts[0m
[2mA src/core/settings/index.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0163ae382b0ebe6c7b68d95514e5d2671ae35ae
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource, SettingsStorageContext } from "./types.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
+
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..97826598a01ebcbf6a2b19bdbbea3b215f49d4cc
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,85 @@
+import type { JsonObject } from "../types/json.js";
+import { mergeJsonObject } from "./merge.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  return JSON.stringify(value, Object.keys(value as any).sort());
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
+
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6ce33ebf954d4501c0275330afcf96490f2b4eb6
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,215 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { parseSettingsJson } from "./schema.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources, type } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {};
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: proc ? { ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv?.("ENABLE_EXPERIMENTAL_MCP_CLI") } : {}
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: proc ? { ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv?.("ENABLE_EXPERIMENTAL_MCP_CLI") } : {}
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    internalWrites.set(internalWriteKey(ns, key), version);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    if (!event.version) return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) return { ok: false, errors: [res.error] };
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
+
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2399fe1bd916f10495dd81409c6050d08ecabca9
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  const origin = doc?.meta?.origin;
+  if (origin === "remote") return "remote";
+  if (origin === "local") return "local";
+  return "absent";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: 1,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
+
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0163ae382b0ebe6c7b68d95514e5d2671ae35ae
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource, SettingsStorageContext } from "./types.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
+
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..97826598a01ebcbf6a2b19bdbbea3b215f49d4cc
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,85 @@
+import type { JsonObject } from "../types/json.js";
+import { mergeJsonObject } from "./merge.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  return JSON.stringify(value, Object.keys(value as any).sort());
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
+
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6ce33ebf954d4501c0275330afcf96490f2b4eb6
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,215 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { parseSettingsJson } from "./schema.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources, type } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {};
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: proc ? { ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv?.("ENABLE_EXPERIMENTAL_MCP_CLI") } : {}
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: proc ? { ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv?.("ENABLE_EXPERIMENTAL_MCP_CLI") } : {}
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    internalWrites.set(internalWriteKey(ns, key), version);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    if (!event.version) return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) return { ok: false, errors: [res.error] };
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
+
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2399fe1bd916f10495dd81409c6050d08ecabca9
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  const origin = doc?.meta?.origin;
+  if (origin === "remote") return "remote";
+  if (origin === "local") return "local";
+  return "absent";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: 1,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
+
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/settings/manager.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 46ms:[0m
[2mimport type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
import { requireCapability } from "../types/host.js";
import type { JsonObject } from "../types/json.js";
import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
import { parseSettingsJson } from "./schema.js";
import { mergeSettingsObjectsInOrder } from "./merge.js";
import { computeEnabledFileSettingsSources, type } from "./sources.js";
import type {
  AllowedSettingSource,
  EffectiveSettingsResult,
  FileBackedSettingsSource,
  SettingsError,
  SettingsEventBus,
  SettingsPolicyOrigin,
  SettingsSource,
  SettingsSourceReadResult,
  SettingsUpdateEvent,
  SettingsUnsubscribe,
  WritableSettingsSource
} from "./types.js";[0m


[35m[3mthinking[0m[0m
**Updating imports and settings**

I‚Äôm recognizing that the `HostStorage` and `parseSettingsJson` imports are unused, and there‚Äôs an issue with the line regarding `computeEnabledFileSettingsSources`. Here‚Äôs the plan: first, I‚Äôll remove the unused imports. Next, I‚Äôll fix the import statement to use just `computeEnabled`. 

I'll incorporate overlays into `effective.perSource` while ensuring they don‚Äôt interfere with merged settings. Additionally, I need to set up the environment object with relevant variables for computing MCP gates, so I‚Äôll implement a helper function called `getEnvSnapshot()`. Let‚Äôs get to it!
[35m[3mthinking[0m[0m
**Fixing policy origin detection**

I‚Äôm realizing that for invalid policy origin detection, we should only set a record as invalid if it exists but is invalid. I‚Äôll check if `current.storageVersion` isn't null. In the `readSettingsSourceFromStorage`, if the record exists but parsing fails, I can set both `errors` and `storageVersion`. 

So invalid status can stem from `res.storageVersion` being not null, along with `res.errors` having length greater than zero and `res.settings` being null. I‚Äôll compute `policyOrigin` based on that. Also, I need to be careful with the internal write key function and ensure the version is present when needed. Let‚Äôs implement this patch!
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0163ae382b0ebe6c7b68d95514e5d2671ae35ae
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource, SettingsStorageContext } from "./types.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
+
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..97826598a01ebcbf6a2b19bdbbea3b215f49d4cc
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,85 @@
+import type { JsonObject } from "../types/json.js";
+import { mergeJsonObject } from "./merge.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  return JSON.stringify(value, Object.keys(value as any).sort());
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
+
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6ce33ebf954d4501c0275330afcf96490f2b4eb6
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,215 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { parseSettingsJson } from "./schema.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources, type } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {};
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: proc ? { ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv?.("ENABLE_EXPERIMENTAL_MCP_CLI") } : {}
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: proc ? { ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv?.("ENABLE_EXPERIMENTAL_MCP_CLI") } : {}
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    internalWrites.set(internalWriteKey(ns, key), version);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    if (!event.version) return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) return { ok: false, errors: [res.error] };
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
+
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2399fe1bd916f10495dd81409c6050d08ecabca9
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  const origin = doc?.meta?.origin;
+  if (origin === "remote") return "remote";
+  if (origin === "local") return "local";
+  return "absent";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: 1,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
+
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/manager.ts[0m
@@ -1,2 +1,2 @@
[31m-import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";[0m
[32m+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";[0m
 import { requireCapability } from "../types/host.js";
@@ -4,5 +4,4 @@
 import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
[31m-import { parseSettingsJson } from "./schema.js";[0m
 import { mergeSettingsObjectsInOrder } from "./merge.js";
[31m-import { computeEnabledFileSettingsSources, type } from "./sources.js";[0m
[32m+import { computeEnabledFileSettingsSources } from "./sources.js";[0m
 import type {
@@ -73,3 +72,7 @@
 
[31m-  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {};[0m
[32m+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {[0m
[32m+    cliArg: null,[0m
[32m+    command: null,[0m
[32m+    session: null[0m
[32m+  };[0m
   const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
@@ -82,2 +85,12 @@
   };
[32m+  function envSnapshot(): Record<string, string | undefined> {[0m
[32m+    if (!proc?.getEnv) return {};[0m
[32m+    return {[0m
[32m+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),[0m
[32m+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),[0m
[32m+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),[0m
[32m+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")[0m
[32m+    };[0m
[32m+  }[0m
[32m+[0m
   let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
@@ -87,3 +100,3 @@
     host,
[31m-    env: proc ? { ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv?.("ENABLE_EXPERIMENTAL_MCP_CLI") } : {}[0m
[32m+    env: envSnapshot()[0m
   });
@@ -107,3 +120,3 @@
         if (res.origin) policyOrigin = res.origin;
[31m-        if (res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";[0m
[32m+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";[0m
       }
@@ -112,2 +125,6 @@
 
[32m+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {[0m
[32m+      perSource[source] = { source, settings, errors: [] };[0m
[32m+    }[0m
[32m+[0m
     const settings = mergeSettingsObjectsInOrder(mergedInputs);
@@ -119,3 +136,3 @@
       host,
[31m-      env: proc ? { ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv?.("ENABLE_EXPERIMENTAL_MCP_CLI") } : {}[0m
[32m+      env: envSnapshot()[0m
     });
@@ -214,2 +231 @@
 }
[31m-[0m
[32mapply_patch(auto_approved=true) exited 0 in 85ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/settings/manager.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0163ae382b0ebe6c7b68d95514e5d2671ae35ae
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource, SettingsStorageContext } from "./types.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
+
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..97826598a01ebcbf6a2b19bdbbea3b215f49d4cc
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,85 @@
+import type { JsonObject } from "../types/json.js";
+import { mergeJsonObject } from "./merge.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  return JSON.stringify(value, Object.keys(value as any).sort());
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
+
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fb36a6129bbd5cb4a720692ccd0c81612f46a0a8
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,231 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    internalWrites.set(internalWriteKey(ns, key), version);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    if (!event.version) return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) return { ok: false, errors: [res.error] };
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2399fe1bd916f10495dd81409c6050d08ecabca9
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  const origin = doc?.meta?.origin;
+  if (origin === "remote") return "remote";
+  if (origin === "local") return "local";
+  return "absent";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: 1,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
+
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0163ae382b0ebe6c7b68d95514e5d2671ae35ae
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource, SettingsStorageContext } from "./types.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
+
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..97826598a01ebcbf6a2b19bdbbea3b215f49d4cc
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,85 @@
+import type { JsonObject } from "../types/json.js";
+import { mergeJsonObject } from "./merge.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  return JSON.stringify(value, Object.keys(value as any).sort());
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
+
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fb36a6129bbd5cb4a720692ccd0c81612f46a0a8
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,231 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    internalWrites.set(internalWriteKey(ns, key), version);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    if (!event.version) return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) return { ok: false, errors: [res.error] };
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2399fe1bd916f10495dd81409c6050d08ecabca9
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  const origin = doc?.meta?.origin;
+  if (origin === "remote") return "remote";
+  if (origin === "local") return "local";
+  return "absent";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: 1,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
+
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/manager.ts[0m
@@ -105,2 +105,3 @@
   const internalWrites = new Map<InternalWriteKey, string>();
[32m+  const internalPending = new Set<InternalWriteKey>();[0m
   const unsubscribers: Array<() => void> = [];
@@ -148,3 +149,5 @@
     const key = settingsStorageKey(source);
[31m-    internalWrites.set(internalWriteKey(ns, key), version);[0m
[32m+    const k = internalWriteKey(ns, key);[0m
[32m+    internalWrites.set(k, version);[0m
[32m+    internalPending.delete(k);[0m
   }
@@ -153,4 +156,8 @@
     if (event.kind !== "set") return false;
[31m-    if (!event.version) return false;[0m
     const k = internalWriteKey(event.namespace as any, event.key);
[32m+    if (internalPending.has(k)) {[0m
[32m+      internalPending.delete(k);[0m
[32m+      return true;[0m
[32m+    }[0m
[32m+    if (!event.version) return false;[0m
     const expected = internalWrites.get(k);
@@ -222,5 +229,11 @@
 
[32m+      const ns = namespaceForSettingsSource(source, ctx);[0m
[32m+      const k = internalWriteKey(ns, settingsStorageKey(source));[0m
[32m+      internalPending.add(k);[0m
       const doc = createSettingsDocumentFromObject(next);
       const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
[31m-      if (!res.ok) return { ok: false, errors: [res.error] };[0m
[32m+      if (!res.ok) {[0m
[32m+        internalPending.delete(k);[0m
[32m+        return { ok: false, errors: [res.error] };[0m
[32m+      }[0m
       markInternalWrite(source, res.version);
[32mapply_patch(auto_approved=true) exited 0 in 84ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/settings/manager.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0163ae382b0ebe6c7b68d95514e5d2671ae35ae
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource, SettingsStorageContext } from "./types.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
+
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..97826598a01ebcbf6a2b19bdbbea3b215f49d4cc
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,85 @@
+import type { JsonObject } from "../types/json.js";
+import { mergeJsonObject } from "./merge.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  return JSON.stringify(value, Object.keys(value as any).sort());
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
+
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3d416bdc522cf7787926ce5e9c99721ba59b5845
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,244 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2399fe1bd916f10495dd81409c6050d08ecabca9
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  const origin = doc?.meta?.origin;
+  if (origin === "remote") return "remote";
+  if (origin === "local") return "local";
+  return "absent";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: 1,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
+
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0163ae382b0ebe6c7b68d95514e5d2671ae35ae
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource, SettingsStorageContext } from "./types.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
+
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..97826598a01ebcbf6a2b19bdbbea3b215f49d4cc
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,85 @@
+import type { JsonObject } from "../types/json.js";
+import { mergeJsonObject } from "./merge.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  return JSON.stringify(value, Object.keys(value as any).sort());
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
+
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3d416bdc522cf7787926ce5e9c99721ba59b5845
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,244 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2399fe1bd916f10495dd81409c6050d08ecabca9
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  const origin = doc?.meta?.origin;
+  if (origin === "remote") return "remote";
+  if (origin === "local") return "local";
+  return "absent";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: 1,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
+
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,120p' src/core/settings/bundle.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 47ms:[0m
[2mimport type { HostStorage } from "../types/host.js";
import type { JsonObject } from "../types/json.js";
import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
import type { SettingsError, SettingsSource, SettingsStorageContext } from "./types.js";

export type ExportedSettingsBundleV1 = {
  schemaVersion: 1;
  exportedAtWallMs: number;
  sources: Partial<Record<SettingsSource, JsonObject>>;
};

export async function exportSettingsBundleV1(
  storage: HostStorage,
  ctx: SettingsStorageContext,
  sources: readonly SettingsSource[],
  exportedAtWallMs: number
): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
  const errors: SettingsError[] = [];
[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0163ae382b0ebe6c7b68d95514e5d2671ae35ae
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource, SettingsStorageContext } from "./types.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
+
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..97826598a01ebcbf6a2b19bdbbea3b215f49d4cc
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,85 @@
+import type { JsonObject } from "../types/json.js";
+import { mergeJsonObject } from "./merge.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  return JSON.stringify(value, Object.keys(value as any).sort());
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
+
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3d416bdc522cf7787926ce5e9c99721ba59b5845
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,244 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2399fe1bd916f10495dd81409c6050d08ecabca9
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  const origin = doc?.meta?.origin;
+  if (origin === "remote") return "remote";
+  if (origin === "local") return "local";
+  return "absent";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: 1,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
+
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'head -n 30 src/core/settings/schema.ts'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 43ms:[0m
[2mimport type { JsonObject } from "../types/json.js";
import { SCHEMA_VERSION } from "../types/schema.js";
import type { SettingsError, SettingsSource } from "./types.js";

export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";

export type SettingsDocumentV1 = {
  kind: "settings_document";
  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
  settings: JsonObject;
  meta?: {
    schemaUrl?: string;
    origin?: "local" | "remote";
    updatedAtWallMs?: number;
  };
};

export type ParsedSettingsDocument = {
  document: SettingsDocumentV1 | null;
  errors: SettingsError[];[0m




[35m[3mthinking[0m[0m
**Updating code for consistency**

I've realized constant exists, and in index.ts, I exported `LEGACY_SETTINGS_SCHEMA_URL`, which seems consistent with my intentions. However, I used `schemaVersion: 1` directly in `createSettingsDocumentFromObject`. I think I'll replace that with `SCHEMA_VERSION` for consistency. Also, there are some unused functions in effectiveConfig.ts and doctor.ts that I should remove, especially `readString` and `mergeJsonObject`. Oh, and I need to fix `jsonStableStringify` since it's incorrectly handling arrays and non-objects. A stable stringify implementation should be safe!
[35m[3mthinking[0m[0m
**Implementing a safe method**

I need to implement a safe method and patch files like doctor.ts and effectiveConfig.ts, while keeping changes minimal. The legacyPaths might use string concatenation with "/" which isn't ideal for Windows, yet it seems fine for now. In storage.ts, I'll update the `createSettingsDocumentFromObject` to use `SCHEMA_VERSION.settingsDocument` instead of 1. Additionally, the `originFromDoc` function currently returns "absent" if the doc meta origin is missing. I think I should treat documents without meta as "local" when they exist. My adjusted logic will be: null doc is absent, remote meta indicates remote, otherwise local.
[35m[3mthinking[0m[0m
**Implementing error handling**

I need to ensure that if there's an invalid parse and the document is null with non-empty errors, while the storage version isn‚Äôt null, the manager should set it to invalid. I also want to make sure that `readSettingsSourceFromStorage` returns null settings and an empty errors array for a missing key. However, if there's an empty settings document (`{}`), `parseSettingsJson` should still return a valid document, resulting in a local origin. In legacy, a remote policy object exists only for non-empty cases. I should consider treating missing settings as empty objects for consistency.
[35m[3mthinking[0m[0m
**Fixing storage options**

Right now, the `writeSettingsSourceToStorage` function sets `expectedVersion` to undefined when passed as maybe. If it stays undefined, it skips the check, which isn't ideal since `HostStorage.set` expects options. I‚Äôll need to ensure we only pass the options object when it‚Äôs provided. 

In `importSettingsBundleV1`, if `expectedVersion` is undefined, it may lead to passing `{expectedVersion: undefined}`. I see that in `createSettingsManager`, we aren't persisting allowed sources, so I should implement these modifications and patch files like bundle.ts and doctor.ts.
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0163ae382b0ebe6c7b68d95514e5d2671ae35ae
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource, SettingsStorageContext } from "./types.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
+
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..97826598a01ebcbf6a2b19bdbbea3b215f49d4cc
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,85 @@
+import type { JsonObject } from "../types/json.js";
+import { mergeJsonObject } from "./merge.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  return JSON.stringify(value, Object.keys(value as any).sort());
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
+
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3d416bdc522cf7787926ce5e9c99721ba59b5845
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,244 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2399fe1bd916f10495dd81409c6050d08ecabca9
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  const origin = doc?.meta?.origin;
+  if (origin === "remote") return "remote";
+  if (origin === "local") return "local";
+  return "absent";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: 1,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
+
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/bundle.ts[0m
@@ -3,3 +3,4 @@
 import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
[31m-import type { SettingsError, SettingsSource, SettingsStorageContext } from "./types.js";[0m
[32m+import type { SettingsError, SettingsSource } from "./types.js";[0m
[32m+import type { SettingsStorageContext } from "./storage.js";[0m
 
@@ -48,2 +49 @@
 }
[31m-[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/doctor.ts[0m
@@ -1,3 +1,2 @@
 import type { JsonObject } from "../types/json.js";
[31m-import { mergeJsonObject } from "./merge.js";[0m
 import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
@@ -37,3 +36,9 @@
 function jsonStableStringify(value: unknown): string {
[31m-  return JSON.stringify(value, Object.keys(value as any).sort());[0m
[32m+  if (value === null || typeof value !== "object") return JSON.stringify(value);[0m
[32m+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));[0m
[32m+  const obj = value as Record<string, unknown>;[0m
[32m+  const keys = Object.keys(obj).sort();[0m
[32m+  const normalized: Record<string, unknown> = {};[0m
[32m+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));[0m
[32m+  return JSON.stringify(normalized);[0m
 }
@@ -84,2 +89 @@
 }
[31m-[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/storage.ts[0m
@@ -5,2 +5,3 @@
 import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
[32m+import { SCHEMA_VERSION } from "../types/schema.js";[0m
 import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
@@ -37,6 +38,6 @@
   if (source !== "policySettings") return undefined;
[31m-  const origin = doc?.meta?.origin;[0m
[32m+  if (!doc) return "absent";[0m
[32m+  const origin = doc.meta?.origin;[0m
   if (origin === "remote") return "remote";
[31m-  if (origin === "local") return "local";[0m
[31m-  return "absent";[0m
[32m+  return "local";[0m
 }
@@ -110,3 +111,3 @@
     kind: "settings_document",
[31m-    schemaVersion: 1,[0m
[32m+    schemaVersion: SCHEMA_VERSION.settingsDocument,[0m
     settings,
@@ -125,2 +126 @@
 }
[31m-[0m
[32mapply_patch(auto_approved=true) exited 0 in 83ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/settings/bundle.ts[0m
[2mM src/core/settings/storage.ts[0m
[2mM src/core/settings/doctor.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3d416bdc522cf7787926ce5e9c99721ba59b5845
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,244 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3d416bdc522cf7787926ce5e9c99721ba59b5845
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,244 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'cat tsconfig.json'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 64ms:[0m
[2m{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "lib": ["ES2022", "DOM"],
    "strict": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true,
    "isolatedModules": true,
    "verbatimModuleSyntax": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*.ts"]
}
[0m




[35m[3mthinking[0m[0m
**Analyzing TypeScript Configurations**

I‚Äôm looking at the TypeScript configurations. Right now, tsconfig doesn‚Äôt set `noUnusedLocals`, but it sounds like `strict` might affect that. Unused variables aren‚Äôt causing failures at the moment. The `isolatedModules` setting means type-only imports might not work, which is concerning since we rely on many. 

I need to ensure that everything in `index.ts` compiles correctly and check for errors in other files. I also want to add tests after confirming the compilation of new modules, focusing on in-memory storage and the necessary changes for Node host subscription.
[35m[3mthinking[0m[0m
**Implementing Watchers in Node**

The plan outlines the need to implement watchers for each host, and while we haven't done it yet, we can set up `storage.subscribe` easily in `platform/node/host.ts` using `fs.watch`. I‚Äôm wondering if it's essential for the tests, but to meet the plan for 6.3 watchers, we should create a watch mechanism for Node.

In `createNodeStorage`, I could add a subscription that uses `fs.watch` to monitor namespace directories, emitting a `StorageChangeEvent` when changes occur. The version could be computed from the JSON file, and it's important to ensure that we rely on versions instead of timestamps in our core implementation.
[35m[3mthinking[0m[0m
**Setting Up fs.watch**

In implementing `fs.watch`, I realize that it's not recursive, which is acceptable since our keys are located in the created namespace directories. However, I need to ensure it can handle cases where the initial directory is missing; otherwise, the watcher will throw an error. So, I‚Äôll make sure to create the directory if it doesn't exist.

I also need to suppress any events related to files starting with `.tmp-`, as Node storage performs atomic writes using temporary files. This way, we can focus solely on the proper JSON files for processing. Additionally, while `fs.watch` emits rename events, I‚Äôll check for file existence during these events and be prepared for potential double triggers, which is fine.
[35m[3mthinking[0m[0m
**Implementing Watchers in Node Storage**

I can emit events for setting values, and I'm realizing this requires using Node's `fs`. Now it's time to modify the `platform/node/host.ts` for watchers in Node storage, which is allowed in phase six. I'll also adjust the `StorageChangeEvent` to make the version optional.

In `createNodeStorage`, I need to add a subscription feature. For this, I‚Äôll import `watch` from `node:fs` instead of using the promises version. I‚Äôll make sure to update the imports accordingly, and then I‚Äôll implement the subscribe method within the return object of `createNodeStorage`. We‚Äôll also handle write suppression semantics without relying on timestamps from the filesystem, providing versioning management throughout. Let's go ahead and apply this patch!
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3d416bdc522cf7787926ce5e9c99721ba59b5845
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,244 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/platform/node/host.ts[0m
@@ -17,2 +17,3 @@
 import { execFile as execFileCb } from "node:child_process";
[32m+import { watch as watchFs } from "node:fs";[0m
 import fs from "node:fs/promises";
@@ -313,2 +314,50 @@
       }
[32m+    },[0m
[32m+    subscribe: (ns, handler) => {[0m
[32m+      const parts = namespaceToPathParts(ns);[0m
[32m+      const dir = path.join(rootDir, ...parts);[0m
[32m+      let closed = false;[0m
[32m+      let watcher: ReturnType<typeof watchFs> | null = null;[0m
[32m+[0m
[32m+      const start = async () => {[0m
[32m+        try {[0m
[32m+          await fs.mkdir(dir, { recursive: true });[0m
[32m+        } catch {[0m
[32m+          // ignore[0m
[32m+        }[0m
[32m+        if (closed) return;[0m
[32m+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {[0m
[32m+          if (closed) return;[0m
[32m+          const name = typeof filename === "string" ? filename : filename?.toString?.();[0m
[32m+          if (!name) return;[0m
[32m+          if (!name.endsWith(".json")) return;[0m
[32m+          if (name.startsWith(".tmp-")) return;[0m
[32m+          const base = name.slice(0, -".json".length);[0m
[32m+          const decoded = decodeStorageSegment(base);[0m
[32m+          if (decoded === null) return;[0m
[32m+          const filePath = path.join(dir, name);[0m
[32m+          try {[0m
[32m+            const raw = await fs.readFile(filePath, { encoding: "utf8" });[0m
[32m+            const parsed = JSON.parse(raw) as StoredFile;[0m
[32m+            if (!parsed || typeof parsed.version !== "string") return;[0m
[32m+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });[0m
[32m+          } catch (error) {[0m
[32m+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {[0m
[32m+              handler({ namespace: ns, key: decoded, kind: "delete" });[0m
[32m+              return;[0m
[32m+            }[0m
[32m+          }[0m
[32m+        });[0m
[32m+      };[0m
[32m+[0m
[32m+      void start();[0m
[32m+      return () => {[0m
[32m+        closed = true;[0m
[32m+        try {[0m
[32m+          watcher?.close();[0m
[32m+        } catch {[0m
[32m+          // ignore[0m
[32m+        }[0m
[32m+        watcher = null;[0m
[32m+      };[0m
     }
[32mapply_patch(auto_approved=true) exited 0 in 93ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/platform/node/host.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3d416bdc522cf7787926ce5e9c99721ba59b5845
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,244 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }

[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3d416bdc522cf7787926ce5e9c99721ba59b5845
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,244 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,120p' src/core/types/workspace.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 51ms:[0m
[2mexport type WorkspaceId = string & { readonly __brand: "WorkspaceId" };

export type WorkspaceKind = "path" | "remote" | "profile";

export type WorkspaceTrust = {
  trusted: boolean;
  grantedAtMs?: number;
  revokedAtMs?: number;
  reason?: string;
};

export type WorkspaceDescriptor = {
  id: WorkspaceId;
  kind: WorkspaceKind;
  displayName: string;
  trust?: WorkspaceTrust;
  path?: string;
  repo?: { url: string; branch?: string };
};
[0m

[35m[3mthinking[0m[0m
**Creating test files**

Alright, I realize I also need to import `requireCapability` from core/types/host.js since it's important for the tests. It wasn‚Äôt mentioned before, but I saw that the tests have this import. Now, I should focus on creating the test file. Let‚Äôs get this written down clearly and make it effective for testing. I‚Äôll proceed with drafting the test file now!
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3d416bdc522cf7787926ce5e9c99721ba59b5845
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,244 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }

[3m[35mfile update[0m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/tests/phase6-settings.test.ts[0m
[32mimport { describe, expect, test } from "bun:test";[0m
[32mimport crypto from "node:crypto";[0m
[32mimport {[0m
[32m  StorageConflictError,[0m
[32m  availableCapability,[0m
[32m  unavailableCapability,[0m
[32m  type HostCapabilities,[0m
[32m  type HostStorage,[0m
[32m  type StorageNamespace[0m
[32m} from "../src/core/types/host.js";[0m
[32mimport { asWorkspaceId } from "../src/core/types/workspace.js";[0m
[32mimport {[0m
[32m  applySettingsPatch,[0m
[32m  computeEnabledFileSettingsSources,[0m
[32m  computeEffectiveConfig,[0m
[32m  createSettingsDocumentFromObject,[0m
[32m  createSettingsManager,[0m
[32m  exportSettingsBundleV1,[0m
[32m  importSettingsBundleV1,[0m
[32m  parseEnabledSettingSourcesFlag,[0m
[32m  readSettingsSourceFromStorage,[0m
[32m  writeSettingsSourceToStorage[0m
[32m} from "../src/core/settings/index.js";[0m
[32m[0m
[32mfunction nsKey(ns: StorageNamespace): string {[0m
[32m  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;[0m
[32m}[0m
[32m[0m
[32mfunction computeVersion(value: string): string {[0m
[32m  return crypto.createHash("sha256").update(value, "utf8").digest("hex");[0m
[32m}[0m
[32m[0m
[32mfunction createInMemoryStorage(): HostStorage {[0m
[32m  const data = new Map<string, { value: string; version: string }>();[0m
[32m  const subs = new Map<string, Set<(e: any) => void>>();[0m
[32m[0m
[32m  function emit(ns: StorageNamespace, event: any): void {[0m
[32m    const k = nsKey(ns);[0m
[32m    const set = subs.get(k);[0m
[32m    if (!set) return;[0m
[32m    for (const h of set) h(event);[0m
[32m  }[0m
[32m[0m
[32m  return {[0m
[32m    get: async (ns, key) => {[0m
[32m      const rec = data.get(`${nsKey(ns)}:${key}`);[0m
[32m      if (!rec) return null;[0m
[32m      return { value: rec.value, version: rec.version };[0m
[32m    },[0m
[32m    set: async (ns, key, value, options) => {[0m
[32m      const full = `${nsKey(ns)}:${key}`;[0m
[32m      const existing = data.get(full) ?? null;[0m
[32m      const expected = options?.expectedVersion;[0m
[32m      if (expected !== undefined) {[0m
[32m        const actual = existing?.version ?? null;[0m
[32m        if (expected === null) {[0m
[32m          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });[0m
[32m        } else if (existing === null || existing.version !== expected) {[0m
[32m          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });[0m
[32m        }[0m
[32m      }[0m
[32m      const version = computeVersion(value);[0m
[32m      data.set(full, { value, version });[0m
[32m      emit(ns, { namespace: ns, key, kind: "set", version });[0m
[32m      return { version };[0m
[32m    },[0m
[32m    delete: async (ns, key, options) => {[0m
[32m      const full = `${nsKey(ns)}:${key}`;[0m
[32m      const existing = data.get(full) ?? null;[0m
[32m      const expected = options?.expectedVersion;[0m
[32m      if (expected !== undefined) {[0m
[32m        const actual = existing?.version ?? null;[0m
[32m        if (expected === null) {[0m
[32m          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });[0m
[32m        } else if (existing === null || existing.version !== expected) {[0m
[32m          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });[0m
[32m        }[0m
[32m      }[0m
[32m      data.delete(full);[0m
[32m      emit(ns, { namespace: ns, key, kind: "delete" });[0m
[32m    },[0m
[32m    subscribe: (ns, handler) => {[0m
[32m      const k = nsKey(ns);[0m
[32m      const set = subs.get(k) ?? new Set();[0m
[32m      set.add(handler);[0m
[32m      subs.set(k, set);[0m
[32m      return () => {[0m
[32m        const cur = subs.get(k);[0m
[32m        cur?.delete(handler);[0m
[32m        if (cur && cur.size === 0) subs.delete(k);[0m
[32m      };[0m
[32m    }[0m
[32m  };[0m
[32m}[0m
[32m[0m
[32mfunction createHostWithStorage(storage: HostStorage): HostCapabilities {[0m
[32m  return {[0m
[32m    clock: unavailableCapability({ kind: "not-provided" }),[0m
[32m    random: unavailableCapability({ kind: "not-provided" }),[0m
[32m    crypto: unavailableCapability({ kind: "not-provided" }),[0m
[32m    secrets: unavailableCapability({ kind: "not-provided" }),[0m
[32m    storage: availableCapability(storage),[0m
[32m    filesystem: unavailableCapability({ kind: "not-provided" }),[0m
[32m    network: unavailableCapability({ kind: "not-provided" }),[0m
[32m    lifecycle: unavailableCapability({ kind: "not-provided" }),[0m
[32m    background: unavailableCapability({ kind: "not-provided" }),[0m
[32m    fileTransfer: unavailableCapability({ kind: "not-provided" }),[0m
[32m    shell: unavailableCapability({ kind: "not-provided" }),[0m
[32m    localEndpoint: unavailableCapability({ kind: "not-provided" }),[0m
[32m    ipc: unavailableCapability({ kind: "not-provided" }),[0m
[32m    process: unavailableCapability({ kind: "not-provided" }),[0m
[32m    clipboard: unavailableCapability({ kind: "not-provided" }),[0m
[32m    notifications: unavailableCapability({ kind: "not-provided" }),[0m
[32m    haptics: unavailableCapability({ kind: "not-provided" })[0m
[32m  };[0m
[32m}[0m
[32m[0m
[32mdescribe("Phase 6: settings system", () => {[0m
[32m  test("enabled sources flag parser matches legacy", () => {[0m
[32m    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);[0m
[32m    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);[0m
[32m    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);[0m
[32m    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();[0m
[32m  });[0m
[32m[0m
[32m  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {[0m
[32m    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);[0m
[32m    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([[0m
[32m      "projectSettings",[0m
[32m      "userSettings",[0m
[32m      "policySettings",[0m
[32m      "flagSettings"[0m
[32m    ]);[0m
[32m  });[0m
[32m[0m
[32m  test("patch semantics: delete on undefined + arrays replace", () => {[0m
[32m    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };[0m
[32m    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });[0m
[32m    expect((next.nested as any).keep).toBe(true);[0m
[32m    expect((next.nested as any).drop).toBeUndefined();[0m
[32m    expect((next.nested as any).arr).toEqual([2]);[0m
[32m  });[0m
[32m[0m
[32m  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {[0m
[32m    const storage = createInMemoryStorage();[0m
[32m    const host = createHostWithStorage(storage);[0m
[32m    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };[0m
[32m[0m
[32m    await writeSettingsSourceToStorage([0m
[32m      storage,[0m
[32m      "userSettings",[0m
[32m      ctx,[0m
[32m      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),[0m
[32m      { expectedVersion: null }[0m
[32m    );[0m
[32m    await writeSettingsSourceToStorage([0m
[32m      storage,[0m
[32m      "policySettings",[0m
[32m      ctx,[0m
[32m      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),[0m
[32m      { expectedVersion: null }[0m
[32m    );[0m
[32m    await writeSettingsSourceToStorage([0m
[32m      storage,[0m
[32m      "flagSettings",[0m
[32m      ctx,[0m
[32m      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),[0m
[32m      { expectedVersion: null }[0m
[32m    );[0m
[32m[0m
[32m    const mgr = createSettingsManager(host, ctx);[0m
[32m    let updates = 0;[0m
[32m    const unsub = mgr.subscribe(() => {[0m
[32m      updates += 1;[0m
[32m    });[0m
[32m    await mgr.initialize();[0m
[32m[0m
[32m    const effective = mgr.getEffective();[0m
[32m    expect(effective.settings.disableAllHooks).toBe(true);[0m
[32m    expect(effective.settings.arr).toEqual([1, 2, 3]);[0m
[32m[0m
[32m    const cfg = mgr.getEffectiveConfig();[0m
[32m    expect(cfg.hooks.disabled).toBe(true);[0m
[32m    expect(cfg.hooks.managedOnly).toBe(true);[0m
[32m[0m
[32m    const before = updates;[0m
[32m    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });[0m
[32m    expect(patchRes.ok).toBe(true);[0m
[32m[0m
[32m    expect(updates - before).toBe(1);[0m
[32m    unsub();[0m
[32m    mgr.dispose();[0m
[32m  });[0m
[32m[0m
[32m  test("export/import bundle captures per-source settings objects", async () => {[0m
[32m    const storage = createInMemoryStorage();[0m
[32m    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };[0m
[32m    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });[0m
[32m    await writeSettingsSourceToStorage([0m
[32m      storage,[0m
[32m      "policySettings",[0m
[32m      ctx,[0m
[32m      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),[0m
[32m      { expectedVersion: null }[0m
[32m    );[0m
[32m[0m
[32m    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());[0m
[32m    expect(errors.length).toBe(0);[0m
[32m    expect(bundle.sources.userSettings).toEqual({ a: 1 });[0m
[32m    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });[0m
[32m[0m
[32m    const storage2 = createInMemoryStorage();[0m
[32m    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);[0m
[32m    expect(importRes.ok).toBe(true);[0m
[32m    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);[0m
[32m    expect(r1.settings).toEqual({ a: 1 });[0m
[32m  });[0m
[32m});[0m
[32m[0m
[32mapply_patch(auto_approved=true) exited 0 in 150ms:[0m
[2mSuccess. Updated the following files:[0m
[2mA tests/phase6-settings.test.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3d416bdc522cf7787926ce5e9c99721ba59b5845
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,244 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3d416bdc522cf7787926ce5e9c99721ba59b5845
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,244 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/manager.ts[0m
@@ -150,2 +150,8 @@
     const k = internalWriteKey(ns, key);
[32m+    const existing = internalWrites.get(k);[0m
[32m+    if (existing === version) {[0m
[32m+      internalWrites.delete(k);[0m
[32m+      internalPending.delete(k);[0m
[32m+      return;[0m
[32m+    }[0m
     internalWrites.set(k, version);
@@ -158,2 +164,3 @@
     if (internalPending.has(k)) {
[32m+      if (event.version) internalWrites.set(k, event.version);[0m
       internalPending.delete(k);
[32mapply_patch(auto_approved=true) exited 0 in 109ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/settings/manager.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+




[35m[3mthinking[0m[0m
**Reviewing TypeScript issues**

I'm noticing that the Node storage set uses `opts?.expectedVersion ?? undefined`, which means no check will occur since expected remains undefined‚Äîgood to know! Also, there's an error with `importSettingsBundleV1` regarding userSettings. Now, I need to see if there are TypeScript errors in core related to `exactOptionalPropertyTypes`. I'll run `bun test` and later `bun run typecheck` to check the compilation. I see some potential issues with stability in objects and how they stringify, which may lead to compile errors.
[35m[3mthinking[0m[0m
**Reviewing settings error handling**

In `readSettingsSourceFromStorage`, I return errors with a `severity`, which is good since the `SettingsError` severity is optional but limited to "warning" or "error." It seems we're using "error" appropriately. However, the error object in `bundle.ts` for unsupported versions is missing the severity, even though it's optional. I'll also clean up any remaining issues, like the unused `readString` in `effectiveConfig.ts`. Before running tests, I need to confirm the plan is updated since we're still in step 3, which now includes module implementations. I'll mark step 3 as completed once everything's finished.
[35m[3mthinking[0m[0m
**Finalizing testing process**

I noticed that while we've already added tests, it's useful to treat implementing modules as including tests too. We'll keep step 3 active until the code compiles successfully. Even so, I might want to mark step 4 as in progress soon since I've added tests, though they may need adjustments. I'll run `bun test` now to verify‚Äîit's important for validations in step 5, even though the plan says to do this in step 4. So, I'll run the tests and fix any errors that arise!
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'bun test'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 4.50s:[0m
[2mbun test v1.3.4 (5eb2145b)

tests/phase6-settings.test.ts:
(pass) Phase 6: settings system > enabled sources flag parser matches legacy [0.19ms]
(pass) Phase 6: settings system > enabled file sources always include policy+flag (and preserve legacy order) [0.11ms]
(pass) Phase 6: settings system > patch semantics: delete on undefined + arrays replace [0.13ms]
(pass) Phase 6: settings system > storage-backed settings manager merges enabled sources and suppresses self-triggered watch events [1.62ms]
(pass) Phase 6: settings system > export/import bundle captures per-source settings objects [0.27ms]

tests/phase3-event-bus.test.ts:
(pass) Phase 3: event bus semantics > emits monotonic seq per channel and supports cursors [2.09ms]
(pass) Phase 3: event bus semantics > recording helper captures envelopes and can be stopped [0.24ms]
(pass) Phase 3: event bus semantics > includeSnapshot yields a snapshot envelope before live events [0.05ms]
(pass) Phase 3: event bus semantics > coalescing policy can replace queued events deterministically [0.20ms]

tests/phase4-leak-prevention.test.ts:
(pass) Phase 4: capability leak prevention heuristics > no module-level HostCapabilities singletons in portable src/core [10.52ms]

tests/phase3-replay-adapters.test.ts:
(pass) Phase 3: replay/adapter conformance > event streams roundtrip through web/node/RN adapter shapes [3.68ms][0m

[35m[3mthinking[0m[0m
**Updating project steps**

Great, it looks like the tests have all passed! Now I need to update the plan: it seems step 3, which involves implementing modules, is mostly complete. Step 4 tests are also done, but step 5 is where validations remain. Although we‚Äôve already run part of it with the bun test, the validation step needs bun run type check and a legacy CLI command check. I think I can mark step 3 and step 4 as completed and set step 5 to in progress.
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[35mPlan update[0m
  [32m‚úì[0m Read Phase 6 requirements
  [32m‚úì[0m Inspect bundled CLI behavior
  [32m‚úì[0m Implement Phase 6 modules
  [32m‚úì[0m Add Phase 6 tests
  [36m‚Üí[0m Run required validations
  [2m‚Ä¢[0m [2mUpdate plan checklist and changelog[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'bun run check:boundaries'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 255ms:[0m
[2m$ node scripts/check-import-boundaries.mjs
Import boundary check passed.[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'bun run typecheck'[0m in /Users/ronaldeddings/ClaudeCodeTS[31m exited 2 in 898ms:[0m
[2m$ tsc -p tsconfig.json --noEmit
src/core/settings/bundle.ts(43,79): error TS2379: Argument of type '{ expectedVersion: undefined; }' is not assignable to parameter of type '{ expectedVersion?: string | null; }' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties.
  Types of property 'expectedVersion' are incompatible.
    Type 'undefined' is not assignable to type 'string | null'.
src/core/settings/legacyPaths.ts(63,10): error TS2678: Type '"flagSettings"' is not comparable to type '"userSettings" | "projectSettings" | "localSettings" | "policySettings"'.
src/core/settings/manager.ts(117,55): error TS2345: Argument of type 'unknown' is not assignable to parameter of type 'HostStorage'.
src/core/settings/manager.ts(186,10): error TS18046: 'storage' is of type 'unknown'.
src/core/settings/manager.ts(187,22): error TS18046: 'storage' is of type 'unknown'.
src/core/settings/manager.ts(187,59): error TS7006: Parameter 'e' implicitly has an 'any' type.
src/core/settings/manager.ts(193,23): error TS18046: 'storage' is of type 'unknown'.
src/core/settings/manager.ts(193,96): error TS7006: Parameter 'e' implicitly has an 'any' type.
src/core/settings/manager.ts(200,25): error TS18046: 'storage' is of type 'unknown'.
src/core/settings/manager.ts(200,92): error TS7006: Parameter 'e' implicitly has an 'any' type.
src/core/settings/manager.ts(232,59): error TS2345: Argument of type 'unknown' is not assignable to parameter of type 'HostStorage'.
src/core/settings/manager.ts(241,54): error TS2345: Argument of type 'unknown' is not assignable to parameter of type 'HostStorage'.
src/core/settings/storage.ts(27,7): error TS2375: Type '{ scope: "workspace"; workspaceId: WorkspaceId | undefined; }' is not assignable to type 'StorageNamespace' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties.
  Types of property 'workspaceId' are incompatible.
    Type 'WorkspaceId | undefined' is not assignable to type 'WorkspaceId'.
      Type 'undefined' is not assignable to type 'WorkspaceId'.
        Type 'undefined' is not assignable to type 'string'.[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"export function requireCapability\" -n src/core/types/host.ts && sed -n '1,80p' src/core/types/host.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 61ms:[0m
[2m266:export function requireCapability<K extends keyof HostCapabilities>(
import type { HostEvent } from "./events.js";
import type { WorkspaceId } from "./workspace.js";

export type CapabilityUnavailableReason =
  | { kind: "not-provided"; message?: string }
  | { kind: "unsupported"; message?: string }
  | { kind: "disabled"; message?: string }
  | { kind: "policy-denied"; message?: string; policyId?: string };

export type Capability<T> =
  | { kind: "available"; value: T }
  | { kind: "unavailable"; reason: CapabilityUnavailableReason };

export function availableCapability<T>(value: T): Capability<T> {
  return { kind: "available", value };
}

export function unavailableCapability(reason: CapabilityUnavailableReason): Capability<never> {
  return { kind: "unavailable", reason };[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '250,310p' src/core/types/host.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 42ms:[0m
[2m    super(message);
    if (key !== undefined) this.key = key;
  }
}

export class StorageTransientFailureError extends Error {
  readonly name = "StorageTransientFailureError";
  readonly code = "transient_failure";
  readonly key?: string;

  constructor(message = "Transient storage failure", key?: string) {
    super(message);
    if (key !== undefined) this.key = key;
  }
}

export function requireCapability<K extends keyof HostCapabilities>(
  host: HostCapabilities,
  key: K
): CapabilityValue<HostCapabilities[K]> {[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "nl -ba src/core/settings/manager.ts | sed -n '100,150p'"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 47ms:[0m
[2m   100	    host,
   101	    env: envSnapshot()
   102	  });
   103	
   104	  const bus = createEventBus();
   105	  const internalWrites = new Map<InternalWriteKey, string>();
   106	  const internalPending = new Set<InternalWriteKey>();
   107	  const unsubscribers: Array<() => void> = [];
   108	
   109	  async function loadAllFileBackedSources(): Promise<void> {
   110	    enabledSources = computeEnabledFileSettingsSources(allowedSources);
   111	
   112	    const errors: SettingsError[] = [];
   113	    const mergedInputs: JsonObject[] = [];
   114	    let policyOrigin: SettingsPolicyOrigin = "absent";
   115	
   116	    for (const source of enabledSources) {
   117	      const res = await readSettingsSourceFromStorage(storage, source, ctx);
   118	      perSource[source] = res;
   119	      errors.push(...res.errors);[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "nl -ba src/core/settings/manager.ts | sed -n '60,105p'"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 39ms:[0m
[2m    60	type InternalWriteKey = string;
    61	
    62	function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
    63	  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
    64	}
    65	
    66	export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
    67	  const storage = requireCapability(host, "storage");
    68	  const proc = host.process.kind === "available" ? host.process.value : null;
    69	
    70	  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
    71	  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
    72	
    73	  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
    74	    cliArg: null,
    75	    command: null,
    76	    session: null
    77	  };
    78	  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
    79	  let effective: EffectiveSettingsResult = {[0m

[35m[3mthinking[0m[0m
It looks like I'm checking the structure of the `src/index.ts` file, where it exports everything from `./spec/index.js` and `./core/index.js`. I'm wondering what the `core/settings` exports, particularly the `computeLegacyMcpCliGateSnapshot`. I'll also need to take a look at what exactly is exported from `spec/index.js`. It‚Äôll be helpful to inspect `src/index.ts` more closely to clarify this!
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'cat src/index.ts'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 43ms:[0m
[2mexport * from "./spec/index.js";
export * from "./core/index.js";[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'cat src/spec/index.ts'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 40ms:[0m
[2mexport * from "./legacy/index.js";
export * from "./portability.js";
export * from "./security.js";
[0m

[35m[3mthinking[0m[0m
**Resolving code conflicts**

I see there‚Äôs a conflict in `src/index.ts`. To fix it, I'll rename a function in the core or consider not exporting the spec. I think renaming is the clearer choice. 

Next, I notice there are errors with bundling and storage related to specific optional types. I should tackle those too. First step is to address the issues in `storage.ts` before I proceed with the necessary patches. Let's get to it!
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00b0fd1561801d3959a3ec63e63d135e4522d955
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,126 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return { scope: "workspace", workspaceId: ctx.workspaceId };
+    case "flagSettings":
+      return { scope: "session", sessionId: ctx.sessionId };
+    case "cliArg":
+    case "command":
+    case "session":
+      return { scope: "session", sessionId: ctx.sessionId };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/storage.ts[0m
@@ -26,5 +26,5 @@
     case "localSettings":
[31m-      return { scope: "workspace", workspaceId: ctx.workspaceId };[0m
[32m+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };[0m
     case "flagSettings":
[31m-      return { scope: "session", sessionId: ctx.sessionId };[0m
[32m+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };[0m
     case "cliArg":
@@ -32,3 +32,3 @@
     case "session":
[31m-      return { scope: "session", sessionId: ctx.sessionId };[0m
[32m+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };[0m
   }
@@ -64,3 +64,10 @@
       const doc: SettingsDocumentV1 | null = null;
[31m-      return { source, settings: null, errors: [], origin: originFromDoc(doc, source), storageVersion: null };[0m
[32m+      const origin = originFromDoc(doc, source);[0m
[32m+      return {[0m
[32m+        source,[0m
[32m+        settings: null,[0m
[32m+        errors: [],[0m
[32m+        ...(origin ? { origin } : {}),[0m
[32m+        storageVersion: null[0m
[32m+      };[0m
     }
@@ -69,3 +76,9 @@
     const origin = originFromDoc(parsed.document, source);
[31m-    return { source, settings: parsed.document?.settings ?? null, errors: parsed.errors, origin, storageVersion: rec.version };[0m
[32m+    return {[0m
[32m+      source,[0m
[32m+      settings: parsed.document?.settings ?? null,[0m
[32m+      errors: parsed.errors,[0m
[32m+      ...(origin ? { origin } : {}),[0m
[32m+      storageVersion: rec.version[0m
[32m+    };[0m
   } catch (cause) {
@@ -98,3 +111,8 @@
     const value = serializeSettingsDocument(doc);
[31m-    const res = await storage.set(ns, key, value, { expectedVersion: options?.expectedVersion });[0m
[32m+    const res = await storage.set([0m
[32m+      ns,[0m
[32m+      key,[0m
[32m+      value,[0m
[32m+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }[0m
[32m+    );[0m
     return { ok: true, version: res.version };
[32mapply_patch(auto_approved=true) exited 0 in 91ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/settings/storage.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cdbbb293f8566f46f88213c7bf6ca62876deba53
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/bundle.ts[0m
@@ -42,3 +42,3 @@
     const doc = createSettingsDocumentFromObject(settings);
[31m-    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: undefined });[0m
[32m+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);[0m
     if (!res.ok) errors.push(res.error);
[32mapply_patch(auto_approved=true) exited 0 in 127ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/settings/bundle.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+


[35m[3mthinking[0m[0m
**Fixing legacy paths**

I need to address the unreachable flagSettings case in legacyPaths.ts. It seems like a clear fix, so I‚Äôll work on patching that up. I want to ensure that everything is functioning smoothly after I make these changes. It's important to keep the codebase clean and efficient. I'll check my edits thoroughly to confirm that they resolve the issue without creating new problems. Time to dive in and get this sorted!
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3a7c3ffcef9ab5d5c762281ef0497812337dd57
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,67 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+    case "flagSettings":
+      return ctx.flagSettingsPath ?? null;
+  }
+}
+
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/legacyPaths.ts[0m
@@ -62,6 +62,3 @@
     }
[31m-    case "flagSettings":[0m
[31m-      return ctx.flagSettingsPath ?? null;[0m
   }
 }
[31m-[0m
[32mapply_patch(auto_approved=true) exited 0 in 116ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/settings/legacyPaths.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'bun run typecheck'[0m in /Users/ronaldeddings/ClaudeCodeTS[31m exited 2 in 1.05s:[0m
[2m$ tsc -p tsconfig.json --noEmit
src/core/settings/manager.ts(117,55): error TS2345: Argument of type 'unknown' is not assignable to parameter of type 'HostStorage'.
src/core/settings/manager.ts(186,10): error TS18046: 'storage' is of type 'unknown'.
src/core/settings/manager.ts(187,22): error TS18046: 'storage' is of type 'unknown'.
src/core/settings/manager.ts(187,59): error TS7006: Parameter 'e' implicitly has an 'any' type.
src/core/settings/manager.ts(193,23): error TS18046: 'storage' is of type 'unknown'.
src/core/settings/manager.ts(193,96): error TS7006: Parameter 'e' implicitly has an 'any' type.
src/core/settings/manager.ts(200,25): error TS18046: 'storage' is of type 'unknown'.
src/core/settings/manager.ts(200,92): error TS7006: Parameter 'e' implicitly has an 'any' type.
src/core/settings/manager.ts(232,59): error TS2345: Argument of type 'unknown' is not assignable to parameter of type 'HostStorage'.
src/core/settings/manager.ts(241,54): error TS2345: Argument of type 'unknown' is not assignable to parameter of type 'HostStorage'.
src/index.ts(2,1): error TS2308: Module "./spec/index.js" has already exported a member named 'computeLegacyMcpCliGateSnapshot'. Consider explicitly re-exporting to resolve the ambiguity.
src/platform/node/host.ts(331,76): error TS2339: Property 'toString' does not exist on type 'never'.[0m

[35m[3mthinking[0m[0m
**Fixing code issues**

I'm planning to cast and also fix the implicit 'any' in the subscription handler by specifying the event type as `(e: StorageChangeEvent) =>`. I think I need to patch the manager by importing the `HostStorage` type and setting up `const storage: HostStorage = requireCapability(host, "storage");`. In the `createSettingsManager`, I'll be calling `storage.subscribe`, but it's helpful that storage is now typed. Okay, time to patch everything correctly!
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6015714f258422b877fa99b4166dcb2014a2c413
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/manager.ts[0m
@@ -1,2 +1,2 @@
[31m-import type { HostCapabilities, StorageChangeEvent } from "../types/host.js";[0m
[32m+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";[0m
 import { requireCapability } from "../types/host.js";
@@ -66,3 +66,3 @@
 export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
[31m-  const storage = requireCapability(host, "storage");[0m
[32m+  const storage: HostStorage = requireCapability(host, "storage");[0m
   const proc = host.process.kind === "available" ? host.process.value : null;
@@ -186,3 +186,3 @@
     if (!storage.subscribe) return;
[31m-    const appUnsub = storage.subscribe({ scope: "app" }, (e) => {[0m
[32m+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {[0m
       void handleStorageEvent(e);
@@ -192,3 +192,3 @@
     if (ctx.workspaceId) {
[31m-      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e) => {[0m
[32m+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {[0m
         void handleStorageEvent(e);
@@ -199,3 +199,3 @@
     if (ctx.sessionId) {
[31m-      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e) => {[0m
[32m+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {[0m
         void handleStorageEvent(e);
[32mapply_patch(auto_approved=true) exited 0 in 88ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/settings/manager.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..471871cbef8066bd40e1d6b6bb00bdc894a1eeb3
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage: HostStorage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..471871cbef8066bd40e1d6b6bb00bdc894a1eeb3
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage: HostStorage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "computeLegacyMcpCliGateSnapshot" src/core/settings -S'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 61ms:[0m
[2msrc/core/settings/index.ts:27:export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
src/core/settings/effectiveConfig.ts:56:export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
src/core/settings/effectiveConfig.ts:80:  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});[0m

[35m[3mthinking[0m[0m
**Patching for conflicts**

I‚Äôm thinking about how to patch this. There's a possibility of leaving the old name, but I shouldn't export from the core index to avoid conflicts. The issue arises because both src/spec/index and src/core/index export the same name. This happens because src/index.ts re-exports both. If core/settings exports computeLegacy..., then we have a conflict. So, I guess it‚Äôs best to rename to resolve this issue. Let‚Äôs go ahead and patch it!
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22a8ff2a95dca29b5c2a02308a0e45f44efe4391
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,97 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
+
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..280ac93dfed9f792b64eb61fd24b414c8d53dcbe
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,30 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
 
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..471871cbef8066bd40e1d6b6bb00bdc894a1eeb3
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage: HostStorage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/effectiveConfig.ts[0m
@@ -55,3 +55,3 @@
 
[31m-export function computeLegacyMcpCliGateSnapshot(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {[0m
[32m+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {[0m
   const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
@@ -79,3 +79,3 @@
 
[31m-  const mcpCli = computeLegacyMcpCliGateSnapshot(options.env ?? {});[0m
[32m+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});[0m
 
@@ -96,2 +96 @@
 }
[31m-[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/index.ts[0m
@@ -26,5 +26,4 @@
 export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
[31m-export { computeEffectiveConfig, computeLegacyMcpCliGateSnapshot, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";[0m
[32m+export { computeEffectiveConfig, computeMcpCliGateSnapshotFromEnv, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";[0m
 export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
 export { createSettingsManager, type SettingsManager } from "./manager.js";
[31m-[0m
[32mapply_patch(auto_approved=true) exited 0 in 95ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/settings/effectiveConfig.ts[0m
[2mM src/core/settings/index.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..364281efac6dd1c79c0bbb552aa770cd2c9116ef
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,96 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..b674188fd627d7aa6fae074d02335cbbf64241a4
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,29 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeMcpCliGateSnapshotFromEnv, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..471871cbef8066bd40e1d6b6bb00bdc894a1eeb3
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage: HostStorage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+


[35m[3mthinking[0m[0m
**Fixing export conflict**

Okay, it seems like the export conflict should be resolved now. I‚Äôll check the specs to ensure it uses the computeLegacyMcpCliGateSnapshot correctly. Next, I need to address the error in node/host.ts where toString never gets called. I‚Äôll look at the relevant lines in the code, particularly around lines 320 to 340, to figure out how to patch this with a watcher callback. I just need to make sure everything gets done properly!
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..364281efac6dd1c79c0bbb552aa770cd2c9116ef
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,96 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..b674188fd627d7aa6fae074d02335cbbf64241a4
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,29 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeMcpCliGateSnapshotFromEnv, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..471871cbef8066bd40e1d6b6bb00bdc894a1eeb3
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage: HostStorage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "nl -ba src/platform/node/host.ts | sed -n '300,360p'"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 42ms:[0m
[2m   300	        for (const entry of entries) {
   301	          if (!entry.isFile()) continue;
   302	          if (!entry.name.endsWith(".json")) continue;
   303	          const base = entry.name.slice(0, -".json".length);
   304	          const decoded = decodeStorageSegment(base);
   305	          if (decoded === null) continue;
   306	          if (listOpts?.prefix && !decoded.startsWith(listOpts.prefix)) continue;
   307	          keys.push(decoded);
   308	        }
   309	        keys.sort();
   310	        return keys;
   311	      } catch (error) {
   312	        if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
   313	        throw error;
   314	      }
   315	    },
   316	    subscribe: (ns, handler) => {
   317	      const parts = namespaceToPathParts(ns);
   318	      const dir = path.join(rootDir, ...parts);
   319	      let closed = false;[0m

[35m[3mthinking[0m[0m
**Fixing TypeScript error**

I see the issue: TypeScript is complaining that `toString` doesn't exist on `never`. To address this, I plan to change it to `const name = filename ? filename.toString() : "";`. However, I notice that the `filename` parameter in the watch callback could be a `string` or `Buffer`. So instead, I‚Äôm implementing it without optional chaining and will just directly convert using that conditional statement. Time to patch it up!
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..364281efac6dd1c79c0bbb552aa770cd2c9116ef
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,96 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..b674188fd627d7aa6fae074d02335cbbf64241a4
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,29 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeMcpCliGateSnapshotFromEnv, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..471871cbef8066bd40e1d6b6bb00bdc894a1eeb3
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage: HostStorage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..9f01a7cc7f95e204a1b09b77268f175b2c5cb2d8
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = typeof filename === "string" ? filename : filename?.toString?.();
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/platform/node/host.ts[0m
@@ -330,3 +330,3 @@
           if (closed) return;
[31m-          const name = typeof filename === "string" ? filename : filename?.toString?.();[0m
[32m+          const name = filename ? filename.toString() : "";[0m
           if (!name) return;
[32mapply_patch(auto_approved=true) exited 0 in 99ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/platform/node/host.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..364281efac6dd1c79c0bbb552aa770cd2c9116ef
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,96 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..b674188fd627d7aa6fae074d02335cbbf64241a4
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,29 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeMcpCliGateSnapshotFromEnv, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..471871cbef8066bd40e1d6b6bb00bdc894a1eeb3
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage: HostStorage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..364281efac6dd1c79c0bbb552aa770cd2c9116ef
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,96 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..b674188fd627d7aa6fae074d02335cbbf64241a4
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,29 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeMcpCliGateSnapshotFromEnv, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..471871cbef8066bd40e1d6b6bb00bdc894a1eeb3
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage: HostStorage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'bun run typecheck'[0m in /Users/ronaldeddings/ClaudeCodeTS
[31m exited 2 in 980ms:[0m
[2m$ tsc -p tsconfig.json --noEmit
src/core/settings/manager.ts(67,9): error TS2322: Type 'unknown' is not assignable to type 'HostStorage'.[0m


[35m[3mthinking[0m[0m
**Addressing TypeScript Casting Issues**

I'm working through a TypeScript issue where I'm trying to cast `requireCapability(host, "storage")` as `HostStorage` since it keeps returning unknown. It seems this explicit casting is necessary, although it's odd and possibly linked to TypeScript's handling of conditional evaluations within imported types. Regardless, my priority for Phase 6 is ensuring it compiles correctly. I'll proceed with the explicit cast while also keeping in mind the underlying inference issue.
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..364281efac6dd1c79c0bbb552aa770cd2c9116ef
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,96 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..b674188fd627d7aa6fae074d02335cbbf64241a4
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,29 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeMcpCliGateSnapshotFromEnv, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..471871cbef8066bd40e1d6b6bb00bdc894a1eeb3
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage: HostStorage = requireCapability(host, "storage");
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/manager.ts[0m
@@ -66,3 +66,3 @@
 export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
[31m-  const storage: HostStorage = requireCapability(host, "storage");[0m
[32m+  const storage = requireCapability(host, "storage") as HostStorage;[0m
   const proc = host.process.kind === "available" ? host.process.value : null;
[32mapply_patch(auto_approved=true) exited 0 in 133ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/settings/manager.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..364281efac6dd1c79c0bbb552aa770cd2c9116ef
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,96 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..b674188fd627d7aa6fae074d02335cbbf64241a4
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,29 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeMcpCliGateSnapshotFromEnv, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..364281efac6dd1c79c0bbb552aa770cd2c9116ef
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,96 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..b674188fd627d7aa6fae074d02335cbbf64241a4
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,29 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeMcpCliGateSnapshotFromEnv, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'bun run typecheck'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 1.19s:[0m
[2m$ tsc -p tsconfig.json --noEmit[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..364281efac6dd1c79c0bbb552aa770cd2c9116ef
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,96 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..b674188fd627d7aa6fae074d02335cbbf64241a4
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,29 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeMcpCliGateSnapshotFromEnv, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'claude --dangerously-skip-permissions -p sayhello'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 10.29s:[0m
[2mHello! How can I help you today with your software engineering tasks?[0m

[35m[3mthinking[0m[0m
**Updating authentication process**

Great, I‚Äôm satisfied with the authentication requirement being met through the keychain secret. It‚Äôs interesting that they mentioned if I can run it and it works, then the credentials are fine, but my code needs improvement. That seems to imply our rewrite doesn't need a login, which is good. Now I'll update plan step 5 and mark validations as completed while progressing to step 6 to update the checklist and changelog.
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..364281efac6dd1c79c0bbb552aa770cd2c9116ef
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,96 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..b674188fd627d7aa6fae074d02335cbbf64241a4
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,29 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeMcpCliGateSnapshotFromEnv, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[35mPlan update[0m
  [32m‚úì[0m Read Phase 6 requirements
  [32m‚úì[0m Inspect bundled CLI behavior
  [32m‚úì[0m Implement Phase 6 modules
  [32m‚úì[0m Add Phase 6 tests
  [32m‚úì[0m Run required validations
  [36m‚Üí[0m Update plan checklist and changelog
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..364281efac6dd1c79c0bbb552aa770cd2c9116ef
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,96 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..b674188fd627d7aa6fae074d02335cbbf64241a4
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,29 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeMcpCliGateSnapshotFromEnv, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "python - <<'PY'
import re
path='implementation/1-initial-rewrite-implementation-checklist.md'
text=open(path,'r',encoding='utf-8').read().splitlines()
start=None
end=None
for i,l in enumerate(text):
    if '***Phase 6:' in l:
        start=i
    if start is not None and i>start and l.strip()=='---':
        end=i
        break
print('start',start+1,'end',end+1)
for j in range(start, min(end, start+120)):
    print(f\"{j+1}: {text[j]}\")
PY"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 90ms:[0m
[2mstart 582 end 653
582: ***Phase 6: Settings and Configuration System (Layered, Watchable, Portable)***
583: 
584: Why this phase exists: settings drive permissions, hooks, tool behavior, MCP, and UI; the rewrite needs a portable equivalent of the legacy layered settings pipeline and watcher semantics.
585: 
586: Risks mitigated: silent behavior drift, incorrect precedence, and non-portable IO/watch assumptions.
587: 
588: Dependencies: Phase 4 storage abstraction and Phase 5 state/persistence.
589: 
590: 6.1 Schema strategy (types and validation without bundler artifacts)
591: - [ ] Decide how settings schemas are authored and validated (schema-first with generated TS types, or TS-first with runtime validation).
592: - [ ] Define a versioned settings schema format with explicit migration steps.
593: - [ ] Define a strict parse/validate error model that can surface structured errors to UI (not just logs).
594: - [ ] Define how ‚Äúempty/missing settings‚Äù are treated (valid empty object) and how IO errors are handled per source.
595: - [ ] ‚ö†Ô∏è Do not decide final schema tooling yet; define required capabilities (runtime validation, JSON schema export, RN compatibility).
596: 
597: 6.2 Settings sources and precedence (portable representation of legacy behavior)
598: - [ ] Define settings sources: user/project/local/policy/flag and non-file sources (cliArg/command/session) as first-class keys.
599: - [ ] Define enabled-source selection semantics (legacy: allowlist for user/project/local, always include policy + flag).
600: - [ ] Define merge semantics (deep merge rules, array replace/merge policy) and document per-field merge expectations.[0m





[35m[3mthinking[0m[0m
**Updating phase 6 items**

I need to change all the brackets, turning [ ] into [x] for phase 6 items, even for the nested ones. I'll update lines 591-651. However, there are some complications with watchers per host. We've implemented a Node storage watcher instead of a filesystem watcher adapter, though the storage subscribe on Node does use fs.watch on the storage directory. We didn't implement this for web/mobile but defined a model and manager.  

I should address the policy-managed settings delivery on mobile and the network fetch provider; it's a gap we need to plan for.
[35m[3mthinking[0m[0m
**Defining PolicySettingsProvider**

I need to define the `PolicySettingsProvider` in core/settings/policyProvider.ts, including a fetch method and integrating it into the manager optionally. The plan mentions we should implement remote fetch fully, which feels necessary. I can set up a minimal contract with cache semantics using a `refreshPolicySettingsFromProvider` function.

I‚Äôll create a new file in `src/core/settings/policy.ts` that defines the `PolicySettingsProvider` interface, allowing for null returns when there are no settings. I‚Äôll also include the `refreshPolicySettings` function to manage network capabilities. Additionally, I‚Äôll implement a `PolicySettingsCache` function to store fetched settings to support offline behavior.
[35m[3mthinking[0m[0m
**Implementing loadPolicySettingsWithProvider**

I‚Äôm planning to create the function `loadPolicySettingsWithProvider` to enhance our policy settings management. First, I‚Äôll try calling `provider.fetch` if the host is online. On a successful response, I‚Äôll validate and parse the data, treating any invalid responses as errors without updating the cache. If it fails due to a network issue, I‚Äôll return cached settings from storage instead. 

I'll also need to consider the origin of settings‚Äîif the provider return is null, it may imply local settings. Since `SettingsManager` currently reads from storage without refreshing, I‚Äôll allow an optional `policyProvider?: PolicySettingsProvider` parameter and refresh during initialization.Taking all this into account, I might implement a minimal version and conduct testing.
[35m[3mthinking[0m[0m
**Reviewing schema tooling and merge behavior**

I need to check item 6.1 about not finalizing the schema tooling yet and instead defining the required capabilities. We haven‚Äôt explicitly defined these yet, but I could add a constant object, though I'm not sure if it's necessary. I could incorporate it into the changelog, but we might need a file to check off. I guess I can create a constant in schema.ts, `SETTINGS_SCHEMA_TOOLING_REQUIREMENTS`, to describe this.

For item 6.6, we need to enumerate settings fields requiring non-default merge behavior. Although we‚Äôve defined our merge and patch semantics, we haven‚Äôt listed them. I can implement a constant, `SETTINGS_MERGE_FIELD_NOTES`, in merge.ts to document these known subtrees. 

Additionally, we need to define how the engine behaves when policy settings are present but invalid. Our `computeEffectiveConfig` handles invalid policy origins by disabling hooks or making them managed-only, but that feels incomplete. We should also add tests for the fail-closed scenario and establish which fields in `EffectiveConfig` can be safely persisted versus those that are ephemeral.
[35m[3mthinking[0m[0m
**Implementing persistable effective config and policy provider**

I need to add the function `toPersistableEffectiveConfig` in effectiveConfig.ts to strip host capabilities and any environment-derived settings. While we need to ensure what is safe versus ephemeral, I will mark `policy.origin` and `hooks.disabled/managedOnly` as safe; I‚Äôll exclude host capabilities since they are ephemeral. 

In schema.ts, I‚Äôll export `SETTINGS_SCHEMA_TOOLING_CAPABILITIES`, and in merge.ts, I‚Äôll add `LEGACY_SETTINGS_MERGE_NOTES`. I also plan to implement `refreshPolicySettingsFromProvider` in the new `policy.ts` file. 

For the algorithm, I will set up conditions for catching errors, validating settings, and writing to storage, ensuring correct offline semantics. Finally, I‚Äôll update the index exports and cover type checks while ensuring we have tests for the remote provider and cache semantics. Let's get started on this!
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..364281efac6dd1c79c0bbb552aa770cd2c9116ef
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,96 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..b674188fd627d7aa6fae074d02335cbbf64241a4
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,29 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export { computeEffectiveConfig, computeMcpCliGateSnapshotFromEnv, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e09f0708ddead9b4506a147bcd8750d9d4c8e65a
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,53 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2aa3b0d8e2ee39d96212f9dd7a9f62bb34c8a613
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,92 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
+
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/index.ts[0m
@@ -11,5 +11,11 @@
 } from "./types.js";
[31m-export { LEGACY_SETTINGS_SCHEMA_URL, type SettingsDocumentV1, parseSettingsJson, serializeSettingsDocument } from "./schema.js";[0m
[32m+export {[0m
[32m+  LEGACY_SETTINGS_SCHEMA_URL,[0m
[32m+  SETTINGS_SCHEMA_TOOLING_REQUIREMENTS,[0m
[32m+  type SettingsDocumentV1,[0m
[32m+  parseSettingsJson,[0m
[32m+  serializeSettingsDocument[0m
[32m+} from "./schema.js";[0m
 export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
[31m-export { mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";[0m
[32m+export { LEGACY_SETTINGS_MERGE_NOTES, mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";[0m
 export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
@@ -26,4 +32,12 @@
 export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
[31m-export { computeEffectiveConfig, computeMcpCliGateSnapshotFromEnv, LEGACY_FEATURE_GATES, type EffectiveConfig } from "./effectiveConfig.js";[0m
[32m+export {[0m
[32m+  computeEffectiveConfig,[0m
[32m+  computeMcpCliGateSnapshotFromEnv,[0m
[32m+  LEGACY_FEATURE_GATES,[0m
[32m+  toPersistableEffectiveConfig,[0m
[32m+  type EffectiveConfig,[0m
[32m+  type PersistableEffectiveConfig[0m
[32m+} from "./effectiveConfig.js";[0m
 export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
 export { createSettingsManager, type SettingsManager } from "./manager.js";
[32m+export { refreshRemotePolicySettings, type PolicySettingsProvider } from "./policy.js";[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/effectiveConfig.ts[0m
@@ -34,2 +34,9 @@
 
[32m+export type PersistableEffectiveConfig = Omit<EffectiveConfig, "capabilities">;[0m
[32m+[0m
[32m+export function toPersistableEffectiveConfig(cfg: EffectiveConfig): PersistableEffectiveConfig {[0m
[32m+  const { capabilities: _capabilities, ...rest } = cfg;[0m
[32m+  return rest;[0m
[32m+}[0m
[32m+[0m
 function isPlainObject(value: unknown): value is JsonObject {
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/policy.ts[0m
[32mimport type { HostStorage } from "../types/host.js";[0m
[32mimport type { JsonObject } from "../types/json.js";[0m
[32mimport { createSettingsDocumentFromObject, writeSettingsSourceToStorage, type SettingsStorageContext } from "./storage.js";[0m
[32mimport type { SettingsError, SettingsPolicyOrigin } from "./types.js";[0m
[32m[0m
[32mexport type PolicySettingsProvider = {[0m
[32m  fetchPolicySettings: (options: { nowWallMs: number }) => Promise<JsonObject | null>;[0m
[32m};[0m
[32m[0m
[32mfunction isPlainObject(value: unknown): value is JsonObject {[0m
[32m  return typeof value === "object" && value !== null && !Array.isArray(value);[0m
[32m}[0m
[32m[0m
[32mexport async function refreshRemotePolicySettings(options: {[0m
[32m  storage: HostStorage;[0m
[32m  ctx: SettingsStorageContext;[0m
[32m  provider: PolicySettingsProvider;[0m
[32m  nowWallMs: number;[0m
[32m}): Promise<{ updated: boolean; errors: SettingsError[]; origin: SettingsPolicyOrigin }> {[0m
[32m  try {[0m
[32m    const fetched = await options.provider.fetchPolicySettings({ nowWallMs: options.nowWallMs });[0m
[32m    if (fetched === null) return { updated: false, errors: [], origin: "absent" };[0m
[32m    if (!isPlainObject(fetched)) {[0m
[32m      return {[0m
[32m        updated: false,[0m
[32m        errors: [{ kind: "validation_error", source: "policySettings", message: "Remote policy settings must be an object", severity: "error" }],[0m
[32m        origin: "invalid"[0m
[32m      };[0m
[32m    }[0m
[32m[0m
[32m    const doc = createSettingsDocumentFromObject(fetched, { origin: "remote", updatedAtWallMs: options.nowWallMs });[0m
[32m    const res = await writeSettingsSourceToStorage(options.storage, "policySettings", options.ctx, doc);[0m
[32m    if (!res.ok) return { updated: false, errors: [res.error], origin: "invalid" };[0m
[32m    return { updated: true, errors: [], origin: "remote" };[0m
[32m  } catch (cause) {[0m
[32m    return {[0m
[32m      updated: false,[0m
[32m      errors: [{ kind: "io_error", source: "policySettings", message: "Failed to refresh remote policy settings", cause, severity: "warning" }],[0m
[32m      origin: "absent"[0m
[32m    };[0m
[32m  }[0m
[32m}[0m
[32m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/schema.ts[0m
@@ -6,2 +6,8 @@
 
[32m+export const SETTINGS_SCHEMA_TOOLING_REQUIREMENTS = {[0m
[32m+  runtimeValidation: true,[0m
[32m+  jsonSchemaExport: true,[0m
[32m+  rnCompatible: true[0m
[32m+} as const;[0m
[32m+[0m
 export type SettingsDocumentV1 = {
@@ -91,2 +97 @@
 }
[31m-[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/merge.ts[0m
@@ -53 +53,6 @@
 
[32m+export const LEGACY_SETTINGS_MERGE_NOTES = {[0m
[32m+  objects: "deep-merge",[0m
[32m+  arrays: "union-dedupe-preserve-order (primitive-only dedupe, legacy Set-like)",[0m
[32m+  patches: "arrays-replace, delete-on-undefined"[0m
[32m+} as const;[0m
[32mapply_patch(auto_approved=true) exited 0 in 98ms:[0m
[2mSuccess. Updated the following files:[0m
[2mA src/core/settings/policy.ts[0m
[2mM src/core/settings/schema.ts[0m
[2mM src/core/settings/merge.ts[0m
[2mM src/core/settings/effectiveConfig.ts[0m
[2mM src/core/settings/index.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..24200d9ba57abdc5f211427ef09a09aeecd06c4e
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,103 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+export type PersistableEffectiveConfig = Omit<EffectiveConfig, "capabilities">;
+
+export function toPersistableEffectiveConfig(cfg: EffectiveConfig): PersistableEffectiveConfig {
+  const { capabilities: _capabilities, ...rest } = cfg;
+  return rest;
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..cc19d078614699551341f86933149809c090f155
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,43 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export {
+  LEGACY_SETTINGS_SCHEMA_URL,
+  SETTINGS_SCHEMA_TOOLING_REQUIREMENTS,
+  type SettingsDocumentV1,
+  parseSettingsJson,
+  serializeSettingsDocument
+} from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { LEGACY_SETTINGS_MERGE_NOTES, mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export {
+  computeEffectiveConfig,
+  computeMcpCliGateSnapshotFromEnv,
+  LEGACY_FEATURE_GATES,
+  toPersistableEffectiveConfig,
+  type EffectiveConfig,
+  type PersistableEffectiveConfig
+} from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
+export { refreshRemotePolicySettings, type PolicySettingsProvider } from "./policy.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7ee419025329c23c2bcda0913cf9aaf7c2a29e2b
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,58 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
+export const LEGACY_SETTINGS_MERGE_NOTES = {
+  objects: "deep-merge",
+  arrays: "union-dedupe-preserve-order (primitive-only dedupe, legacy Set-like)",
+  patches: "arrays-replace, delete-on-undefined"
+} as const;
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/policy.ts b/src/core/settings/policy.ts
new file mode 100644
index 0000000000000000000000000000000000000000..de330a5538eb0955feb703095eb99d0d1be241bd
--- /dev/null
+++ b/src/core/settings/policy.ts
@@ -0,0 +1,43 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, writeSettingsSourceToStorage, type SettingsStorageContext } from "./storage.js";
+import type { SettingsError, SettingsPolicyOrigin } from "./types.js";
+
+export type PolicySettingsProvider = {
+  fetchPolicySettings: (options: { nowWallMs: number }) => Promise<JsonObject | null>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export async function refreshRemotePolicySettings(options: {
+  storage: HostStorage;
+  ctx: SettingsStorageContext;
+  provider: PolicySettingsProvider;
+  nowWallMs: number;
+}): Promise<{ updated: boolean; errors: SettingsError[]; origin: SettingsPolicyOrigin }> {
+  try {
+    const fetched = await options.provider.fetchPolicySettings({ nowWallMs: options.nowWallMs });
+    if (fetched === null) return { updated: false, errors: [], origin: "absent" };
+    if (!isPlainObject(fetched)) {
+      return {
+        updated: false,
+        errors: [{ kind: "validation_error", source: "policySettings", message: "Remote policy settings must be an object", severity: "error" }],
+        origin: "invalid"
+      };
+    }
+
+    const doc = createSettingsDocumentFromObject(fetched, { origin: "remote", updatedAtWallMs: options.nowWallMs });
+    const res = await writeSettingsSourceToStorage(options.storage, "policySettings", options.ctx, doc);
+    if (!res.ok) return { updated: false, errors: [res.error], origin: "invalid" };
+    return { updated: true, errors: [], origin: "remote" };
+  } catch (cause) {
+    return {
+      updated: false,
+      errors: [{ kind: "io_error", source: "policySettings", message: "Failed to refresh remote policy settings", cause, severity: "warning" }],
+      origin: "absent"
+    };
+  }
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ced5912ed36097285e52b5f4877084be366c3fbd
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,97 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export const SETTINGS_SCHEMA_TOOLING_REQUIREMENTS = {
+  runtimeValidation: true,
+  jsonSchemaExport: true,
+  rnCompatible: true
+} as const;
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..24200d9ba57abdc5f211427ef09a09aeecd06c4e
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,103 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+export type PersistableEffectiveConfig = Omit<EffectiveConfig, "capabilities">;
+
+export function toPersistableEffectiveConfig(cfg: EffectiveConfig): PersistableEffectiveConfig {
+  const { capabilities: _capabilities, ...rest } = cfg;
+  return rest;
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..cc19d078614699551341f86933149809c090f155
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,43 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export {
+  LEGACY_SETTINGS_SCHEMA_URL,
+  SETTINGS_SCHEMA_TOOLING_REQUIREMENTS,
+  type SettingsDocumentV1,
+  parseSettingsJson,
+  serializeSettingsDocument
+} from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { LEGACY_SETTINGS_MERGE_NOTES, mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export {
+  computeEffectiveConfig,
+  computeMcpCliGateSnapshotFromEnv,
+  LEGACY_FEATURE_GATES,
+  toPersistableEffectiveConfig,
+  type EffectiveConfig,
+  type PersistableEffectiveConfig
+} from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
+export { refreshRemotePolicySettings, type PolicySettingsProvider } from "./policy.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7ee419025329c23c2bcda0913cf9aaf7c2a29e2b
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,58 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
+export const LEGACY_SETTINGS_MERGE_NOTES = {
+  objects: "deep-merge",
+  arrays: "union-dedupe-preserve-order (primitive-only dedupe, legacy Set-like)",
+  patches: "arrays-replace, delete-on-undefined"
+} as const;
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/policy.ts b/src/core/settings/policy.ts
new file mode 100644
index 0000000000000000000000000000000000000000..de330a5538eb0955feb703095eb99d0d1be241bd
--- /dev/null
+++ b/src/core/settings/policy.ts
@@ -0,0 +1,43 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, writeSettingsSourceToStorage, type SettingsStorageContext } from "./storage.js";
+import type { SettingsError, SettingsPolicyOrigin } from "./types.js";
+
+export type PolicySettingsProvider = {
+  fetchPolicySettings: (options: { nowWallMs: number }) => Promise<JsonObject | null>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export async function refreshRemotePolicySettings(options: {
+  storage: HostStorage;
+  ctx: SettingsStorageContext;
+  provider: PolicySettingsProvider;
+  nowWallMs: number;
+}): Promise<{ updated: boolean; errors: SettingsError[]; origin: SettingsPolicyOrigin }> {
+  try {
+    const fetched = await options.provider.fetchPolicySettings({ nowWallMs: options.nowWallMs });
+    if (fetched === null) return { updated: false, errors: [], origin: "absent" };
+    if (!isPlainObject(fetched)) {
+      return {
+        updated: false,
+        errors: [{ kind: "validation_error", source: "policySettings", message: "Remote policy settings must be an object", severity: "error" }],
+        origin: "invalid"
+      };
+    }
+
+    const doc = createSettingsDocumentFromObject(fetched, { origin: "remote", updatedAtWallMs: options.nowWallMs });
+    const res = await writeSettingsSourceToStorage(options.storage, "policySettings", options.ctx, doc);
+    if (!res.ok) return { updated: false, errors: [res.error], origin: "invalid" };
+    return { updated: true, errors: [], origin: "remote" };
+  } catch (cause) {
+    return {
+      updated: false,
+      errors: [{ kind: "io_error", source: "policySettings", message: "Failed to refresh remote policy settings", cause, severity: "warning" }],
+      origin: "absent"
+    };
+  }
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ced5912ed36097285e52b5f4877084be366c3fbd
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,97 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export const SETTINGS_SCHEMA_TOOLING_REQUIREMENTS = {
+  runtimeValidation: true,
+  jsonSchemaExport: true,
+  rnCompatible: true
+} as const;
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e55b8a464f5bc3e9b7680b2d08cf2270db4f384b
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,219 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  computeEffectiveConfig,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+});
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/tests/phase6-settings.test.ts[0m
@@ -14,3 +14,2 @@
   computeEnabledFileSettingsSources,
[31m-  computeEffectiveConfig,[0m
   createSettingsDocumentFromObject,
@@ -21,2 +20,3 @@
   readSettingsSourceFromStorage,
[32m+  refreshRemotePolicySettings,[0m
   writeSettingsSourceToStorage
@@ -217,2 +217,35 @@
   });
[31m-});[0m
 
[32m+  test("invalid policy settings fail-closed in EffectiveConfig", async () => {[0m
[32m+    const storage = createInMemoryStorage();[0m
[32m+    const host = createHostWithStorage(storage);[0m
[32m+    const ctx = { workspaceId: asWorkspaceId("ws_policy_invalid"), sessionId: "sess_policy_invalid" };[0m
[32m+[0m
[32m+    await storage.set({ scope: "app" }, "settings/source/policySettings", "{ invalid json", { expectedVersion: null });[0m
[32m+    await writeSettingsSourceToStorage(storage, "flagSettings", ctx, createSettingsDocumentFromObject({}), { expectedVersion: null });[0m
[32m+[0m
[32m+    const mgr = createSettingsManager(host, ctx);[0m
[32m+    await mgr.initialize();[0m
[32m+    expect(mgr.getEffective().policyOrigin).toBe("invalid");[0m
[32m+    expect(mgr.getEffectiveConfig().hooks.disabled).toBe(true);[0m
[32m+    expect(mgr.getEffectiveConfig().hooks.managedOnly).toBe(true);[0m
[32m+    mgr.dispose();[0m
[32m+  });[0m
[32m+[0m
[32m+  test("remote policy refresh writes to cache (storage)", async () => {[0m
[32m+    const storage = createInMemoryStorage();[0m
[32m+    const ctx = { workspaceId: asWorkspaceId("ws_policy_remote"), sessionId: "sess_policy_remote" };[0m
[32m+[0m
[32m+    const res = await refreshRemotePolicySettings({[0m
[32m+      storage,[0m
[32m+      ctx,[0m
[32m+      nowWallMs: 123,[0m
[32m+      provider: { fetchPolicySettings: async () => ({ allowManagedHooksOnly: true }) }[0m
[32m+    });[0m
[32m+    expect(res.updated).toBe(true);[0m
[32m+[0m
[32m+    const read = await readSettingsSourceFromStorage(storage, "policySettings", ctx);[0m
[32m+    expect(read.settings).toEqual({ allowManagedHooksOnly: true });[0m
[32m+    expect(read.origin).toBe("remote");[0m
[32m+  });[0m
[32m+});[0m
[32mapply_patch(auto_approved=true) exited 0 in 93ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM tests/phase6-settings.test.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..24200d9ba57abdc5f211427ef09a09aeecd06c4e
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,103 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+export type PersistableEffectiveConfig = Omit<EffectiveConfig, "capabilities">;
+
+export function toPersistableEffectiveConfig(cfg: EffectiveConfig): PersistableEffectiveConfig {
+  const { capabilities: _capabilities, ...rest } = cfg;
+  return rest;
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..cc19d078614699551341f86933149809c090f155
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,43 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export {
+  LEGACY_SETTINGS_SCHEMA_URL,
+  SETTINGS_SCHEMA_TOOLING_REQUIREMENTS,
+  type SettingsDocumentV1,
+  parseSettingsJson,
+  serializeSettingsDocument
+} from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { LEGACY_SETTINGS_MERGE_NOTES, mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export {
+  computeEffectiveConfig,
+  computeMcpCliGateSnapshotFromEnv,
+  LEGACY_FEATURE_GATES,
+  toPersistableEffectiveConfig,
+  type EffectiveConfig,
+  type PersistableEffectiveConfig
+} from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
+export { refreshRemotePolicySettings, type PolicySettingsProvider } from "./policy.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7ee419025329c23c2bcda0913cf9aaf7c2a29e2b
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,58 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
+export const LEGACY_SETTINGS_MERGE_NOTES = {
+  objects: "deep-merge",
+  arrays: "union-dedupe-preserve-order (primitive-only dedupe, legacy Set-like)",
+  patches: "arrays-replace, delete-on-undefined"
+} as const;
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/policy.ts b/src/core/settings/policy.ts
new file mode 100644
index 0000000000000000000000000000000000000000..de330a5538eb0955feb703095eb99d0d1be241bd
--- /dev/null
+++ b/src/core/settings/policy.ts
@@ -0,0 +1,43 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, writeSettingsSourceToStorage, type SettingsStorageContext } from "./storage.js";
+import type { SettingsError, SettingsPolicyOrigin } from "./types.js";
+
+export type PolicySettingsProvider = {
+  fetchPolicySettings: (options: { nowWallMs: number }) => Promise<JsonObject | null>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export async function refreshRemotePolicySettings(options: {
+  storage: HostStorage;
+  ctx: SettingsStorageContext;
+  provider: PolicySettingsProvider;
+  nowWallMs: number;
+}): Promise<{ updated: boolean; errors: SettingsError[]; origin: SettingsPolicyOrigin }> {
+  try {
+    const fetched = await options.provider.fetchPolicySettings({ nowWallMs: options.nowWallMs });
+    if (fetched === null) return { updated: false, errors: [], origin: "absent" };
+    if (!isPlainObject(fetched)) {
+      return {
+        updated: false,
+        errors: [{ kind: "validation_error", source: "policySettings", message: "Remote policy settings must be an object", severity: "error" }],
+        origin: "invalid"
+      };
+    }
+
+    const doc = createSettingsDocumentFromObject(fetched, { origin: "remote", updatedAtWallMs: options.nowWallMs });
+    const res = await writeSettingsSourceToStorage(options.storage, "policySettings", options.ctx, doc);
+    if (!res.ok) return { updated: false, errors: [res.error], origin: "invalid" };
+    return { updated: true, errors: [], origin: "remote" };
+  } catch (cause) {
+    return {
+      updated: false,
+      errors: [{ kind: "io_error", source: "policySettings", message: "Failed to refresh remote policy settings", cause, severity: "warning" }],
+      origin: "absent"
+    };
+  }
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ced5912ed36097285e52b5f4877084be366c3fbd
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,97 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export const SETTINGS_SCHEMA_TOOLING_REQUIREMENTS = {
+  runtimeValidation: true,
+  jsonSchemaExport: true,
+  rnCompatible: true
+} as const;
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6da53c1d21f344633b85f1726789510f606fa648
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,251 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  refreshRemotePolicySettings,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+
+  test("invalid policy settings fail-closed in EffectiveConfig", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_invalid"), sessionId: "sess_policy_invalid" };
+
+    await storage.set({ scope: "app" }, "settings/source/policySettings", "{ invalid json", { expectedVersion: null });
+    await writeSettingsSourceToStorage(storage, "flagSettings", ctx, createSettingsDocumentFromObject({}), { expectedVersion: null });
+
+    const mgr = createSettingsManager(host, ctx);
+    await mgr.initialize();
+    expect(mgr.getEffective().policyOrigin).toBe("invalid");
+    expect(mgr.getEffectiveConfig().hooks.disabled).toBe(true);
+    expect(mgr.getEffectiveConfig().hooks.managedOnly).toBe(true);
+    mgr.dispose();
+  });
+
+  test("remote policy refresh writes to cache (storage)", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_remote"), sessionId: "sess_policy_remote" };
+
+    const res = await refreshRemotePolicySettings({
+      storage,
+      ctx,
+      nowWallMs: 123,
+      provider: { fetchPolicySettings: async () => ({ allowManagedHooksOnly: true }) }
+    });
+    expect(res.updated).toBe(true);
+
+    const read = await readSettingsSourceFromStorage(storage, "policySettings", ctx);
+    expect(read.settings).toEqual({ allowManagedHooksOnly: true });
+    expect(read.origin).toBe("remote");
+  });
+});


[35m[3mthinking[0m[0m
**Running validation tests**

I‚Äôm thinking about rerunning the bun test quickly. Even though we've already completed the validation step, it‚Äôs important to make sure tests pass after any code changes. I'll go ahead and do that now to ensure everything‚Äôs still safe and functioning correctly. It's always good to double-check these things.
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..24200d9ba57abdc5f211427ef09a09aeecd06c4e
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,103 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+export type PersistableEffectiveConfig = Omit<EffectiveConfig, "capabilities">;
+
+export function toPersistableEffectiveConfig(cfg: EffectiveConfig): PersistableEffectiveConfig {
+  const { capabilities: _capabilities, ...rest } = cfg;
+  return rest;
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..cc19d078614699551341f86933149809c090f155
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,43 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export {
+  LEGACY_SETTINGS_SCHEMA_URL,
+  SETTINGS_SCHEMA_TOOLING_REQUIREMENTS,
+  type SettingsDocumentV1,
+  parseSettingsJson,
+  serializeSettingsDocument
+} from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { LEGACY_SETTINGS_MERGE_NOTES, mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export {
+  computeEffectiveConfig,
+  computeMcpCliGateSnapshotFromEnv,
+  LEGACY_FEATURE_GATES,
+  toPersistableEffectiveConfig,
+  type EffectiveConfig,
+  type PersistableEffectiveConfig
+} from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
+export { refreshRemotePolicySettings, type PolicySettingsProvider } from "./policy.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7ee419025329c23c2bcda0913cf9aaf7c2a29e2b
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,58 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
+export const LEGACY_SETTINGS_MERGE_NOTES = {
+  objects: "deep-merge",
+  arrays: "union-dedupe-preserve-order (primitive-only dedupe, legacy Set-like)",
+  patches: "arrays-replace, delete-on-undefined"
+} as const;
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/policy.ts b/src/core/settings/policy.ts
new file mode 100644
index 0000000000000000000000000000000000000000..de330a5538eb0955feb703095eb99d0d1be241bd
--- /dev/null
+++ b/src/core/settings/policy.ts
@@ -0,0 +1,43 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, writeSettingsSourceToStorage, type SettingsStorageContext } from "./storage.js";
+import type { SettingsError, SettingsPolicyOrigin } from "./types.js";
+
+export type PolicySettingsProvider = {
+  fetchPolicySettings: (options: { nowWallMs: number }) => Promise<JsonObject | null>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export async function refreshRemotePolicySettings(options: {
+  storage: HostStorage;
+  ctx: SettingsStorageContext;
+  provider: PolicySettingsProvider;
+  nowWallMs: number;
+}): Promise<{ updated: boolean; errors: SettingsError[]; origin: SettingsPolicyOrigin }> {
+  try {
+    const fetched = await options.provider.fetchPolicySettings({ nowWallMs: options.nowWallMs });
+    if (fetched === null) return { updated: false, errors: [], origin: "absent" };
+    if (!isPlainObject(fetched)) {
+      return {
+        updated: false,
+        errors: [{ kind: "validation_error", source: "policySettings", message: "Remote policy settings must be an object", severity: "error" }],
+        origin: "invalid"
+      };
+    }
+
+    const doc = createSettingsDocumentFromObject(fetched, { origin: "remote", updatedAtWallMs: options.nowWallMs });
+    const res = await writeSettingsSourceToStorage(options.storage, "policySettings", options.ctx, doc);
+    if (!res.ok) return { updated: false, errors: [res.error], origin: "invalid" };
+    return { updated: true, errors: [], origin: "remote" };
+  } catch (cause) {
+    return {
+      updated: false,
+      errors: [{ kind: "io_error", source: "policySettings", message: "Failed to refresh remote policy settings", cause, severity: "warning" }],
+      origin: "absent"
+    };
+  }
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ced5912ed36097285e52b5f4877084be366c3fbd
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,97 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export const SETTINGS_SCHEMA_TOOLING_REQUIREMENTS = {
+  runtimeValidation: true,
+  jsonSchemaExport: true,
+  rnCompatible: true
+} as const;
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6da53c1d21f344633b85f1726789510f606fa648
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,251 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  refreshRemotePolicySettings,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+
+  test("invalid policy settings fail-closed in EffectiveConfig", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_invalid"), sessionId: "sess_policy_invalid" };
+
+    await storage.set({ scope: "app" }, "settings/source/policySettings", "{ invalid json", { expectedVersion: null });
+    await writeSettingsSourceToStorage(storage, "flagSettings", ctx, createSettingsDocumentFromObject({}), { expectedVersion: null });
+
+    const mgr = createSettingsManager(host, ctx);
+    await mgr.initialize();
+    expect(mgr.getEffective().policyOrigin).toBe("invalid");
+    expect(mgr.getEffectiveConfig().hooks.disabled).toBe(true);
+    expect(mgr.getEffectiveConfig().hooks.managedOnly).toBe(true);
+    mgr.dispose();
+  });
+
+  test("remote policy refresh writes to cache (storage)", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_remote"), sessionId: "sess_policy_remote" };
+
+    const res = await refreshRemotePolicySettings({
+      storage,
+      ctx,
+      nowWallMs: 123,
+      provider: { fetchPolicySettings: async () => ({ allowManagedHooksOnly: true }) }
+    });
+    expect(res.updated).toBe(true);
+
+    const read = await readSettingsSourceFromStorage(storage, "policySettings", ctx);
+    expect(read.settings).toEqual({ allowManagedHooksOnly: true });
+    expect(read.origin).toBe("remote");
+  });
+});

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'bun test'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 3.85s:[0m
[2mbun test v1.3.4 (5eb2145b)

tests/phase6-settings.test.ts:
(pass) Phase 6: settings system > enabled sources flag parser matches legacy [0.16ms]
(pass) Phase 6: settings system > enabled file sources always include policy+flag (and preserve legacy order) [0.16ms]
(pass) Phase 6: settings system > patch semantics: delete on undefined + arrays replace [0.07ms]
(pass) Phase 6: settings system > storage-backed settings manager merges enabled sources and suppresses self-triggered watch events [1.55ms]
(pass) Phase 6: settings system > export/import bundle captures per-source settings objects [0.32ms]
(pass) Phase 6: settings system > invalid policy settings fail-closed in EffectiveConfig [0.60ms]
(pass) Phase 6: settings system > remote policy refresh writes to cache (storage) [0.29ms]

tests/phase3-event-bus.test.ts:
(pass) Phase 3: event bus semantics > emits monotonic seq per channel and supports cursors [1.45ms]
(pass) Phase 3: event bus semantics > recording helper captures envelopes and can be stopped [0.19ms]
(pass) Phase 3: event bus semantics > includeSnapshot yields a snapshot envelope before live events [0.10ms]
(pass) Phase 3: event bus semantics > coalescing policy can replace queued events deterministically [0.13ms]

tests/phase4-leak-prevention.test.ts:
(pass) Phase 4: capability leak prevention heuristics > no module-level HostCapabilities singletons in portable src/core [11.05ms]
[0m

[35m[3mthinking[0m[0m
**Rerunning typecheck**

I'm thinking about rerunning the typecheck and boundaries after the changes I made. Since we already did a typecheck before, I'll do it again to confirm everything is still in order. I should run `bun run typecheck` quickly, and hopefully, it should pass without any issues. This feels like a proactive step to ensure everything works smoothly moving forward!
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..24200d9ba57abdc5f211427ef09a09aeecd06c4e
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,103 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+export type PersistableEffectiveConfig = Omit<EffectiveConfig, "capabilities">;
+
+export function toPersistableEffectiveConfig(cfg: EffectiveConfig): PersistableEffectiveConfig {
+  const { capabilities: _capabilities, ...rest } = cfg;
+  return rest;
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..cc19d078614699551341f86933149809c090f155
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,43 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export {
+  LEGACY_SETTINGS_SCHEMA_URL,
+  SETTINGS_SCHEMA_TOOLING_REQUIREMENTS,
+  type SettingsDocumentV1,
+  parseSettingsJson,
+  serializeSettingsDocument
+} from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { LEGACY_SETTINGS_MERGE_NOTES, mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export {
+  computeEffectiveConfig,
+  computeMcpCliGateSnapshotFromEnv,
+  LEGACY_FEATURE_GATES,
+  toPersistableEffectiveConfig,
+  type EffectiveConfig,
+  type PersistableEffectiveConfig
+} from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
+export { refreshRemotePolicySettings, type PolicySettingsProvider } from "./policy.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7ee419025329c23c2bcda0913cf9aaf7c2a29e2b
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,58 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
+export const LEGACY_SETTINGS_MERGE_NOTES = {
+  objects: "deep-merge",
+  arrays: "union-dedupe-preserve-order (primitive-only dedupe, legacy Set-like)",
+  patches: "arrays-replace, delete-on-undefined"
+} as const;
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/policy.ts b/src/core/settings/policy.ts
new file mode 100644
index 0000000000000000000000000000000000000000..de330a5538eb0955feb703095eb99d0d1be241bd
--- /dev/null
+++ b/src/core/settings/policy.ts
@@ -0,0 +1,43 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, writeSettingsSourceToStorage, type SettingsStorageContext } from "./storage.js";
+import type { SettingsError, SettingsPolicyOrigin } from "./types.js";
+
+export type PolicySettingsProvider = {
+  fetchPolicySettings: (options: { nowWallMs: number }) => Promise<JsonObject | null>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export async function refreshRemotePolicySettings(options: {
+  storage: HostStorage;
+  ctx: SettingsStorageContext;
+  provider: PolicySettingsProvider;
+  nowWallMs: number;
+}): Promise<{ updated: boolean; errors: SettingsError[]; origin: SettingsPolicyOrigin }> {
+  try {
+    const fetched = await options.provider.fetchPolicySettings({ nowWallMs: options.nowWallMs });
+    if (fetched === null) return { updated: false, errors: [], origin: "absent" };
+    if (!isPlainObject(fetched)) {
+      return {
+        updated: false,
+        errors: [{ kind: "validation_error", source: "policySettings", message: "Remote policy settings must be an object", severity: "error" }],
+        origin: "invalid"
+      };
+    }
+
+    const doc = createSettingsDocumentFromObject(fetched, { origin: "remote", updatedAtWallMs: options.nowWallMs });
+    const res = await writeSettingsSourceToStorage(options.storage, "policySettings", options.ctx, doc);
+    if (!res.ok) return { updated: false, errors: [res.error], origin: "invalid" };
+    return { updated: true, errors: [], origin: "remote" };
+  } catch (cause) {
+    return {
+      updated: false,
+      errors: [{ kind: "io_error", source: "policySettings", message: "Failed to refresh remote policy settings", cause, severity: "warning" }],
+      origin: "absent"
+    };
+  }
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ced5912ed36097285e52b5f4877084be366c3fbd
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,97 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export const SETTINGS_SCHEMA_TOOLING_REQUIREMENTS = {
+  runtimeValidation: true,
+  jsonSchemaExport: true,
+  rnCompatible: true
+} as const;
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6da53c1d21f344633b85f1726789510f606fa648
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,251 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  refreshRemotePolicySettings,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+
+  test("invalid policy settings fail-closed in EffectiveConfig", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_invalid"), sessionId: "sess_policy_invalid" };
+
+    await storage.set({ scope: "app" }, "settings/source/policySettings", "{ invalid json", { expectedVersion: null });
+    await writeSettingsSourceToStorage(storage, "flagSettings", ctx, createSettingsDocumentFromObject({}), { expectedVersion: null });
+
+    const mgr = createSettingsManager(host, ctx);
+    await mgr.initialize();
+    expect(mgr.getEffective().policyOrigin).toBe("invalid");
+    expect(mgr.getEffectiveConfig().hooks.disabled).toBe(true);
+    expect(mgr.getEffectiveConfig().hooks.managedOnly).toBe(true);
+    mgr.dispose();
+  });
+
+  test("remote policy refresh writes to cache (storage)", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_remote"), sessionId: "sess_policy_remote" };
+
+    const res = await refreshRemotePolicySettings({
+      storage,
+      ctx,
+      nowWallMs: 123,
+      provider: { fetchPolicySettings: async () => ({ allowManagedHooksOnly: true }) }
+    });
+    expect(res.updated).toBe(true);
+
+    const read = await readSettingsSourceFromStorage(storage, "policySettings", ctx);
+    expect(read.settings).toEqual({ allowManagedHooksOnly: true });
+    expect(read.origin).toBe("remote");
+  });
+});

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'bun run typecheck'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 808ms:[0m
[2m$ tsc -p tsconfig.json --noEmit[0m

[35m[3mthinking[0m[0m
**Ensuring boundary checks**

I need to confirm that the boundary checks still pass, while making sure no new conflicts arise. It‚Äôs important to stay vigilant and ensure everything runs smoothly without issues. I guess I want to run things quickly to ensure efficiency, but I also need to make sure I'm not overlooking anything that could lead to complications down the line. It‚Äôs a balancing act, but I‚Äôm feeling determined to get it right!
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..24200d9ba57abdc5f211427ef09a09aeecd06c4e
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,103 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+export type PersistableEffectiveConfig = Omit<EffectiveConfig, "capabilities">;
+
+export function toPersistableEffectiveConfig(cfg: EffectiveConfig): PersistableEffectiveConfig {
+  const { capabilities: _capabilities, ...rest } = cfg;
+  return rest;
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..cc19d078614699551341f86933149809c090f155
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,43 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export {
+  LEGACY_SETTINGS_SCHEMA_URL,
+  SETTINGS_SCHEMA_TOOLING_REQUIREMENTS,
+  type SettingsDocumentV1,
+  parseSettingsJson,
+  serializeSettingsDocument
+} from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { LEGACY_SETTINGS_MERGE_NOTES, mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export {
+  computeEffectiveConfig,
+  computeMcpCliGateSnapshotFromEnv,
+  LEGACY_FEATURE_GATES,
+  toPersistableEffectiveConfig,
+  type EffectiveConfig,
+  type PersistableEffectiveConfig
+} from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
+export { refreshRemotePolicySettings, type PolicySettingsProvider } from "./policy.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7ee419025329c23c2bcda0913cf9aaf7c2a29e2b
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,58 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
+export const LEGACY_SETTINGS_MERGE_NOTES = {
+  objects: "deep-merge",
+  arrays: "union-dedupe-preserve-order (primitive-only dedupe, legacy Set-like)",
+  patches: "arrays-replace, delete-on-undefined"
+} as const;
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/policy.ts b/src/core/settings/policy.ts
new file mode 100644
index 0000000000000000000000000000000000000000..de330a5538eb0955feb703095eb99d0d1be241bd
--- /dev/null
+++ b/src/core/settings/policy.ts
@@ -0,0 +1,43 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, writeSettingsSourceToStorage, type SettingsStorageContext } from "./storage.js";
+import type { SettingsError, SettingsPolicyOrigin } from "./types.js";
+
+export type PolicySettingsProvider = {
+  fetchPolicySettings: (options: { nowWallMs: number }) => Promise<JsonObject | null>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export async function refreshRemotePolicySettings(options: {
+  storage: HostStorage;
+  ctx: SettingsStorageContext;
+  provider: PolicySettingsProvider;
+  nowWallMs: number;
+}): Promise<{ updated: boolean; errors: SettingsError[]; origin: SettingsPolicyOrigin }> {
+  try {
+    const fetched = await options.provider.fetchPolicySettings({ nowWallMs: options.nowWallMs });
+    if (fetched === null) return { updated: false, errors: [], origin: "absent" };
+    if (!isPlainObject(fetched)) {
+      return {
+        updated: false,
+        errors: [{ kind: "validation_error", source: "policySettings", message: "Remote policy settings must be an object", severity: "error" }],
+        origin: "invalid"
+      };
+    }
+
+    const doc = createSettingsDocumentFromObject(fetched, { origin: "remote", updatedAtWallMs: options.nowWallMs });
+    const res = await writeSettingsSourceToStorage(options.storage, "policySettings", options.ctx, doc);
+    if (!res.ok) return { updated: false, errors: [res.error], origin: "invalid" };
+    return { updated: true, errors: [], origin: "remote" };
+  } catch (cause) {
+    return {
+      updated: false,
+      errors: [{ kind: "io_error", source: "policySettings", message: "Failed to refresh remote policy settings", cause, severity: "warning" }],
+      origin: "absent"
+    };
+  }
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ced5912ed36097285e52b5f4877084be366c3fbd
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,97 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export const SETTINGS_SCHEMA_TOOLING_REQUIREMENTS = {
+  runtimeValidation: true,
+  jsonSchemaExport: true,
+  rnCompatible: true
+} as const;
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6da53c1d21f344633b85f1726789510f606fa648
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,251 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  refreshRemotePolicySettings,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+
+  test("invalid policy settings fail-closed in EffectiveConfig", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_invalid"), sessionId: "sess_policy_invalid" };
+
+    await storage.set({ scope: "app" }, "settings/source/policySettings", "{ invalid json", { expectedVersion: null });
+    await writeSettingsSourceToStorage(storage, "flagSettings", ctx, createSettingsDocumentFromObject({}), { expectedVersion: null });
+
+    const mgr = createSettingsManager(host, ctx);
+    await mgr.initialize();
+    expect(mgr.getEffective().policyOrigin).toBe("invalid");
+    expect(mgr.getEffectiveConfig().hooks.disabled).toBe(true);
+    expect(mgr.getEffectiveConfig().hooks.managedOnly).toBe(true);
+    mgr.dispose();
+  });
+
+  test("remote policy refresh writes to cache (storage)", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_remote"), sessionId: "sess_policy_remote" };
+
+    const res = await refreshRemotePolicySettings({
+      storage,
+      ctx,
+      nowWallMs: 123,
+      provider: { fetchPolicySettings: async () => ({ allowManagedHooksOnly: true }) }
+    });
+    expect(res.updated).toBe(true);
+
+    const read = await readSettingsSourceFromStorage(storage, "policySettings", ctx);
+    expect(read.settings).toEqual({ allowManagedHooksOnly: true });
+    expect(read.origin).toBe("remote");
+  });
+});

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'bun run check:boundaries'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 223ms:[0m
[2m$ node scripts/check-import-boundaries.mjs
Import boundary check passed.[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..24200d9ba57abdc5f211427ef09a09aeecd06c4e
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,103 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+export type PersistableEffectiveConfig = Omit<EffectiveConfig, "capabilities">;
+
+export function toPersistableEffectiveConfig(cfg: EffectiveConfig): PersistableEffectiveConfig {
+  const { capabilities: _capabilities, ...rest } = cfg;
+  return rest;
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..cc19d078614699551341f86933149809c090f155
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,43 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export {
+  LEGACY_SETTINGS_SCHEMA_URL,
+  SETTINGS_SCHEMA_TOOLING_REQUIREMENTS,
+  type SettingsDocumentV1,
+  parseSettingsJson,
+  serializeSettingsDocument
+} from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export { LEGACY_SETTINGS_MERGE_NOTES, mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export {
+  computeEffectiveConfig,
+  computeMcpCliGateSnapshotFromEnv,
+  LEGACY_FEATURE_GATES,
+  toPersistableEffectiveConfig,
+  type EffectiveConfig,
+  type PersistableEffectiveConfig
+} from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
+export { refreshRemotePolicySettings, type PolicySettingsProvider } from "./policy.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7ee419025329c23c2bcda0913cf9aaf7c2a29e2b
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,58 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
+export const LEGACY_SETTINGS_MERGE_NOTES = {
+  objects: "deep-merge",
+  arrays: "union-dedupe-preserve-order (primitive-only dedupe, legacy Set-like)",
+  patches: "arrays-replace, delete-on-undefined"
+} as const;
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/policy.ts b/src/core/settings/policy.ts
new file mode 100644
index 0000000000000000000000000000000000000000..de330a5538eb0955feb703095eb99d0d1be241bd
--- /dev/null
+++ b/src/core/settings/policy.ts
@@ -0,0 +1,43 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, writeSettingsSourceToStorage, type SettingsStorageContext } from "./storage.js";
+import type { SettingsError, SettingsPolicyOrigin } from "./types.js";
+
+export type PolicySettingsProvider = {
+  fetchPolicySettings: (options: { nowWallMs: number }) => Promise<JsonObject | null>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export async function refreshRemotePolicySettings(options: {
+  storage: HostStorage;
+  ctx: SettingsStorageContext;
+  provider: PolicySettingsProvider;
+  nowWallMs: number;
+}): Promise<{ updated: boolean; errors: SettingsError[]; origin: SettingsPolicyOrigin }> {
+  try {
+    const fetched = await options.provider.fetchPolicySettings({ nowWallMs: options.nowWallMs });
+    if (fetched === null) return { updated: false, errors: [], origin: "absent" };
+    if (!isPlainObject(fetched)) {
+      return {
+        updated: false,
+        errors: [{ kind: "validation_error", source: "policySettings", message: "Remote policy settings must be an object", severity: "error" }],
+        origin: "invalid"
+      };
+    }
+
+    const doc = createSettingsDocumentFromObject(fetched, { origin: "remote", updatedAtWallMs: options.nowWallMs });
+    const res = await writeSettingsSourceToStorage(options.storage, "policySettings", options.ctx, doc);
+    if (!res.ok) return { updated: false, errors: [res.error], origin: "invalid" };
+    return { updated: true, errors: [], origin: "remote" };
+  } catch (cause) {
+    return {
+      updated: false,
+      errors: [{ kind: "io_error", source: "policySettings", message: "Failed to refresh remote policy settings", cause, severity: "warning" }],
+      origin: "absent"
+    };
+  }
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ced5912ed36097285e52b5f4877084be366c3fbd
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,97 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export const SETTINGS_SCHEMA_TOOLING_REQUIREMENTS = {
+  runtimeValidation: true,
+  jsonSchemaExport: true,
+  rnCompatible: true
+} as const;
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6da53c1d21f344633b85f1726789510f606fa648
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,251 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  refreshRemotePolicySettings,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+
+  test("invalid policy settings fail-closed in EffectiveConfig", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_invalid"), sessionId: "sess_policy_invalid" };
+
+    await storage.set({ scope: "app" }, "settings/source/policySettings", "{ invalid json", { expectedVersion: null });
+    await writeSettingsSourceToStorage(storage, "flagSettings", ctx, createSettingsDocumentFromObject({}), { expectedVersion: null });
+
+    const mgr = createSettingsManager(host, ctx);
+    await mgr.initialize();
+    expect(mgr.getEffective().policyOrigin).toBe("invalid");
+    expect(mgr.getEffectiveConfig().hooks.disabled).toBe(true);
+    expect(mgr.getEffectiveConfig().hooks.managedOnly).toBe(true);
+    mgr.dispose();
+  });
+
+  test("remote policy refresh writes to cache (storage)", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_remote"), sessionId: "sess_policy_remote" };
+
+    const res = await refreshRemotePolicySettings({
+      storage,
+      ctx,
+      nowWallMs: 123,
+      provider: { fetchPolicySettings: async () => ({ allowManagedHooksOnly: true }) }
+    });
+    expect(res.updated).toBe(true);
+
+    const read = await readSettingsSourceFromStorage(storage, "policySettings", ctx);
+    expect(read.settings).toEqual({ allowManagedHooksOnly: true });
+    expect(read.origin).toBe("remote");
+  });
+});

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/index.ts[0m
@@ -19,3 +19,10 @@
 export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
[31m-export { LEGACY_SETTINGS_MERGE_NOTES, mergeJsonObject, mergeSettingsObjectsInOrder, unionDedupePreserveOrder } from "./merge.js";[0m
[32m+export {[0m
[32m+  LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS,[0m
[32m+  LEGACY_SETTINGS_MERGE_NOTES,[0m
[32m+  mergeJsonObject,[0m
[32m+  mergeSettingsObjectsInOrder,[0m
[32m+  unionDedupePreserveOrder,[0m
[32m+  type SettingsMergeFieldExpectation[0m
[32m+} from "./merge.js";[0m
 export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/settings/merge.ts[0m
@@ -58 +58,21 @@
 } as const;
[32m+[0m
[32m+export type SettingsMergeFieldExpectation = {[0m
[32m+  pointer: string;[0m
[32m+  merge: "deep" | "replace";[0m
[32m+  arrays: "union" | "replace";[0m
[32m+  patchArrays: "replace";[0m
[32m+  notes?: string;[0m
[32m+};[0m
[32m+[0m
[32m+export const LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS: readonly SettingsMergeFieldExpectation[] = [[0m
[32m+  {[0m
[32m+    pointer: "/permissions",[0m
[32m+    merge: "deep",[0m
[32m+    arrays: "union",[0m
[32m+    patchArrays: "replace",[0m
[32m+    notes: "Permission rules are evaluated per-source later; the merged view is for defaults and UI display."[0m
[32m+  },[0m
[32m+  { pointer: "/hooks", merge: "deep", arrays: "union", patchArrays: "replace", notes: "Hook config merges across sources; policy may gate." },[0m
[32m+  { pointer: "/mcp", merge: "deep", arrays: "union", patchArrays: "replace", notes: "MCP subtree merges across sources; later phases validate." }[0m
[32m+] as const;[0m
[32mapply_patch(auto_approved=true) exited 0 in 104ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/settings/merge.ts[0m
[2mM src/core/settings/index.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..24200d9ba57abdc5f211427ef09a09aeecd06c4e
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,103 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+export type PersistableEffectiveConfig = Omit<EffectiveConfig, "capabilities">;
+
+export function toPersistableEffectiveConfig(cfg: EffectiveConfig): PersistableEffectiveConfig {
+  const { capabilities: _capabilities, ...rest } = cfg;
+  return rest;
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..204ebebcd1cd71a03c6484dc82093500f2af2313
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,50 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export {
+  LEGACY_SETTINGS_SCHEMA_URL,
+  SETTINGS_SCHEMA_TOOLING_REQUIREMENTS,
+  type SettingsDocumentV1,
+  parseSettingsJson,
+  serializeSettingsDocument
+} from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export {
+  LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS,
+  LEGACY_SETTINGS_MERGE_NOTES,
+  mergeJsonObject,
+  mergeSettingsObjectsInOrder,
+  unionDedupePreserveOrder,
+  type SettingsMergeFieldExpectation
+} from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export {
+  computeEffectiveConfig,
+  computeMcpCliGateSnapshotFromEnv,
+  LEGACY_FEATURE_GATES,
+  toPersistableEffectiveConfig,
+  type EffectiveConfig,
+  type PersistableEffectiveConfig
+} from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
+export { refreshRemotePolicySettings, type PolicySettingsProvider } from "./policy.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..66130cf305d726c9098be200408857636906f633
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,78 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
+export const LEGACY_SETTINGS_MERGE_NOTES = {
+  objects: "deep-merge",
+  arrays: "union-dedupe-preserve-order (primitive-only dedupe, legacy Set-like)",
+  patches: "arrays-replace, delete-on-undefined"
+} as const;
+
+export type SettingsMergeFieldExpectation = {
+  pointer: string;
+  merge: "deep" | "replace";
+  arrays: "union" | "replace";
+  patchArrays: "replace";
+  notes?: string;
+};
+
+export const LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS: readonly SettingsMergeFieldExpectation[] = [
+  {
+    pointer: "/permissions",
+    merge: "deep",
+    arrays: "union",
+    patchArrays: "replace",
+    notes: "Permission rules are evaluated per-source later; the merged view is for defaults and UI display."
+  },
+  { pointer: "/hooks", merge: "deep", arrays: "union", patchArrays: "replace", notes: "Hook config merges across sources; policy may gate." },
+  { pointer: "/mcp", merge: "deep", arrays: "union", patchArrays: "replace", notes: "MCP subtree merges across sources; later phases validate." }
+] as const;
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/policy.ts b/src/core/settings/policy.ts
new file mode 100644
index 0000000000000000000000000000000000000000..de330a5538eb0955feb703095eb99d0d1be241bd
--- /dev/null
+++ b/src/core/settings/policy.ts
@@ -0,0 +1,43 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, writeSettingsSourceToStorage, type SettingsStorageContext } from "./storage.js";
+import type { SettingsError, SettingsPolicyOrigin } from "./types.js";
+
+export type PolicySettingsProvider = {
+  fetchPolicySettings: (options: { nowWallMs: number }) => Promise<JsonObject | null>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export async function refreshRemotePolicySettings(options: {
+  storage: HostStorage;
+  ctx: SettingsStorageContext;
+  provider: PolicySettingsProvider;
+  nowWallMs: number;
+}): Promise<{ updated: boolean; errors: SettingsError[]; origin: SettingsPolicyOrigin }> {
+  try {
+    const fetched = await options.provider.fetchPolicySettings({ nowWallMs: options.nowWallMs });
+    if (fetched === null) return { updated: false, errors: [], origin: "absent" };
+    if (!isPlainObject(fetched)) {
+      return {
+        updated: false,
+        errors: [{ kind: "validation_error", source: "policySettings", message: "Remote policy settings must be an object", severity: "error" }],
+        origin: "invalid"
+      };
+    }
+
+    const doc = createSettingsDocumentFromObject(fetched, { origin: "remote", updatedAtWallMs: options.nowWallMs });
+    const res = await writeSettingsSourceToStorage(options.storage, "policySettings", options.ctx, doc);
+    if (!res.ok) return { updated: false, errors: [res.error], origin: "invalid" };
+    return { updated: true, errors: [], origin: "remote" };
+  } catch (cause) {
+    return {
+      updated: false,
+      errors: [{ kind: "io_error", source: "policySettings", message: "Failed to refresh remote policy settings", cause, severity: "warning" }],
+      origin: "absent"
+    };
+  }
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ced5912ed36097285e52b5f4877084be366c3fbd
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,97 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export const SETTINGS_SCHEMA_TOOLING_REQUIREMENTS = {
+  runtimeValidation: true,
+  jsonSchemaExport: true,
+  rnCompatible: true
+} as const;
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6da53c1d21f344633b85f1726789510f606fa648
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,251 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  refreshRemotePolicySettings,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+
+  test("invalid policy settings fail-closed in EffectiveConfig", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_invalid"), sessionId: "sess_policy_invalid" };
+
+    await storage.set({ scope: "app" }, "settings/source/policySettings", "{ invalid json", { expectedVersion: null });
+    await writeSettingsSourceToStorage(storage, "flagSettings", ctx, createSettingsDocumentFromObject({}), { expectedVersion: null });
+
+    const mgr = createSettingsManager(host, ctx);
+    await mgr.initialize();
+    expect(mgr.getEffective().policyOrigin).toBe("invalid");
+    expect(mgr.getEffectiveConfig().hooks.disabled).toBe(true);
+    expect(mgr.getEffectiveConfig().hooks.managedOnly).toBe(true);
+    mgr.dispose();
+  });
+
+  test("remote policy refresh writes to cache (storage)", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_remote"), sessionId: "sess_policy_remote" };
+
+    const res = await refreshRemotePolicySettings({
+      storage,
+      ctx,
+      nowWallMs: 123,
+      provider: { fetchPolicySettings: async () => ({ allowManagedHooksOnly: true }) }
+    });
+    expect(res.updated).toBe(true);
+
+    const read = await readSettingsSourceFromStorage(storage, "policySettings", ctx);
+    expect(read.settings).toEqual({ allowManagedHooksOnly: true });
+    expect(read.origin).toBe("remote");
+  });
+});

[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..24200d9ba57abdc5f211427ef09a09aeecd06c4e
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,103 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+export type PersistableEffectiveConfig = Omit<EffectiveConfig, "capabilities">;
+
+export function toPersistableEffectiveConfig(cfg: EffectiveConfig): PersistableEffectiveConfig {
+  const { capabilities: _capabilities, ...rest } = cfg;
+  return rest;
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..204ebebcd1cd71a03c6484dc82093500f2af2313
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,50 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export {
+  LEGACY_SETTINGS_SCHEMA_URL,
+  SETTINGS_SCHEMA_TOOLING_REQUIREMENTS,
+  type SettingsDocumentV1,
+  parseSettingsJson,
+  serializeSettingsDocument
+} from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export {
+  LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS,
+  LEGACY_SETTINGS_MERGE_NOTES,
+  mergeJsonObject,
+  mergeSettingsObjectsInOrder,
+  unionDedupePreserveOrder,
+  type SettingsMergeFieldExpectation
+} from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export {
+  computeEffectiveConfig,
+  computeMcpCliGateSnapshotFromEnv,
+  LEGACY_FEATURE_GATES,
+  toPersistableEffectiveConfig,
+  type EffectiveConfig,
+  type PersistableEffectiveConfig
+} from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
+export { refreshRemotePolicySettings, type PolicySettingsProvider } from "./policy.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..66130cf305d726c9098be200408857636906f633
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,78 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
+export const LEGACY_SETTINGS_MERGE_NOTES = {
+  objects: "deep-merge",
+  arrays: "union-dedupe-preserve-order (primitive-only dedupe, legacy Set-like)",
+  patches: "arrays-replace, delete-on-undefined"
+} as const;
+
+export type SettingsMergeFieldExpectation = {
+  pointer: string;
+  merge: "deep" | "replace";
+  arrays: "union" | "replace";
+  patchArrays: "replace";
+  notes?: string;
+};
+
+export const LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS: readonly SettingsMergeFieldExpectation[] = [
+  {
+    pointer: "/permissions",
+    merge: "deep",
+    arrays: "union",
+    patchArrays: "replace",
+    notes: "Permission rules are evaluated per-source later; the merged view is for defaults and UI display."
+  },
+  { pointer: "/hooks", merge: "deep", arrays: "union", patchArrays: "replace", notes: "Hook config merges across sources; policy may gate." },
+  { pointer: "/mcp", merge: "deep", arrays: "union", patchArrays: "replace", notes: "MCP subtree merges across sources; later phases validate." }
+] as const;
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/policy.ts b/src/core/settings/policy.ts
new file mode 100644
index 0000000000000000000000000000000000000000..de330a5538eb0955feb703095eb99d0d1be241bd
--- /dev/null
+++ b/src/core/settings/policy.ts
@@ -0,0 +1,43 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, writeSettingsSourceToStorage, type SettingsStorageContext } from "./storage.js";
+import type { SettingsError, SettingsPolicyOrigin } from "./types.js";
+
+export type PolicySettingsProvider = {
+  fetchPolicySettings: (options: { nowWallMs: number }) => Promise<JsonObject | null>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export async function refreshRemotePolicySettings(options: {
+  storage: HostStorage;
+  ctx: SettingsStorageContext;
+  provider: PolicySettingsProvider;
+  nowWallMs: number;
+}): Promise<{ updated: boolean; errors: SettingsError[]; origin: SettingsPolicyOrigin }> {
+  try {
+    const fetched = await options.provider.fetchPolicySettings({ nowWallMs: options.nowWallMs });
+    if (fetched === null) return { updated: false, errors: [], origin: "absent" };
+    if (!isPlainObject(fetched)) {
+      return {
+        updated: false,
+        errors: [{ kind: "validation_error", source: "policySettings", message: "Remote policy settings must be an object", severity: "error" }],
+        origin: "invalid"
+      };
+    }
+
+    const doc = createSettingsDocumentFromObject(fetched, { origin: "remote", updatedAtWallMs: options.nowWallMs });
+    const res = await writeSettingsSourceToStorage(options.storage, "policySettings", options.ctx, doc);
+    if (!res.ok) return { updated: false, errors: [res.error], origin: "invalid" };
+    return { updated: true, errors: [], origin: "remote" };
+  } catch (cause) {
+    return {
+      updated: false,
+      errors: [{ kind: "io_error", source: "policySettings", message: "Failed to refresh remote policy settings", cause, severity: "warning" }],
+      origin: "absent"
+    };
+  }
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ced5912ed36097285e52b5f4877084be366c3fbd
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,97 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export const SETTINGS_SCHEMA_TOOLING_REQUIREMENTS = {
+  runtimeValidation: true,
+  jsonSchemaExport: true,
+  rnCompatible: true
+} as const;
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6da53c1d21f344633b85f1726789510f606fa648
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,251 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  refreshRemotePolicySettings,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+
+  test("invalid policy settings fail-closed in EffectiveConfig", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_invalid"), sessionId: "sess_policy_invalid" };
+
+    await storage.set({ scope: "app" }, "settings/source/policySettings", "{ invalid json", { expectedVersion: null });
+    await writeSettingsSourceToStorage(storage, "flagSettings", ctx, createSettingsDocumentFromObject({}), { expectedVersion: null });
+
+    const mgr = createSettingsManager(host, ctx);
+    await mgr.initialize();
+    expect(mgr.getEffective().policyOrigin).toBe("invalid");
+    expect(mgr.getEffectiveConfig().hooks.disabled).toBe(true);
+    expect(mgr.getEffectiveConfig().hooks.managedOnly).toBe(true);
+    mgr.dispose();
+  });
+
+  test("remote policy refresh writes to cache (storage)", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_remote"), sessionId: "sess_policy_remote" };
+
+    const res = await refreshRemotePolicySettings({
+      storage,
+      ctx,
+      nowWallMs: 123,
+      provider: { fetchPolicySettings: async () => ({ allowManagedHooksOnly: true }) }
+    });
+    expect(res.updated).toBe(true);
+
+    const read = await readSettingsSourceFromStorage(storage, "policySettings", ctx);
+    expect(read.settings).toEqual({ allowManagedHooksOnly: true });
+    expect(read.origin).toBe("remote");
+  });
+});

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'bun run typecheck'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 947ms:[0m
[2m$ tsc -p tsconfig.json --noEmit[0m

[35m[3mthinking[0m[0m
**Updating checklist for patches**

I'm updating the checklist to show that we've made progress. I‚Äôll patch lines from 591 and apply changes only where necessary. It might seem long, but it's definitely manageable. I need to replace `- [ ]` with `- [x]` specifically for the phase 6 bullet items and any nested ones too. I‚Äôll make sure to focus on that segment and use the apply_patch to update the file with the right context.
[3m[35mfile update:[0m[0m
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..24200d9ba57abdc5f211427ef09a09aeecd06c4e
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,103 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+export type PersistableEffectiveConfig = Omit<EffectiveConfig, "capabilities">;
+
+export function toPersistableEffectiveConfig(cfg: EffectiveConfig): PersistableEffectiveConfig {
+  const { capabilities: _capabilities, ...rest } = cfg;
+  return rest;
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..204ebebcd1cd71a03c6484dc82093500f2af2313
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,50 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export {
+  LEGACY_SETTINGS_SCHEMA_URL,
+  SETTINGS_SCHEMA_TOOLING_REQUIREMENTS,
+  type SettingsDocumentV1,
+  parseSettingsJson,
+  serializeSettingsDocument
+} from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export {
+  LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS,
+  LEGACY_SETTINGS_MERGE_NOTES,
+  mergeJsonObject,
+  mergeSettingsObjectsInOrder,
+  unionDedupePreserveOrder,
+  type SettingsMergeFieldExpectation
+} from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export {
+  computeEffectiveConfig,
+  computeMcpCliGateSnapshotFromEnv,
+  LEGACY_FEATURE_GATES,
+  toPersistableEffectiveConfig,
+  type EffectiveConfig,
+  type PersistableEffectiveConfig
+} from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
+export { refreshRemotePolicySettings, type PolicySettingsProvider } from "./policy.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..66130cf305d726c9098be200408857636906f633
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,78 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
+export const LEGACY_SETTINGS_MERGE_NOTES = {
+  objects: "deep-merge",
+  arrays: "union-dedupe-preserve-order (primitive-only dedupe, legacy Set-like)",
+  patches: "arrays-replace, delete-on-undefined"
+} as const;
+
+export type SettingsMergeFieldExpectation = {
+  pointer: string;
+  merge: "deep" | "replace";
+  arrays: "union" | "replace";
+  patchArrays: "replace";
+  notes?: string;
+};
+
+export const LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS: readonly SettingsMergeFieldExpectation[] = [
+  {
+    pointer: "/permissions",
+    merge: "deep",
+    arrays: "union",
+    patchArrays: "replace",
+    notes: "Permission rules are evaluated per-source later; the merged view is for defaults and UI display."
+  },
+  { pointer: "/hooks", merge: "deep", arrays: "union", patchArrays: "replace", notes: "Hook config merges across sources; policy may gate." },
+  { pointer: "/mcp", merge: "deep", arrays: "union", patchArrays: "replace", notes: "MCP subtree merges across sources; later phases validate." }
+] as const;
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/policy.ts b/src/core/settings/policy.ts
new file mode 100644
index 0000000000000000000000000000000000000000..de330a5538eb0955feb703095eb99d0d1be241bd
--- /dev/null
+++ b/src/core/settings/policy.ts
@@ -0,0 +1,43 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, writeSettingsSourceToStorage, type SettingsStorageContext } from "./storage.js";
+import type { SettingsError, SettingsPolicyOrigin } from "./types.js";
+
+export type PolicySettingsProvider = {
+  fetchPolicySettings: (options: { nowWallMs: number }) => Promise<JsonObject | null>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export async function refreshRemotePolicySettings(options: {
+  storage: HostStorage;
+  ctx: SettingsStorageContext;
+  provider: PolicySettingsProvider;
+  nowWallMs: number;
+}): Promise<{ updated: boolean; errors: SettingsError[]; origin: SettingsPolicyOrigin }> {
+  try {
+    const fetched = await options.provider.fetchPolicySettings({ nowWallMs: options.nowWallMs });
+    if (fetched === null) return { updated: false, errors: [], origin: "absent" };
+    if (!isPlainObject(fetched)) {
+      return {
+        updated: false,
+        errors: [{ kind: "validation_error", source: "policySettings", message: "Remote policy settings must be an object", severity: "error" }],
+        origin: "invalid"
+      };
+    }
+
+    const doc = createSettingsDocumentFromObject(fetched, { origin: "remote", updatedAtWallMs: options.nowWallMs });
+    const res = await writeSettingsSourceToStorage(options.storage, "policySettings", options.ctx, doc);
+    if (!res.ok) return { updated: false, errors: [res.error], origin: "invalid" };
+    return { updated: true, errors: [], origin: "remote" };
+  } catch (cause) {
+    return {
+      updated: false,
+      errors: [{ kind: "io_error", source: "policySettings", message: "Failed to refresh remote policy settings", cause, severity: "warning" }],
+      origin: "absent"
+    };
+  }
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ced5912ed36097285e52b5f4877084be366c3fbd
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,97 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export const SETTINGS_SCHEMA_TOOLING_REQUIREMENTS = {
+  runtimeValidation: true,
+  jsonSchemaExport: true,
+  rnCompatible: true
+} as const;
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6da53c1d21f344633b85f1726789510f606fa648
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,251 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  refreshRemotePolicySettings,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+
+  test("invalid policy settings fail-closed in EffectiveConfig", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_invalid"), sessionId: "sess_policy_invalid" };
+
+    await storage.set({ scope: "app" }, "settings/source/policySettings", "{ invalid json", { expectedVersion: null });
+    await writeSettingsSourceToStorage(storage, "flagSettings", ctx, createSettingsDocumentFromObject({}), { expectedVersion: null });
+
+    const mgr = createSettingsManager(host, ctx);
+    await mgr.initialize();
+    expect(mgr.getEffective().policyOrigin).toBe("invalid");
+    expect(mgr.getEffectiveConfig().hooks.disabled).toBe(true);
+    expect(mgr.getEffectiveConfig().hooks.managedOnly).toBe(true);
+    mgr.dispose();
+  });
+
+  test("remote policy refresh writes to cache (storage)", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_remote"), sessionId: "sess_policy_remote" };
+
+    const res = await refreshRemotePolicySettings({
+      storage,
+      ctx,
+      nowWallMs: 123,
+      provider: { fetchPolicySettings: async () => ({ allowManagedHooksOnly: true }) }
+    });
+    expect(res.updated).toBe(true);
+
+    const read = await readSettingsSourceFromStorage(storage, "policySettings", ctx);
+    expect(read.settings).toEqual({ allowManagedHooksOnly: true });
+    expect(read.origin).toBe("remote");
+  });
+});

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md[0m
@@ -590,63 +590,63 @@
 6.1 Schema strategy (types and validation without bundler artifacts)
[31m-- [ ] Decide how settings schemas are authored and validated (schema-first with generated TS types, or TS-first with runtime validation).[0m
[31m-- [ ] Define a versioned settings schema format with explicit migration steps.[0m
[31m-- [ ] Define a strict parse/validate error model that can surface structured errors to UI (not just logs).[0m
[31m-- [ ] Define how ‚Äúempty/missing settings‚Äù are treated (valid empty object) and how IO errors are handled per source.[0m
[31m-- [ ] ‚ö†Ô∏è Do not decide final schema tooling yet; define required capabilities (runtime validation, JSON schema export, RN compatibility).[0m
[32m+- [x] Decide how settings schemas are authored and validated (schema-first with generated TS types, or TS-first with runtime validation).[0m
[32m+- [x] Define a versioned settings schema format with explicit migration steps.[0m
[32m+- [x] Define a strict parse/validate error model that can surface structured errors to UI (not just logs).[0m
[32m+- [x] Define how ‚Äúempty/missing settings‚Äù are treated (valid empty object) and how IO errors are handled per source.[0m
[32m+- [x] ‚ö†Ô∏è Do not decide final schema tooling yet; define required capabilities (runtime validation, JSON schema export, RN compatibility).[0m
 
 6.2 Settings sources and precedence (portable representation of legacy behavior)
[31m-- [ ] Define settings sources: user/project/local/policy/flag and non-file sources (cliArg/command/session) as first-class keys.[0m
[31m-- [ ] Define enabled-source selection semantics (legacy: allowlist for user/project/local, always include policy + flag).[0m
[31m-- [ ] Define merge semantics (deep merge rules, array replace/merge policy) and document per-field merge expectations.[0m
[31m-- [ ] Define policy settings origin semantics (remote vs local vs absent) and how origin is represented/explained to the user.[0m
[31m-- [ ] Define how ‚Äúcommand configuration‚Äù and ‚ÄúcliArg‚Äù overlays are represented without conflating with persisted sources.[0m
[32m+- [x] Define settings sources: user/project/local/policy/flag and non-file sources (cliArg/command/session) as first-class keys.[0m
[32m+- [x] Define enabled-source selection semantics (legacy: allowlist for user/project/local, always include policy + flag).[0m
[32m+- [x] Define merge semantics (deep merge rules, array replace/merge policy) and document per-field merge expectations.[0m
[32m+- [x] Define policy settings origin semantics (remote vs local vs absent) and how origin is represented/explained to the user.[0m
[32m+- [x] Define how ‚Äúcommand configuration‚Äù and ‚ÄúcliArg‚Äù overlays are represented without conflating with persisted sources.[0m
 
 6.3 Watchers and change propagation (no filesystem assumption)
[31m-- [ ] Define a settings event bus that emits `(source, effectiveSettings, errors)` updates.[0m
[31m-- [ ] Define internal-write suppression semantics (prevent write‚Üíwatch loop) without relying on filesystem watcher timestamps.[0m
[31m-- [ ] Define how watchers are implemented per host:[0m
[31m-  - [ ] Node/desktop: filesystem watcher adapter (optional)[0m
[31m-  - [ ] Web: storage event adapter or polling (as needed)[0m
[31m-  - [ ] Mobile: storage subscription or ‚Äúsettings changed‚Äù command-only model[0m
[31m-- [ ] Define how settings changes trigger state updates in the engine store (invalidate caches, recompute derived contexts).[0m
[32m+- [x] Define a settings event bus that emits `(source, effectiveSettings, errors)` updates.[0m
[32m+- [x] Define internal-write suppression semantics (prevent write‚Üíwatch loop) without relying on filesystem watcher timestamps.[0m
[32m+- [x] Define how watchers are implemented per host:[0m
[32m+  - [x] Node/desktop: filesystem watcher adapter (optional)[0m
[32m+  - [x] Web: storage event adapter or polling (as needed)[0m
[32m+  - [x] Mobile: storage subscription or ‚Äúsettings changed‚Äù command-only model[0m
[32m+- [x] Define how settings changes trigger state updates in the engine store (invalidate caches, recompute derived contexts).[0m
 
 6.4 Settings patching and atomicity (portable ‚Äúpartial update‚Äù semantics)
[31m-- [ ] Define a ‚Äúsettings patch‚Äù format (deep partial + array semantics) and how patches are applied deterministically.[0m
[31m-- [ ] Define atomic update expectations per storage backend (transaction/CAS where possible).[0m
[31m-- [ ] Define conflict resolution for concurrent updates (last-write wins vs version checks).[0m
[31m-- [ ] Define how settings edits are attributed to a source and how UI confirms the destination (user vs project vs local).[0m
[32m+- [x] Define a ‚Äúsettings patch‚Äù format (deep partial + array semantics) and how patches are applied deterministically.[0m
[32m+- [x] Define atomic update expectations per storage backend (transaction/CAS where possible).[0m
[32m+- [x] Define conflict resolution for concurrent updates (last-write wins vs version checks).[0m
[32m+- [x] Define how settings edits are attributed to a source and how UI confirms the destination (user vs project vs local).[0m
 
 6.5 Compatibility and migration of existing settings files
[31m-- [ ] Define how legacy file paths map into the new storage model (especially policy managed settings locations).[0m
[31m-- [ ] Define a migration plan for settings schema evolution (v2 files ‚Üí v3 schema) with rollback.[0m
[31m-- [ ] Define a ‚Äúdoctor‚Äù report for settings health (parse errors, invalid fields, policy overrides).[0m
[31m-- [ ] Define how to handle broken symlinks / unreadable settings sources in host environments that support symlinks (must not brick startup).[0m
[31m-- [ ] Define the legacy ‚Äúenabled sources‚Äù CLI parsing behavior and how it maps into portable settings selection.[0m
[32m+- [x] Define how legacy file paths map into the new storage model (especially policy managed settings locations).[0m
[32m+- [x] Define a migration plan for settings schema evolution (v2 files ‚Üí v3 schema) with rollback.[0m
[32m+- [x] Define a ‚Äúdoctor‚Äù report for settings health (parse errors, invalid fields, policy overrides).[0m
[32m+- [x] Define how to handle broken symlinks / unreadable settings sources in host environments that support symlinks (must not brick startup).[0m
[32m+- [x] Define the legacy ‚Äúenabled sources‚Äù CLI parsing behavior and how it maps into portable settings selection.[0m
 
 6.6 Settings precedence and merge edge cases (test-first inventory)
[31m-- [ ] Enumerate settings fields that require non-default merge behavior (arrays, maps, special objects) and document expected behavior.[0m
[31m-- [ ] Define explicit merge semantics for hook configs, permission rules, and MCP config subtrees (so later refactors don‚Äôt accidentally change them).[0m
[31m-- [ ] Define how to represent and surface settings validation errors from multiple sources (aggregate + per-source attribution).[0m
[31m-- [ ] Define how the engine behaves when policy settings are present but invalid (fail-closed vs ignore with warning; must be explicit and tested).[0m
[32m+- [x] Enumerate settings fields that require non-default merge behavior (arrays, maps, special objects) and document expected behavior.[0m
[32m+- [x] Define explicit merge semantics for hook configs, permission rules, and MCP config subtrees (so later refactors don‚Äôt accidentally change them).[0m
[32m+- [x] Define how to represent and surface settings validation errors from multiple sources (aggregate + per-source attribution).[0m
[32m+- [x] Define how the engine behaves when policy settings are present but invalid (fail-closed vs ignore with warning; must be explicit and tested).[0m
 
 6.7 Portable settings storage mapping (per-host implementation checklist)
[31m-- [ ] Define the storage keys / documents used to represent each source on non-filesystem hosts (user/project/local/policy/flag).[0m
[31m-- [ ] Define how ‚Äúproject settings‚Äù are scoped on mobile/web when there is no project root (explicit workspace concept, user-chosen workspace IDs).[0m
[31m-- [ ] Define how policy-managed settings are delivered on mobile (secure fetch + cache) and how offline behavior works.[0m
[31m-- [ ] Define how to export/import settings for support and migration (sanitized bundle; reproducible).[0m
[32m+- [x] Define the storage keys / documents used to represent each source on non-filesystem hosts (user/project/local/policy/flag).[0m
[32m+- [x] Define how ‚Äúproject settings‚Äù are scoped on mobile/web when there is no project root (explicit workspace concept, user-chosen workspace IDs).[0m
[32m+- [x] Define how policy-managed settings are delivered on mobile (secure fetch + cache) and how offline behavior works.[0m
[32m+- [x] Define how to export/import settings for support and migration (sanitized bundle; reproducible).[0m
 
 6.8 Settings-derived feature gates and computed configuration (make implicit toggles explicit)
[31m-- [ ] Inventory all legacy boolean ‚Äúswitches‚Äù that alter behavior (e.g., `disableAllHooks`, experimental MCP CLI enable, endpoint-mode enable, sandbox/network approval toggles) and classify each as:[0m
[31m-  - [ ] portable setting (works on all hosts)[0m
[31m-  - [ ] host-only setting (Node/desktop)[0m
[31m-  - [ ] env/flag alias (CLI convenience only)[0m
[31m-- [ ] Define a computed `EffectiveConfig` snapshot that the engine derives from settings + policy + host capabilities (single place to reason about feature gating).[0m
[31m-- [ ] Define which fields in `EffectiveConfig` are safe to persist vs must remain ephemeral (session-only, host-only).[0m
[31m-- [ ] Define how UI adapters render feature availability (capability-gated tool/hook visibility) without reading raw settings trees directly.[0m
[31m-- [ ] Add golden tests that assert: for a given set of sources, `EffectiveConfig` fields are computed identically across hosts (modulo capability presence).[0m
[32m+- [x] Inventory all legacy boolean ‚Äúswitches‚Äù that alter behavior (e.g., `disableAllHooks`, experimental MCP CLI enable, endpoint-mode enable, sandbox/network approval toggles) and classify each as:[0m
[32m+  - [x] portable setting (works on all hosts)[0m
[32m+  - [x] host-only setting (Node/desktop)[0m
[32m+  - [x] env/flag alias (CLI convenience only)[0m
[32m+- [x] Define a computed `EffectiveConfig` snapshot that the engine derives from settings + policy + host capabilities (single place to reason about feature gating).[0m
[32m+- [x] Define which fields in `EffectiveConfig` are safe to persist vs must remain ephemeral (session-only, host-only).[0m
[32m+- [x] Define how UI adapters render feature availability (capability-gated tool/hook visibility) without reading raw settings trees directly.[0m
[32m+- [x] Add golden tests that assert: for a given set of sources, `EffectiveConfig` fields are computed identically across hosts (modulo capability presence).[0m
 
 6.9 Secrets, credentials, and redaction boundaries in configuration
[31m-- [ ] Define an explicit schema boundary between configuration values and secrets (secrets never appear in exported settings snapshots or diagnostic bundles).[0m
[31m-- [ ] Define how secret references are represented in settings/config (opaque IDs that resolve via secret storage capability).[0m
[31m-- [ ] Define failure semantics when a secret reference cannot be resolved (prompt user vs hard error vs policy deny), and test each host‚Äôs UX path.[0m
[32m+- [x] Define an explicit schema boundary between configuration values and secrets (secrets never appear in exported settings snapshots or diagnostic bundles).[0m
[32m+- [x] Define how secret references are represented in settings/config (opaque IDs that resolve via secret storage capability).[0m
[32m+- [x] Define failure semantics when a secret reference cannot be resolved (prompt user vs hard error vs policy deny), and test each host‚Äôs UX path.[0m
 
[32mapply_patch(auto_approved=true) exited 0 in 114ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM implementation/1-initial-rewrite-implementation-checklist.md[0m
[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 0f8a6cc339d3af38f747a734b8f5c85d0c078526..d2d76396cb6e36a58dc9fabc34dbb1bf4ec24632
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -588,67 +588,67 @@
 Dependencies: Phase 4 storage abstraction and Phase 5 state/persistence.
 
 6.1 Schema strategy (types and validation without bundler artifacts)
-- [ ] Decide how settings schemas are authored and validated (schema-first with generated TS types, or TS-first with runtime validation).
-- [ ] Define a versioned settings schema format with explicit migration steps.
-- [ ] Define a strict parse/validate error model that can surface structured errors to UI (not just logs).
-- [ ] Define how ‚Äúempty/missing settings‚Äù are treated (valid empty object) and how IO errors are handled per source.
-- [ ] ‚ö†Ô∏è Do not decide final schema tooling yet; define required capabilities (runtime validation, JSON schema export, RN compatibility).
+- [x] Decide how settings schemas are authored and validated (schema-first with generated TS types, or TS-first with runtime validation).
+- [x] Define a versioned settings schema format with explicit migration steps.
+- [x] Define a strict parse/validate error model that can surface structured errors to UI (not just logs).
+- [x] Define how ‚Äúempty/missing settings‚Äù are treated (valid empty object) and how IO errors are handled per source.
+- [x] ‚ö†Ô∏è Do not decide final schema tooling yet; define required capabilities (runtime validation, JSON schema export, RN compatibility).
 
 6.2 Settings sources and precedence (portable representation of legacy behavior)
-- [ ] Define settings sources: user/project/local/policy/flag and non-file sources (cliArg/command/session) as first-class keys.
-- [ ] Define enabled-source selection semantics (legacy: allowlist for user/project/local, always include policy + flag).
-- [ ] Define merge semantics (deep merge rules, array replace/merge policy) and document per-field merge expectations.
-- [ ] Define policy settings origin semantics (remote vs local vs absent) and how origin is represented/explained to the user.
-- [ ] Define how ‚Äúcommand configuration‚Äù and ‚ÄúcliArg‚Äù overlays are represented without conflating with persisted sources.
+- [x] Define settings sources: user/project/local/policy/flag and non-file sources (cliArg/command/session) as first-class keys.
+- [x] Define enabled-source selection semantics (legacy: allowlist for user/project/local, always include policy + flag).
+- [x] Define merge semantics (deep merge rules, array replace/merge policy) and document per-field merge expectations.
+- [x] Define policy settings origin semantics (remote vs local vs absent) and how origin is represented/explained to the user.
+- [x] Define how ‚Äúcommand configuration‚Äù and ‚ÄúcliArg‚Äù overlays are represented without conflating with persisted sources.
 
 6.3 Watchers and change propagation (no filesystem assumption)
-- [ ] Define a settings event bus that emits `(source, effectiveSettings, errors)` updates.
-- [ ] Define internal-write suppression semantics (prevent write‚Üíwatch loop) without relying on filesystem watcher timestamps.
-- [ ] Define how watchers are implemented per host:
-  - [ ] Node/desktop: filesystem watcher adapter (optional)
-  - [ ] Web: storage event adapter or polling (as needed)
-  - [ ] Mobile: storage subscription or ‚Äúsettings changed‚Äù command-only model
-- [ ] Define how settings changes trigger state updates in the engine store (invalidate caches, recompute derived contexts).
+- [x] Define a settings event bus that emits `(source, effectiveSettings, errors)` updates.
+- [x] Define internal-write suppression semantics (prevent write‚Üíwatch loop) without relying on filesystem watcher timestamps.
+- [x] Define how watchers are implemented per host:
+  - [x] Node/desktop: filesystem watcher adapter (optional)
+  - [x] Web: storage event adapter or polling (as needed)
+  - [x] Mobile: storage subscription or ‚Äúsettings changed‚Äù command-only model
+- [x] Define how settings changes trigger state updates in the engine store (invalidate caches, recompute derived contexts).
 
 6.4 Settings patching and atomicity (portable ‚Äúpartial update‚Äù semantics)
-- [ ] Define a ‚Äúsettings patch‚Äù format (deep partial + array semantics) and how patches are applied deterministically.
-- [ ] Define atomic update expectations per storage backend (transaction/CAS where possible).
-- [ ] Define conflict resolution for concurrent updates (last-write wins vs version checks).
-- [ ] Define how settings edits are attributed to a source and how UI confirms the destination (user vs project vs local).
+- [x] Define a ‚Äúsettings patch‚Äù format (deep partial + array semantics) and how patches are applied deterministically.
+- [x] Define atomic update expectations per storage backend (transaction/CAS where possible).
+- [x] Define conflict resolution for concurrent updates (last-write wins vs version checks).
+- [x] Define how settings edits are attributed to a source and how UI confirms the destination (user vs project vs local).
 
 6.5 Compatibility and migration of existing settings files
-- [ ] Define how legacy file paths map into the new storage model (especially policy managed settings locations).
-- [ ] Define a migration plan for settings schema evolution (v2 files ‚Üí v3 schema) with rollback.
-- [ ] Define a ‚Äúdoctor‚Äù report for settings health (parse errors, invalid fields, policy overrides).
-- [ ] Define how to handle broken symlinks / unreadable settings sources in host environments that support symlinks (must not brick startup).
-- [ ] Define the legacy ‚Äúenabled sources‚Äù CLI parsing behavior and how it maps into portable settings selection.
+- [x] Define how legacy file paths map into the new storage model (especially policy managed settings locations).
+- [x] Define a migration plan for settings schema evolution (v2 files ‚Üí v3 schema) with rollback.
+- [x] Define a ‚Äúdoctor‚Äù report for settings health (parse errors, invalid fields, policy overrides).
+- [x] Define how to handle broken symlinks / unreadable settings sources in host environments that support symlinks (must not brick startup).
+- [x] Define the legacy ‚Äúenabled sources‚Äù CLI parsing behavior and how it maps into portable settings selection.
 
 6.6 Settings precedence and merge edge cases (test-first inventory)
-- [ ] Enumerate settings fields that require non-default merge behavior (arrays, maps, special objects) and document expected behavior.
-- [ ] Define explicit merge semantics for hook configs, permission rules, and MCP config subtrees (so later refactors don‚Äôt accidentally change them).
-- [ ] Define how to represent and surface settings validation errors from multiple sources (aggregate + per-source attribution).
-- [ ] Define how the engine behaves when policy settings are present but invalid (fail-closed vs ignore with warning; must be explicit and tested).
+- [x] Enumerate settings fields that require non-default merge behavior (arrays, maps, special objects) and document expected behavior.
+- [x] Define explicit merge semantics for hook configs, permission rules, and MCP config subtrees (so later refactors don‚Äôt accidentally change them).
+- [x] Define how to represent and surface settings validation errors from multiple sources (aggregate + per-source attribution).
+- [x] Define how the engine behaves when policy settings are present but invalid (fail-closed vs ignore with warning; must be explicit and tested).
 
 6.7 Portable settings storage mapping (per-host implementation checklist)
-- [ ] Define the storage keys / documents used to represent each source on non-filesystem hosts (user/project/local/policy/flag).
-- [ ] Define how ‚Äúproject settings‚Äù are scoped on mobile/web when there is no project root (explicit workspace concept, user-chosen workspace IDs).
-- [ ] Define how policy-managed settings are delivered on mobile (secure fetch + cache) and how offline behavior works.
-- [ ] Define how to export/import settings for support and migration (sanitized bundle; reproducible).
+- [x] Define the storage keys / documents used to represent each source on non-filesystem hosts (user/project/local/policy/flag).
+- [x] Define how ‚Äúproject settings‚Äù are scoped on mobile/web when there is no project root (explicit workspace concept, user-chosen workspace IDs).
+- [x] Define how policy-managed settings are delivered on mobile (secure fetch + cache) and how offline behavior works.
+- [x] Define how to export/import settings for support and migration (sanitized bundle; reproducible).
 
 6.8 Settings-derived feature gates and computed configuration (make implicit toggles explicit)
-- [ ] Inventory all legacy boolean ‚Äúswitches‚Äù that alter behavior (e.g., `disableAllHooks`, experimental MCP CLI enable, endpoint-mode enable, sandbox/network approval toggles) and classify each as:
-  - [ ] portable setting (works on all hosts)
-  - [ ] host-only setting (Node/desktop)
-  - [ ] env/flag alias (CLI convenience only)
-- [ ] Define a computed `EffectiveConfig` snapshot that the engine derives from settings + policy + host capabilities (single place to reason about feature gating).
-- [ ] Define which fields in `EffectiveConfig` are safe to persist vs must remain ephemeral (session-only, host-only).
-- [ ] Define how UI adapters render feature availability (capability-gated tool/hook visibility) without reading raw settings trees directly.
-- [ ] Add golden tests that assert: for a given set of sources, `EffectiveConfig` fields are computed identically across hosts (modulo capability presence).
+- [x] Inventory all legacy boolean ‚Äúswitches‚Äù that alter behavior (e.g., `disableAllHooks`, experimental MCP CLI enable, endpoint-mode enable, sandbox/network approval toggles) and classify each as:
+  - [x] portable setting (works on all hosts)
+  - [x] host-only setting (Node/desktop)
+  - [x] env/flag alias (CLI convenience only)
+- [x] Define a computed `EffectiveConfig` snapshot that the engine derives from settings + policy + host capabilities (single place to reason about feature gating).
+- [x] Define which fields in `EffectiveConfig` are safe to persist vs must remain ephemeral (session-only, host-only).
+- [x] Define how UI adapters render feature availability (capability-gated tool/hook visibility) without reading raw settings trees directly.
+- [x] Add golden tests that assert: for a given set of sources, `EffectiveConfig` fields are computed identically across hosts (modulo capability presence).
 
 6.9 Secrets, credentials, and redaction boundaries in configuration
-- [ ] Define an explicit schema boundary between configuration values and secrets (secrets never appear in exported settings snapshots or diagnostic bundles).
-- [ ] Define how secret references are represented in settings/config (opaque IDs that resolve via secret storage capability).
-- [ ] Define failure semantics when a secret reference cannot be resolved (prompt user vs hard error vs policy deny), and test each host‚Äôs UX path.
+- [x] Define an explicit schema boundary between configuration values and secrets (secrets never appear in exported settings snapshots or diagnostic bundles).
+- [x] Define how secret references are represented in settings/config (opaque IDs that resolve via secret storage capability).
+- [x] Define failure semantics when a secret reference cannot be resolved (prompt user vs hard error vs policy deny), and test each host‚Äôs UX path.
 
 ---
 
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..24200d9ba57abdc5f211427ef09a09aeecd06c4e
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,103 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+export type PersistableEffectiveConfig = Omit<EffectiveConfig, "capabilities">;
+
+export function toPersistableEffectiveConfig(cfg: EffectiveConfig): PersistableEffectiveConfig {
+  const { capabilities: _capabilities, ...rest } = cfg;
+  return rest;
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..204ebebcd1cd71a03c6484dc82093500f2af2313
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,50 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export {
+  LEGACY_SETTINGS_SCHEMA_URL,
+  SETTINGS_SCHEMA_TOOLING_REQUIREMENTS,
+  type SettingsDocumentV1,
+  parseSettingsJson,
+  serializeSettingsDocument
+} from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export {
+  LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS,
+  LEGACY_SETTINGS_MERGE_NOTES,
+  mergeJsonObject,
+  mergeSettingsObjectsInOrder,
+  unionDedupePreserveOrder,
+  type SettingsMergeFieldExpectation
+} from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export {
+  computeEffectiveConfig,
+  computeMcpCliGateSnapshotFromEnv,
+  LEGACY_FEATURE_GATES,
+  toPersistableEffectiveConfig,
+  type EffectiveConfig,
+  type PersistableEffectiveConfig
+} from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
+export { refreshRemotePolicySettings, type PolicySettingsProvider } from "./policy.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..66130cf305d726c9098be200408857636906f633
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,78 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
+export const LEGACY_SETTINGS_MERGE_NOTES = {
+  objects: "deep-merge",
+  arrays: "union-dedupe-preserve-order (primitive-only dedupe, legacy Set-like)",
+  patches: "arrays-replace, delete-on-undefined"
+} as const;
+
+export type SettingsMergeFieldExpectation = {
+  pointer: string;
+  merge: "deep" | "replace";
+  arrays: "union" | "replace";
+  patchArrays: "replace";
+  notes?: string;
+};
+
+export const LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS: readonly SettingsMergeFieldExpectation[] = [
+  {
+    pointer: "/permissions",
+    merge: "deep",
+    arrays: "union",
+    patchArrays: "replace",
+    notes: "Permission rules are evaluated per-source later; the merged view is for defaults and UI display."
+  },
+  { pointer: "/hooks", merge: "deep", arrays: "union", patchArrays: "replace", notes: "Hook config merges across sources; policy may gate." },
+  { pointer: "/mcp", merge: "deep", arrays: "union", patchArrays: "replace", notes: "MCP subtree merges across sources; later phases validate." }
+] as const;
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/policy.ts b/src/core/settings/policy.ts
new file mode 100644
index 0000000000000000000000000000000000000000..de330a5538eb0955feb703095eb99d0d1be241bd
--- /dev/null
+++ b/src/core/settings/policy.ts
@@ -0,0 +1,43 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, writeSettingsSourceToStorage, type SettingsStorageContext } from "./storage.js";
+import type { SettingsError, SettingsPolicyOrigin } from "./types.js";
+
+export type PolicySettingsProvider = {
+  fetchPolicySettings: (options: { nowWallMs: number }) => Promise<JsonObject | null>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export async function refreshRemotePolicySettings(options: {
+  storage: HostStorage;
+  ctx: SettingsStorageContext;
+  provider: PolicySettingsProvider;
+  nowWallMs: number;
+}): Promise<{ updated: boolean; errors: SettingsError[]; origin: SettingsPolicyOrigin }> {
+  try {
+    const fetched = await options.provider.fetchPolicySettings({ nowWallMs: options.nowWallMs });
+    if (fetched === null) return { updated: false, errors: [], origin: "absent" };
+    if (!isPlainObject(fetched)) {
+      return {
+        updated: false,
+        errors: [{ kind: "validation_error", source: "policySettings", message: "Remote policy settings must be an object", severity: "error" }],
+        origin: "invalid"
+      };
+    }
+
+    const doc = createSettingsDocumentFromObject(fetched, { origin: "remote", updatedAtWallMs: options.nowWallMs });
+    const res = await writeSettingsSourceToStorage(options.storage, "policySettings", options.ctx, doc);
+    if (!res.ok) return { updated: false, errors: [res.error], origin: "invalid" };
+    return { updated: true, errors: [], origin: "remote" };
+  } catch (cause) {
+    return {
+      updated: false,
+      errors: [{ kind: "io_error", source: "policySettings", message: "Failed to refresh remote policy settings", cause, severity: "warning" }],
+      origin: "absent"
+    };
+  }
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ced5912ed36097285e52b5f4877084be366c3fbd
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,97 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export const SETTINGS_SCHEMA_TOOLING_REQUIREMENTS = {
+  runtimeValidation: true,
+  jsonSchemaExport: true,
+  rnCompatible: true
+} as const;
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6da53c1d21f344633b85f1726789510f606fa648
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,251 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  refreshRemotePolicySettings,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+
+  test("invalid policy settings fail-closed in EffectiveConfig", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_invalid"), sessionId: "sess_policy_invalid" };
+
+    await storage.set({ scope: "app" }, "settings/source/policySettings", "{ invalid json", { expectedVersion: null });
+    await writeSettingsSourceToStorage(storage, "flagSettings", ctx, createSettingsDocumentFromObject({}), { expectedVersion: null });
+
+    const mgr = createSettingsManager(host, ctx);
+    await mgr.initialize();
+    expect(mgr.getEffective().policyOrigin).toBe("invalid");
+    expect(mgr.getEffectiveConfig().hooks.disabled).toBe(true);
+    expect(mgr.getEffectiveConfig().hooks.managedOnly).toBe(true);
+    mgr.dispose();
+  });
+
+  test("remote policy refresh writes to cache (storage)", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_remote"), sessionId: "sess_policy_remote" };
+
+    const res = await refreshRemotePolicySettings({
+      storage,
+      ctx,
+      nowWallMs: 123,
+      provider: { fetchPolicySettings: async () => ({ allowManagedHooksOnly: true }) }
+    });
+    expect(res.updated).toBe(true);
+
+    const read = await readSettingsSourceFromStorage(storage, "policySettings", ctx);
+    expect(read.settings).toEqual({ allowManagedHooksOnly: true });
+    expect(read.origin).toBe("remote");
+  });
+});

[3m[35mfile update:[0m[0m
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 0f8a6cc339d3af38f747a734b8f5c85d0c078526..d2d76396cb6e36a58dc9fabc34dbb1bf4ec24632
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -588,67 +588,67 @@
 Dependencies: Phase 4 storage abstraction and Phase 5 state/persistence.
 
 6.1 Schema strategy (types and validation without bundler artifacts)
-- [ ] Decide how settings schemas are authored and validated (schema-first with generated TS types, or TS-first with runtime validation).
-- [ ] Define a versioned settings schema format with explicit migration steps.
-- [ ] Define a strict parse/validate error model that can surface structured errors to UI (not just logs).
-- [ ] Define how ‚Äúempty/missing settings‚Äù are treated (valid empty object) and how IO errors are handled per source.
-- [ ] ‚ö†Ô∏è Do not decide final schema tooling yet; define required capabilities (runtime validation, JSON schema export, RN compatibility).
+- [x] Decide how settings schemas are authored and validated (schema-first with generated TS types, or TS-first with runtime validation).
+- [x] Define a versioned settings schema format with explicit migration steps.
+- [x] Define a strict parse/validate error model that can surface structured errors to UI (not just logs).
+- [x] Define how ‚Äúempty/missing settings‚Äù are treated (valid empty object) and how IO errors are handled per source.
+- [x] ‚ö†Ô∏è Do not decide final schema tooling yet; define required capabilities (runtime validation, JSON schema export, RN compatibility).
 
 6.2 Settings sources and precedence (portable representation of legacy behavior)
-- [ ] Define settings sources: user/project/local/policy/flag and non-file sources (cliArg/command/session) as first-class keys.
-- [ ] Define enabled-source selection semantics (legacy: allowlist for user/project/local, always include policy + flag).
-- [ ] Define merge semantics (deep merge rules, array replace/merge policy) and document per-field merge expectations.
-- [ ] Define policy settings origin semantics (remote vs local vs absent) and how origin is represented/explained to the user.
-- [ ] Define how ‚Äúcommand configuration‚Äù and ‚ÄúcliArg‚Äù overlays are represented without conflating with persisted sources.
+- [x] Define settings sources: user/project/local/policy/flag and non-file sources (cliArg/command/session) as first-class keys.
+- [x] Define enabled-source selection semantics (legacy: allowlist for user/project/local, always include policy + flag).
+- [x] Define merge semantics (deep merge rules, array replace/merge policy) and document per-field merge expectations.
+- [x] Define policy settings origin semantics (remote vs local vs absent) and how origin is represented/explained to the user.
+- [x] Define how ‚Äúcommand configuration‚Äù and ‚ÄúcliArg‚Äù overlays are represented without conflating with persisted sources.
 
 6.3 Watchers and change propagation (no filesystem assumption)
-- [ ] Define a settings event bus that emits `(source, effectiveSettings, errors)` updates.
-- [ ] Define internal-write suppression semantics (prevent write‚Üíwatch loop) without relying on filesystem watcher timestamps.
-- [ ] Define how watchers are implemented per host:
-  - [ ] Node/desktop: filesystem watcher adapter (optional)
-  - [ ] Web: storage event adapter or polling (as needed)
-  - [ ] Mobile: storage subscription or ‚Äúsettings changed‚Äù command-only model
-- [ ] Define how settings changes trigger state updates in the engine store (invalidate caches, recompute derived contexts).
+- [x] Define a settings event bus that emits `(source, effectiveSettings, errors)` updates.
+- [x] Define internal-write suppression semantics (prevent write‚Üíwatch loop) without relying on filesystem watcher timestamps.
+- [x] Define how watchers are implemented per host:
+  - [x] Node/desktop: filesystem watcher adapter (optional)
+  - [x] Web: storage event adapter or polling (as needed)
+  - [x] Mobile: storage subscription or ‚Äúsettings changed‚Äù command-only model
+- [x] Define how settings changes trigger state updates in the engine store (invalidate caches, recompute derived contexts).
 
 6.4 Settings patching and atomicity (portable ‚Äúpartial update‚Äù semantics)
-- [ ] Define a ‚Äúsettings patch‚Äù format (deep partial + array semantics) and how patches are applied deterministically.
-- [ ] Define atomic update expectations per storage backend (transaction/CAS where possible).
-- [ ] Define conflict resolution for concurrent updates (last-write wins vs version checks).
-- [ ] Define how settings edits are attributed to a source and how UI confirms the destination (user vs project vs local).
+- [x] Define a ‚Äúsettings patch‚Äù format (deep partial + array semantics) and how patches are applied deterministically.
+- [x] Define atomic update expectations per storage backend (transaction/CAS where possible).
+- [x] Define conflict resolution for concurrent updates (last-write wins vs version checks).
+- [x] Define how settings edits are attributed to a source and how UI confirms the destination (user vs project vs local).
 
 6.5 Compatibility and migration of existing settings files
-- [ ] Define how legacy file paths map into the new storage model (especially policy managed settings locations).
-- [ ] Define a migration plan for settings schema evolution (v2 files ‚Üí v3 schema) with rollback.
-- [ ] Define a ‚Äúdoctor‚Äù report for settings health (parse errors, invalid fields, policy overrides).
-- [ ] Define how to handle broken symlinks / unreadable settings sources in host environments that support symlinks (must not brick startup).
-- [ ] Define the legacy ‚Äúenabled sources‚Äù CLI parsing behavior and how it maps into portable settings selection.
+- [x] Define how legacy file paths map into the new storage model (especially policy managed settings locations).
+- [x] Define a migration plan for settings schema evolution (v2 files ‚Üí v3 schema) with rollback.
+- [x] Define a ‚Äúdoctor‚Äù report for settings health (parse errors, invalid fields, policy overrides).
+- [x] Define how to handle broken symlinks / unreadable settings sources in host environments that support symlinks (must not brick startup).
+- [x] Define the legacy ‚Äúenabled sources‚Äù CLI parsing behavior and how it maps into portable settings selection.
 
 6.6 Settings precedence and merge edge cases (test-first inventory)
-- [ ] Enumerate settings fields that require non-default merge behavior (arrays, maps, special objects) and document expected behavior.
-- [ ] Define explicit merge semantics for hook configs, permission rules, and MCP config subtrees (so later refactors don‚Äôt accidentally change them).
-- [ ] Define how to represent and surface settings validation errors from multiple sources (aggregate + per-source attribution).
-- [ ] Define how the engine behaves when policy settings are present but invalid (fail-closed vs ignore with warning; must be explicit and tested).
+- [x] Enumerate settings fields that require non-default merge behavior (arrays, maps, special objects) and document expected behavior.
+- [x] Define explicit merge semantics for hook configs, permission rules, and MCP config subtrees (so later refactors don‚Äôt accidentally change them).
+- [x] Define how to represent and surface settings validation errors from multiple sources (aggregate + per-source attribution).
+- [x] Define how the engine behaves when policy settings are present but invalid (fail-closed vs ignore with warning; must be explicit and tested).
 
 6.7 Portable settings storage mapping (per-host implementation checklist)
-- [ ] Define the storage keys / documents used to represent each source on non-filesystem hosts (user/project/local/policy/flag).
-- [ ] Define how ‚Äúproject settings‚Äù are scoped on mobile/web when there is no project root (explicit workspace concept, user-chosen workspace IDs).
-- [ ] Define how policy-managed settings are delivered on mobile (secure fetch + cache) and how offline behavior works.
-- [ ] Define how to export/import settings for support and migration (sanitized bundle; reproducible).
+- [x] Define the storage keys / documents used to represent each source on non-filesystem hosts (user/project/local/policy/flag).
+- [x] Define how ‚Äúproject settings‚Äù are scoped on mobile/web when there is no project root (explicit workspace concept, user-chosen workspace IDs).
+- [x] Define how policy-managed settings are delivered on mobile (secure fetch + cache) and how offline behavior works.
+- [x] Define how to export/import settings for support and migration (sanitized bundle; reproducible).
 
 6.8 Settings-derived feature gates and computed configuration (make implicit toggles explicit)
-- [ ] Inventory all legacy boolean ‚Äúswitches‚Äù that alter behavior (e.g., `disableAllHooks`, experimental MCP CLI enable, endpoint-mode enable, sandbox/network approval toggles) and classify each as:
-  - [ ] portable setting (works on all hosts)
-  - [ ] host-only setting (Node/desktop)
-  - [ ] env/flag alias (CLI convenience only)
-- [ ] Define a computed `EffectiveConfig` snapshot that the engine derives from settings + policy + host capabilities (single place to reason about feature gating).
-- [ ] Define which fields in `EffectiveConfig` are safe to persist vs must remain ephemeral (session-only, host-only).
-- [ ] Define how UI adapters render feature availability (capability-gated tool/hook visibility) without reading raw settings trees directly.
-- [ ] Add golden tests that assert: for a given set of sources, `EffectiveConfig` fields are computed identically across hosts (modulo capability presence).
+- [x] Inventory all legacy boolean ‚Äúswitches‚Äù that alter behavior (e.g., `disableAllHooks`, experimental MCP CLI enable, endpoint-mode enable, sandbox/network approval toggles) and classify each as:
+  - [x] portable setting (works on all hosts)
+  - [x] host-only setting (Node/desktop)
+  - [x] env/flag alias (CLI convenience only)
+- [x] Define a computed `EffectiveConfig` snapshot that the engine derives from settings + policy + host capabilities (single place to reason about feature gating).
+- [x] Define which fields in `EffectiveConfig` are safe to persist vs must remain ephemeral (session-only, host-only).
+- [x] Define how UI adapters render feature availability (capability-gated tool/hook visibility) without reading raw settings trees directly.
+- [x] Add golden tests that assert: for a given set of sources, `EffectiveConfig` fields are computed identically across hosts (modulo capability presence).
 
 6.9 Secrets, credentials, and redaction boundaries in configuration
-- [ ] Define an explicit schema boundary between configuration values and secrets (secrets never appear in exported settings snapshots or diagnostic bundles).
-- [ ] Define how secret references are represented in settings/config (opaque IDs that resolve via secret storage capability).
-- [ ] Define failure semantics when a secret reference cannot be resolved (prompt user vs hard error vs policy deny), and test each host‚Äôs UX path.
+- [x] Define an explicit schema boundary between configuration values and secrets (secrets never appear in exported settings snapshots or diagnostic bundles).
+- [x] Define how secret references are represented in settings/config (opaque IDs that resolve via secret storage capability).
+- [x] Define failure semantics when a secret reference cannot be resolved (prompt user vs hard error vs policy deny), and test each host‚Äôs UX path.
 
 ---
 
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..24200d9ba57abdc5f211427ef09a09aeecd06c4e
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,103 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+export type PersistableEffectiveConfig = Omit<EffectiveConfig, "capabilities">;
+
+export function toPersistableEffectiveConfig(cfg: EffectiveConfig): PersistableEffectiveConfig {
+  const { capabilities: _capabilities, ...rest } = cfg;
+  return rest;
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..204ebebcd1cd71a03c6484dc82093500f2af2313
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,50 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export {
+  LEGACY_SETTINGS_SCHEMA_URL,
+  SETTINGS_SCHEMA_TOOLING_REQUIREMENTS,
+  type SettingsDocumentV1,
+  parseSettingsJson,
+  serializeSettingsDocument
+} from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export {
+  LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS,
+  LEGACY_SETTINGS_MERGE_NOTES,
+  mergeJsonObject,
+  mergeSettingsObjectsInOrder,
+  unionDedupePreserveOrder,
+  type SettingsMergeFieldExpectation
+} from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export {
+  computeEffectiveConfig,
+  computeMcpCliGateSnapshotFromEnv,
+  LEGACY_FEATURE_GATES,
+  toPersistableEffectiveConfig,
+  type EffectiveConfig,
+  type PersistableEffectiveConfig
+} from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
+export { refreshRemotePolicySettings, type PolicySettingsProvider } from "./policy.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..66130cf305d726c9098be200408857636906f633
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,78 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
+export const LEGACY_SETTINGS_MERGE_NOTES = {
+  objects: "deep-merge",
+  arrays: "union-dedupe-preserve-order (primitive-only dedupe, legacy Set-like)",
+  patches: "arrays-replace, delete-on-undefined"
+} as const;
+
+export type SettingsMergeFieldExpectation = {
+  pointer: string;
+  merge: "deep" | "replace";
+  arrays: "union" | "replace";
+  patchArrays: "replace";
+  notes?: string;
+};
+
+export const LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS: readonly SettingsMergeFieldExpectation[] = [
+  {
+    pointer: "/permissions",
+    merge: "deep",
+    arrays: "union",
+    patchArrays: "replace",
+    notes: "Permission rules are evaluated per-source later; the merged view is for defaults and UI display."
+  },
+  { pointer: "/hooks", merge: "deep", arrays: "union", patchArrays: "replace", notes: "Hook config merges across sources; policy may gate." },
+  { pointer: "/mcp", merge: "deep", arrays: "union", patchArrays: "replace", notes: "MCP subtree merges across sources; later phases validate." }
+] as const;
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/policy.ts b/src/core/settings/policy.ts
new file mode 100644
index 0000000000000000000000000000000000000000..de330a5538eb0955feb703095eb99d0d1be241bd
--- /dev/null
+++ b/src/core/settings/policy.ts
@@ -0,0 +1,43 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, writeSettingsSourceToStorage, type SettingsStorageContext } from "./storage.js";
+import type { SettingsError, SettingsPolicyOrigin } from "./types.js";
+
+export type PolicySettingsProvider = {
+  fetchPolicySettings: (options: { nowWallMs: number }) => Promise<JsonObject | null>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export async function refreshRemotePolicySettings(options: {
+  storage: HostStorage;
+  ctx: SettingsStorageContext;
+  provider: PolicySettingsProvider;
+  nowWallMs: number;
+}): Promise<{ updated: boolean; errors: SettingsError[]; origin: SettingsPolicyOrigin }> {
+  try {
+    const fetched = await options.provider.fetchPolicySettings({ nowWallMs: options.nowWallMs });
+    if (fetched === null) return { updated: false, errors: [], origin: "absent" };
+    if (!isPlainObject(fetched)) {
+      return {
+        updated: false,
+        errors: [{ kind: "validation_error", source: "policySettings", message: "Remote policy settings must be an object", severity: "error" }],
+        origin: "invalid"
+      };
+    }
+
+    const doc = createSettingsDocumentFromObject(fetched, { origin: "remote", updatedAtWallMs: options.nowWallMs });
+    const res = await writeSettingsSourceToStorage(options.storage, "policySettings", options.ctx, doc);
+    if (!res.ok) return { updated: false, errors: [res.error], origin: "invalid" };
+    return { updated: true, errors: [], origin: "remote" };
+  } catch (cause) {
+    return {
+      updated: false,
+      errors: [{ kind: "io_error", source: "policySettings", message: "Failed to refresh remote policy settings", cause, severity: "warning" }],
+      origin: "absent"
+    };
+  }
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ced5912ed36097285e52b5f4877084be366c3fbd
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,97 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export const SETTINGS_SCHEMA_TOOLING_REQUIREMENTS = {
+  runtimeValidation: true,
+  jsonSchemaExport: true,
+  rnCompatible: true
+} as const;
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6da53c1d21f344633b85f1726789510f606fa648
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,251 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  refreshRemotePolicySettings,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+
+  test("invalid policy settings fail-closed in EffectiveConfig", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_invalid"), sessionId: "sess_policy_invalid" };
+
+    await storage.set({ scope: "app" }, "settings/source/policySettings", "{ invalid json", { expectedVersion: null });
+    await writeSettingsSourceToStorage(storage, "flagSettings", ctx, createSettingsDocumentFromObject({}), { expectedVersion: null });
+
+    const mgr = createSettingsManager(host, ctx);
+    await mgr.initialize();
+    expect(mgr.getEffective().policyOrigin).toBe("invalid");
+    expect(mgr.getEffectiveConfig().hooks.disabled).toBe(true);
+    expect(mgr.getEffectiveConfig().hooks.managedOnly).toBe(true);
+    mgr.dispose();
+  });
+
+  test("remote policy refresh writes to cache (storage)", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_remote"), sessionId: "sess_policy_remote" };
+
+    const res = await refreshRemotePolicySettings({
+      storage,
+      ctx,
+      nowWallMs: 123,
+      provider: { fetchPolicySettings: async () => ({ allowManagedHooksOnly: true }) }
+    });
+    expect(res.updated).toBe(true);
+
+    const read = await readSettingsSourceFromStorage(storage, "policySettings", ctx);
+    expect(read.settings).toEqual({ allowManagedHooksOnly: true });
+    expect(read.origin).toBe("remote");
+  });
+});

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/changelogs/implementation-20251217-093335/phase-6-changelog.md[0m
@@ -0,0 +1,55 @@
[32m+## Summary (Phase 6)[0m
[32m+[0m
[32m+- Implemented a portable, layered settings system in `src/core/settings/*` with legacy-parity source keys, enabled-source selection, deterministic merge + patch semantics, and structured error reporting.[0m
[32m+- Added watchable settings propagation via storage subscriptions with internal-write suppression (version/pending-key based), plus a Node `HostStorage.subscribe()` implementation backed by `fs.watch`.[0m
[32m+- Added `EffectiveConfig` computation and feature-gate inventory, including a fail-closed policy-invalid behavior that disables hooks/managed-only gate.[0m
[32m+- Implemented portable storage mapping (app/workspace/session namespaces), settings doctor reporting, export/import bundles, legacy path mapping, and a remote policy refresh API that caches into storage.[0m
[32m+[0m
[32m+## Files changed[0m
[32m+[0m
[32m+- Deleted: `src/core/settings/index.ts`[0m
[32m+- Added:[0m
[32m+  - `src/core/settings/types.ts`[0m
[32m+  - `src/core/settings/schema.ts`[0m
[32m+  - `src/core/settings/sources.ts`[0m
[32m+  - `src/core/settings/merge.ts`[0m
[32m+  - `src/core/settings/patch.ts`[0m
[32m+  - `src/core/settings/secrets.ts`[0m
[32m+  - `src/core/settings/storage.ts`[0m
[32m+  - `src/core/settings/legacyPaths.ts`[0m
[32m+  - `src/core/settings/doctor.ts`[0m
[32m+  - `src/core/settings/effectiveConfig.ts`[0m
[32m+  - `src/core/settings/bundle.ts`[0m
[32m+  - `src/core/settings/manager.ts`[0m
[32m+  - `src/core/settings/policy.ts`[0m
[32m+  - `src/core/settings/index.ts`[0m
[32m+  - `tests/phase6-settings.test.ts`[0m
[32m+- Modified:[0m
[32m+  - `src/platform/node/host.ts`[0m
[32m+  - `implementation/1-initial-rewrite-implementation-checklist.md`[0m
[32m+[0m
[32m+## Decisions made[0m
[32m+[0m
[32m+- Settings schema strategy: TS-first + lightweight runtime validation (no new schema/tooling dependency added yet), with a versioned settings envelope (`kind: settings_document`, `schemaVersion: 1`) and legacy ‚Äúbare object‚Äù compatibility (`src/core/settings/schema.ts`).[0m
[32m+- Source enablement order: preserve legacy semantics where enabled sources = `allowedSettingSources` + `policySettings` + `flagSettings` (with policy added before flag so flags override policy in effective settings).[0m
[32m+- Merge vs patch semantics:[0m
[32m+  - Effective settings merge uses deep merge + array union/dedupe (primitive-only, legacy Set-like).[0m
[32m+  - Patches delete keys on `undefined` and **replace arrays** (matches legacy `E2/X2` behavior; required for rule/directory removals).[0m
[32m+- Policy invalid behavior: treat invalid policy settings as `policyOrigin: "invalid"` and fail-closed for hook gating in `EffectiveConfig` (hooks disabled + managedOnly enabled), with tests proving the contract.[0m
[32m+- Naming collision avoidance: renamed core MCP gate helper to `computeMcpCliGateSnapshotFromEnv` to avoid export conflicts with legacy-spec helpers re-exported from `src/spec/*`.[0m
[32m+[0m
[32m+## Tests/validation run + results[0m
[32m+[0m
[32m+- `bun test` (bun v1.3.4): PASS[0m
[32m+- `bun run typecheck`: PASS[0m
[32m+- `bun run check:boundaries`: PASS (`Import boundary check passed.`)[0m
[32m+- Legacy CLI sanity (auth + network): `claude --dangerously-skip-permissions -p sayhello` => PASS[0m
[32m+[0m
[32m+## Remaining work inside Phase 6[0m
[32m+[0m
[32m+- None identified (Phase 6 checklist fully checked off).[0m
[32m+[0m
[32m+## Handoff notes for next phase[0m
[32m+[0m
[32m+- Phase 7 (permissions) should treat settings sources as first-class (`SettingsSource` in `src/core/settings/types.ts`) and rely on per-source attribution from `readSettingsSourceFromStorage()` rather than the merged settings object for rule precedence.[0m
[32m+- Node hosts now support `HostStorage.subscribe()`; settings/watch flows can be exercised without filesystem-specific watchers.[0m
[32mapply_patch(auto_approved=true) exited 0 in 107ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM changelogs/implementation-20251217-093335/phase-6-changelog.md[0m
[3m[35mfile update:[0m[0m
diff --git a/changelogs/implementation-20251217-093335/phase-6-changelog.md b/changelogs/implementation-20251217-093335/phase-6-changelog.md
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..0eef68699ae9525ddb44bd6e654732d6c2a7973f
--- a/changelogs/implementation-20251217-093335/phase-6-changelog.md
+++ b/changelogs/implementation-20251217-093335/phase-6-changelog.md
@@ -0,0 +1,55 @@
+## Summary (Phase 6)
+
+- Implemented a portable, layered settings system in `src/core/settings/*` with legacy-parity source keys, enabled-source selection, deterministic merge + patch semantics, and structured error reporting.
+- Added watchable settings propagation via storage subscriptions with internal-write suppression (version/pending-key based), plus a Node `HostStorage.subscribe()` implementation backed by `fs.watch`.
+- Added `EffectiveConfig` computation and feature-gate inventory, including a fail-closed policy-invalid behavior that disables hooks/managed-only gate.
+- Implemented portable storage mapping (app/workspace/session namespaces), settings doctor reporting, export/import bundles, legacy path mapping, and a remote policy refresh API that caches into storage.
+
+## Files changed
+
+- Deleted: `src/core/settings/index.ts`
+- Added:
+  - `src/core/settings/types.ts`
+  - `src/core/settings/schema.ts`
+  - `src/core/settings/sources.ts`
+  - `src/core/settings/merge.ts`
+  - `src/core/settings/patch.ts`
+  - `src/core/settings/secrets.ts`
+  - `src/core/settings/storage.ts`
+  - `src/core/settings/legacyPaths.ts`
+  - `src/core/settings/doctor.ts`
+  - `src/core/settings/effectiveConfig.ts`
+  - `src/core/settings/bundle.ts`
+  - `src/core/settings/manager.ts`
+  - `src/core/settings/policy.ts`
+  - `src/core/settings/index.ts`
+  - `tests/phase6-settings.test.ts`
+- Modified:
+  - `src/platform/node/host.ts`
+  - `implementation/1-initial-rewrite-implementation-checklist.md`
+
+## Decisions made
+
+- Settings schema strategy: TS-first + lightweight runtime validation (no new schema/tooling dependency added yet), with a versioned settings envelope (`kind: settings_document`, `schemaVersion: 1`) and legacy ‚Äúbare object‚Äù compatibility (`src/core/settings/schema.ts`).
+- Source enablement order: preserve legacy semantics where enabled sources = `allowedSettingSources` + `policySettings` + `flagSettings` (with policy added before flag so flags override policy in effective settings).
+- Merge vs patch semantics:
+  - Effective settings merge uses deep merge + array union/dedupe (primitive-only, legacy Set-like).
+  - Patches delete keys on `undefined` and **replace arrays** (matches legacy `E2/X2` behavior; required for rule/directory removals).
+- Policy invalid behavior: treat invalid policy settings as `policyOrigin: "invalid"` and fail-closed for hook gating in `EffectiveConfig` (hooks disabled + managedOnly enabled), with tests proving the contract.
+- Naming collision avoidance: renamed core MCP gate helper to `computeMcpCliGateSnapshotFromEnv` to avoid export conflicts with legacy-spec helpers re-exported from `src/spec/*`.
+
+## Tests/validation run + results
+
+- `bun test` (bun v1.3.4): PASS
+- `bun run typecheck`: PASS
+- `bun run check:boundaries`: PASS (`Import boundary check passed.`)
+- Legacy CLI sanity (auth + network): `claude --dangerously-skip-permissions -p sayhello` => PASS
+
+## Remaining work inside Phase 6
+
+- None identified (Phase 6 checklist fully checked off).
+
+## Handoff notes for next phase
+
+- Phase 7 (permissions) should treat settings sources as first-class (`SettingsSource` in `src/core/settings/types.ts`) and rely on per-source attribution from `readSettingsSourceFromStorage()` rather than the merged settings object for rule precedence.
+- Node hosts now support `HostStorage.subscribe()`; settings/watch flows can be exercised without filesystem-specific watchers.
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 0f8a6cc339d3af38f747a734b8f5c85d0c078526..d2d76396cb6e36a58dc9fabc34dbb1bf4ec24632
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -588,67 +588,67 @@
 Dependencies: Phase 4 storage abstraction and Phase 5 state/persistence.
 
 6.1 Schema strategy (types and validation without bundler artifacts)
-- [ ] Decide how settings schemas are authored and validated (schema-first with generated TS types, or TS-first with runtime validation).
-- [ ] Define a versioned settings schema format with explicit migration steps.
-- [ ] Define a strict parse/validate error model that can surface structured errors to UI (not just logs).
-- [ ] Define how ‚Äúempty/missing settings‚Äù are treated (valid empty object) and how IO errors are handled per source.
-- [ ] ‚ö†Ô∏è Do not decide final schema tooling yet; define required capabilities (runtime validation, JSON schema export, RN compatibility).
+- [x] Decide how settings schemas are authored and validated (schema-first with generated TS types, or TS-first with runtime validation).
+- [x] Define a versioned settings schema format with explicit migration steps.
+- [x] Define a strict parse/validate error model that can surface structured errors to UI (not just logs).
+- [x] Define how ‚Äúempty/missing settings‚Äù are treated (valid empty object) and how IO errors are handled per source.
+- [x] ‚ö†Ô∏è Do not decide final schema tooling yet; define required capabilities (runtime validation, JSON schema export, RN compatibility).
 
 6.2 Settings sources and precedence (portable representation of legacy behavior)
-- [ ] Define settings sources: user/project/local/policy/flag and non-file sources (cliArg/command/session) as first-class keys.
-- [ ] Define enabled-source selection semantics (legacy: allowlist for user/project/local, always include policy + flag).
-- [ ] Define merge semantics (deep merge rules, array replace/merge policy) and document per-field merge expectations.
-- [ ] Define policy settings origin semantics (remote vs local vs absent) and how origin is represented/explained to the user.
-- [ ] Define how ‚Äúcommand configuration‚Äù and ‚ÄúcliArg‚Äù overlays are represented without conflating with persisted sources.
+- [x] Define settings sources: user/project/local/policy/flag and non-file sources (cliArg/command/session) as first-class keys.
+- [x] Define enabled-source selection semantics (legacy: allowlist for user/project/local, always include policy + flag).
+- [x] Define merge semantics (deep merge rules, array replace/merge policy) and document per-field merge expectations.
+- [x] Define policy settings origin semantics (remote vs local vs absent) and how origin is represented/explained to the user.
+- [x] Define how ‚Äúcommand configuration‚Äù and ‚ÄúcliArg‚Äù overlays are represented without conflating with persisted sources.
 
 6.3 Watchers and change propagation (no filesystem assumption)
-- [ ] Define a settings event bus that emits `(source, effectiveSettings, errors)` updates.
-- [ ] Define internal-write suppression semantics (prevent write‚Üíwatch loop) without relying on filesystem watcher timestamps.
-- [ ] Define how watchers are implemented per host:
-  - [ ] Node/desktop: filesystem watcher adapter (optional)
-  - [ ] Web: storage event adapter or polling (as needed)
-  - [ ] Mobile: storage subscription or ‚Äúsettings changed‚Äù command-only model
-- [ ] Define how settings changes trigger state updates in the engine store (invalidate caches, recompute derived contexts).
+- [x] Define a settings event bus that emits `(source, effectiveSettings, errors)` updates.
+- [x] Define internal-write suppression semantics (prevent write‚Üíwatch loop) without relying on filesystem watcher timestamps.
+- [x] Define how watchers are implemented per host:
+  - [x] Node/desktop: filesystem watcher adapter (optional)
+  - [x] Web: storage event adapter or polling (as needed)
+  - [x] Mobile: storage subscription or ‚Äúsettings changed‚Äù command-only model
+- [x] Define how settings changes trigger state updates in the engine store (invalidate caches, recompute derived contexts).
 
 6.4 Settings patching and atomicity (portable ‚Äúpartial update‚Äù semantics)
-- [ ] Define a ‚Äúsettings patch‚Äù format (deep partial + array semantics) and how patches are applied deterministically.
-- [ ] Define atomic update expectations per storage backend (transaction/CAS where possible).
-- [ ] Define conflict resolution for concurrent updates (last-write wins vs version checks).
-- [ ] Define how settings edits are attributed to a source and how UI confirms the destination (user vs project vs local).
+- [x] Define a ‚Äúsettings patch‚Äù format (deep partial + array semantics) and how patches are applied deterministically.
+- [x] Define atomic update expectations per storage backend (transaction/CAS where possible).
+- [x] Define conflict resolution for concurrent updates (last-write wins vs version checks).
+- [x] Define how settings edits are attributed to a source and how UI confirms the destination (user vs project vs local).
 
 6.5 Compatibility and migration of existing settings files
-- [ ] Define how legacy file paths map into the new storage model (especially policy managed settings locations).
-- [ ] Define a migration plan for settings schema evolution (v2 files ‚Üí v3 schema) with rollback.
-- [ ] Define a ‚Äúdoctor‚Äù report for settings health (parse errors, invalid fields, policy overrides).
-- [ ] Define how to handle broken symlinks / unreadable settings sources in host environments that support symlinks (must not brick startup).
-- [ ] Define the legacy ‚Äúenabled sources‚Äù CLI parsing behavior and how it maps into portable settings selection.
+- [x] Define how legacy file paths map into the new storage model (especially policy managed settings locations).
+- [x] Define a migration plan for settings schema evolution (v2 files ‚Üí v3 schema) with rollback.
+- [x] Define a ‚Äúdoctor‚Äù report for settings health (parse errors, invalid fields, policy overrides).
+- [x] Define how to handle broken symlinks / unreadable settings sources in host environments that support symlinks (must not brick startup).
+- [x] Define the legacy ‚Äúenabled sources‚Äù CLI parsing behavior and how it maps into portable settings selection.
 
 6.6 Settings precedence and merge edge cases (test-first inventory)
-- [ ] Enumerate settings fields that require non-default merge behavior (arrays, maps, special objects) and document expected behavior.
-- [ ] Define explicit merge semantics for hook configs, permission rules, and MCP config subtrees (so later refactors don‚Äôt accidentally change them).
-- [ ] Define how to represent and surface settings validation errors from multiple sources (aggregate + per-source attribution).
-- [ ] Define how the engine behaves when policy settings are present but invalid (fail-closed vs ignore with warning; must be explicit and tested).
+- [x] Enumerate settings fields that require non-default merge behavior (arrays, maps, special objects) and document expected behavior.
+- [x] Define explicit merge semantics for hook configs, permission rules, and MCP config subtrees (so later refactors don‚Äôt accidentally change them).
+- [x] Define how to represent and surface settings validation errors from multiple sources (aggregate + per-source attribution).
+- [x] Define how the engine behaves when policy settings are present but invalid (fail-closed vs ignore with warning; must be explicit and tested).
 
 6.7 Portable settings storage mapping (per-host implementation checklist)
-- [ ] Define the storage keys / documents used to represent each source on non-filesystem hosts (user/project/local/policy/flag).
-- [ ] Define how ‚Äúproject settings‚Äù are scoped on mobile/web when there is no project root (explicit workspace concept, user-chosen workspace IDs).
-- [ ] Define how policy-managed settings are delivered on mobile (secure fetch + cache) and how offline behavior works.
-- [ ] Define how to export/import settings for support and migration (sanitized bundle; reproducible).
+- [x] Define the storage keys / documents used to represent each source on non-filesystem hosts (user/project/local/policy/flag).
+- [x] Define how ‚Äúproject settings‚Äù are scoped on mobile/web when there is no project root (explicit workspace concept, user-chosen workspace IDs).
+- [x] Define how policy-managed settings are delivered on mobile (secure fetch + cache) and how offline behavior works.
+- [x] Define how to export/import settings for support and migration (sanitized bundle; reproducible).
 
 6.8 Settings-derived feature gates and computed configuration (make implicit toggles explicit)
-- [ ] Inventory all legacy boolean ‚Äúswitches‚Äù that alter behavior (e.g., `disableAllHooks`, experimental MCP CLI enable, endpoint-mode enable, sandbox/network approval toggles) and classify each as:
-  - [ ] portable setting (works on all hosts)
-  - [ ] host-only setting (Node/desktop)
-  - [ ] env/flag alias (CLI convenience only)
-- [ ] Define a computed `EffectiveConfig` snapshot that the engine derives from settings + policy + host capabilities (single place to reason about feature gating).
-- [ ] Define which fields in `EffectiveConfig` are safe to persist vs must remain ephemeral (session-only, host-only).
-- [ ] Define how UI adapters render feature availability (capability-gated tool/hook visibility) without reading raw settings trees directly.
-- [ ] Add golden tests that assert: for a given set of sources, `EffectiveConfig` fields are computed identically across hosts (modulo capability presence).
+- [x] Inventory all legacy boolean ‚Äúswitches‚Äù that alter behavior (e.g., `disableAllHooks`, experimental MCP CLI enable, endpoint-mode enable, sandbox/network approval toggles) and classify each as:
+  - [x] portable setting (works on all hosts)
+  - [x] host-only setting (Node/desktop)
+  - [x] env/flag alias (CLI convenience only)
+- [x] Define a computed `EffectiveConfig` snapshot that the engine derives from settings + policy + host capabilities (single place to reason about feature gating).
+- [x] Define which fields in `EffectiveConfig` are safe to persist vs must remain ephemeral (session-only, host-only).
+- [x] Define how UI adapters render feature availability (capability-gated tool/hook visibility) without reading raw settings trees directly.
+- [x] Add golden tests that assert: for a given set of sources, `EffectiveConfig` fields are computed identically across hosts (modulo capability presence).
 
 6.9 Secrets, credentials, and redaction boundaries in configuration
-- [ ] Define an explicit schema boundary between configuration values and secrets (secrets never appear in exported settings snapshots or diagnostic bundles).
-- [ ] Define how secret references are represented in settings/config (opaque IDs that resolve via secret storage capability).
-- [ ] Define failure semantics when a secret reference cannot be resolved (prompt user vs hard error vs policy deny), and test each host‚Äôs UX path.
+- [x] Define an explicit schema boundary between configuration values and secrets (secrets never appear in exported settings snapshots or diagnostic bundles).
+- [x] Define how secret references are represented in settings/config (opaque IDs that resolve via secret storage capability).
+- [x] Define failure semantics when a secret reference cannot be resolved (prompt user vs hard error vs policy deny), and test each host‚Äôs UX path.
 
 ---
 
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..24200d9ba57abdc5f211427ef09a09aeecd06c4e
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,103 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+export type PersistableEffectiveConfig = Omit<EffectiveConfig, "capabilities">;
+
+export function toPersistableEffectiveConfig(cfg: EffectiveConfig): PersistableEffectiveConfig {
+  const { capabilities: _capabilities, ...rest } = cfg;
+  return rest;
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..204ebebcd1cd71a03c6484dc82093500f2af2313
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,50 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export {
+  LEGACY_SETTINGS_SCHEMA_URL,
+  SETTINGS_SCHEMA_TOOLING_REQUIREMENTS,
+  type SettingsDocumentV1,
+  parseSettingsJson,
+  serializeSettingsDocument
+} from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export {
+  LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS,
+  LEGACY_SETTINGS_MERGE_NOTES,
+  mergeJsonObject,
+  mergeSettingsObjectsInOrder,
+  unionDedupePreserveOrder,
+  type SettingsMergeFieldExpectation
+} from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export {
+  computeEffectiveConfig,
+  computeMcpCliGateSnapshotFromEnv,
+  LEGACY_FEATURE_GATES,
+  toPersistableEffectiveConfig,
+  type EffectiveConfig,
+  type PersistableEffectiveConfig
+} from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
+export { refreshRemotePolicySettings, type PolicySettingsProvider } from "./policy.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..66130cf305d726c9098be200408857636906f633
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,78 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
+export const LEGACY_SETTINGS_MERGE_NOTES = {
+  objects: "deep-merge",
+  arrays: "union-dedupe-preserve-order (primitive-only dedupe, legacy Set-like)",
+  patches: "arrays-replace, delete-on-undefined"
+} as const;
+
+export type SettingsMergeFieldExpectation = {
+  pointer: string;
+  merge: "deep" | "replace";
+  arrays: "union" | "replace";
+  patchArrays: "replace";
+  notes?: string;
+};
+
+export const LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS: readonly SettingsMergeFieldExpectation[] = [
+  {
+    pointer: "/permissions",
+    merge: "deep",
+    arrays: "union",
+    patchArrays: "replace",
+    notes: "Permission rules are evaluated per-source later; the merged view is for defaults and UI display."
+  },
+  { pointer: "/hooks", merge: "deep", arrays: "union", patchArrays: "replace", notes: "Hook config merges across sources; policy may gate." },
+  { pointer: "/mcp", merge: "deep", arrays: "union", patchArrays: "replace", notes: "MCP subtree merges across sources; later phases validate." }
+] as const;
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/policy.ts b/src/core/settings/policy.ts
new file mode 100644
index 0000000000000000000000000000000000000000..de330a5538eb0955feb703095eb99d0d1be241bd
--- /dev/null
+++ b/src/core/settings/policy.ts
@@ -0,0 +1,43 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, writeSettingsSourceToStorage, type SettingsStorageContext } from "./storage.js";
+import type { SettingsError, SettingsPolicyOrigin } from "./types.js";
+
+export type PolicySettingsProvider = {
+  fetchPolicySettings: (options: { nowWallMs: number }) => Promise<JsonObject | null>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export async function refreshRemotePolicySettings(options: {
+  storage: HostStorage;
+  ctx: SettingsStorageContext;
+  provider: PolicySettingsProvider;
+  nowWallMs: number;
+}): Promise<{ updated: boolean; errors: SettingsError[]; origin: SettingsPolicyOrigin }> {
+  try {
+    const fetched = await options.provider.fetchPolicySettings({ nowWallMs: options.nowWallMs });
+    if (fetched === null) return { updated: false, errors: [], origin: "absent" };
+    if (!isPlainObject(fetched)) {
+      return {
+        updated: false,
+        errors: [{ kind: "validation_error", source: "policySettings", message: "Remote policy settings must be an object", severity: "error" }],
+        origin: "invalid"
+      };
+    }
+
+    const doc = createSettingsDocumentFromObject(fetched, { origin: "remote", updatedAtWallMs: options.nowWallMs });
+    const res = await writeSettingsSourceToStorage(options.storage, "policySettings", options.ctx, doc);
+    if (!res.ok) return { updated: false, errors: [res.error], origin: "invalid" };
+    return { updated: true, errors: [], origin: "remote" };
+  } catch (cause) {
+    return {
+      updated: false,
+      errors: [{ kind: "io_error", source: "policySettings", message: "Failed to refresh remote policy settings", cause, severity: "warning" }],
+      origin: "absent"
+    };
+  }
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ced5912ed36097285e52b5f4877084be366c3fbd
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,97 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export const SETTINGS_SCHEMA_TOOLING_REQUIREMENTS = {
+  runtimeValidation: true,
+  jsonSchemaExport: true,
+  rnCompatible: true
+} as const;
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6da53c1d21f344633b85f1726789510f606fa648
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,251 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  refreshRemotePolicySettings,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+
+  test("invalid policy settings fail-closed in EffectiveConfig", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_invalid"), sessionId: "sess_policy_invalid" };
+
+    await storage.set({ scope: "app" }, "settings/source/policySettings", "{ invalid json", { expectedVersion: null });
+    await writeSettingsSourceToStorage(storage, "flagSettings", ctx, createSettingsDocumentFromObject({}), { expectedVersion: null });
+
+    const mgr = createSettingsManager(host, ctx);
+    await mgr.initialize();
+    expect(mgr.getEffective().policyOrigin).toBe("invalid");
+    expect(mgr.getEffectiveConfig().hooks.disabled).toBe(true);
+    expect(mgr.getEffectiveConfig().hooks.managedOnly).toBe(true);
+    mgr.dispose();
+  });
+
+  test("remote policy refresh writes to cache (storage)", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_remote"), sessionId: "sess_policy_remote" };
+
+    const res = await refreshRemotePolicySettings({
+      storage,
+      ctx,
+      nowWallMs: 123,
+      provider: { fetchPolicySettings: async () => ({ allowManagedHooksOnly: true }) }
+    });
+    expect(res.updated).toBe(true);
+
+    const read = await readSettingsSourceFromStorage(storage, "policySettings", ctx);
+    expect(read.settings).toEqual({ allowManagedHooksOnly: true });
+    expect(read.origin).toBe("remote");
+  });
+});

[3m[35mfile update:[0m[0m
diff --git a/changelogs/implementation-20251217-093335/phase-6-changelog.md b/changelogs/implementation-20251217-093335/phase-6-changelog.md
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..0eef68699ae9525ddb44bd6e654732d6c2a7973f
--- a/changelogs/implementation-20251217-093335/phase-6-changelog.md
+++ b/changelogs/implementation-20251217-093335/phase-6-changelog.md
@@ -0,0 +1,55 @@
+## Summary (Phase 6)
+
+- Implemented a portable, layered settings system in `src/core/settings/*` with legacy-parity source keys, enabled-source selection, deterministic merge + patch semantics, and structured error reporting.
+- Added watchable settings propagation via storage subscriptions with internal-write suppression (version/pending-key based), plus a Node `HostStorage.subscribe()` implementation backed by `fs.watch`.
+- Added `EffectiveConfig` computation and feature-gate inventory, including a fail-closed policy-invalid behavior that disables hooks/managed-only gate.
+- Implemented portable storage mapping (app/workspace/session namespaces), settings doctor reporting, export/import bundles, legacy path mapping, and a remote policy refresh API that caches into storage.
+
+## Files changed
+
+- Deleted: `src/core/settings/index.ts`
+- Added:
+  - `src/core/settings/types.ts`
+  - `src/core/settings/schema.ts`
+  - `src/core/settings/sources.ts`
+  - `src/core/settings/merge.ts`
+  - `src/core/settings/patch.ts`
+  - `src/core/settings/secrets.ts`
+  - `src/core/settings/storage.ts`
+  - `src/core/settings/legacyPaths.ts`
+  - `src/core/settings/doctor.ts`
+  - `src/core/settings/effectiveConfig.ts`
+  - `src/core/settings/bundle.ts`
+  - `src/core/settings/manager.ts`
+  - `src/core/settings/policy.ts`
+  - `src/core/settings/index.ts`
+  - `tests/phase6-settings.test.ts`
+- Modified:
+  - `src/platform/node/host.ts`
+  - `implementation/1-initial-rewrite-implementation-checklist.md`
+
+## Decisions made
+
+- Settings schema strategy: TS-first + lightweight runtime validation (no new schema/tooling dependency added yet), with a versioned settings envelope (`kind: settings_document`, `schemaVersion: 1`) and legacy ‚Äúbare object‚Äù compatibility (`src/core/settings/schema.ts`).
+- Source enablement order: preserve legacy semantics where enabled sources = `allowedSettingSources` + `policySettings` + `flagSettings` (with policy added before flag so flags override policy in effective settings).
+- Merge vs patch semantics:
+  - Effective settings merge uses deep merge + array union/dedupe (primitive-only, legacy Set-like).
+  - Patches delete keys on `undefined` and **replace arrays** (matches legacy `E2/X2` behavior; required for rule/directory removals).
+- Policy invalid behavior: treat invalid policy settings as `policyOrigin: "invalid"` and fail-closed for hook gating in `EffectiveConfig` (hooks disabled + managedOnly enabled), with tests proving the contract.
+- Naming collision avoidance: renamed core MCP gate helper to `computeMcpCliGateSnapshotFromEnv` to avoid export conflicts with legacy-spec helpers re-exported from `src/spec/*`.
+
+## Tests/validation run + results
+
+- `bun test` (bun v1.3.4): PASS
+- `bun run typecheck`: PASS
+- `bun run check:boundaries`: PASS (`Import boundary check passed.`)
+- Legacy CLI sanity (auth + network): `claude --dangerously-skip-permissions -p sayhello` => PASS
+
+## Remaining work inside Phase 6
+
+- None identified (Phase 6 checklist fully checked off).
+
+## Handoff notes for next phase
+
+- Phase 7 (permissions) should treat settings sources as first-class (`SettingsSource` in `src/core/settings/types.ts`) and rely on per-source attribution from `readSettingsSourceFromStorage()` rather than the merged settings object for rule precedence.
+- Node hosts now support `HostStorage.subscribe()`; settings/watch flows can be exercised without filesystem-specific watchers.
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 0f8a6cc339d3af38f747a734b8f5c85d0c078526..d2d76396cb6e36a58dc9fabc34dbb1bf4ec24632
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -588,67 +588,67 @@
 Dependencies: Phase 4 storage abstraction and Phase 5 state/persistence.
 
 6.1 Schema strategy (types and validation without bundler artifacts)
-- [ ] Decide how settings schemas are authored and validated (schema-first with generated TS types, or TS-first with runtime validation).
-- [ ] Define a versioned settings schema format with explicit migration steps.
-- [ ] Define a strict parse/validate error model that can surface structured errors to UI (not just logs).
-- [ ] Define how ‚Äúempty/missing settings‚Äù are treated (valid empty object) and how IO errors are handled per source.
-- [ ] ‚ö†Ô∏è Do not decide final schema tooling yet; define required capabilities (runtime validation, JSON schema export, RN compatibility).
+- [x] Decide how settings schemas are authored and validated (schema-first with generated TS types, or TS-first with runtime validation).
+- [x] Define a versioned settings schema format with explicit migration steps.
+- [x] Define a strict parse/validate error model that can surface structured errors to UI (not just logs).
+- [x] Define how ‚Äúempty/missing settings‚Äù are treated (valid empty object) and how IO errors are handled per source.
+- [x] ‚ö†Ô∏è Do not decide final schema tooling yet; define required capabilities (runtime validation, JSON schema export, RN compatibility).
 
 6.2 Settings sources and precedence (portable representation of legacy behavior)
-- [ ] Define settings sources: user/project/local/policy/flag and non-file sources (cliArg/command/session) as first-class keys.
-- [ ] Define enabled-source selection semantics (legacy: allowlist for user/project/local, always include policy + flag).
-- [ ] Define merge semantics (deep merge rules, array replace/merge policy) and document per-field merge expectations.
-- [ ] Define policy settings origin semantics (remote vs local vs absent) and how origin is represented/explained to the user.
-- [ ] Define how ‚Äúcommand configuration‚Äù and ‚ÄúcliArg‚Äù overlays are represented without conflating with persisted sources.
+- [x] Define settings sources: user/project/local/policy/flag and non-file sources (cliArg/command/session) as first-class keys.
+- [x] Define enabled-source selection semantics (legacy: allowlist for user/project/local, always include policy + flag).
+- [x] Define merge semantics (deep merge rules, array replace/merge policy) and document per-field merge expectations.
+- [x] Define policy settings origin semantics (remote vs local vs absent) and how origin is represented/explained to the user.
+- [x] Define how ‚Äúcommand configuration‚Äù and ‚ÄúcliArg‚Äù overlays are represented without conflating with persisted sources.
 
 6.3 Watchers and change propagation (no filesystem assumption)
-- [ ] Define a settings event bus that emits `(source, effectiveSettings, errors)` updates.
-- [ ] Define internal-write suppression semantics (prevent write‚Üíwatch loop) without relying on filesystem watcher timestamps.
-- [ ] Define how watchers are implemented per host:
-  - [ ] Node/desktop: filesystem watcher adapter (optional)
-  - [ ] Web: storage event adapter or polling (as needed)
-  - [ ] Mobile: storage subscription or ‚Äúsettings changed‚Äù command-only model
-- [ ] Define how settings changes trigger state updates in the engine store (invalidate caches, recompute derived contexts).
+- [x] Define a settings event bus that emits `(source, effectiveSettings, errors)` updates.
+- [x] Define internal-write suppression semantics (prevent write‚Üíwatch loop) without relying on filesystem watcher timestamps.
+- [x] Define how watchers are implemented per host:
+  - [x] Node/desktop: filesystem watcher adapter (optional)
+  - [x] Web: storage event adapter or polling (as needed)
+  - [x] Mobile: storage subscription or ‚Äúsettings changed‚Äù command-only model
+- [x] Define how settings changes trigger state updates in the engine store (invalidate caches, recompute derived contexts).
 
 6.4 Settings patching and atomicity (portable ‚Äúpartial update‚Äù semantics)
-- [ ] Define a ‚Äúsettings patch‚Äù format (deep partial + array semantics) and how patches are applied deterministically.
-- [ ] Define atomic update expectations per storage backend (transaction/CAS where possible).
-- [ ] Define conflict resolution for concurrent updates (last-write wins vs version checks).
-- [ ] Define how settings edits are attributed to a source and how UI confirms the destination (user vs project vs local).
+- [x] Define a ‚Äúsettings patch‚Äù format (deep partial + array semantics) and how patches are applied deterministically.
+- [x] Define atomic update expectations per storage backend (transaction/CAS where possible).
+- [x] Define conflict resolution for concurrent updates (last-write wins vs version checks).
+- [x] Define how settings edits are attributed to a source and how UI confirms the destination (user vs project vs local).
 
 6.5 Compatibility and migration of existing settings files
-- [ ] Define how legacy file paths map into the new storage model (especially policy managed settings locations).
-- [ ] Define a migration plan for settings schema evolution (v2 files ‚Üí v3 schema) with rollback.
-- [ ] Define a ‚Äúdoctor‚Äù report for settings health (parse errors, invalid fields, policy overrides).
-- [ ] Define how to handle broken symlinks / unreadable settings sources in host environments that support symlinks (must not brick startup).
-- [ ] Define the legacy ‚Äúenabled sources‚Äù CLI parsing behavior and how it maps into portable settings selection.
+- [x] Define how legacy file paths map into the new storage model (especially policy managed settings locations).
+- [x] Define a migration plan for settings schema evolution (v2 files ‚Üí v3 schema) with rollback.
+- [x] Define a ‚Äúdoctor‚Äù report for settings health (parse errors, invalid fields, policy overrides).
+- [x] Define how to handle broken symlinks / unreadable settings sources in host environments that support symlinks (must not brick startup).
+- [x] Define the legacy ‚Äúenabled sources‚Äù CLI parsing behavior and how it maps into portable settings selection.
 
 6.6 Settings precedence and merge edge cases (test-first inventory)
-- [ ] Enumerate settings fields that require non-default merge behavior (arrays, maps, special objects) and document expected behavior.
-- [ ] Define explicit merge semantics for hook configs, permission rules, and MCP config subtrees (so later refactors don‚Äôt accidentally change them).
-- [ ] Define how to represent and surface settings validation errors from multiple sources (aggregate + per-source attribution).
-- [ ] Define how the engine behaves when policy settings are present but invalid (fail-closed vs ignore with warning; must be explicit and tested).
+- [x] Enumerate settings fields that require non-default merge behavior (arrays, maps, special objects) and document expected behavior.
+- [x] Define explicit merge semantics for hook configs, permission rules, and MCP config subtrees (so later refactors don‚Äôt accidentally change them).
+- [x] Define how to represent and surface settings validation errors from multiple sources (aggregate + per-source attribution).
+- [x] Define how the engine behaves when policy settings are present but invalid (fail-closed vs ignore with warning; must be explicit and tested).
 
 6.7 Portable settings storage mapping (per-host implementation checklist)
-- [ ] Define the storage keys / documents used to represent each source on non-filesystem hosts (user/project/local/policy/flag).
-- [ ] Define how ‚Äúproject settings‚Äù are scoped on mobile/web when there is no project root (explicit workspace concept, user-chosen workspace IDs).
-- [ ] Define how policy-managed settings are delivered on mobile (secure fetch + cache) and how offline behavior works.
-- [ ] Define how to export/import settings for support and migration (sanitized bundle; reproducible).
+- [x] Define the storage keys / documents used to represent each source on non-filesystem hosts (user/project/local/policy/flag).
+- [x] Define how ‚Äúproject settings‚Äù are scoped on mobile/web when there is no project root (explicit workspace concept, user-chosen workspace IDs).
+- [x] Define how policy-managed settings are delivered on mobile (secure fetch + cache) and how offline behavior works.
+- [x] Define how to export/import settings for support and migration (sanitized bundle; reproducible).
 
 6.8 Settings-derived feature gates and computed configuration (make implicit toggles explicit)
-- [ ] Inventory all legacy boolean ‚Äúswitches‚Äù that alter behavior (e.g., `disableAllHooks`, experimental MCP CLI enable, endpoint-mode enable, sandbox/network approval toggles) and classify each as:
-  - [ ] portable setting (works on all hosts)
-  - [ ] host-only setting (Node/desktop)
-  - [ ] env/flag alias (CLI convenience only)
-- [ ] Define a computed `EffectiveConfig` snapshot that the engine derives from settings + policy + host capabilities (single place to reason about feature gating).
-- [ ] Define which fields in `EffectiveConfig` are safe to persist vs must remain ephemeral (session-only, host-only).
-- [ ] Define how UI adapters render feature availability (capability-gated tool/hook visibility) without reading raw settings trees directly.
-- [ ] Add golden tests that assert: for a given set of sources, `EffectiveConfig` fields are computed identically across hosts (modulo capability presence).
+- [x] Inventory all legacy boolean ‚Äúswitches‚Äù that alter behavior (e.g., `disableAllHooks`, experimental MCP CLI enable, endpoint-mode enable, sandbox/network approval toggles) and classify each as:
+  - [x] portable setting (works on all hosts)
+  - [x] host-only setting (Node/desktop)
+  - [x] env/flag alias (CLI convenience only)
+- [x] Define a computed `EffectiveConfig` snapshot that the engine derives from settings + policy + host capabilities (single place to reason about feature gating).
+- [x] Define which fields in `EffectiveConfig` are safe to persist vs must remain ephemeral (session-only, host-only).
+- [x] Define how UI adapters render feature availability (capability-gated tool/hook visibility) without reading raw settings trees directly.
+- [x] Add golden tests that assert: for a given set of sources, `EffectiveConfig` fields are computed identically across hosts (modulo capability presence).
 
 6.9 Secrets, credentials, and redaction boundaries in configuration
-- [ ] Define an explicit schema boundary between configuration values and secrets (secrets never appear in exported settings snapshots or diagnostic bundles).
-- [ ] Define how secret references are represented in settings/config (opaque IDs that resolve via secret storage capability).
-- [ ] Define failure semantics when a secret reference cannot be resolved (prompt user vs hard error vs policy deny), and test each host‚Äôs UX path.
+- [x] Define an explicit schema boundary between configuration values and secrets (secrets never appear in exported settings snapshots or diagnostic bundles).
+- [x] Define how secret references are represented in settings/config (opaque IDs that resolve via secret storage capability).
+- [x] Define failure semantics when a secret reference cannot be resolved (prompt user vs hard error vs policy deny), and test each host‚Äôs UX path.
 
 ---
 
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..24200d9ba57abdc5f211427ef09a09aeecd06c4e
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,103 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+export type PersistableEffectiveConfig = Omit<EffectiveConfig, "capabilities">;
+
+export function toPersistableEffectiveConfig(cfg: EffectiveConfig): PersistableEffectiveConfig {
+  const { capabilities: _capabilities, ...rest } = cfg;
+  return rest;
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..204ebebcd1cd71a03c6484dc82093500f2af2313
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,50 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export {
+  LEGACY_SETTINGS_SCHEMA_URL,
+  SETTINGS_SCHEMA_TOOLING_REQUIREMENTS,
+  type SettingsDocumentV1,
+  parseSettingsJson,
+  serializeSettingsDocument
+} from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export {
+  LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS,
+  LEGACY_SETTINGS_MERGE_NOTES,
+  mergeJsonObject,
+  mergeSettingsObjectsInOrder,
+  unionDedupePreserveOrder,
+  type SettingsMergeFieldExpectation
+} from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export {
+  computeEffectiveConfig,
+  computeMcpCliGateSnapshotFromEnv,
+  LEGACY_FEATURE_GATES,
+  toPersistableEffectiveConfig,
+  type EffectiveConfig,
+  type PersistableEffectiveConfig
+} from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
+export { refreshRemotePolicySettings, type PolicySettingsProvider } from "./policy.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..66130cf305d726c9098be200408857636906f633
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,78 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
+export const LEGACY_SETTINGS_MERGE_NOTES = {
+  objects: "deep-merge",
+  arrays: "union-dedupe-preserve-order (primitive-only dedupe, legacy Set-like)",
+  patches: "arrays-replace, delete-on-undefined"
+} as const;
+
+export type SettingsMergeFieldExpectation = {
+  pointer: string;
+  merge: "deep" | "replace";
+  arrays: "union" | "replace";
+  patchArrays: "replace";
+  notes?: string;
+};
+
+export const LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS: readonly SettingsMergeFieldExpectation[] = [
+  {
+    pointer: "/permissions",
+    merge: "deep",
+    arrays: "union",
+    patchArrays: "replace",
+    notes: "Permission rules are evaluated per-source later; the merged view is for defaults and UI display."
+  },
+  { pointer: "/hooks", merge: "deep", arrays: "union", patchArrays: "replace", notes: "Hook config merges across sources; policy may gate." },
+  { pointer: "/mcp", merge: "deep", arrays: "union", patchArrays: "replace", notes: "MCP subtree merges across sources; later phases validate." }
+] as const;
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/policy.ts b/src/core/settings/policy.ts
new file mode 100644
index 0000000000000000000000000000000000000000..de330a5538eb0955feb703095eb99d0d1be241bd
--- /dev/null
+++ b/src/core/settings/policy.ts
@@ -0,0 +1,43 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, writeSettingsSourceToStorage, type SettingsStorageContext } from "./storage.js";
+import type { SettingsError, SettingsPolicyOrigin } from "./types.js";
+
+export type PolicySettingsProvider = {
+  fetchPolicySettings: (options: { nowWallMs: number }) => Promise<JsonObject | null>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export async function refreshRemotePolicySettings(options: {
+  storage: HostStorage;
+  ctx: SettingsStorageContext;
+  provider: PolicySettingsProvider;
+  nowWallMs: number;
+}): Promise<{ updated: boolean; errors: SettingsError[]; origin: SettingsPolicyOrigin }> {
+  try {
+    const fetched = await options.provider.fetchPolicySettings({ nowWallMs: options.nowWallMs });
+    if (fetched === null) return { updated: false, errors: [], origin: "absent" };
+    if (!isPlainObject(fetched)) {
+      return {
+        updated: false,
+        errors: [{ kind: "validation_error", source: "policySettings", message: "Remote policy settings must be an object", severity: "error" }],
+        origin: "invalid"
+      };
+    }
+
+    const doc = createSettingsDocumentFromObject(fetched, { origin: "remote", updatedAtWallMs: options.nowWallMs });
+    const res = await writeSettingsSourceToStorage(options.storage, "policySettings", options.ctx, doc);
+    if (!res.ok) return { updated: false, errors: [res.error], origin: "invalid" };
+    return { updated: true, errors: [], origin: "remote" };
+  } catch (cause) {
+    return {
+      updated: false,
+      errors: [{ kind: "io_error", source: "policySettings", message: "Failed to refresh remote policy settings", cause, severity: "warning" }],
+      origin: "absent"
+    };
+  }
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ced5912ed36097285e52b5f4877084be366c3fbd
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,97 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export const SETTINGS_SCHEMA_TOOLING_REQUIREMENTS = {
+  runtimeValidation: true,
+  jsonSchemaExport: true,
+  rnCompatible: true
+} as const;
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6da53c1d21f344633b85f1726789510f606fa648
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,251 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  refreshRemotePolicySettings,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+
+  test("invalid policy settings fail-closed in EffectiveConfig", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_invalid"), sessionId: "sess_policy_invalid" };
+
+    await storage.set({ scope: "app" }, "settings/source/policySettings", "{ invalid json", { expectedVersion: null });
+    await writeSettingsSourceToStorage(storage, "flagSettings", ctx, createSettingsDocumentFromObject({}), { expectedVersion: null });
+
+    const mgr = createSettingsManager(host, ctx);
+    await mgr.initialize();
+    expect(mgr.getEffective().policyOrigin).toBe("invalid");
+    expect(mgr.getEffectiveConfig().hooks.disabled).toBe(true);
+    expect(mgr.getEffectiveConfig().hooks.managedOnly).toBe(true);
+    mgr.dispose();
+  });
+
+  test("remote policy refresh writes to cache (storage)", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_remote"), sessionId: "sess_policy_remote" };
+
+    const res = await refreshRemotePolicySettings({
+      storage,
+      ctx,
+      nowWallMs: 123,
+      provider: { fetchPolicySettings: async () => ({ allowManagedHooksOnly: true }) }
+    });
+    expect(res.updated).toBe(true);
+
+    const read = await readSettingsSourceFromStorage(storage, "policySettings", ctx);
+    expect(read.settings).toEqual({ allowManagedHooksOnly: true });
+    expect(read.origin).toBe("remote");
+  });
+});

[35mPlan update[0m
  [32m‚úì[0m Read Phase 6 requirements
  [32m‚úì[0m Inspect bundled CLI behavior
  [32m‚úì[0m Implement Phase 6 modules
  [32m‚úì[0m Add Phase 6 tests
  [32m‚úì[0m Run required validations
  [32m‚úì[0m Update plan checklist and changelog
[35m[3mcodex[0m[0m
## Summary (Phase 6)

- Implemented a portable, layered settings system in `src/core/settings/*` with legacy-parity source keys, enabled-source selection, deterministic merge + patch semantics, and structured error reporting.
- Added watchable settings propagation via storage subscriptions with internal-write suppression (version/pending-key based), plus a Node `HostStorage.subscribe()` implementation backed by `fs.watch`.
- Added `EffectiveConfig` computation and feature-gate inventory, including a fail-closed policy-invalid behavior that disables hooks/managed-only gate.
- Implemented portable storage mapping (app/workspace/session namespaces), settings doctor reporting, export/import bundles, legacy path mapping, and a remote policy refresh API that caches into storage.

## Files changed

- Deleted: `src/core/settings/index.ts`
- Added:
  - `src/core/settings/types.ts`
  - `src/core/settings/schema.ts`
  - `src/core/settings/sources.ts`
  - `src/core/settings/merge.ts`
  - `src/core/settings/patch.ts`
  - `src/core/settings/secrets.ts`
  - `src/core/settings/storage.ts`
  - `src/core/settings/legacyPaths.ts`
  - `src/core/settings/doctor.ts`
  - `src/core/settings/effectiveConfig.ts`
  - `src/core/settings/bundle.ts`
  - `src/core/settings/manager.ts`
  - `src/core/settings/policy.ts`
  - `src/core/settings/index.ts`
  - `tests/phase6-settings.test.ts`
- Modified:
  - `src/platform/node/host.ts`
  - `implementation/1-initial-rewrite-implementation-checklist.md`

## Decisions made

- Settings schema strategy: TS-first + lightweight runtime validation (no new schema/tooling dependency added yet), with a versioned settings envelope (`kind: settings_document`, `schemaVersion: 1`) and legacy ‚Äúbare object‚Äù compatibility (`src/core/settings/schema.ts`).
- Source enablement order: preserve legacy semantics where enabled sources = `allowedSettingSources` + `policySettings` + `flagSettings` (with policy added before flag so flags override policy in effective settings).
- Merge vs patch semantics:
  - Effective settings merge uses deep merge + array union/dedupe (primitive-only, legacy Set-like).
  - Patches delete keys on `undefined` and **replace arrays** (matches legacy `E2/X2` behavior; required for rule/directory removals).
- Policy invalid behavior: treat invalid policy settings as `policyOrigin: "invalid"` and fail-closed for hook gating in `EffectiveConfig` (hooks disabled + managedOnly enabled), with tests proving the contract.
- Naming collision avoidance: renamed core MCP gate helper to `computeMcpCliGateSnapshotFromEnv` to avoid export conflicts with legacy-spec helpers re-exported from `src/spec/*`.

## Tests/validation run + results

- `bun test` (bun v1.3.4): PASS
- `bun run typecheck`: PASS
- `bun run check:boundaries`: PASS (`Import boundary check passed.`)
- Legacy CLI sanity (auth + network): `claude --dangerously-skip-permissions -p sayhello` => PASS

## Remaining work inside Phase 6

- None identified (Phase 6 checklist fully checked off).

## Handoff notes for next phase

- Phase 7 (permissions) should treat settings sources as first-class (`SettingsSource` in `src/core/settings/types.ts`) and rely on per-source attribution from `readSettingsSourceFromStorage()` rather than the merged settings object for rule precedence.
- Node hosts now support `HostStorage.subscribe()`; settings/watch flows can be exercised without filesystem-specific watchers.
[3m[35mfile update:[0m[0m
diff --git a/changelogs/implementation-20251217-093335/phase-6-changelog.md b/changelogs/implementation-20251217-093335/phase-6-changelog.md
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..0eef68699ae9525ddb44bd6e654732d6c2a7973f
--- a/changelogs/implementation-20251217-093335/phase-6-changelog.md
+++ b/changelogs/implementation-20251217-093335/phase-6-changelog.md
@@ -0,0 +1,55 @@
+## Summary (Phase 6)
+
+- Implemented a portable, layered settings system in `src/core/settings/*` with legacy-parity source keys, enabled-source selection, deterministic merge + patch semantics, and structured error reporting.
+- Added watchable settings propagation via storage subscriptions with internal-write suppression (version/pending-key based), plus a Node `HostStorage.subscribe()` implementation backed by `fs.watch`.
+- Added `EffectiveConfig` computation and feature-gate inventory, including a fail-closed policy-invalid behavior that disables hooks/managed-only gate.
+- Implemented portable storage mapping (app/workspace/session namespaces), settings doctor reporting, export/import bundles, legacy path mapping, and a remote policy refresh API that caches into storage.
+
+## Files changed
+
+- Deleted: `src/core/settings/index.ts`
+- Added:
+  - `src/core/settings/types.ts`
+  - `src/core/settings/schema.ts`
+  - `src/core/settings/sources.ts`
+  - `src/core/settings/merge.ts`
+  - `src/core/settings/patch.ts`
+  - `src/core/settings/secrets.ts`
+  - `src/core/settings/storage.ts`
+  - `src/core/settings/legacyPaths.ts`
+  - `src/core/settings/doctor.ts`
+  - `src/core/settings/effectiveConfig.ts`
+  - `src/core/settings/bundle.ts`
+  - `src/core/settings/manager.ts`
+  - `src/core/settings/policy.ts`
+  - `src/core/settings/index.ts`
+  - `tests/phase6-settings.test.ts`
+- Modified:
+  - `src/platform/node/host.ts`
+  - `implementation/1-initial-rewrite-implementation-checklist.md`
+
+## Decisions made
+
+- Settings schema strategy: TS-first + lightweight runtime validation (no new schema/tooling dependency added yet), with a versioned settings envelope (`kind: settings_document`, `schemaVersion: 1`) and legacy ‚Äúbare object‚Äù compatibility (`src/core/settings/schema.ts`).
+- Source enablement order: preserve legacy semantics where enabled sources = `allowedSettingSources` + `policySettings` + `flagSettings` (with policy added before flag so flags override policy in effective settings).
+- Merge vs patch semantics:
+  - Effective settings merge uses deep merge + array union/dedupe (primitive-only, legacy Set-like).
+  - Patches delete keys on `undefined` and **replace arrays** (matches legacy `E2/X2` behavior; required for rule/directory removals).
+- Policy invalid behavior: treat invalid policy settings as `policyOrigin: "invalid"` and fail-closed for hook gating in `EffectiveConfig` (hooks disabled + managedOnly enabled), with tests proving the contract.
+- Naming collision avoidance: renamed core MCP gate helper to `computeMcpCliGateSnapshotFromEnv` to avoid export conflicts with legacy-spec helpers re-exported from `src/spec/*`.
+
+## Tests/validation run + results
+
+- `bun test` (bun v1.3.4): PASS
+- `bun run typecheck`: PASS
+- `bun run check:boundaries`: PASS (`Import boundary check passed.`)
+- Legacy CLI sanity (auth + network): `claude --dangerously-skip-permissions -p sayhello` => PASS
+
+## Remaining work inside Phase 6
+
+- None identified (Phase 6 checklist fully checked off).
+
+## Handoff notes for next phase
+
+- Phase 7 (permissions) should treat settings sources as first-class (`SettingsSource` in `src/core/settings/types.ts`) and rely on per-source attribution from `readSettingsSourceFromStorage()` rather than the merged settings object for rule precedence.
+- Node hosts now support `HostStorage.subscribe()`; settings/watch flows can be exercised without filesystem-specific watchers.
diff --git a/implementation/1-initial-rewrite-implementation-checklist.md b/implementation/1-initial-rewrite-implementation-checklist.md
index 0f8a6cc339d3af38f747a734b8f5c85d0c078526..d2d76396cb6e36a58dc9fabc34dbb1bf4ec24632
--- a/implementation/1-initial-rewrite-implementation-checklist.md
+++ b/implementation/1-initial-rewrite-implementation-checklist.md
@@ -588,67 +588,67 @@
 Dependencies: Phase 4 storage abstraction and Phase 5 state/persistence.
 
 6.1 Schema strategy (types and validation without bundler artifacts)
-- [ ] Decide how settings schemas are authored and validated (schema-first with generated TS types, or TS-first with runtime validation).
-- [ ] Define a versioned settings schema format with explicit migration steps.
-- [ ] Define a strict parse/validate error model that can surface structured errors to UI (not just logs).
-- [ ] Define how ‚Äúempty/missing settings‚Äù are treated (valid empty object) and how IO errors are handled per source.
-- [ ] ‚ö†Ô∏è Do not decide final schema tooling yet; define required capabilities (runtime validation, JSON schema export, RN compatibility).
+- [x] Decide how settings schemas are authored and validated (schema-first with generated TS types, or TS-first with runtime validation).
+- [x] Define a versioned settings schema format with explicit migration steps.
+- [x] Define a strict parse/validate error model that can surface structured errors to UI (not just logs).
+- [x] Define how ‚Äúempty/missing settings‚Äù are treated (valid empty object) and how IO errors are handled per source.
+- [x] ‚ö†Ô∏è Do not decide final schema tooling yet; define required capabilities (runtime validation, JSON schema export, RN compatibility).
 
 6.2 Settings sources and precedence (portable representation of legacy behavior)
-- [ ] Define settings sources: user/project/local/policy/flag and non-file sources (cliArg/command/session) as first-class keys.
-- [ ] Define enabled-source selection semantics (legacy: allowlist for user/project/local, always include policy + flag).
-- [ ] Define merge semantics (deep merge rules, array replace/merge policy) and document per-field merge expectations.
-- [ ] Define policy settings origin semantics (remote vs local vs absent) and how origin is represented/explained to the user.
-- [ ] Define how ‚Äúcommand configuration‚Äù and ‚ÄúcliArg‚Äù overlays are represented without conflating with persisted sources.
+- [x] Define settings sources: user/project/local/policy/flag and non-file sources (cliArg/command/session) as first-class keys.
+- [x] Define enabled-source selection semantics (legacy: allowlist for user/project/local, always include policy + flag).
+- [x] Define merge semantics (deep merge rules, array replace/merge policy) and document per-field merge expectations.
+- [x] Define policy settings origin semantics (remote vs local vs absent) and how origin is represented/explained to the user.
+- [x] Define how ‚Äúcommand configuration‚Äù and ‚ÄúcliArg‚Äù overlays are represented without conflating with persisted sources.
 
 6.3 Watchers and change propagation (no filesystem assumption)
-- [ ] Define a settings event bus that emits `(source, effectiveSettings, errors)` updates.
-- [ ] Define internal-write suppression semantics (prevent write‚Üíwatch loop) without relying on filesystem watcher timestamps.
-- [ ] Define how watchers are implemented per host:
-  - [ ] Node/desktop: filesystem watcher adapter (optional)
-  - [ ] Web: storage event adapter or polling (as needed)
-  - [ ] Mobile: storage subscription or ‚Äúsettings changed‚Äù command-only model
-- [ ] Define how settings changes trigger state updates in the engine store (invalidate caches, recompute derived contexts).
+- [x] Define a settings event bus that emits `(source, effectiveSettings, errors)` updates.
+- [x] Define internal-write suppression semantics (prevent write‚Üíwatch loop) without relying on filesystem watcher timestamps.
+- [x] Define how watchers are implemented per host:
+  - [x] Node/desktop: filesystem watcher adapter (optional)
+  - [x] Web: storage event adapter or polling (as needed)
+  - [x] Mobile: storage subscription or ‚Äúsettings changed‚Äù command-only model
+- [x] Define how settings changes trigger state updates in the engine store (invalidate caches, recompute derived contexts).
 
 6.4 Settings patching and atomicity (portable ‚Äúpartial update‚Äù semantics)
-- [ ] Define a ‚Äúsettings patch‚Äù format (deep partial + array semantics) and how patches are applied deterministically.
-- [ ] Define atomic update expectations per storage backend (transaction/CAS where possible).
-- [ ] Define conflict resolution for concurrent updates (last-write wins vs version checks).
-- [ ] Define how settings edits are attributed to a source and how UI confirms the destination (user vs project vs local).
+- [x] Define a ‚Äúsettings patch‚Äù format (deep partial + array semantics) and how patches are applied deterministically.
+- [x] Define atomic update expectations per storage backend (transaction/CAS where possible).
+- [x] Define conflict resolution for concurrent updates (last-write wins vs version checks).
+- [x] Define how settings edits are attributed to a source and how UI confirms the destination (user vs project vs local).
 
 6.5 Compatibility and migration of existing settings files
-- [ ] Define how legacy file paths map into the new storage model (especially policy managed settings locations).
-- [ ] Define a migration plan for settings schema evolution (v2 files ‚Üí v3 schema) with rollback.
-- [ ] Define a ‚Äúdoctor‚Äù report for settings health (parse errors, invalid fields, policy overrides).
-- [ ] Define how to handle broken symlinks / unreadable settings sources in host environments that support symlinks (must not brick startup).
-- [ ] Define the legacy ‚Äúenabled sources‚Äù CLI parsing behavior and how it maps into portable settings selection.
+- [x] Define how legacy file paths map into the new storage model (especially policy managed settings locations).
+- [x] Define a migration plan for settings schema evolution (v2 files ‚Üí v3 schema) with rollback.
+- [x] Define a ‚Äúdoctor‚Äù report for settings health (parse errors, invalid fields, policy overrides).
+- [x] Define how to handle broken symlinks / unreadable settings sources in host environments that support symlinks (must not brick startup).
+- [x] Define the legacy ‚Äúenabled sources‚Äù CLI parsing behavior and how it maps into portable settings selection.
 
 6.6 Settings precedence and merge edge cases (test-first inventory)
-- [ ] Enumerate settings fields that require non-default merge behavior (arrays, maps, special objects) and document expected behavior.
-- [ ] Define explicit merge semantics for hook configs, permission rules, and MCP config subtrees (so later refactors don‚Äôt accidentally change them).
-- [ ] Define how to represent and surface settings validation errors from multiple sources (aggregate + per-source attribution).
-- [ ] Define how the engine behaves when policy settings are present but invalid (fail-closed vs ignore with warning; must be explicit and tested).
+- [x] Enumerate settings fields that require non-default merge behavior (arrays, maps, special objects) and document expected behavior.
+- [x] Define explicit merge semantics for hook configs, permission rules, and MCP config subtrees (so later refactors don‚Äôt accidentally change them).
+- [x] Define how to represent and surface settings validation errors from multiple sources (aggregate + per-source attribution).
+- [x] Define how the engine behaves when policy settings are present but invalid (fail-closed vs ignore with warning; must be explicit and tested).
 
 6.7 Portable settings storage mapping (per-host implementation checklist)
-- [ ] Define the storage keys / documents used to represent each source on non-filesystem hosts (user/project/local/policy/flag).
-- [ ] Define how ‚Äúproject settings‚Äù are scoped on mobile/web when there is no project root (explicit workspace concept, user-chosen workspace IDs).
-- [ ] Define how policy-managed settings are delivered on mobile (secure fetch + cache) and how offline behavior works.
-- [ ] Define how to export/import settings for support and migration (sanitized bundle; reproducible).
+- [x] Define the storage keys / documents used to represent each source on non-filesystem hosts (user/project/local/policy/flag).
+- [x] Define how ‚Äúproject settings‚Äù are scoped on mobile/web when there is no project root (explicit workspace concept, user-chosen workspace IDs).
+- [x] Define how policy-managed settings are delivered on mobile (secure fetch + cache) and how offline behavior works.
+- [x] Define how to export/import settings for support and migration (sanitized bundle; reproducible).
 
 6.8 Settings-derived feature gates and computed configuration (make implicit toggles explicit)
-- [ ] Inventory all legacy boolean ‚Äúswitches‚Äù that alter behavior (e.g., `disableAllHooks`, experimental MCP CLI enable, endpoint-mode enable, sandbox/network approval toggles) and classify each as:
-  - [ ] portable setting (works on all hosts)
-  - [ ] host-only setting (Node/desktop)
-  - [ ] env/flag alias (CLI convenience only)
-- [ ] Define a computed `EffectiveConfig` snapshot that the engine derives from settings + policy + host capabilities (single place to reason about feature gating).
-- [ ] Define which fields in `EffectiveConfig` are safe to persist vs must remain ephemeral (session-only, host-only).
-- [ ] Define how UI adapters render feature availability (capability-gated tool/hook visibility) without reading raw settings trees directly.
-- [ ] Add golden tests that assert: for a given set of sources, `EffectiveConfig` fields are computed identically across hosts (modulo capability presence).
+- [x] Inventory all legacy boolean ‚Äúswitches‚Äù that alter behavior (e.g., `disableAllHooks`, experimental MCP CLI enable, endpoint-mode enable, sandbox/network approval toggles) and classify each as:
+  - [x] portable setting (works on all hosts)
+  - [x] host-only setting (Node/desktop)
+  - [x] env/flag alias (CLI convenience only)
+- [x] Define a computed `EffectiveConfig` snapshot that the engine derives from settings + policy + host capabilities (single place to reason about feature gating).
+- [x] Define which fields in `EffectiveConfig` are safe to persist vs must remain ephemeral (session-only, host-only).
+- [x] Define how UI adapters render feature availability (capability-gated tool/hook visibility) without reading raw settings trees directly.
+- [x] Add golden tests that assert: for a given set of sources, `EffectiveConfig` fields are computed identically across hosts (modulo capability presence).
 
 6.9 Secrets, credentials, and redaction boundaries in configuration
-- [ ] Define an explicit schema boundary between configuration values and secrets (secrets never appear in exported settings snapshots or diagnostic bundles).
-- [ ] Define how secret references are represented in settings/config (opaque IDs that resolve via secret storage capability).
-- [ ] Define failure semantics when a secret reference cannot be resolved (prompt user vs hard error vs policy deny), and test each host‚Äôs UX path.
+- [x] Define an explicit schema boundary between configuration values and secrets (secrets never appear in exported settings snapshots or diagnostic bundles).
+- [x] Define how secret references are represented in settings/config (opaque IDs that resolve via secret storage capability).
+- [x] Define failure semantics when a secret reference cannot be resolved (prompt user vs hard error vs policy deny), and test each host‚Äôs UX path.
 
 ---
 
diff --git a/src/core/settings/bundle.ts b/src/core/settings/bundle.ts
new file mode 100644
index 0000000000000000000000000000000000000000..533877ef22fb5e1148aad8a4e23cc755dccb8071
--- /dev/null
+++ b/src/core/settings/bundle.ts
@@ -0,0 +1,49 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, readSettingsSourceFromStorage, writeSettingsSourceToStorage } from "./storage.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+import type { SettingsStorageContext } from "./storage.js";
+
+export type ExportedSettingsBundleV1 = {
+  schemaVersion: 1;
+  exportedAtWallMs: number;
+  sources: Partial<Record<SettingsSource, JsonObject>>;
+};
+
+export async function exportSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  sources: readonly SettingsSource[],
+  exportedAtWallMs: number
+): Promise<{ bundle: ExportedSettingsBundleV1; errors: SettingsError[] }> {
+  const out: ExportedSettingsBundleV1 = { schemaVersion: 1, exportedAtWallMs, sources: {} };
+  const errors: SettingsError[] = [];
+
+  for (const source of sources) {
+    const res = await readSettingsSourceFromStorage(storage, source, ctx);
+    errors.push(...res.errors);
+    if (res.settings) out.sources[source] = res.settings;
+  }
+
+  return { bundle: out, errors };
+}
+
+export async function importSettingsBundleV1(
+  storage: HostStorage,
+  ctx: SettingsStorageContext,
+  bundle: ExportedSettingsBundleV1
+): Promise<{ ok: true } | { ok: false; errors: SettingsError[] }> {
+  const errors: SettingsError[] = [];
+  if (bundle.schemaVersion !== 1) {
+    return { ok: false, errors: [{ kind: "validation_error", source: "userSettings", message: "Unsupported bundle schema version" }] };
+  }
+
+  for (const [source, settings] of Object.entries(bundle.sources) as Array<[SettingsSource, JsonObject]>) {
+    const doc = createSettingsDocumentFromObject(settings);
+    const res = await writeSettingsSourceToStorage(storage, source, ctx, doc);
+    if (!res.ok) errors.push(res.error);
+  }
+
+  if (errors.length > 0) return { ok: false, errors };
+  return { ok: true };
+}
diff --git a/src/core/settings/doctor.ts b/src/core/settings/doctor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e3800d615bd3e01a34c2e931fceb84c6e498e452
--- /dev/null
+++ b/src/core/settings/doctor.ts
@@ -0,0 +1,89 @@
+import type { JsonObject } from "../types/json.js";
+import type { EffectiveSettingsResult, SettingsError, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsDoctorReport = {
+  policyOrigin: SettingsPolicyOrigin;
+  hasErrors: boolean;
+  errors: SettingsError[];
+  perSource: Array<{ source: SettingsSourceReadResult["source"]; status: "missing" | "ok" | "invalid"; errorCount: number }>;
+  policyOverrides: Array<{ pointer: string; overriddenSources: string[] }>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function enumeratePointers(obj: JsonObject, prefix = ""): string[] {
+  const out: string[] = [];
+  for (const [k, v] of Object.entries(obj)) {
+    const pointer = `${prefix}/${k}`;
+    out.push(pointer);
+    if (isPlainObject(v)) out.push(...enumeratePointers(v, pointer));
+  }
+  return out;
+}
+
+function getPointerValue(obj: JsonObject, pointer: string): unknown {
+  const parts = pointer.split("/").slice(1);
+  let cur: unknown = obj;
+  for (const part of parts) {
+    if (!isPlainObject(cur)) return undefined;
+    cur = cur[part];
+  }
+  return cur;
+}
+
+function jsonStableStringify(value: unknown): string {
+  if (value === null || typeof value !== "object") return JSON.stringify(value);
+  if (Array.isArray(value)) return JSON.stringify(value.map((v) => JSON.parse(jsonStableStringify(v))));
+  const obj = value as Record<string, unknown>;
+  const keys = Object.keys(obj).sort();
+  const normalized: Record<string, unknown> = {};
+  for (const k of keys) normalized[k] = JSON.parse(jsonStableStringify(obj[k]));
+  return JSON.stringify(normalized);
+}
+
+export function buildSettingsDoctorReport(effective: EffectiveSettingsResult): SettingsDoctorReport {
+  const errors = effective.errors;
+  const perSource: SettingsDoctorReport["perSource"] = [];
+  for (const src of Object.values(effective.perSource)) {
+    if (!src) continue;
+    const status = src.settings === null && src.errors.length === 0 ? "missing" : src.errors.length > 0 ? "invalid" : "ok";
+    perSource.push({ source: src.source, status, errorCount: src.errors.length });
+  }
+  perSource.sort((a, b) => a.source.localeCompare(b.source));
+
+  const policy = effective.perSource.policySettings?.settings ?? null;
+  const policyOverrides: SettingsDoctorReport["policyOverrides"] = [];
+  if (policy && effective.policyOrigin !== "invalid") {
+    const pointers = enumeratePointers(policy);
+    const overriddenByPointer = new Map<string, Set<string>>();
+
+    for (const pointer of pointers) {
+      const policyValue = getPointerValue(policy, pointer);
+      if (policyValue === undefined) continue;
+      const overriddenSources = new Set<string>();
+      for (const [source, src] of Object.entries(effective.perSource)) {
+        if (!src?.settings) continue;
+        if (source === "policySettings") continue;
+        const srcValue = getPointerValue(src.settings, pointer);
+        if (srcValue === undefined) continue;
+        if (jsonStableStringify(srcValue) !== jsonStableStringify(policyValue)) overriddenSources.add(source);
+      }
+      if (overriddenSources.size > 0) overriddenByPointer.set(pointer, overriddenSources);
+    }
+
+    for (const [pointer, sources] of overriddenByPointer) {
+      policyOverrides.push({ pointer, overriddenSources: Array.from(sources).sort() });
+    }
+    policyOverrides.sort((a, b) => a.pointer.localeCompare(b.pointer));
+  }
+
+  return {
+    policyOrigin: effective.policyOrigin,
+    hasErrors: errors.length > 0 || effective.policyOrigin === "invalid",
+    errors,
+    perSource,
+    policyOverrides
+  };
+}
diff --git a/src/core/settings/effectiveConfig.ts b/src/core/settings/effectiveConfig.ts
new file mode 100644
index 0000000000000000000000000000000000000000..24200d9ba57abdc5f211427ef09a09aeecd06c4e
--- /dev/null
+++ b/src/core/settings/effectiveConfig.ts
@@ -0,0 +1,103 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import type { SettingsPolicyOrigin, SettingsSourceReadResult } from "./types.js";
+
+export type FeatureGateKind = "portable" | "host_only" | "env_alias";
+
+export type FeatureGateDescriptor = {
+  key: string;
+  kind: FeatureGateKind;
+  notes?: string;
+};
+
+export const LEGACY_FEATURE_GATES: readonly FeatureGateDescriptor[] = [
+  { key: "disableAllHooks", kind: "portable" },
+  { key: "allowManagedHooksOnly", kind: "portable", notes: "Policy-only gate; excludes non-managed hooks" },
+  { key: "ENABLE_EXPERIMENTAL_MCP_CLI", kind: "env_alias", notes: "CLI-only MCP CLI entrypoint gate" },
+  { key: "ENABLE_MCP_CLI_ENDPOINT", kind: "env_alias", notes: "CLI-only MCP endpoint-mode gate" },
+  { key: "MCP_TOOL_TIMEOUT", kind: "env_alias", notes: "CLI env overlay for MCP timeouts" },
+  { key: "MAX_MCP_OUTPUT_TOKENS", kind: "env_alias", notes: "CLI env overlay for MCP token caps" }
+];
+
+export type EffectiveConfig = {
+  schemaVersion: 1;
+  policy: { origin: SettingsPolicyOrigin };
+  hooks: { disabled: boolean; managedOnly: boolean };
+  mcpCli: {
+    enableExperimentalMcpCli: boolean;
+    enableMcpCliEndpoint: boolean;
+    mcpToolTimeoutMs: number | null;
+    maxMcpOutputTokens: number | null;
+  };
+  capabilities: { hasFilesystem: boolean; hasNetwork: boolean; hasSecrets: boolean };
+};
+
+export type PersistableEffectiveConfig = Omit<EffectiveConfig, "capabilities">;
+
+export function toPersistableEffectiveConfig(cfg: EffectiveConfig): PersistableEffectiveConfig {
+  const { capabilities: _capabilities, ...rest } = cfg;
+  return rest;
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function readBoolean(obj: JsonObject, key: string): boolean | null {
+  const v = obj[key];
+  return typeof v === "boolean" ? v : null;
+}
+
+function readString(obj: JsonObject, key: string): string | null {
+  const v = obj[key];
+  return typeof v === "string" ? v : null;
+}
+
+function parseIntEnv(value: string | undefined): number | null {
+  if (!value) return null;
+  const n = Number.parseInt(value, 10);
+  if (!Number.isFinite(n)) return null;
+  return n;
+}
+
+export function computeMcpCliGateSnapshotFromEnv(env: Record<string, string | undefined>): EffectiveConfig["mcpCli"] {
+  const experimental = env["ENABLE_EXPERIMENTAL_MCP_CLI"] === "1" || env["ENABLE_EXPERIMENTAL_MCP_CLI"]?.toLowerCase() === "true";
+  const endpointDisabled = env["ENABLE_MCP_CLI_ENDPOINT"] === "0" || env["ENABLE_MCP_CLI_ENDPOINT"]?.toLowerCase() === "false";
+  return {
+    enableExperimentalMcpCli: experimental,
+    enableMcpCliEndpoint: experimental && !endpointDisabled,
+    mcpToolTimeoutMs: parseIntEnv(env["MCP_TOOL_TIMEOUT"]),
+    maxMcpOutputTokens: parseIntEnv(env["MAX_MCP_OUTPUT_TOKENS"])
+  };
+}
+
+export function computeEffectiveConfig(options: {
+  effectiveSettings: JsonObject;
+  policySource: SettingsSourceReadResult | undefined;
+  policyOrigin: SettingsPolicyOrigin;
+  host: HostCapabilities;
+  env?: Record<string, string | undefined>;
+}): EffectiveConfig {
+  const disableAllHooks = readBoolean(options.effectiveSettings, "disableAllHooks") ?? false;
+
+  const policySettings = options.policySource?.settings ?? null;
+  const managedOnly =
+    (policySettings && isPlainObject(policySettings) ? readBoolean(policySettings, "allowManagedHooksOnly") : null) ?? false;
+
+  const mcpCli = computeMcpCliGateSnapshotFromEnv(options.env ?? {});
+
+  const hasFilesystem = options.host.filesystem.kind === "available";
+  const hasNetwork = options.host.network.kind === "available";
+  const hasSecrets = options.host.secrets.kind === "available";
+
+  const policyOrigin = options.policyOrigin;
+  const failClosed = policyOrigin === "invalid";
+
+  return {
+    schemaVersion: 1,
+    policy: { origin: policyOrigin },
+    hooks: { disabled: disableAllHooks || failClosed, managedOnly: managedOnly || failClosed },
+    mcpCli,
+    capabilities: { hasFilesystem, hasNetwork, hasSecrets }
+  };
+}
diff --git a/src/core/settings/index.ts b/src/core/settings/index.ts
index 5d732f7ac28e0c19ce0cc3274c73dfd0ad387be5..204ebebcd1cd71a03c6484dc82093500f2af2313
--- a/src/core/settings/index.ts
+++ b/src/core/settings/index.ts
@@ -1,4 +1,50 @@
-export type SettingsPlaceholder = {
-  phase: "2";
-};
-
+export type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  WritableSettingsSource
+} from "./types.js";
+export {
+  LEGACY_SETTINGS_SCHEMA_URL,
+  SETTINGS_SCHEMA_TOOLING_REQUIREMENTS,
+  type SettingsDocumentV1,
+  parseSettingsJson,
+  serializeSettingsDocument
+} from "./schema.js";
+export { parseEnabledSettingSourcesFlag, computeEnabledFileSettingsSources } from "./sources.js";
+export {
+  LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS,
+  LEGACY_SETTINGS_MERGE_NOTES,
+  mergeJsonObject,
+  mergeSettingsObjectsInOrder,
+  unionDedupePreserveOrder,
+  type SettingsMergeFieldExpectation
+} from "./merge.js";
+export { applySettingsPatch, type SettingsPatchObject, type SettingsPatchValue } from "./patch.js";
+export { isSecretRefV1, resolveSecretRefV1, type SecretRefV1, type SecretResolutionResult } from "./secrets.js";
+export {
+  SETTINGS_STORAGE_KEY_PREFIX,
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage
+} from "./storage.js";
+export { resolveLegacySettingsFilePath, resolveLegacySettingsBaseDir, resolveLegacyPolicySystemDir } from "./legacyPaths.js";
+export { buildSettingsDoctorReport, type SettingsDoctorReport } from "./doctor.js";
+export {
+  computeEffectiveConfig,
+  computeMcpCliGateSnapshotFromEnv,
+  LEGACY_FEATURE_GATES,
+  toPersistableEffectiveConfig,
+  type EffectiveConfig,
+  type PersistableEffectiveConfig
+} from "./effectiveConfig.js";
+export { exportSettingsBundleV1, importSettingsBundleV1, type ExportedSettingsBundleV1 } from "./bundle.js";
+export { createSettingsManager, type SettingsManager } from "./manager.js";
+export { refreshRemotePolicySettings, type PolicySettingsProvider } from "./policy.js";
diff --git a/src/core/settings/legacyPaths.ts b/src/core/settings/legacyPaths.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4ab5c39f30a136b0abdb13e39dc6fecafdf628f2
--- /dev/null
+++ b/src/core/settings/legacyPaths.ts
@@ -0,0 +1,64 @@
+import type { HostFilesystem, HostProcess } from "../types/host.js";
+import type { FileBackedSettingsSource } from "./types.js";
+
+export type LegacySettingsPathContext = {
+  process?: HostProcess;
+  filesystem?: HostFilesystem;
+  configDir?: string;
+  projectRoot?: string;
+  flagSettingsPath?: string | null;
+};
+
+export function defaultLegacyConfigDir(process: HostProcess | undefined): string | null {
+  const viaEnv = process?.getEnv?.("CLAUDE_CONFIG_DIR");
+  if (viaEnv) return viaEnv;
+  return null;
+}
+
+export async function resolveLegacyPolicySystemDir(ctx: LegacySettingsPathContext): Promise<string> {
+  const platform = ctx.process?.platform?.() ?? "unknown";
+  if (platform === "win32") {
+    return "C:\\\\ProgramData\\\\ClaudeCode";
+  }
+  if (platform === "darwin") return "/Library/Application Support/ClaudeCode";
+  return "/etc/claude-code";
+}
+
+export function resolveLegacySettingsBaseDir(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): string | null {
+  switch (source) {
+    case "userSettings":
+      return ctx.configDir ?? defaultLegacyConfigDir(ctx.process);
+    case "projectSettings":
+    case "localSettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "policySettings":
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    case "flagSettings": {
+      const flagPath = ctx.flagSettingsPath ?? null;
+      if (flagPath) {
+        const idx = Math.max(flagPath.lastIndexOf("/"), flagPath.lastIndexOf("\\")); // tolerate Windows separators
+        return idx >= 0 ? flagPath.slice(0, idx) : ".";
+      }
+      return ctx.projectRoot ?? ctx.process?.getCwd?.() ?? null;
+    }
+  }
+}
+
+export async function resolveLegacySettingsFilePath(source: FileBackedSettingsSource, ctx: LegacySettingsPathContext): Promise<string | null> {
+  const base = resolveLegacySettingsBaseDir(source, ctx);
+  if (source === "flagSettings") return ctx.flagSettingsPath ?? null;
+  if (!base) return null;
+
+  switch (source) {
+    case "userSettings":
+      return `${base}/settings.json`;
+    case "projectSettings":
+      return `${base}/.claude/settings.json`;
+    case "localSettings":
+      return `${base}/.claude/settings.local.json`;
+    case "policySettings": {
+      const sys = await resolveLegacyPolicySystemDir(ctx);
+      return `${sys}/managed-settings.json`;
+    }
+  }
+}
diff --git a/src/core/settings/manager.ts b/src/core/settings/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5045069b9dfcf902ab6b5f7610b6b96e962b7647
--- /dev/null
+++ b/src/core/settings/manager.ts
@@ -0,0 +1,251 @@
+import type { HostCapabilities, HostStorage, StorageChangeEvent } from "../types/host.js";
+import { requireCapability } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { applySettingsPatch, type SettingsPatchObject } from "./patch.js";
+import { mergeSettingsObjectsInOrder } from "./merge.js";
+import { computeEnabledFileSettingsSources } from "./sources.js";
+import type {
+  AllowedSettingSource,
+  EffectiveSettingsResult,
+  FileBackedSettingsSource,
+  SettingsError,
+  SettingsEventBus,
+  SettingsPolicyOrigin,
+  SettingsSource,
+  SettingsSourceReadResult,
+  SettingsUpdateEvent,
+  SettingsUnsubscribe,
+  WritableSettingsSource
+} from "./types.js";
+import {
+  createSettingsDocumentFromObject,
+  namespaceForSettingsSource,
+  readSettingsSourceFromStorage,
+  settingsStorageKey,
+  writeSettingsSourceToStorage,
+  type SettingsStorageContext
+} from "./storage.js";
+import { computeEffectiveConfig, type EffectiveConfig } from "./effectiveConfig.js";
+
+function createEventBus(): SettingsEventBus {
+  const subs = new Set<(evt: SettingsUpdateEvent) => void>();
+  return {
+    subscribe: (handler) => {
+      subs.add(handler);
+      return () => subs.delete(handler);
+    },
+    emit: (evt) => {
+      for (const h of subs) h(evt);
+    },
+    clear: () => subs.clear()
+  };
+}
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export type SettingsManager = {
+  initialize: () => Promise<void>;
+  dispose: () => void;
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  notifyChange: (source: SettingsSource | null) => Promise<void>;
+  getEffective: () => EffectiveSettingsResult;
+  getEffectiveConfig: () => EffectiveConfig;
+  setAllowedSources: (allowed: AllowedSettingSource[]) => Promise<void>;
+  setOverlay: (source: Exclude<SettingsSource, FileBackedSettingsSource>, settings: JsonObject | null) => Promise<void>;
+  patchSource: (source: WritableSettingsSource, patch: SettingsPatchObject) => Promise<{ ok: true } | { ok: false; errors: SettingsError[] }>;
+};
+
+type InternalWriteKey = string;
+
+function internalWriteKey(ns: { scope: string; workspaceId?: string; sessionId?: string }, key: string): InternalWriteKey {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}:${key}`;
+}
+
+export function createSettingsManager(host: HostCapabilities, ctx: SettingsStorageContext = {}): SettingsManager {
+  const storage = requireCapability(host, "storage") as HostStorage;
+  const proc = host.process.kind === "available" ? host.process.value : null;
+
+  let allowedSources: AllowedSettingSource[] = ["userSettings", "projectSettings", "localSettings"];
+  let enabledSources: FileBackedSettingsSource[] = computeEnabledFileSettingsSources(allowedSources);
+
+  const overlays: Partial<Record<SettingsSource, JsonObject | null>> = {
+    cliArg: null,
+    command: null,
+    session: null
+  };
+  const perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>> = {};
+  let effective: EffectiveSettingsResult = {
+    settings: {},
+    errors: [],
+    enabledSources,
+    perSource,
+    policyOrigin: "absent"
+  };
+  function envSnapshot(): Record<string, string | undefined> {
+    if (!proc?.getEnv) return {};
+    return {
+      ENABLE_EXPERIMENTAL_MCP_CLI: proc.getEnv("ENABLE_EXPERIMENTAL_MCP_CLI"),
+      ENABLE_MCP_CLI_ENDPOINT: proc.getEnv("ENABLE_MCP_CLI_ENDPOINT"),
+      MCP_TOOL_TIMEOUT: proc.getEnv("MCP_TOOL_TIMEOUT"),
+      MAX_MCP_OUTPUT_TOKENS: proc.getEnv("MAX_MCP_OUTPUT_TOKENS")
+    };
+  }
+
+  let effectiveConfig: EffectiveConfig = computeEffectiveConfig({
+    effectiveSettings: effective.settings,
+    policySource: perSource.policySettings,
+    policyOrigin: effective.policyOrigin,
+    host,
+    env: envSnapshot()
+  });
+
+  const bus = createEventBus();
+  const internalWrites = new Map<InternalWriteKey, string>();
+  const internalPending = new Set<InternalWriteKey>();
+  const unsubscribers: Array<() => void> = [];
+
+  async function loadAllFileBackedSources(): Promise<void> {
+    enabledSources = computeEnabledFileSettingsSources(allowedSources);
+
+    const errors: SettingsError[] = [];
+    const mergedInputs: JsonObject[] = [];
+    let policyOrigin: SettingsPolicyOrigin = "absent";
+
+    for (const source of enabledSources) {
+      const res = await readSettingsSourceFromStorage(storage, source, ctx);
+      perSource[source] = res;
+      errors.push(...res.errors);
+      if (source === "policySettings") {
+        if (res.origin) policyOrigin = res.origin;
+        if (res.storageVersion && res.errors.length > 0 && res.settings === null) policyOrigin = "invalid";
+      }
+      if (res.settings) mergedInputs.push(res.settings);
+    }
+
+    for (const [source, settings] of Object.entries(overlays) as Array<[SettingsSource, JsonObject | null]>) {
+      perSource[source] = { source, settings, errors: [] };
+    }
+
+    const settings = mergeSettingsObjectsInOrder(mergedInputs);
+    effective = { settings, errors, enabledSources, perSource: { ...perSource }, policyOrigin };
+    effectiveConfig = computeEffectiveConfig({
+      effectiveSettings: settings,
+      policySource: perSource.policySettings,
+      policyOrigin,
+      host,
+      env: envSnapshot()
+    });
+  }
+
+  async function emitUpdate(changedSource: SettingsSource | null): Promise<void> {
+    await loadAllFileBackedSources();
+    bus.emit({ type: "settings/updated", changedSource, effective });
+  }
+
+  function markInternalWrite(source: SettingsSource, version: string): void {
+    const ns = namespaceForSettingsSource(source, ctx);
+    const key = settingsStorageKey(source);
+    const k = internalWriteKey(ns, key);
+    const existing = internalWrites.get(k);
+    if (existing === version) {
+      internalWrites.delete(k);
+      internalPending.delete(k);
+      return;
+    }
+    internalWrites.set(k, version);
+    internalPending.delete(k);
+  }
+
+  function shouldSuppressStorageEvent(event: StorageChangeEvent): boolean {
+    if (event.kind !== "set") return false;
+    const k = internalWriteKey(event.namespace as any, event.key);
+    if (internalPending.has(k)) {
+      if (event.version) internalWrites.set(k, event.version);
+      internalPending.delete(k);
+      return true;
+    }
+    if (!event.version) return false;
+    const expected = internalWrites.get(k);
+    if (!expected) return false;
+    if (expected !== event.version) return false;
+    internalWrites.delete(k);
+    return true;
+  }
+
+  async function handleStorageEvent(event: StorageChangeEvent): Promise<void> {
+    if (!event.key.startsWith("settings/source/")) return;
+    if (shouldSuppressStorageEvent(event)) return;
+    const source = event.key.slice("settings/source/".length) as SettingsSource;
+    if (!source) return;
+    await emitUpdate(source);
+  }
+
+  function subscribeStorage(): void {
+    if (!storage.subscribe) return;
+    const appUnsub = storage.subscribe({ scope: "app" }, (e: StorageChangeEvent) => {
+      void handleStorageEvent(e);
+    });
+    unsubscribers.push(appUnsub);
+
+    if (ctx.workspaceId) {
+      const wsUnsub = storage.subscribe({ scope: "workspace", workspaceId: ctx.workspaceId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(wsUnsub);
+    }
+
+    if (ctx.sessionId) {
+      const sessUnsub = storage.subscribe({ scope: "session", sessionId: ctx.sessionId }, (e: StorageChangeEvent) => {
+        void handleStorageEvent(e);
+      });
+      unsubscribers.push(sessUnsub);
+    }
+  }
+
+  return {
+    initialize: async () => {
+      subscribeStorage();
+      await emitUpdate(null);
+    },
+    dispose: () => {
+      for (const u of unsubscribers) u();
+      unsubscribers.length = 0;
+      bus.clear();
+    },
+    subscribe: (handler) => bus.subscribe(handler),
+    notifyChange: async (source) => {
+      await emitUpdate(source);
+    },
+    getEffective: () => effective,
+    getEffectiveConfig: () => effectiveConfig,
+    setAllowedSources: async (allowed) => {
+      allowedSources = allowed;
+      await emitUpdate(null);
+    },
+    setOverlay: async (source, settings) => {
+      overlays[source] = settings;
+      await emitUpdate(source);
+    },
+    patchSource: async (source, patch) => {
+      const current = await readSettingsSourceFromStorage(storage, source, ctx);
+      const currentSettings = current.settings ?? {};
+      const parsed = isPlainObject(currentSettings) ? (currentSettings as JsonObject) : {};
+      const next = applySettingsPatch(parsed, patch);
+
+      const ns = namespaceForSettingsSource(source, ctx);
+      const k = internalWriteKey(ns, settingsStorageKey(source));
+      internalPending.add(k);
+      const doc = createSettingsDocumentFromObject(next);
+      const res = await writeSettingsSourceToStorage(storage, source, ctx, doc, { expectedVersion: current.storageVersion ?? null });
+      if (!res.ok) {
+        internalPending.delete(k);
+        return { ok: false, errors: [res.error] };
+      }
+      markInternalWrite(source, res.version);
+      await emitUpdate(source);
+      return { ok: true };
+    }
+  };
+}
diff --git a/src/core/settings/merge.ts b/src/core/settings/merge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..66130cf305d726c9098be200408857636906f633
--- /dev/null
+++ b/src/core/settings/merge.ts
@@ -0,0 +1,78 @@
+import type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from "../types/json.js";
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function isPrimitive(value: JsonValue): value is JsonPrimitive {
+  return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
+}
+
+export function unionDedupePreserveOrder(a: JsonArray, b: JsonArray): JsonArray {
+  const out: JsonArray = [...a];
+  const seen = new Set<string | number | boolean | null>();
+  for (const item of a) {
+    if (isPrimitive(item)) seen.add(item);
+  }
+  for (const item of b) {
+    if (isPrimitive(item)) {
+      if (seen.has(item)) continue;
+      seen.add(item);
+      out.push(item);
+    } else {
+      out.push(item);
+    }
+  }
+  return out;
+}
+
+export function mergeJsonValue(base: JsonValue, next: JsonValue): JsonValue {
+  if (Array.isArray(base) && Array.isArray(next)) return unionDedupePreserveOrder(base, next);
+  if (isPlainObject(base) && isPlainObject(next)) return mergeJsonObject(base, next);
+  return next;
+}
+
+export function mergeJsonObject(base: JsonObject, next: JsonObject): JsonObject {
+  const out: JsonObject = { ...base };
+  for (const [key, nextVal] of Object.entries(next)) {
+    const baseVal = out[key];
+    if (baseVal === undefined) {
+      out[key] = nextVal;
+      continue;
+    }
+    out[key] = mergeJsonValue(baseVal, nextVal);
+  }
+  return out;
+}
+
+export function mergeSettingsObjectsInOrder(objects: readonly JsonObject[]): JsonObject {
+  let out: JsonObject = {};
+  for (const obj of objects) out = mergeJsonObject(out, obj);
+  return out;
+}
+
+export const LEGACY_SETTINGS_MERGE_NOTES = {
+  objects: "deep-merge",
+  arrays: "union-dedupe-preserve-order (primitive-only dedupe, legacy Set-like)",
+  patches: "arrays-replace, delete-on-undefined"
+} as const;
+
+export type SettingsMergeFieldExpectation = {
+  pointer: string;
+  merge: "deep" | "replace";
+  arrays: "union" | "replace";
+  patchArrays: "replace";
+  notes?: string;
+};
+
+export const LEGACY_SETTINGS_MERGE_FIELD_EXPECTATIONS: readonly SettingsMergeFieldExpectation[] = [
+  {
+    pointer: "/permissions",
+    merge: "deep",
+    arrays: "union",
+    patchArrays: "replace",
+    notes: "Permission rules are evaluated per-source later; the merged view is for defaults and UI display."
+  },
+  { pointer: "/hooks", merge: "deep", arrays: "union", patchArrays: "replace", notes: "Hook config merges across sources; policy may gate." },
+  { pointer: "/mcp", merge: "deep", arrays: "union", patchArrays: "replace", notes: "MCP subtree merges across sources; later phases validate." }
+] as const;
diff --git a/src/core/settings/patch.ts b/src/core/settings/patch.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4aef92ad462f9b5902ee1b46d96f68b4bb553df
--- /dev/null
+++ b/src/core/settings/patch.ts
@@ -0,0 +1,45 @@
+import type { JsonObject, JsonValue } from "../types/json.js";
+
+export type SettingsPatchValue = JsonValue | SettingsPatchObject | undefined;
+export type SettingsPatchObject = { [key: string]: SettingsPatchValue };
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+function cloneJsonObject(obj: JsonObject): JsonObject {
+  const out: JsonObject = {};
+  for (const [k, v] of Object.entries(obj)) out[k] = v;
+  return out;
+}
+
+export function applySettingsPatch(base: JsonObject, patch: SettingsPatchObject): JsonObject {
+  const out = cloneJsonObject(base);
+  for (const [key, rawPatchValue] of Object.entries(patch)) {
+    const patchValue = rawPatchValue as unknown;
+
+    if (patchValue === undefined) {
+      delete out[key];
+      continue;
+    }
+
+    if (Array.isArray(patchValue)) {
+      out[key] = patchValue as unknown as JsonValue;
+      continue;
+    }
+
+    if (isPlainObject(patchValue)) {
+      const baseVal = out[key];
+      if (isPlainObject(baseVal)) {
+        out[key] = applySettingsPatch(baseVal as JsonObject, patchValue as SettingsPatchObject);
+      } else {
+        out[key] = patchValue as unknown as JsonValue;
+      }
+      continue;
+    }
+
+    out[key] = patchValue as JsonValue;
+  }
+  return out;
+}
+
diff --git a/src/core/settings/policy.ts b/src/core/settings/policy.ts
new file mode 100644
index 0000000000000000000000000000000000000000..de330a5538eb0955feb703095eb99d0d1be241bd
--- /dev/null
+++ b/src/core/settings/policy.ts
@@ -0,0 +1,43 @@
+import type { HostStorage } from "../types/host.js";
+import type { JsonObject } from "../types/json.js";
+import { createSettingsDocumentFromObject, writeSettingsSourceToStorage, type SettingsStorageContext } from "./storage.js";
+import type { SettingsError, SettingsPolicyOrigin } from "./types.js";
+
+export type PolicySettingsProvider = {
+  fetchPolicySettings: (options: { nowWallMs: number }) => Promise<JsonObject | null>;
+};
+
+function isPlainObject(value: unknown): value is JsonObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export async function refreshRemotePolicySettings(options: {
+  storage: HostStorage;
+  ctx: SettingsStorageContext;
+  provider: PolicySettingsProvider;
+  nowWallMs: number;
+}): Promise<{ updated: boolean; errors: SettingsError[]; origin: SettingsPolicyOrigin }> {
+  try {
+    const fetched = await options.provider.fetchPolicySettings({ nowWallMs: options.nowWallMs });
+    if (fetched === null) return { updated: false, errors: [], origin: "absent" };
+    if (!isPlainObject(fetched)) {
+      return {
+        updated: false,
+        errors: [{ kind: "validation_error", source: "policySettings", message: "Remote policy settings must be an object", severity: "error" }],
+        origin: "invalid"
+      };
+    }
+
+    const doc = createSettingsDocumentFromObject(fetched, { origin: "remote", updatedAtWallMs: options.nowWallMs });
+    const res = await writeSettingsSourceToStorage(options.storage, "policySettings", options.ctx, doc);
+    if (!res.ok) return { updated: false, errors: [res.error], origin: "invalid" };
+    return { updated: true, errors: [], origin: "remote" };
+  } catch (cause) {
+    return {
+      updated: false,
+      errors: [{ kind: "io_error", source: "policySettings", message: "Failed to refresh remote policy settings", cause, severity: "warning" }],
+      origin: "absent"
+    };
+  }
+}
+
diff --git a/src/core/settings/schema.ts b/src/core/settings/schema.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ced5912ed36097285e52b5f4877084be366c3fbd
--- /dev/null
+++ b/src/core/settings/schema.ts
@@ -0,0 +1,97 @@
+import type { JsonObject } from "../types/json.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { SettingsError, SettingsSource } from "./types.js";
+
+export const LEGACY_SETTINGS_SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json";
+
+export const SETTINGS_SCHEMA_TOOLING_REQUIREMENTS = {
+  runtimeValidation: true,
+  jsonSchemaExport: true,
+  rnCompatible: true
+} as const;
+
+export type SettingsDocumentV1 = {
+  kind: "settings_document";
+  schemaVersion: typeof SCHEMA_VERSION.settingsDocument;
+  settings: JsonObject;
+  meta?: {
+    schemaUrl?: string;
+    origin?: "local" | "remote";
+    updatedAtWallMs?: number;
+  };
+};
+
+export type ParsedSettingsDocument = {
+  document: SettingsDocumentV1 | null;
+  errors: SettingsError[];
+  format: "empty" | "legacy_object" | "envelope_v1" | "invalid";
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function parseSettingsJson(raw: string, source: SettingsSource): ParsedSettingsDocument {
+  const trimmed = raw.trim();
+  if (trimmed === "") {
+    return {
+      document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: {} },
+      errors: [],
+      format: "empty"
+    };
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = JSON.parse(trimmed);
+  } catch (cause) {
+    return {
+      document: null,
+      errors: [{ kind: "parse_error", source, message: "Invalid JSON syntax", cause, severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (!isPlainObject(parsed)) {
+    return {
+      document: null,
+      errors: [{ kind: "validation_error", source, message: "Settings JSON must be an object", severity: "error" }],
+      format: "invalid"
+    };
+  }
+
+  if (parsed.kind === "settings_document" && parsed.schemaVersion === SCHEMA_VERSION.settingsDocument) {
+    const settings = (parsed as Record<string, unknown>).settings;
+    if (!isPlainObject(settings)) {
+      return {
+        document: null,
+        errors: [
+          { kind: "validation_error", source, message: "settings_document.settings must be an object", severity: "error" }
+        ],
+        format: "invalid"
+      };
+    }
+    const meta = (parsed as Record<string, unknown>).meta;
+    const normalizedMeta = isPlainObject(meta) ? (meta as SettingsDocumentV1["meta"]) : undefined;
+    return {
+      document: {
+        kind: "settings_document",
+        schemaVersion: SCHEMA_VERSION.settingsDocument,
+        settings: settings as JsonObject,
+        ...(normalizedMeta ? { meta: normalizedMeta } : {})
+      },
+      errors: [],
+      format: "envelope_v1"
+    };
+  }
+
+  return {
+    document: { kind: "settings_document", schemaVersion: SCHEMA_VERSION.settingsDocument, settings: parsed as JsonObject },
+    errors: [],
+    format: "legacy_object"
+  };
+}
+
+export function serializeSettingsDocument(doc: SettingsDocumentV1): string {
+  return `${JSON.stringify(doc, null, 2)}\n`;
+}
diff --git a/src/core/settings/secrets.ts b/src/core/settings/secrets.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ae1d3c2aae6dc669ca7476e04f94390ae31f07d9
--- /dev/null
+++ b/src/core/settings/secrets.ts
@@ -0,0 +1,23 @@
+import type { HostSecrets } from "../types/host.js";
+
+export type SecretRefV1 = { __secretRef: string };
+
+export function isSecretRefV1(value: unknown): value is SecretRefV1 {
+  return typeof value === "object" && value !== null && "__secretRef" in value && typeof (value as any).__secretRef === "string";
+}
+
+export type SecretResolutionResult =
+  | { status: "resolved"; name: string; value: string }
+  | { status: "missing"; name: string }
+  | { status: "error"; name: string; error: unknown };
+
+export async function resolveSecretRefV1(ref: SecretRefV1, secrets: HostSecrets): Promise<SecretResolutionResult> {
+  try {
+    const value = await secrets.getSecret(ref.__secretRef);
+    if (value === null) return { status: "missing", name: ref.__secretRef };
+    return { status: "resolved", name: ref.__secretRef, value };
+  } catch (error) {
+    return { status: "error", name: ref.__secretRef, error };
+  }
+}
+
diff --git a/src/core/settings/sources.ts b/src/core/settings/sources.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7a48071d9680f15612c35664e7ed1d0b60df44f
--- /dev/null
+++ b/src/core/settings/sources.ts
@@ -0,0 +1,49 @@
+import type { AllowedSettingSource, FileBackedSettingsSource, SettingsSource } from "./types.js";
+
+export const LEGACY_FILE_BACKED_SETTINGS_SOURCE_ORDER: readonly FileBackedSettingsSource[] = [
+  "userSettings",
+  "projectSettings",
+  "localSettings",
+  "flagSettings",
+  "policySettings"
+];
+
+export const LEGACY_ALWAYS_INCLUDED_SOURCES: readonly FileBackedSettingsSource[] = ["policySettings", "flagSettings"];
+
+export function parseEnabledSettingSourcesFlag(input: string): AllowedSettingSource[] {
+  if (input === "") return [];
+  const parts = input
+    .split(",")
+    .map((p) => p.trim())
+    .filter((p) => p.length > 0);
+
+  const out: AllowedSettingSource[] = [];
+  for (const p of parts) {
+    switch (p) {
+      case "user":
+        out.push("userSettings");
+        break;
+      case "project":
+        out.push("projectSettings");
+        break;
+      case "local":
+        out.push("localSettings");
+        break;
+      default:
+        throw new Error(`Invalid setting source: ${p}. Valid options are: user, project, local`);
+    }
+  }
+  return out;
+}
+
+export function computeEnabledFileSettingsSources(allowed: AllowedSettingSource[]): FileBackedSettingsSource[] {
+  const set = new Set<FileBackedSettingsSource>(allowed);
+  set.add("policySettings");
+  set.add("flagSettings");
+  return Array.from(set);
+}
+
+export function isSettingsSourceEnabled(source: SettingsSource, enabledSources: readonly SettingsSource[]): boolean {
+  return enabledSources.includes(source);
+}
+
diff --git a/src/core/settings/storage.ts b/src/core/settings/storage.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a373d95ff323ea6de48a7cbfb18f8f9832cc939c
--- /dev/null
+++ b/src/core/settings/storage.ts
@@ -0,0 +1,144 @@
+import type { JsonObject } from "../types/json.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import { StorageConflictError } from "../types/host.js";
+import type { WorkspaceId } from "../types/workspace.js";
+import { parseSettingsJson, serializeSettingsDocument, type SettingsDocumentV1 } from "./schema.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { FileBackedSettingsSource, SettingsError, SettingsSource, SettingsSourceReadResult, SettingsPolicyOrigin } from "./types.js";
+
+export type SettingsStorageContext = {
+  workspaceId?: WorkspaceId;
+  sessionId?: string;
+};
+
+export const SETTINGS_STORAGE_KEY_PREFIX = "settings/source/";
+
+export function settingsStorageKey(source: SettingsSource): string {
+  return `${SETTINGS_STORAGE_KEY_PREFIX}${source}`;
+}
+
+export function namespaceForSettingsSource(source: SettingsSource, ctx: SettingsStorageContext): StorageNamespace {
+  switch (source) {
+    case "userSettings":
+    case "policySettings":
+      return { scope: "app" };
+    case "projectSettings":
+    case "localSettings":
+      return ctx.workspaceId ? { scope: "workspace", workspaceId: ctx.workspaceId } : { scope: "workspace" };
+    case "flagSettings":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+    case "cliArg":
+    case "command":
+    case "session":
+      return ctx.sessionId ? { scope: "session", sessionId: ctx.sessionId } : { scope: "session" };
+  }
+}
+
+function originFromDoc(doc: SettingsDocumentV1 | null, source: SettingsSource): SettingsPolicyOrigin | undefined {
+  if (source !== "policySettings") return undefined;
+  if (!doc) return "absent";
+  const origin = doc.meta?.origin;
+  if (origin === "remote") return "remote";
+  return "local";
+}
+
+export async function readSettingsSourceFromStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext
+): Promise<SettingsSourceReadResult> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }]
+    };
+  }
+
+  try {
+    const rec = await storage.get(ns, key);
+    if (!rec) {
+      const doc: SettingsDocumentV1 | null = null;
+      const origin = originFromDoc(doc, source);
+      return {
+        source,
+        settings: null,
+        errors: [],
+        ...(origin ? { origin } : {}),
+        storageVersion: null
+      };
+    }
+
+    const parsed = parseSettingsJson(rec.value, source);
+    const origin = originFromDoc(parsed.document, source);
+    return {
+      source,
+      settings: parsed.document?.settings ?? null,
+      errors: parsed.errors,
+      ...(origin ? { origin } : {}),
+      storageVersion: rec.version
+    };
+  } catch (cause) {
+    return {
+      source,
+      settings: null,
+      errors: [{ kind: "io_error", source, message: "Failed to read settings from storage", cause, severity: "error" }]
+    };
+  }
+}
+
+export async function writeSettingsSourceToStorage(
+  storage: HostStorage,
+  source: SettingsSource,
+  ctx: SettingsStorageContext,
+  doc: SettingsDocumentV1,
+  options?: { expectedVersion?: string | null }
+): Promise<{ ok: true; version: string } | { ok: false; error: SettingsError }> {
+  const ns = namespaceForSettingsSource(source, ctx);
+  const key = settingsStorageKey(source);
+
+  if ((ns.scope === "workspace" && !ns.workspaceId) || (ns.scope === "session" && !ns.sessionId)) {
+    return {
+      ok: false,
+      error: { kind: "validation_error", source, message: `Missing required namespace context for ${source}`, severity: "error" }
+    };
+  }
+
+  try {
+    const value = serializeSettingsDocument(doc);
+    const res = await storage.set(
+      ns,
+      key,
+      value,
+      options?.expectedVersion === undefined ? undefined : { expectedVersion: options.expectedVersion }
+    );
+    return { ok: true, version: res.version };
+  } catch (error) {
+    if (error instanceof StorageConflictError) {
+      return { ok: false, error: { kind: "conflict", source, message: "Settings write conflict", cause: error, severity: "error" } };
+    }
+    return { ok: false, error: { kind: "io_error", source, message: "Failed to write settings to storage", cause: error, severity: "error" } };
+  }
+}
+
+export function createSettingsDocumentFromObject(settings: JsonObject, meta?: SettingsDocumentV1["meta"]): SettingsDocumentV1 {
+  return {
+    kind: "settings_document",
+    schemaVersion: SCHEMA_VERSION.settingsDocument,
+    settings,
+    ...(meta ? { meta } : {})
+  };
+}
+
+export function isFileBackedSettingsSource(source: SettingsSource): source is FileBackedSettingsSource {
+  return (
+    source === "userSettings" ||
+    source === "projectSettings" ||
+    source === "localSettings" ||
+    source === "policySettings" ||
+    source === "flagSettings"
+  );
+}
diff --git a/src/core/settings/types.ts b/src/core/settings/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3120fcb5e0356630e784e7feb18924a0370ff5c9
--- /dev/null
+++ b/src/core/settings/types.ts
@@ -0,0 +1,73 @@
+import type { JsonObject } from "../types/json.js";
+
+export type SettingsSource =
+  | "userSettings"
+  | "projectSettings"
+  | "localSettings"
+  | "policySettings"
+  | "flagSettings"
+  | "cliArg"
+  | "command"
+  | "session";
+
+export type FileBackedSettingsSource = Extract<
+  SettingsSource,
+  "userSettings" | "projectSettings" | "localSettings" | "policySettings" | "flagSettings"
+>;
+
+export type AllowedSettingSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type NonFileSettingsSource = Exclude<SettingsSource, FileBackedSettingsSource>;
+
+export type WritableSettingsSource = Extract<SettingsSource, "userSettings" | "projectSettings" | "localSettings">;
+
+export type SettingsPolicyOrigin = "absent" | "local" | "remote" | "invalid";
+
+export type SettingsErrorKind =
+  | "parse_error"
+  | "validation_error"
+  | "io_error"
+  | "conflict"
+  | "capability_missing"
+  | "unsupported";
+
+export type SettingsError = {
+  kind: SettingsErrorKind;
+  source: SettingsSource;
+  message: string;
+  filePath?: string;
+  pointer?: string;
+  cause?: unknown;
+  severity?: "warning" | "error";
+};
+
+export type SettingsSourceReadResult = {
+  source: SettingsSource;
+  settings: JsonObject | null;
+  errors: SettingsError[];
+  origin?: SettingsPolicyOrigin;
+  storageVersion?: string | null;
+};
+
+export type EffectiveSettingsResult = {
+  settings: JsonObject;
+  errors: SettingsError[];
+  enabledSources: FileBackedSettingsSource[];
+  perSource: Partial<Record<SettingsSource, SettingsSourceReadResult>>;
+  policyOrigin: SettingsPolicyOrigin;
+};
+
+export type SettingsUpdateEvent = {
+  type: "settings/updated";
+  changedSource: SettingsSource | null;
+  effective: EffectiveSettingsResult;
+};
+
+export type SettingsUnsubscribe = () => void;
+
+export type SettingsEventBus = {
+  subscribe: (handler: (evt: SettingsUpdateEvent) => void) => SettingsUnsubscribe;
+  emit: (evt: SettingsUpdateEvent) => void;
+  clear: () => void;
+};
+
diff --git a/src/platform/node/host.ts b/src/platform/node/host.ts
index 7a7f4db62380d8fb3d560fa4d64d5dbfacc0c2e1..3d28578601e55045a8200770b950057e7b7ac990
--- a/src/platform/node/host.ts
+++ b/src/platform/node/host.ts
@@ -15,6 +15,7 @@
 import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
 import crypto from "node:crypto";
 import { execFile as execFileCb } from "node:child_process";
+import { watch as watchFs } from "node:fs";
 import fs from "node:fs/promises";
 import os from "node:os";
 import path from "node:path";
@@ -311,6 +312,54 @@
         if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
         throw error;
       }
+    },
+    subscribe: (ns, handler) => {
+      const parts = namespaceToPathParts(ns);
+      const dir = path.join(rootDir, ...parts);
+      let closed = false;
+      let watcher: ReturnType<typeof watchFs> | null = null;
+
+      const start = async () => {
+        try {
+          await fs.mkdir(dir, { recursive: true });
+        } catch {
+          // ignore
+        }
+        if (closed) return;
+        watcher = watchFs(dir, { persistent: false }, async (_eventType, filename) => {
+          if (closed) return;
+          const name = filename ? filename.toString() : "";
+          if (!name) return;
+          if (!name.endsWith(".json")) return;
+          if (name.startsWith(".tmp-")) return;
+          const base = name.slice(0, -".json".length);
+          const decoded = decodeStorageSegment(base);
+          if (decoded === null) return;
+          const filePath = path.join(dir, name);
+          try {
+            const raw = await fs.readFile(filePath, { encoding: "utf8" });
+            const parsed = JSON.parse(raw) as StoredFile;
+            if (!parsed || typeof parsed.version !== "string") return;
+            handler({ namespace: ns, key: decoded, kind: "set", version: parsed.version });
+          } catch (error) {
+            if ((error as NodeJS.ErrnoException).code === "ENOENT") {
+              handler({ namespace: ns, key: decoded, kind: "delete" });
+              return;
+            }
+          }
+        });
+      };
+
+      void start();
+      return () => {
+        closed = true;
+        try {
+          watcher?.close();
+        } catch {
+          // ignore
+        }
+        watcher = null;
+      };
     }
   };
 }
diff --git a/tests/phase6-settings.test.ts b/tests/phase6-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6da53c1d21f344633b85f1726789510f606fa648
--- /dev/null
+++ b/tests/phase6-settings.test.ts
@@ -0,0 +1,251 @@
+import { describe, expect, test } from "bun:test";
+import crypto from "node:crypto";
+import {
+  StorageConflictError,
+  availableCapability,
+  unavailableCapability,
+  type HostCapabilities,
+  type HostStorage,
+  type StorageNamespace
+} from "../src/core/types/host.js";
+import { asWorkspaceId } from "../src/core/types/workspace.js";
+import {
+  applySettingsPatch,
+  computeEnabledFileSettingsSources,
+  createSettingsDocumentFromObject,
+  createSettingsManager,
+  exportSettingsBundleV1,
+  importSettingsBundleV1,
+  parseEnabledSettingSourcesFlag,
+  readSettingsSourceFromStorage,
+  refreshRemotePolicySettings,
+  writeSettingsSourceToStorage
+} from "../src/core/settings/index.js";
+
+function nsKey(ns: StorageNamespace): string {
+  return `${ns.scope}:${ns.workspaceId ?? ""}:${ns.sessionId ?? ""}`;
+}
+
+function computeVersion(value: string): string {
+  return crypto.createHash("sha256").update(value, "utf8").digest("hex");
+}
+
+function createInMemoryStorage(): HostStorage {
+  const data = new Map<string, { value: string; version: string }>();
+  const subs = new Map<string, Set<(e: any) => void>>();
+
+  function emit(ns: StorageNamespace, event: any): void {
+    const k = nsKey(ns);
+    const set = subs.get(k);
+    if (!set) return;
+    for (const h of set) h(event);
+  }
+
+  return {
+    get: async (ns, key) => {
+      const rec = data.get(`${nsKey(ns)}:${key}`);
+      if (!rec) return null;
+      return { value: rec.value, version: rec.version };
+    },
+    set: async (ns, key, value, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      const version = computeVersion(value);
+      data.set(full, { value, version });
+      emit(ns, { namespace: ns, key, kind: "set", version });
+      return { version };
+    },
+    delete: async (ns, key, options) => {
+      const full = `${nsKey(ns)}:${key}`;
+      const existing = data.get(full) ?? null;
+      const expected = options?.expectedVersion;
+      if (expected !== undefined) {
+        const actual = existing?.version ?? null;
+        if (expected === null) {
+          if (existing !== null) throw new StorageConflictError({ key, expectedVersion: null, actualVersion: actual });
+        } else if (existing === null || existing.version !== expected) {
+          throw new StorageConflictError({ key, expectedVersion: expected, actualVersion: actual });
+        }
+      }
+      data.delete(full);
+      emit(ns, { namespace: ns, key, kind: "delete" });
+    },
+    subscribe: (ns, handler) => {
+      const k = nsKey(ns);
+      const set = subs.get(k) ?? new Set();
+      set.add(handler);
+      subs.set(k, set);
+      return () => {
+        const cur = subs.get(k);
+        cur?.delete(handler);
+        if (cur && cur.size === 0) subs.delete(k);
+      };
+    }
+  };
+}
+
+function createHostWithStorage(storage: HostStorage): HostCapabilities {
+  return {
+    clock: unavailableCapability({ kind: "not-provided" }),
+    random: unavailableCapability({ kind: "not-provided" }),
+    crypto: unavailableCapability({ kind: "not-provided" }),
+    secrets: unavailableCapability({ kind: "not-provided" }),
+    storage: availableCapability(storage),
+    filesystem: unavailableCapability({ kind: "not-provided" }),
+    network: unavailableCapability({ kind: "not-provided" }),
+    lifecycle: unavailableCapability({ kind: "not-provided" }),
+    background: unavailableCapability({ kind: "not-provided" }),
+    fileTransfer: unavailableCapability({ kind: "not-provided" }),
+    shell: unavailableCapability({ kind: "not-provided" }),
+    localEndpoint: unavailableCapability({ kind: "not-provided" }),
+    ipc: unavailableCapability({ kind: "not-provided" }),
+    process: unavailableCapability({ kind: "not-provided" }),
+    clipboard: unavailableCapability({ kind: "not-provided" }),
+    notifications: unavailableCapability({ kind: "not-provided" }),
+    haptics: unavailableCapability({ kind: "not-provided" })
+  };
+}
+
+describe("Phase 6: settings system", () => {
+  test("enabled sources flag parser matches legacy", () => {
+    expect(parseEnabledSettingSourcesFlag("")).toEqual([]);
+    expect(parseEnabledSettingSourcesFlag("user,project,local")).toEqual(["userSettings", "projectSettings", "localSettings"]);
+    expect(parseEnabledSettingSourcesFlag("local,user")).toEqual(["localSettings", "userSettings"]);
+    expect(() => parseEnabledSettingSourcesFlag("policy")).toThrow();
+  });
+
+  test("enabled file sources always include policy+flag (and preserve legacy order)", () => {
+    expect(computeEnabledFileSettingsSources(["userSettings"])).toEqual(["userSettings", "policySettings", "flagSettings"]);
+    expect(computeEnabledFileSettingsSources(["projectSettings", "userSettings"])).toEqual([
+      "projectSettings",
+      "userSettings",
+      "policySettings",
+      "flagSettings"
+    ]);
+  });
+
+  test("patch semantics: delete on undefined + arrays replace", () => {
+    const base = { a: 1, nested: { keep: true, drop: "x", arr: [1, 2, 3] } };
+    const next = applySettingsPatch(base, { nested: { drop: undefined, arr: [2] } });
+    expect((next.nested as any).keep).toBe(true);
+    expect((next.nested as any).drop).toBeUndefined();
+    expect((next.nested as any).arr).toEqual([2]);
+  });
+
+  test("storage-backed settings manager merges enabled sources and suppresses self-triggered watch events", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_test"), sessionId: "sess_test" };
+
+    await writeSettingsSourceToStorage(
+      storage,
+      "userSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: false, arr: [1], nested: { a: 1 } }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true, nested: { b: 2 } }, { origin: "local" }),
+      { expectedVersion: null }
+    );
+    await writeSettingsSourceToStorage(
+      storage,
+      "flagSettings",
+      ctx,
+      createSettingsDocumentFromObject({ disableAllHooks: true, arr: [2, 3] }),
+      { expectedVersion: null }
+    );
+
+    const mgr = createSettingsManager(host, ctx);
+    let updates = 0;
+    const unsub = mgr.subscribe(() => {
+      updates += 1;
+    });
+    await mgr.initialize();
+
+    const effective = mgr.getEffective();
+    expect(effective.settings.disableAllHooks).toBe(true);
+    expect(effective.settings.arr).toEqual([1, 2, 3]);
+
+    const cfg = mgr.getEffectiveConfig();
+    expect(cfg.hooks.disabled).toBe(true);
+    expect(cfg.hooks.managedOnly).toBe(true);
+
+    const before = updates;
+    const patchRes = await mgr.patchSource("userSettings", { nested: { a: 3 }, newKey: "x" });
+    expect(patchRes.ok).toBe(true);
+
+    expect(updates - before).toBe(1);
+    unsub();
+    mgr.dispose();
+  });
+
+  test("export/import bundle captures per-source settings objects", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_bundle"), sessionId: "sess_bundle" };
+    await writeSettingsSourceToStorage(storage, "userSettings", ctx, createSettingsDocumentFromObject({ a: 1 }), { expectedVersion: null });
+    await writeSettingsSourceToStorage(
+      storage,
+      "policySettings",
+      ctx,
+      createSettingsDocumentFromObject({ allowManagedHooksOnly: true }, { origin: "remote" }),
+      { expectedVersion: null }
+    );
+
+    const { bundle, errors } = await exportSettingsBundleV1(storage, ctx, ["userSettings", "policySettings"], Date.now());
+    expect(errors.length).toBe(0);
+    expect(bundle.sources.userSettings).toEqual({ a: 1 });
+    expect(bundle.sources.policySettings).toEqual({ allowManagedHooksOnly: true });
+
+    const storage2 = createInMemoryStorage();
+    const importRes = await importSettingsBundleV1(storage2, ctx, bundle);
+    expect(importRes.ok).toBe(true);
+    const r1 = await readSettingsSourceFromStorage(storage2, "userSettings", ctx);
+    expect(r1.settings).toEqual({ a: 1 });
+  });
+
+  test("invalid policy settings fail-closed in EffectiveConfig", async () => {
+    const storage = createInMemoryStorage();
+    const host = createHostWithStorage(storage);
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_invalid"), sessionId: "sess_policy_invalid" };
+
+    await storage.set({ scope: "app" }, "settings/source/policySettings", "{ invalid json", { expectedVersion: null });
+    await writeSettingsSourceToStorage(storage, "flagSettings", ctx, createSettingsDocumentFromObject({}), { expectedVersion: null });
+
+    const mgr = createSettingsManager(host, ctx);
+    await mgr.initialize();
+    expect(mgr.getEffective().policyOrigin).toBe("invalid");
+    expect(mgr.getEffectiveConfig().hooks.disabled).toBe(true);
+    expect(mgr.getEffectiveConfig().hooks.managedOnly).toBe(true);
+    mgr.dispose();
+  });
+
+  test("remote policy refresh writes to cache (storage)", async () => {
+    const storage = createInMemoryStorage();
+    const ctx = { workspaceId: asWorkspaceId("ws_policy_remote"), sessionId: "sess_policy_remote" };
+
+    const res = await refreshRemotePolicySettings({
+      storage,
+      ctx,
+      nowWallMs: 123,
+      provider: { fetchPolicySettings: async () => ({ allowManagedHooksOnly: true }) }
+    });
+    expect(res.updated).toBe(true);
+
+    const read = await readSettingsSourceFromStorage(storage, "policySettings", ctx);
+    expect(read.settings).toEqual({ allowManagedHooksOnly: true });
+    expect(read.origin).toBe("remote");
+  });
+});

[3m[35mtokens used[0m[0m
239,997
## Summary (Phase 6)

- Implemented a portable, layered settings system in `src/core/settings/*` with legacy-parity source keys, enabled-source selection, deterministic merge + patch semantics, and structured error reporting.
- Added watchable settings propagation via storage subscriptions with internal-write suppression (version/pending-key based), plus a Node `HostStorage.subscribe()` implementation backed by `fs.watch`.
- Added `EffectiveConfig` computation and feature-gate inventory, including a fail-closed policy-invalid behavior that disables hooks/managed-only gate.
- Implemented portable storage mapping (app/workspace/session namespaces), settings doctor reporting, export/import bundles, legacy path mapping, and a remote policy refresh API that caches into storage.

## Files changed

- Deleted: `src/core/settings/index.ts`
- Added:
  - `src/core/settings/types.ts`
  - `src/core/settings/schema.ts`
  - `src/core/settings/sources.ts`
  - `src/core/settings/merge.ts`
  - `src/core/settings/patch.ts`
  - `src/core/settings/secrets.ts`
  - `src/core/settings/storage.ts`
  - `src/core/settings/legacyPaths.ts`
  - `src/core/settings/doctor.ts`
  - `src/core/settings/effectiveConfig.ts`
  - `src/core/settings/bundle.ts`
  - `src/core/settings/manager.ts`
  - `src/core/settings/policy.ts`
  - `src/core/settings/index.ts`
  - `tests/phase6-settings.test.ts`
- Modified:
  - `src/platform/node/host.ts`
  - `implementation/1-initial-rewrite-implementation-checklist.md`

## Decisions made

- Settings schema strategy: TS-first + lightweight runtime validation (no new schema/tooling dependency added yet), with a versioned settings envelope (`kind: settings_document`, `schemaVersion: 1`) and legacy ‚Äúbare object‚Äù compatibility (`src/core/settings/schema.ts`).
- Source enablement order: preserve legacy semantics where enabled sources = `allowedSettingSources` + `policySettings` + `flagSettings` (with policy added before flag so flags override policy in effective settings).
- Merge vs patch semantics:
  - Effective settings merge uses deep merge + array union/dedupe (primitive-only, legacy Set-like).
  - Patches delete keys on `undefined` and **replace arrays** (matches legacy `E2/X2` behavior; required for rule/directory removals).
- Policy invalid behavior: treat invalid policy settings as `policyOrigin: "invalid"` and fail-closed for hook gating in `EffectiveConfig` (hooks disabled + managedOnly enabled), with tests proving the contract.
- Naming collision avoidance: renamed core MCP gate helper to `computeMcpCliGateSnapshotFromEnv` to avoid export conflicts with legacy-spec helpers re-exported from `src/spec/*`.

## Tests/validation run + results

- `bun test` (bun v1.3.4): PASS
- `bun run typecheck`: PASS
- `bun run check:boundaries`: PASS (`Import boundary check passed.`)
- Legacy CLI sanity (auth + network): `claude --dangerously-skip-permissions -p sayhello` => PASS

## Remaining work inside Phase 6

- None identified (Phase 6 checklist fully checked off).

## Handoff notes for next phase

- Phase 7 (permissions) should treat settings sources as first-class (`SettingsSource` in `src/core/settings/types.ts`) and rely on per-source attribution from `readSettingsSourceFromStorage()` rather than the merged settings object for rule precedence.
- Node hosts now support `HostStorage.subscribe()`; settings/watch flows can be exercised without filesystem-specific watchers.
