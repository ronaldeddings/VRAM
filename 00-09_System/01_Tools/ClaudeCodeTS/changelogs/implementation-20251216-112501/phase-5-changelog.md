Reading prompt from stdin...
OpenAI Codex v0.73.0 (research preview)
--------
[1mworkdir:[0m /Users/ronaldeddings/ClaudeCodeTS
[1mmodel:[0m gpt-5.2
[1mprovider:[0m openai
[1mapproval:[0m never
[1msandbox:[0m danger-full-access
[1mreasoning effort:[0m high
[1mreasoning summaries:[0m auto
[1msession id:[0m 019b2874-7003-7422-91b6-46c31201a2d4
--------
[36muser[0m
You are implementing PHASE 5 of 19.

==============================================
MISSION: IMPLEMENT THE REWRITE PLAN (PHASE-BY-PHASE)
==============================================

AUTHORITATIVE INPUTS:
- Implementation Plan: @/Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md
- CLI Encyclopedia: @CLI_ENCYCLOPEDIA.md
- Bundles directory: @/Users/ronaldeddings/ClaudeCodeTS/bundles
- Target source directory: @src
- Local docs directory: @/Users/ronaldeddings/ClaudeCodeTS/docs

PREVIOUS PHASE CHANGELOG:
- @/Users/ronaldeddings/ClaudeCodeTS/changelogs/implementation-20251216-112501/phase-4-changelog.md

CRITICAL RULES:
1) Only implement PHASE 5 right now.
2) Do NOT jump ahead to future phases.
3) Read the relevant files thoroughly, especially the bundled/minified cli.js files @bundles/ClaudeCodeCode/cli.js and @bundles/ClaudeAgentSDKCode/cli.js.
4) You must treat third-party code as dependencies ‚Äî do not re-implement vendor internals.
5) You must build a clean TypeScript module graph in ./src that matches the plan and the encyclopedia and @implementation/1-initial-rewrite-implementation-checklist.md
6) Prefer async-first JS/TS, no subprocess-centric control flow.

AUTHENTICATION REQUIREMENT (SAFE):
- Use keychain to extract secrets, search for Claude Code-credentials .... within it there is an accessToken.... Also reference CLAUDE_CODE_SESSION_ACCESS_TOKEN in our old cli.js files
- Assume that using the keychain secret will log you in and you do NOT need to run /login.
- If you're able to run 'claude --dangerously-skip-permissions -p sayhello' and if it works, then creds are good and your code is not good.

WHAT TO DO IN THIS PHASE:
- Locate the '## Phase 5:' section in the implementation plan and implement it fully.
- If the plan references new files/modules to create, create them in ./src.
- If it references refactors or migrations, do the minimal necessary to complete this phase safely.
- If something is ambiguous, make a reasonable best decision and record it in the changelog as a 'Decision'.

VALIDATION:
- Run whatever is appropriate to validate progress (typecheck, tests, basic run), but avoid destructive commands.
- YOU MUST RUN THE IDENTICAL COMMAANDS that are in the previous cli.js files....
- If you cannot run something, explain why and what command should be run by the user.

STDOUT CONTRACT:
- Output ONLY a PHASE Change Log.
- Include these sections:
  1) Summary (what you accomplished in Phase 5)
  2) Files changed (created/modified/deleted)
  3) Decisions made (with rationale)
  4) Tests/validation run + results
  5) Remaining work inside Phase 5 (if any)
  6) Handoff notes for next phase

DO NOT print source code to stdout.
Begin now.

[36mmcp:[0m context7 starting
[36mmcp:[0m chrome-devtools starting
[1m[33mwarning:[0m[0m Repository snapshot ignored untracked files larger than 10 MiB: changelogs/implementation-20251216-112501/phase-2-changelog.md (15 MiB). These files are preserved during undo cleanup, but their contents are not captured in the snapshot. Adjust `ghost_snapshot.ignore_large_untracked_files` to change this behavior. To avoid this message in the future, update your `.gitignore`.
[36mmcp:[0m context7 ready
[36mmcp:[0m chrome-devtools ready
[36mmcp startup:[0m ready: context7, chrome-devtools
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'ls -la bundles && ls -la bundles/ClaudeCodeCode && ls -la bundles/ClaudeAgentSDKCode'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 55ms:[0m
[2mtotal 0
drwxr-xr-x   4 ronaldeddings  staff  128 Dec 16 11:13 .
drwxr-xr-x  20 ronaldeddings  staff  640 Dec 16 12:33 ..
drwxr-xr-x  17 ronaldeddings  staff  544 Dec 16 07:57 ClaudeAgentSDKCode
drwxr-xr-x  14 ronaldeddings  staff  448 Dec 16 07:57 ClaudeCodeCode
total 28328
drwxr-xr-x  14 ronaldeddings  staff       448 Dec 16 07:57 .
drwxr-xr-x   4 ronaldeddings  staff       128 Dec 16 11:13 ..
-rw-r--r--@  1 ronaldeddings  staff      6148 Dec 16 07:57 .DS_Store
-rw-r--r--   1 ronaldeddings  staff       551 Dec 15 07:25 bun.lock
-rwxr-xr-x   1 ronaldeddings  staff  10335889 Dec 15 07:25 cli.js
-rw-r--r--   1 ronaldeddings  staff       147 Dec 15 07:25 LICENSE.md
drwxr-xr-x   3 ronaldeddings  staff        96 Dec 15 07:25 node_modules
-rw-r--r--   1 ronaldeddings  staff      1200 Dec 15 07:25 package.json
-rw-r--r--   1 ronaldeddings  staff      1986 Dec 15 07:25 README.md
-rw-r--r--   1 ronaldeddings  staff   2478606 Dec 15 07:25 resvg.wasm
-rw-r--r--   1 ronaldeddings  staff     65063 Dec 15 07:25 sdk-tools.d.ts
-rw-r--r--   1 ronaldeddings  staff   1380769 Dec 15 07:25 tree-sitter-bash.wasm
-rwxr-xr-x   1 ronaldeddings  staff    205498 Dec 15 07:25 tree-sitter.wasm
drwxr-xr-x   3 ronaldeddings  staff        96 Dec 15 07:25 vendor[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'ls -la'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 34ms:[0m
[2mtotal 440
drwxr-xr-x   20 ronaldeddings  staff     640 Dec 16 12:33 .
drwxr-xr-x@ 288 ronaldeddings  staff    9216 Dec 16 12:35 ..
-rw-r--r--@   1 ronaldeddings  staff    6148 Dec 16 07:57 .DS_Store
drwxr-xr-x   13 ronaldeddings  staff     416 Dec 16 12:37 .git
-rw-r--r--    1 ronaldeddings  staff      25 Dec 16 11:39 .gitignore
-rw-r--r--    1 ronaldeddings  staff     809 Dec 16 12:33 bun.lock
drwxr-xr-x    4 ronaldeddings  staff     128 Dec 16 11:13 bundles
drwxr-xr-x    5 ronaldeddings  staff     160 Dec 16 11:25 changelogs
-rw-r--r--    1 ronaldeddings  staff  159739 Dec 15 07:25 CLI_ENCYCLOPEDIA.md
-rw-r--r--    1 ronaldeddings  staff    8625 Dec 15 07:25 CLI_FUNCTION_CLASS_MAP.md
drwxr-xr-x    4 ronaldeddings  staff     128 Dec 16 11:30 docs
drwxr-xr-x    3 ronaldeddings  staff      96 Dec 16 11:08 ignore
drwxr-xr-x    4 ronaldeddings  staff     128 Dec 16 07:55 implementation
-rw-r--r--    1 ronaldeddings  staff   17620 Dec 16 07:25 instruction.md
drwxr-xr-x    6 ronaldeddings  staff     192 Dec 16 12:33 node_modules
-rw-r--r--    1 ronaldeddings  staff     301 Dec 16 12:32 package.json
-rw-r--r--    1 ronaldeddings  staff    5435 Dec 16 11:38 runner-v2.sh
drwxr-xr-x    4 ronaldeddings  staff     128 Dec 16 12:29 scripts
drwxr-xr-x    7 ronaldeddings  staff     224 Dec 16 11:47 src[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,200p' CLI_ENCYCLOPEDIA.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 35ms:[0m
[2m# CLI Encyclopedia (WIP) ‚Äî Rebuilding `cli.js` into TypeScript

This is an **encyclopedia-style** guide to the two bundled/minified CLIs:

- `ClaudeAgentSDKCode/cli.js` (Claude Code 2.0.67 bundle)
- `ClaudeCodeCode/cli.js` (Claude Code 2.0.69 bundle)

Goal: document *what each top-level function/class does* (including minified symbol meanings) so we can **extract** it into a clean TypeScript module graph.

Important constraints:

1. These are **bundled + minified** with **no source maps** (no `sourceMappingURL`, no `*.map` files). That means:
   - Many identifiers are arbitrary (`uQ`, `coB`, `qV5`, ‚Ä¶) and not stable across builds.
   - A symbol name alone is not meaningful without its **definition site** and **call sites**.
2. The bundle contains **a large amount of third-party code** (e.g., lodash, commander, AWS SDK, XML parsing, etc.). Rewriting those internals is usually the wrong goal; instead, we should treat them as **dependencies** in the TS rewrite.
3. Therefore, this encyclopedia is organized by **subsystems** and focuses first on **first-party/product logic** that should become your TS modules.

---

## How to read minified symbols (practical decoding rules)[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "''^## Phase 5" -n implementation/1-initial-rewrite-implementation-checklist.md'[0m in /Users/ronaldeddings/ClaudeCodeTS[31m exited 1 in 44ms:[0m
[2m[0m

[35m[3mthinking[0m[0m
**Locating Phase 5**

I encountered an issue with the rg tool for phase 5, as it returned exit code 1 which might mean the pattern wasn't found due to varying formatting. I need to locate the Phase 5 section by performing a search. To do this, I'll open the plan surrounding phase 5 and use the rg tool to search specifically for "Phase 5," but I won't anchor it this time.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "Phase 5" implementation/1-initial-rewrite-implementation-checklist.md'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 56ms:[0m
[2m490:***Phase 5: App and Session State Model (UI-Agnostic, Event-Driven)***
573:Dependencies: Phase 4 storage abstraction and Phase 5 state/persistence.
646:Dependencies: Phase 6 settings model (sources), Phase 4 capability boundary, and Phase 5 prompt queue semantics.
767:Dependencies: Phase 3 runtime, Phase 4 capabilities, Phase 7 permission engine, Phase 5 state model.
1138:Dependencies: Phase 4 network abstraction, Phase 8 tool pipeline, Phase 5 elicitation queue model.
1287:Dependencies: Phase 3 scheduler, Phase 5 state model, Phase 8 tool pipeline.
1397:Dependencies: Phase 4 capability interfaces and Phase 5 store/event bus.
1463:Dependencies: Phase 3 task model (spans), Phase 5 state events.
1668:Dependencies: Phase 2 packaging constraints, Phase 4 capability adapters, Phase 5/6 persistence schemas.[0m

[35m[3mthinking[0m[0m
**Reviewing Phase 5**

Alright, I'm starting with Phase 5, which kicks off at line 490. I‚Äôll need to check the surrounding lines for context on that section. It's all about markdown formatting, so I want to make sure I'm clear on how to structure it. I‚Äôm curious to see what specific details are laid out in this phase, and I‚Äôll keep note of anything important as I go along. Let‚Äôs dive into those lines!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '470,650p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 48ms:[0m
[2m
4.8 Workspace identity and project scoping (portable replacement for ‚Äúcwd‚Äù assumptions)
- [ ] Define a `WorkspaceId` concept that can exist without a filesystem path (mobile/web), and a mapping to a path-based workspace on desktop/Node.
- [ ] Define workspace discovery/selection flows per host:
  - [ ] CLI: default workspace = cwd (but explicitly captured as a workspace record)
  - [ ] Desktop GUI: user selects a folder (workspace record persisted)
  - [ ] Mobile/web: user selects a ‚Äúworkspace profile‚Äù (remote repo, synced snapshot, or document set)
- [ ] Define how settings sources that are ‚Äúproject-scoped‚Äù bind to `WorkspaceId` on non-filesystem hosts.
- [ ] Define a ‚Äúworkspace trust‚Äù artifact per workspace (used by hooks/tools) with clear UX for establishing/withdrawing trust.
- [ ] Define workspace-to-repo binding semantics (optional): how a `WorkspaceId` can map to a remote repo identifier (URL + branch) even when no local checkout exists.
- [ ] Define workspace renaming/migration semantics (IDs stable; display names mutable) and ensure persisted settings/policy references remain valid.

4.9 Host capability matrix and polyfill strategy (make portability testable)
- [ ] Produce a host/capability matrix for: Node/CLI, desktop GUI, web, RN (Hermes/JSC), including known gaps (ReadableStream support, crypto APIs, filesystem availability).
- [ ] Define per-capability ‚Äúpolyfill allowed?‚Äù rules (e.g., `fetch` polyfill allowed in RN; filesystem polyfill not allowed if it breaks trust model).
- [ ] Define a ‚Äúcapability compliance‚Äù diagnostic report: at boot, enumerate available capabilities, polyfills activated, and policy restrictions applied.
- [ ] Add a conformance test that boots the engine with a ‚Äúminimal mobile-safe‚Äù capability set (no filesystem, no local endpoint, no process/env) and asserts required subsystems still function (settings, permissions prompts, hooks lifecycle, MCP endpoint).

---
[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "nl -ba implementation/1-initial-rewrite-implementation-checklist.md | sed -n '485,590p'"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 57ms:[0m
[2m   485	- [ ] Define a ‚Äúcapability compliance‚Äù diagnostic report: at boot, enumerate available capabilities, polyfills activated, and policy restrictions applied.
   486	- [ ] Add a conformance test that boots the engine with a ‚Äúminimal mobile-safe‚Äù capability set (no filesystem, no local endpoint, no process/env) and asserts required subsystems still function (settings, permissions prompts, hooks lifecycle, MCP endpoint).
   487	
   488	---
   489	
   490	***Phase 5: App and Session State Model (UI-Agnostic, Event-Driven)***
   491	
   492	Why this phase exists: the legacy CLI‚Äôs wide React/Ink `AppState` acts as a central runtime container; the rewrite needs a portable, testable state model independent of any UI framework.
   493	
   494	Risks mitigated: UI-framework coupling, state inconsistency, and inability to replay/debug decisions.
   495	
   496	Dependencies: Phase 2 event taxonomy and Phase 3 runtime primitives.
   497	
   498	5.1 Define canonical domain entities and their lifecycles
   499	- [ ] Define `AppState` vs `SessionState` separation (global settings/capabilities vs per-session conversation/task state).
   500	- [ ] Define session identity and lifecycle states (created, active, paused, ended, error).
   501	- [ ] Define transcript/event-log model (append-only log + derived views) and retention policy.
   502	- [ ] Define ‚Äútool use‚Äù entity model (tool name, input, output, streaming events, permissions decision, timing, cancellation).
   503	- [ ] Define ‚Äúhook run‚Äù entity model (event name, selected hooks, per-hook outcomes/effects, streaming messages).
   504	- [ ] Define ‚ÄúMCP connection‚Äù model (server identity, mode, connection status, resources/tools snapshot).[0m

[35m[3mthinking[0m[0m
**Considering TypeScript implementation**

I‚Äôm moving into Phase 5 tasks, which are conceptual but now need to be implemented in TypeScript. So, we‚Äôre creating modules for the app's state entities, including the store, queues, and persistence/hydration semantics. Since the phases are sequential, we‚Äôve already built some runtime primitives and an event taxonomy in previous phases. I‚Äôll inspect the source to see the current modules and list the source tree to get a clear overview.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'ls -R src'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 83ms:[0m
[2mcore
index.ts
platform
spec
ui

src/core:
agents
capabilities
engine
events
filesystem
hooks
index.ts
mcp
network
permissions
runtime
settings
state[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'find .. -name AGENTS.md -maxdepth 4 -print'[0m in /Users/ronaldeddings/ClaudeCodeTS[31m exited 124 in 10.01s:[0m
[2mfind: ../.fleet: Permission denied
../open-swe/AGENTS.md
find: ../Library/Saved Application State/com.izotope.installer.RX-11-Audio-Editor-Advanced.savedState: Permission denied
find: ../Library/Saved Application State/com.izotope.audioplugins.productportal.savedState: Permission denied
find: ../Library/Saved Application State/com.izotope.installer.RX-10-Audio-Editor-Advanced.savedState: Permission denied[0m

[35m[3mthinking[0m[0m
**Finding directory issues**

Oops, it looks like my last search ran beyond the workspace due to some permission issues! I need to focus on restricting the search to the repository only. I think it‚Äôs a good idea to run the find command specifically in the current directory instead. That should help me avoid any future mix-ups and get the right results. Let‚Äôs go ahead and try that!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'find . -name AGENTS.md -print'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 102ms:[0m
[2m[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/runtime/queue.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 48ms:[0m
[2mimport { createDeferred, type Deferred } from "./deferred.js";

export type DropPolicy = "drop_oldest" | "drop_newest" | "block_producer";

export type QueueCloseReason =
  | { kind: "closed"; message?: string }
  | { kind: "cancelled"; message?: string }
  | { kind: "error"; message?: string };

export type QueueStats = {
  size: number;
  maxSize: number;
  dropped: number;
  closed: boolean;
};

export class BoundedAsyncQueue<T> implements AsyncIterable<T> {
  private readonly maxSize: number;
  private readonly dropPolicy: DropPolicy;
[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,220p' src/core/engine/index.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 30ms:[0m
[2mexport type { Engine, EngineCommand, EngineCreateOptions, EngineEventHandler, EngineFactory } from "../types/engine.js";
[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,200p' src/core/state/index.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 32ms:[0m
[2mexport type StatePlaceholder = {
  phase: "2";
};
[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/types/events.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 32ms:[0m
[2mimport type { EngineError } from "./errors.js";
import type { VersionedEnvelopeBase } from "./schema.js";
import type { RuntimeSnapshot, TaskId } from "./runtime.js";

export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
export type EngineEventSeverity = "debug" | "info" | "warn" | "error";

export type EngineEventSensitivity = "public" | "internal" | "pii" | "secret";

export type EngineEventCorrelationIds = {
  taskId?: TaskId;
  toolRunId?: string;
  hookRunId?: string;
  mcpRequestId?: string;
};

export type EngineEventCursor = {
  channel: EngineEventChannel;
  seq: number;
};[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/types/engine.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 34ms:[0m
[2mimport type { EngineEventEnvelope, HostEvent } from "./events.js";
import type { HostCapabilities } from "./host.js";

export type EngineCommand =
  | { type: "engine/start" }
  | { type: "engine/stop"; reason?: string }
  | { type: "engine/dispatchHostEvent"; event: HostEvent };

export type EngineEventHandler = (event: EngineEventEnvelope) => void;
export type Unsubscribe = () => void;

export type Engine = {
  start: () => Promise<void>;
  stop: (reason?: string) => Promise<void>;
  dispatch: (command: EngineCommand) => Promise<void>;
  subscribe: (handler: EngineEventHandler) => Unsubscribe;
};

export type EngineCreateOptions = {
  host: HostCapabilities;[0m

[35m[3mthinking[0m[0m
**Considering state model implementation**

Phase 5 seems to be bringing in components like store and queues that go beyond the runtime queue. Right now, core/state/index.ts is just a placeholder, so I need to dive into creating an actual state model and store interface. Following the plan, I'll be working on deterministic reducers, selectors, snapshot and restore functionality, typed actions, and UI events. There‚Äôs already a core/events/bus that might serve for the engine event bus, so I should check out core/events/bus.ts.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/events/bus.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 51ms:[0m
[2mimport type {
  EngineEvent,
  EngineEventChannel,
  EngineEventCorrelationIds,
  EngineEventEnvelope,
  EngineEventSensitivity,
  EngineEventSeverity
} from "../types/events.js";
import { SCHEMA_VERSION } from "../types/schema.js";
import type { MonotonicClock } from "../runtime/clock.js";
import type { IdSource } from "../runtime/ids.js";
import { BoundedAsyncQueue, type DropPolicy } from "../runtime/queue.js";

export type ChannelPolicy = {
  bufferSize: number;
  dropPolicy: DropPolicy;
  mustDeliver: boolean;
};

export type EventBusOptions = {[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'cat package.json'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 57ms:[0m
[2m{
  "name": "claude-code-ts-rewrite",
  "private": true,
  "type": "module",
  "scripts": {
    "typecheck": "tsc -p tsconfig.json --noEmit",
    "check:boundaries": "node scripts/check-import-boundaries.mjs"
  },
  "devDependencies": {
    "@types/node": "^22.10.2",
    "typescript": "^5.8.3"
  }
}[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,240p' src/core/index.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 35ms:[0m
[2mexport * from "./types/index.js";
export * from "./engine/index.js";
export * from "./events/index.js";
export * from "./runtime/index.js";
export * from "./state/index.js";
export * from "./settings/index.js";
export * from "./permissions/index.js";
export * from "./hooks/index.js";
export * from "./tools/index.js";
export * from "./mcp/index.js";
export * from "./agents/index.js";
export * from "./capabilities/index.js";
export * from "./network/index.js";
export * from "./filesystem/index.js";[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,200p' src/index.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 33ms:[0m
[2mexport * from "./spec/index.js";
export * from "./core/index.js";[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,220p' src/platform/smoke.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 35ms:[0m
[2mimport type { HostCapabilities } from "../core/types/host.js";

export type CapabilityKey = keyof HostCapabilities;

export type HostCapabilitySmokeResult = {
  missing: CapabilityKey[];
};

export function smokeCheckHostCapabilities(
  host: HostCapabilities,
  required: readonly CapabilityKey[]
): HostCapabilitySmokeResult {
  const missing: CapabilityKey[] = [];
  for (const key of required) {
    const cap = host[key];
    if (cap.kind === "unavailable") missing.push(key);
  }
  return { missing };
}
[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/platform/node/host.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 35ms:[0m
[2mimport { availableCapability, unavailableCapability } from "../../core/types/host.js";
import type {
  HostCapabilities,
  HostClock,
  HostCrypto,
  HostFilesystem,
  HostLifecycle,
  HostNetwork,
  HostProcess,
  HostRandom,
  HostSecrets,
  HostStorage,
  StorageNamespace
} from "../../core/types/host.js";
import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
import crypto from "node:crypto";
import { execFile as execFileCb } from "node:child_process";
import fs from "node:fs/promises";
import os from "node:os";
import path from "node:path";[0m

[35m[3mthinking[0m[0m
**Focusing on project implementation**

I see the project is minimal and doesn‚Äôt have tests yet. So, I need to concentrate on Phase 5, particularly implementing the app and session state model in the core/state module, along with types. I think it could integrate with the event taxonomy from Phase 2 and the runtime primitives from Phase 3. Currently, the existing types and events are high-level, but we need to add more detail. I should check the implementation phase 4 changelog for context.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,200p' changelogs/implementation-20251216-112501/phase-4-changelog.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 52ms:[0m
[2m# Phase 4 Change Log ‚Äî Host Capability Abstraction (iOS/Web/Desktop-Safe)

## 1) Summary (what you accomplished in Phase 4)

- Expanded the canonical host capability boundary (capability taxonomy, typed capability/storage errors, and workspace identity primitives) so the engine can run without Node-only assumptions.
- Added a capability catalog, compliance report, policy interface, filtered capability views, and an audit mode for tracking capability usage in tests.
- Implemented initial host adapters for Node/CLI, Web, React Native, and Desktop (Desktop currently aliases Node), including Node-safe storage and credential reading hooks aligned with legacy CLI behavior.
- Added portable filesystem path helpers and a deterministic retry/backoff helper for fetch-based network operations.
- Documented the Phase 4 capability matrix and portability stance in `docs/rewrite/phase-4/*`.

## 2) Files changed (created/modified/deleted)

- Modified: `package.json`
- Modified: `bun.lock`
- Modified: `src/core/types/errors.ts`
- Modified: `src/core/types/index.ts`
- Modified: `src/core/types/host.ts`
- Created: `src/core/types/workspace.ts`
- Created: `src/core/capabilities/index.ts`
- Created: `src/core/capabilities/catalog.ts`[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/spec/legacy/appstate.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 54ms:[0m
[2mexport type LegacyNotificationPriority = "immediate" | "high" | "medium" | "low";

export type LegacyNotification = {
  key: string;
  text: string;
  priority: LegacyNotificationPriority;
  color?: string;
  timeoutMs?: number;
  invalidates?: string[];
};

export type LegacyOverlay =
  | "message-selector"
  | "sandbox-permission"
  | "tool-permission"
  | "worker-permission"
  | "worker-sandbox-permission"
  | "elicitation"
  | "cost"
  | "ide-onboarding";[0m

[35m[3mthinking[0m[0m
**Reviewing overlay implementation**

I'm going through the file that defines legacy overlay precedence and notifications. Phase 5 comes up, and it includes the queue model and the overlay selection algorithm that matches the legacy overlay behavior. That sounds solid! I should also check specs for earlier phases, which might be stubs. It looks like I need to implement the overlay selection algorithm and corresponding tests, so I'll take a look at src/spec/legacy/index.ts to get started.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,200p' src/spec/legacy/index.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 54ms:[0m
[2mexport * from "./settings.js";
export * from "./permissions.js";
export * from "./hooks.js";
export * from "./mcpCli.js";
export * from "./appstate.js";
[0m



[35m[3mthinking[0m[0m
**Considering Phase 5 Tests**

I'm examining the legacy mcpCli, permissions, and settings related to Phase 5. It seems like Phase 5 expects golden tests, but the repo lacks actual tests‚Äîjust an internal spec. There's a mention of scripts for checking boundaries. I‚Äôm thinking about implementing golden tests in TypeScript using Node, though the test runner isn't installed. I noticed a bun.lock file, indicating bun might be present, but the plan doesn‚Äôt mention its use. I'll prepare a simple test script for phase 5, similar to the existing phase 4 scripts.
[35m[3mthinking[0m[0m
**Exploring Phase 5 Implementation**

It seems that Phase 5 doesn‚Äôt strictly require tests, but we should validate through type checking. The instructions mention validation by running what‚Äôs appropriate, so I can create a script for validating overlay selection and queue logic. I have to focus solely on Phase 5 for now, meaning I shouldn‚Äôt dive into settings or permissions beyond the state model. However, I can define placeholder types for permission queue semantics while delaying the full implementation of the permission engine for Phase 7.
[35m[3mthinking[0m[0m
**Planning Implementation Structure**

I‚Äôm laying out a plan for implementing important domain entities like AppState and SessionState. The entities will involve session identity/lifecycle, a transcript event log, tool uses, hook runs, and mcp connections. I‚Äôll also create an interface for dispatching typed actions and commands, along with emitting events to the UI and handling snapshot/restore capabilities.

Furthermore, I need to establish a generic queue that includes priority handling, a deterministic overlay selection algorithm, and various queues for notifications, elicitation, permissions, and more while considering persistence rules. Ensuring we define the state properly for persistence versus ephemeral data will be crucial, along with schema versioning and crash recovery. Finally, I‚Äôll write minimal TypeScript models and ensure our module graph remains clean, avoiding imports of Node builtins in core. I'll review the import boundaries to comply with the established restrictions.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'cat scripts/check-import-boundaries.mjs'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 50ms:[0m
[2mimport { readdir, readFile } from "node:fs/promises";
import path from "node:path";

const repoRoot = process.cwd();
const srcRoot = path.join(repoRoot, "src");
const coreRoot = path.join(srcRoot, "core");
const platformRoot = path.join(srcRoot, "platform");
const uiRoot = path.join(srcRoot, "ui");

const nodeBuiltins = new Set([
  "assert",
  "buffer",
  "child_process",
  "cluster",
  "crypto",
  "dgram",
  "dns",
  "events",
  "fs",
  "http",[0m

[35m[3mthinking[0m[0m
**Implementing state store in core**

I‚Äôm realizing that core can‚Äôt import node builtins, which is a bit of a hurdle. So, I need to implement a state store within core instead. I should check out core/types to find the schema base types, including canonicalJson and others. It‚Äôll be helpful to explore src/core/types/schema.ts to understand how the error types are defined. Let‚Äôs dive into those details and see what I can uncover!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/types/runtime.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 52ms:[0m
[2mimport type { EngineError } from "./errors.js";

export type TaskId = string;
export type TaskScopeId = string;
export type StreamId = string;

export type TaskPriority = "immediate" | "high" | "normal" | "low";
export type TaskFailurePolicy = "fail-fast" | "isolate" | "escalate";

export type TaskLifecycleState = "created" | "queued" | "running" | "waiting" | "completed";

export type CancellationReason =
  | { kind: "user_cancel"; message?: string }
  | { kind: "stop_request"; message?: string }
  | { kind: "timeout"; message?: string; deadlineMonoMs?: number }
  | { kind: "policy_denied"; message?: string }
  | { kind: "host_lifecycle"; message?: string; event?: string }
  | { kind: "unknown"; message?: string };

export type TaskResult<T = unknown> =[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,240p' src/core/types/errors.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 29ms:[0m
[2mexport type EngineErrorCode =
  | "capability_missing"
  | "permission_denied"
  | "policy_override"
  | "conflict"
  | "quota_exceeded"
  | "corruption_detected"
  | "transient_failure"
  | "transport_failure"
  | "task_cancelled"
  | "timeout"
  | "unknown";

export type EngineError = {
  code: EngineErrorCode;
  message: string;
  details?: unknown;
  cause?: EngineError;
};
[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,240p' src/core/types/schema.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 27ms:[0m
[2mexport type SchemaVersion = number;

export type SchemaKind =
  | "engine_event_envelope"
  | "settings_document"
  | "state_snapshot"
  | "hook_definition"
  | "hook_result"
  | "tool_invocation"
  | "tool_result"
  | "mcp_envelope";

export type VersionedEnvelopeBase = {
  kind: SchemaKind;
  schemaVersion: SchemaVersion;
};

export const SCHEMA_VERSION = {
  engineEventEnvelope: 1,
  settingsDocument: 1,[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/types/workspace.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 29ms:[0m
[2mexport type WorkspaceId = string & { readonly __brand: "WorkspaceId" };

export type WorkspaceKind = "path" | "remote" | "profile";

export type WorkspaceTrust = {
  trusted: boolean;
  grantedAtMs?: number;
  revokedAtMs?: number;
  reason?: string;
};

export type WorkspaceDescriptor = {
  id: WorkspaceId;
  kind: WorkspaceKind;
  displayName: string;
  trust?: WorkspaceTrust;
  path?: string;
  repo?: { url: string; branch?: string };
};
[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,220p' src/core/types/index.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 49ms:[0m
[2mexport * from "./json.js";
export * from "./schema.js";
export * from "./canonicalJson.js";
export * from "./errors.js";
export * from "./events.js";
export * from "./host.js";
export * from "./workspace.js";
export * from "./engine.js";
export * from "./runtime.js";[0m





[35m[3mthinking[0m[0m
**Planning state management**

I need to add types for the application and session states, possibly in a new file called `src/core/types/state.ts`, exporting from an index. This might be part of phase 5. There's also the need for a store, likely to be placed in `src/core/state/store.ts`, designed to handle pure reducers and side effects.

For now, I'll implement it with side-effect-free functionality and manage events through an EventBus. The store should hold the AppState and allow for dispatching actions. I'll also consider a `Store<Action, Event, StateSnapshot>` that includes a `dispatch(action)` method.
[35m[3mthinking[0m[0m
**Defining dispatch functionality**

I‚Äôm thinking that the dispatch function should ideally be synchronous to ensure determinism, but there's a case for async to allow emitting events through the EventBus. To keep things side-effect free, the reducer will return the next state and events. I can implement `createStore(reducer, initialState, options)` to return a store with methods like `getState()`, `dispatch(action)`, and `subscribe(callback)`.

In phase 5, dispatch will deal with typed actions, emitting typed events to the UI while allowing for state snapshots and restores. I want to create unions for `StateAction` and `StateEvent`, potentially working with `EventBus` for a seamless integration of global event channels.
[35m[3mthinking[0m[0m
**Implementing store events and persistence**

I see that the requirements indicate the store should emit typed events to the UI. To achieve this, I‚Äôll set up a subscriber list with a `subscribe` method to send those events. It‚Äôs important to keep these processes separate, but the Engine might adapt the store events for the EventBus later on. 

Phase 4 created a HostStorage abstraction for persistence, so I‚Äôll work on helpers in `core/state/persistence.ts` to serialize the state snapshot to JSON. I should also consider the dependencies across phases for a smooth implementation.
[35m[3mthinking[0m[0m
**Planning state persistence and migration**

I need to be cautious as I work on defining what state needs to persist and develop schema versioning with migration hooks. This is more conceptual, but I‚Äôll create TypeScript interfaces like `StateSnapshotV1` and the `migrateStateSnapshot` function. I‚Äôll also document crash recovery semantics by coding types like `StateHydrationResult`, which could be useful later.

It‚Äôs important to thoroughly read the bundled `cli.js` for phase 5, especially focusing on state management, and I'll utilize ripgrep for efficient searching of terms like "AppState" or "sandbox-permission".
[35m[3mthinking[0m[0m
**Inspecting cli.js and overlay precedence**

I plan to examine relevant sections of `cli.js` and also look into ClaudeAgent to ensure the overlay precedence aligns with the specifications. While the specs already list this precedence, I want to confirm it. 

The instructions suggest reading certain files thoroughly, especially the bundled or minified ones. I‚Äôll follow this to an extent‚Äîfocusing on targeted sections rather than scrolling through the entire 10MB file. I‚Äôll use ripgrep to search for terms like "message-selector" to help narrow things down efficiently.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "AppState" bundles/ClaudeCodeCode/cli.js bundles/ClaudeAgentSDKCode/cli.js | head -n 40'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 76ms:[0m
[2mbundles/ClaudeCodeCode/cli.js:777:`});var l03,i03,f8A;var my1=L(()=>{z2();l03=P.enum(["pending","in_progress","completed"]),i03=P.object({content:P.string().min(1,"Content cannot be empty"),status:l03,activeForm:P.string().min(1,"Active form cannot be empty")}),f8A=P.array(i03)});function taQ(){return null}function eaQ(){return null}function AoQ(){return null}function QoQ(){return null}function BoQ(){return null}var GoQ="TodoWrite";var n03,a03,lY;var cs=L(()=>{z2();saQ();my1();n03=P.strictObject({todos:f8A.describe("The updated todo list")}),a03=P.object({oldTodos:f8A.describe("The todo list before the update"),newTodos:f8A.describe("The todo list after the update")}),lY={name:GoQ,strict:!0,input_examples:[{todos:[{content:"Implement user authentication",status:"in_progress",activeForm:"Implementing user authentication"},{content:"Write unit tests",status:"pending",activeForm:"Writing unit tests"}]}],async description(){return raQ},async prompt(){return oaQ},inputSchema:n03,outputSchema:a03,userFacingName(){return""},isEnabled(){return!0},isConcurrencySafe(){return!1},isReadOnly(){return!1},async checkPermissions(A){return{behavior:"allow",updatedInput:A}},renderToolUseMessage:taQ,renderToolUseProgressMessage:eaQ,renderToolUseRejectedMessage:AoQ,renderToolUseErrorMessage:QoQ,renderToolResultMessage:BoQ,async call({todos:A},Q){let G=(await Q.getAppState()).todos[Q.agentId]??[],Z=A.every((Y)=>Y.status==="completed")?[]:A;return Q.setAppState((Y)=>({...Y,todos:{...Y.todos,[Q.agentId]:Z}})),{data:{oldTodos:G,newTodos:A}}},mapToolResultToToolResultBlockParam(A,Q){return{tool_use_id:Q,type:"tool_result",content:"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}}}});function _Q(A){let[Q,B]=ZoQ.useState({pending:!1,keyName:null}),G=lk((Y)=>B({pending:Y,keyName:"Ctrl-C"}),A?A:async()=>{await W3(0)}),Z=lk((Y)=>B({pending:Y,keyName:"Ctrl-D"}),A?A:async()=>{await W3(0)});return k1((Y,J)=>{if(J.ctrl&&Y==="c")G();if(J.ctrl&&Y==="d")Z()}),Q}var ZoQ;var c9=L(()=>{fA();adA();iY();ZoQ=o(WA(),1)});function YoQ(){return r4.createElement(z,{dimColor:!0},"Claude Code will be able to read files in this directory and make edits when auto-accept edits is on.")}function r03({path:A}){return r4.createElement(j,{flexDirection:"column",paddingX:2,gap:1},r4.createElement(z,{color:"permission"},A),r4.createElement(YoQ,null))}function s03({value:A,onChange:Q,onSubmit:B,error:G}){return r4.createElement(j,{flexDirection:"column"},r4.createElement(z,null,"Enter the path to the directory:"),r4.createElement(j,{borderDimColor:!0,borderStyle:"round",marginY:1,paddingLeft:1},r4.createElement(K6,{showCursor:!0,placeholder:`Directory path${X1.ellipsis}`,value:A,onChange:Q,onSubmit:B,columns:80,cursorOffset:A.length,onChangeCursorOffset:()=>{}})),G&&r4.createElement(z,{color:"error"},G))}function xpA({onAddDirectory:A,onCancel:Q,permissionContext:B,directoryPath:G}){let[Z,Y]=Xf.useState(""),[J,I]=Xf.useState(null),X=_Q(),W=Xf.useMemo(()=>o03,[]);k1(Xf.useCallback((E,D)=>{if(D.escape||D.ctrl&&E==="c")Q()},[Q]));let K=Xf.useCallback((E)=>{let D=nCA(E,B);if(D.resultType==="success")A(D.absolutePath,!1);else I(aCA(D))},[B,A]),V=Xf.useCallback((E)=>{if(!G)return;switch(E){case"yes-session":A(G,!1);break;case"yes-remember":A(G,!0);break;case"no":Q();break}},[G,A,Q]);return r4.createElement(r4.Fragment,null,r4.createElement(j,{flexDirection:"column",borderStyle:"round",paddingLeft:1,paddingRight:1,gap:1,borderColor:"permission"},r4.createElement(z,{bold:!0,color:"permission"},"Add directory to workspace"),G?r4.createElement(j,{flexDirection:"column",gap:1},r4.createElement(r03,{path:G}),r4.createElement(S0,{options:W,onChange:V,onCancel:()=>V("no")})):r4.createElement(j,{flexDirection:"column",gap:1,marginX:2},r4.createElement(YoQ,null),r4.createElement(s03,{value:Z,onChange:Y,onSubmit:K,error:J}))),!G&&r4.createElement(j,{marginLeft:3},X.pending?r4.createElement(z,{dimColor:!0},"Press ",X.keyName," again to exit"):r4.createElement(z,{dimColor:!0},"Enter to add ¬∑ Esc to cancel")))}var r4,Xf,o03;var dy1=L(()=>{fA();c9();nY();ypA();g2();Z8();r4=o(WA(),1),Xf=o(WA(),1),o03=[{value:"yes-session",label:"Yes, for this session"},{value:"yes-remember",label:"Yes, and remember this directory"},{value:"no",label:"No"}]});function h0({children:A,height:Q}){if(JoQ.useContext(IoQ))return A;return mR.createElement(t03,null,mR.createElement(j,{flexDirection:"row",height:Q,overflowY:"hidden"},mR.createElement(z,null,"  ","‚éø ¬†"),A))}function t03({children:A}){return mR.createElement(IoQ.Provider,{value:!0},A)}var mR,JoQ,IoQ;var h4=L(()=>{fA();mR=o(WA(),1),JoQ=o(WA(),1);IoQ=mR.createContext(!1)});function py1(A){let Q=A.toString();if(Q.includes("\x1B[I"))cy1=!0,ps.forEach((B)=>B(!0));if(Q.includes("\x1B[O"))cy1=!1,ps.forEach((B)=>B(!1))}function XoQ(){let A=()=>{if(ps.size===0)return;process.stdin.off("data",py1),process.stdout.write("\x1B[?1004l")};process.on("exit",A)}function Xc(){let[A,Q]=Wf.useState(cy1),[B,G]=Wf.useState(!1),Z=Wf.useCallback((J)=>{Q(J),G(!1)},[]);Wf.useEffect(()=>{if(!process.stdout.isTTY)return;if(ps.add(Z),ps.size===1)process.stdout.write("\x1B[?1004h"),process.stdin.on("data",py1);return()=>{if(ps.delete(Z),ps.size===0)process.stdin.off("data",py1),process.stdout.write("\x1B[?1004l")}},[Z]),Wf.useEffect(()=>{if(!A&&B)r("tengu_typing_without_terminal_focus",{})},[A,B]);let Y=Wf.useCallback((J,I)=>{if(J==="\x1B[I"||J==="\x1B[O"||J==="[I"||J==="[O")return"";if((J||I)&&!A)G(!0);return J},[A]);return{isFocused:A||B,filterFocusSequences:Y}}var Wf,cy1=!0,ps;var b8A=L(()=>{T0();Wf=o(WA(),1),ps=new Set});function dW(A){let Q=/^---\s*\n([\s\S]*?)---\s*\n?/,B=A.match(Q);if(!B)return{frontmatter:{},content:A};let G=B[1]||"",Z=A.slice(B[0].length),Y={},J=G.split(`
bundles/ClaudeCodeCode/cli.js:961:`,ld1=(A,Q=YwA)=>`File content (${II(A)}) exceeds maximum allowed size (${II(Q)}). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.`;var Cw=L(()=>{z2();pB();g0();ws();XCA();M9();vpA();h1();AV();cY();Ey1();HB();yL();XQ();nWB();MoA();M9();XM3=[];_oA=class _oA extends Error{tokenCount;maxTokens;constructor(A,Q){super(`File content (${A} tokens) exceeds maximum allowed tokens (${Q}). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.`);this.tokenCount=A;this.maxTokens=Q;this.name="MaxFileReadTokenExceededError"}};OoA=new Set(["png","jpg","jpeg","gif","webp"]),WM3=new Set(["mp3","wav","flac","ogg","aac","m4a","wma","aiff","opus","mp4","avi","mov","wmv","flv","mkv","webm","m4v","mpeg","mpg","zip","rar","tar","gz","bz2","7z","xz","z","tgz","iso","exe","dll","so","dylib","app","msi","deb","rpm","bin","dat","db","sqlite","sqlite3","mdb","idx","doc","docx","xls","xlsx","ppt","pptx","odt","ods","odp","ttf","otf","woff","woff2","eot","psd","ai","eps","sketch","fig","xd","blend","obj","3ds","max","class","jar","war","pyc","pyo","rlib","swf","fla"]),KM3=P.strictObject({file_path:P.string().describe("The absolute path to the file to read"),offset:P.number().optional().describe("The line number to start reading from. Only provide if the file is too large to read at once"),limit:P.number().optional().describe("The number of lines to read. Only provide if the file is too large to read at once.")}),VM3=P.enum(["image/jpeg","image/png","image/gif","image/webp"]),EM3=P.discriminatedUnion("type",[P.object({type:P.literal("text"),file:P.object({filePath:P.string().describe("The path to the file that was read"),content:P.string().describe("The content of the file"),numLines:P.number().describe("Number of lines in the returned content"),startLine:P.number().describe("The starting line number"),totalLines:P.number().describe("Total number of lines in the file")})}),P.object({type:P.literal("image"),file:P.object({base64:P.string().describe("Base64-encoded image data"),type:VM3.describe("The MIME type of the image"),originalSize:P.number().describe("Original file size in bytes"),dimensions:P.object({originalWidth:P.number().optional().describe("Original image width in pixels"),originalHeight:P.number().optional().describe("Original image height in pixels"),displayWidth:P.number().optional().describe("Displayed image width in pixels (after resizing)"),displayHeight:P.number().optional().describe("Displayed image height in pixels (after resizing)")}).optional().describe("Image dimension info for coordinate mapping")})}),P.object({type:P.literal("notebook"),file:P.object({filePath:P.string().describe("The path to the notebook file"),cells:P.array(P.any()).describe("Array of notebook cells")})}),P.object({type:P.literal("pdf"),file:P.object({filePath:P.string().describe("The path to the PDF file"),base64:P.string().describe("Base64-encoded PDF data"),originalSize:P.number().describe("Original file size in bytes")})})]),V3={name:L8,strict:!0,input_examples:[{file_path:"/Users/username/project/src/index.ts"},{file_path:"/Users/username/project/README.md",limit:100,offset:0}],async description(){return YaQ},async prompt(){return JaQ},inputSchema:KM3,outputSchema:EM3,userFacingName:lWB,getToolUseSummary:iWB,isEnabled(){return!0},isConcurrencySafe(){return!0},isReadOnly(){return!0},getPath({file_path:A}){return A||r1()},async checkPermissions(A,Q){let B=await Q.getAppState();return Vp(V3,A,B.toolPermissionContext)},renderToolUseMessage:uWB,renderToolUseProgressMessage:mWB,renderToolResultMessage:dWB,renderToolUseRejectedMessage:cWB,renderToolUseErrorMessage:pWB,async validateInput({file_path:A,offset:Q,limit:B},G){let Z=jA(),Y=Kp(A),J=await G.getAppState();if(SE(Y,J.toolPermissionContext,"read","deny")!==null)return{result:!1,message:"File is in a directory that is denied by your permission settings.",errorCode:1};if(Y.startsWith("\\\\")||Y.startsWith("//"))return{result:!0};if(!Z.existsSync(Y)){let H=ToA(Y),F="File does not exist.",C=r1(),U=pQ();if(C!==U)F+=` Current working directory: ${C}`;if(H)F+=` Did you mean ${H}?`;return{result:!1,message:F,errorCode:2}}let W=pd1.extname(Y).toLowerCase();if(WM3.has(W.slice(1))&&!(S8A()&&VpA(W)))return{result:!1,message:`This tool cannot read binary files. The file appears to be a binary ${W} file. Please use appropriate tools for binary file analysis.`,errorCode:4};let V=Z.statSync(Y).size;if(V===0){if(OoA.has(W.slice(1)))return{result:!1,message:"Empty image files cannot be processed.",errorCode:5}}let E=W===".ipynb",D=S8A()&&VpA(W);if(!OoA.has(W.slice(1))&&!E&&!D){if(!joA(Y)&&!Q&&!B)return{result:!1,message:ld1(V),meta:{fileSize:V},errorCode:6}}return{result:!0}},async call({file_path:A,offset:Q=1,limit:B=void 0},G){let{readFileState:Z,fileReadingLimits:Y}=G,J=YwA,I=Y?.maxTokens??id1,X=pd1.extname(A).toLowerCase().slice(1),W=Kp(A);if(X==="ipynb"){let F=EoQ(W),C=JSON.stringify(F);if(C.length>J)throw Error(`Notebook content (${II(C.length)}) exceeds maximum allowed size (${II(J)}). Use ${e9} with jq to read specific portions:
bundles/ClaudeCodeCode/cli.js:1132:}`}],async description(){return"Write a file to the local filesystem."},userFacingName:YRB,getToolUseSummary:JRB,async prompt(){return xaQ},isEnabled(){return!0},renderToolUseMessage:IRB,inputSchema:Wi3,outputSchema:Ki3,isConcurrencySafe(){return!1},isReadOnly(){return!1},getPath(A){return A.file_path},async checkPermissions(A,Q){let B=await Q.getAppState();return EAA(XW,A,B.toolPermissionContext)},renderToolUseRejectedMessage:XRB,renderToolUseErrorMessage:WRB,renderToolUseProgressMessage:KRB,renderToolResultMessage:VRB,async validateInput({file_path:A},Q){let B=t9(A),G=await Q.getAppState();if(SE(B,G.toolPermissionContext,"edit","deny")!==null)return{result:!1,message:"File is in a directory that is denied by your permission settings.",errorCode:1};if(!jA().existsSync(B))return{result:!0};let J=Q.readFileState.get(B);if(!J)return{result:!1,message:"File has not been read yet. Read it first before writing to it.",errorCode:2};if(J){if(ZH(B)>J.timestamp)return{result:!1,message:"File has been modified since read, either by the user or by a linter. Read it again before attempting to write it.",errorCode:3}}return{result:!0}},async call({file_path:A,content:Q},{readFileState:B,updateFileHistoryState:G},Z,Y){let J=t9(A),I=Ji3(J),X=jA();await Db.beforeFileEdited(J);let W=X.existsSync(J);if(W){let F=ZH(J),C=B.get(J);if(!C||F>C.timestamp)throw Error("File has been unexpectedly modified. Read it again before attempting to write it.")}let K=W?LD(J):"utf-8",V=W?X.readFileSync(J,{encoding:K}):null;if(o7())await gGA(G,J,Y.uuid);let E=W?DAA(J):await HRB();X.mkdirSync(I),tGA(J,Q,K,E);let D=SGA();if(D)ptA(`file://${J}`),D.changeFile(J,Q).catch((F)=>{f(`LSP: Failed to notify server of file change for ${J}: ${F.message}`),s(F)}),D.saveFile(J).catch((F)=>{f(`LSP: Failed to notify server of file save for ${J}: ${F.message}`),s(F)});if(B.set(J,{content:Q,timestamp:ZH(J),offset:void 0,limit:void 0}),J.endsWith(`${Ii3}CLAUDE.md`))r("tengu_write_claudemd",{});if(V){let F=zw({filePath:A,fileContents:V,edits:[{old_string:V,new_string:Q,replace_all:!1}]}),C={type:"update",filePath:A,content:Q,structuredPatch:F,originalFile:V};return VwA(F),kS({operation:"write",tool:"FileWriteTool",filePath:J,type:"update"}),{data:C}}let H={type:"create",filePath:A,content:Q,structuredPatch:[],originalFile:null};return VwA([],Q),kS({operation:"write",tool:"FileWriteTool",filePath:J,type:"create"}),{data:H}},mapToolResultToToolResultBlockParam({filePath:A,content:Q,type:B},G){switch(B){case"create":return{tool_use_id:G,type:"tool_result",content:`File created successfully at: ${A}`};case"update":return{tool_use_id:G,type:"tool_result",content:`The file ${A} has been updated. Here's the result of running \`cat -n\` on a snippet of the edited file:
bundles/ClaudeCodeCode/cli.js:1146:... [${G} lines truncated] ...`}function Oa1(A,Q,B=0){if(Q===void 0)return A.slice(B);return A.slice(B,B+Q)}function Ra1(A){let Q=r1(),B=$i3(Q,A);return B.startsWith("..")?A:B}function _a1(A,Q){if(!A&&!Q)return"";return`limit: ${A}, offset: ${Q??0}`}var wi3,La1=20000,Ni3,qi3,Gx;var rNA=L(()=>{z2();pB();OZ();xj();uR();cY();XQ();qRB();HAA();wi3=P.strictObject({pattern:P.string().describe("The regular expression pattern to search for in file contents"),path:P.string().optional().describe("File or directory to search in (rg PATH). Defaults to current working directory."),glob:P.string().optional().describe('Glob pattern to filter files (e.g. "*.js", "*.{ts,tsx}") - maps to rg --glob'),output_mode:P.enum(["content","files_with_matches","count"]).optional().describe('Output mode: "content" shows matching lines (supports -A/-B/-C context, -n line numbers, head_limit), "files_with_matches" shows file paths (supports head_limit), "count" shows match counts (supports head_limit). Defaults to "files_with_matches".'),"-B":P.number().optional().describe('Number of lines to show before each match (rg -B). Requires output_mode: "content", ignored otherwise.'),"-A":P.number().optional().describe('Number of lines to show after each match (rg -A). Requires output_mode: "content", ignored otherwise.'),"-C":P.number().optional().describe('Number of lines to show before and after each match (rg -C). Requires output_mode: "content", ignored otherwise.'),"-n":P.boolean().optional().describe('Show line numbers in output (rg -n). Requires output_mode: "content", ignored otherwise. Defaults to true.'),"-i":P.boolean().optional().describe("Case insensitive search (rg -i)"),type:P.string().optional().describe("File type to search (rg --type). Common types: js, py, rust, go, java, etc. More efficient than include for standard file types."),head_limit:P.number().optional().describe('Limit output to first N lines/entries, equivalent to "| head -N". Works across all output modes: content (limits output lines), files_with_matches (limits file paths), count (limits count entries). Defaults to 0 (unlimited).'),offset:P.number().optional().describe('Skip first N lines/entries before applying head_limit, equivalent to "| tail -n +N | head -N". Works across all output modes. Defaults to 0.'),multiline:P.boolean().optional().describe("Enable multiline mode where . matches newlines and patterns can span lines (rg -U --multiline-dotall). Default: false.")}),Ni3=[".git",".svn",".hg",".bzr"];qi3=P.object({mode:P.enum(["content","files_with_matches","count"]).optional(),numFiles:P.number(),filenames:P.array(P.string()),content:P.string().optional(),numLines:P.number().optional(),numMatches:P.number().optional(),appliedLimit:P.number().optional(),appliedOffset:P.number().optional()}),Gx={name:RJ,strict:!0,input_examples:[{pattern:"TODO",output_mode:"files_with_matches"},{pattern:"function.*export",glob:"*.ts",output_mode:"content","-n":!0},{pattern:"error","-i":!0,type:"js"}],async description(){return yy1()},userFacingName(){return"Search"},getToolUseSummary:NRB,isEnabled(){return!0},inputSchema:wi3,outputSchema:qi3,isConcurrencySafe(){return!0},isReadOnly(){return!0},getPath({path:A}){return A||r1()},async validateInput({path:A}){if(A){let Q=jA(),B=t9(A);if(!Q.existsSync(B))return{result:!1,message:`Path does not exist: ${A}`,errorCode:1}}return{result:!0}},async checkPermissions(A,Q){let B=await Q.getAppState();return Vp(Gx,A,B.toolPermissionContext)},async prompt(){return yy1()},renderToolUseMessage:CRB,renderToolUseRejectedMessage:zRB,renderToolUseErrorMessage:URB,renderToolUseProgressMessage:$RB,renderToolResultMessage:wRB,mapToolResultToToolResultBlockParam({mode:A="files_with_matches",numFiles:Q,filenames:B,content:G,numLines:Z,numMatches:Y,appliedLimit:J,appliedOffset:I},X){if(A==="content"){let E=_a1(J,I),D=Ma1(G||"No matches found"),H=E?`${D}
bundles/ClaudeCodeCode/cli.js:1152:`)}`,V=Ma1(K);return{tool_use_id:X,type:"tool_result",content:V}},async call({pattern:A,path:Q,glob:B,type:G,output_mode:Z="files_with_matches","-B":Y,"-A":J,"-C":I,"-n":X=!0,"-i":W=!1,head_limit:K,offset:V=0,multiline:E=!1},{abortController:D,getAppState:H}){let F=Q?t9(Q):r1(),C=["--hidden"];for(let x of Ni3)C.push("--glob",`!${x}`);if(C.push("--max-columns","500"),E)C.push("-U","--multiline-dotall");if(W)C.push("-i");if(Z==="files_with_matches")C.push("-l");else if(Z==="count")C.push("-c");if(X&&Z==="content")C.push("-n");if(I!==void 0&&Z==="content")C.push("-C",I.toString());else if(Z==="content"){if(Y!==void 0)C.push("-B",Y.toString());if(J!==void 0)C.push("-A",J.toString())}if(A.startsWith("-"))C.push("-e",A);else C.push(A);if(G)C.push("--type",G);if(B){let x=[],m=B.split(/\s+/);for(let g of m)if(g.includes("{")&&g.includes("}"))x.push(g);else x.push(...g.split(",").filter(Boolean));for(let g of x.filter(Boolean))C.push("--glob",g)}let U=await H(),O=eGA(AZA(U.toolPermissionContext),r1());for(let x of O){let m=x.startsWith("/")?`!${x}`:`!**/${x}`;C.push("--glob",m)}let q=await Sj(C,F,D.signal);if(Z==="content"){let x=q.map((t)=>{let p=t.indexOf(":");if(p>0){let k=t.substring(0,p),c=t.substring(p);return Ra1(k)+c}return t}),m=Oa1(x,K,V);return{data:{mode:"content",numFiles:0,filenames:[],content:m.join(`
bundles/ClaudeCodeCode/cli.js:1154:`),numMatches:g,...K!==void 0&&{appliedLimit:K},...V>0&&{appliedOffset:V}}}}let M=await Promise.all(q.map((x)=>jA().stat(x))),_=q.map((x,m)=>[x,M[m]]).sort((x,m)=>{let g=(m[1].mtimeMs??0)-(x[1].mtimeMs??0);if(g===0)return x[0].localeCompare(m[0]);return g}).map((x)=>x[0]),y=Oa1(_,K,V).map(Ra1);return{data:{mode:"files_with_matches",filenames:y,numFiles:y.length,...K!==void 0&&{appliedLimit:K},...V>0&&{appliedOffset:V}}}}}});function ORB(){return"Search"}function RRB({pattern:A,path:Q},{verbose:B}){if(!A)return null;if(!Q)return`pattern: "${A}"`;return`pattern: "${A}", path: "${B?Q:J8(Q)}"`}function _RB(){return sNA.default.createElement(m8,null)}function TRB(A,{verbose:Q}){if(!Q&&typeof A==="string"&&Q9(A,"tool_use_error"))return sNA.default.createElement(h0,null,sNA.default.createElement(z,{color:"error"},"Error searching files"));return sNA.default.createElement(K3,{result:A,verbose:Q})}function jRB(){return null}function SRB(A){if(!A?.pattern)return null;return Q5(A.pattern,Bx)}var sNA,PRB;var xRB=L(()=>{fA();lW();DI();h4();HB();M9();rNA();sNA=o(WA(),1);PRB=Gx.renderToolResultMessage});var Li3,Mi3,ZM;var tNA=L(()=>{z2();pB();M9();cY();OZ();XQ();xRB();Li3=P.strictObject({pattern:P.string().describe("The glob pattern to match files against"),path:P.string().optional().describe('The directory to search in. If not specified, the current working directory will be used. IMPORTANT: Omit this field to use the default directory. DO NOT enter "undefined" or "null" - simply omit it for the default behavior. Must be a valid directory path if provided.')}),Mi3=P.object({durationMs:P.number().describe("Time taken to execute the search in milliseconds"),numFiles:P.number().describe("Total number of files found"),filenames:P.array(P.string()).describe("Array of file paths that match the pattern"),truncated:P.boolean().describe("Whether results were truncated (limited to 100 files)")}),ZM={name:mW,async description(){return xy1},userFacingName:ORB,getToolUseSummary:SRB,isEnabled(){return!0},inputSchema:Li3,outputSchema:Mi3,isConcurrencySafe(){return!0},isReadOnly(){return!0},getPath({path:A}){return A?t9(A):r1()},async validateInput({path:A}){if(A){let Q=jA(),B=t9(A);if(!Q.existsSync(B))return{result:!1,message:`Directory does not exist: ${A}`,errorCode:1};if(!Q.statSync(B).isDirectory())return{result:!1,message:`Path is not a directory: ${A}`,errorCode:2}}return{result:!0}},async checkPermissions(A,Q){let B=await Q.getAppState();return Vp(ZM,A,B.toolPermissionContext)},async prompt(){return xy1},renderToolUseMessage:RRB,renderToolUseRejectedMessage:_RB,renderToolUseErrorMessage:TRB,renderToolUseProgressMessage:jRB,renderToolResultMessage:PRB,async call(A,{abortController:Q,getAppState:B}){let G=Date.now(),Z=await B(),{files:Y,truncated:J}=await yRB(A.pattern,ZM.getPath(A),{limit:100,offset:0},Q.signal,Z.toolPermissionContext);return{data:{filenames:Y,durationMs:Date.now()-G,numFiles:Y.length,truncated:J}}},mapToolResultToToolResultBlockParam(A,Q){if(A.filenames.length===0)return{tool_use_id:Q,type:"tool_result",content:"No files found"};return{tool_use_id:Q,type:"tool_result",content:[...A.filenames,...A.truncated?["(Results are truncated. Consider using a more specific path or pattern.)"]:[]].join(`
bundles/ClaudeCodeCode/cli.js:1501:</bash-notification>`;m_({value:J,mode:"bash-notification"},Z),VW(A,Z,(I)=>({...I,notified:!0}))}function b_B(A,Q){VW(A,Q,(B)=>{if(B.status!=="running"||!Xo1(B))return B;try{f(`LocalBashTask ${A} kill requested`),B.shellCommand?.kill()}catch(G){s(G instanceof Error?G:Error(String(G)))}if(B.unregisterCleanup?.(),B.cleanupTimeoutId)clearTimeout(B.cleanupTimeoutId);return{...B,status:"killed",shellCommand:null,unregisterCleanup:void 0,cleanupTimeoutId:void 0,endTime:Date.now()}})}var kb,Vl;var DqA=L(()=>{fA();EqA();bW();h1();Y0();d_();RAA();WM();kb=o(WA(),1);Vl={name:"LocalBashTask",type:"local_bash",async spawn(A,Q){let{command:B,description:G,shellCommand:Z}=A,{setAppState:Y}=Q,J=AA1("local_bash");yb(J);let I=U8(async()=>{b_B(J,Y)}),X={...vb(J,"local_bash",G),type:"local_bash",status:"running",command:B,completionStatusSentInAttachment:!1,shellCommand:Z,unregisterCleanup:I,stdoutLineCount:0,stderrLineCount:0,lastReportedStdoutLines:0,lastReportedStderrLines:0};fb(X,Y);let W=Z.background(J);if(!W)return VW(J,Y,(K)=>({...K,status:"failed",result:{code:1,interrupted:!1},endTime:Date.now()})),Io1(J,G,"failed",1,Y),{taskId:J};return W.stdoutStream.on("data",(K)=>{let V=K.toString();xb(J,V);let E=V.split(`
bundles/ClaudeCodeCode/cli.js:1503:`).filter((D)=>D.length>0).length;VW(J,Y,(D)=>({...D,stderrLineCount:D.stderrLineCount+E}))}),Z.result.then((K)=>{let V=!1;if(VW(J,Y,(E)=>{if(E.status==="killed")return V=!0,E;return{...E,status:K.code===0?"completed":"failed",result:{code:K.code,interrupted:K.interrupted},shellCommand:null,unregisterCleanup:void 0,endTime:Date.now()}}),V)Io1(J,G,"killed",K.code,Y);else{let E=K.code===0?"completed":"failed";Io1(J,G,E,K.code,Y)}}),{taskId:J,cleanup:()=>{I()}}},async kill(A,Q){b_B(A,Q.setAppState)},renderStatus(A){if(!Xo1(A))return null;let{status:Q,command:B}=A;return kb.createElement(j,null,kb.createElement(z,{color:Q==="running"?"warning":Q==="completed"?"success":Q==="failed"?"error":"inactive"},"[",Q,"] ",B))},renderOutput(A){return kb.createElement(j,null,kb.createElement(z,null,A))},getProgressMessage(A){if(!Xo1(A))return null;let Q=A.stdoutLineCount-A.lastReportedStdoutLines,B=A.stderrLineCount-A.lastReportedStderrLines;if(Q===0&&B===0)return null;let G=[];if(Q>0)G.push(`${Q} line${Q>1?"s":""} of stdout`);if(B>0)G.push(`${B} line${B>1?"s":""} of stderr`);return`Background bash ${A.id} has new output: ${G.join(", ")}. Read ${A.outputFile} to see output.`}}});function _AA(A,Q,B,G,Z){let Y=B==="completed"?`Agent "${Q}" completed.`:B==="failed"?`Agent "${Q}" failed: ${G||"Unknown error"}`:`Agent "${Q}" was stopped.`,J=`<agent-notification>
bundles/ClaudeCodeCode/cli.js:1517:`),{...G,status:"failed",error:Q,endTime:Date.now()}})}function Eo1({agentId:A,description:Q,prompt:B,selectedAgent:G,setAppState:Z}){yb(A);let Y=g9(),J={...vb(A,"local_agent",Q),type:"local_agent",status:"running",agentId:A,prompt:B,selectedAgent:G,agentType:G.agentType??"general-purpose",abortController:Y,retrieved:!1,lastReportedToolCount:0,lastReportedTokenCount:0},I=U8(async()=>{HZA(A,Z)});return J.unregisterCleanup=I,fb(J,Z),J}var bb,QA1;var BA1=L(()=>{fA();EqA();LZ();bW();d_();RAA();WM();bb=o(WA(),1);QA1={name:"LocalAgentTask",type:"local_agent",async spawn(A,Q){let{prompt:B,description:G,agentType:Z,model:Y,selectedAgent:J,agentId:I}=A,{setAppState:X}=Q,W=I??AA1("local_agent");yb(W);let K=g9(),V={...vb(W,"local_agent",G),type:"local_agent",status:"running",agentId:W,prompt:B,selectedAgent:J,agentType:Z,model:Y,abortController:K,retrieved:!1,lastReportedToolCount:0,lastReportedTokenCount:0},E=U8(async()=>{HZA(W,X)});return V.unregisterCleanup=E,fb(V,X),{taskId:W,cleanup:()=>{E(),K.abort()}}},async kill(A,Q){HZA(A,Q.setAppState)},renderStatus(A){let Q=A,B=Q.status,G=Q.description,Z=Q.progress,Y=B==="running"?"warning":B==="completed"?"success":B==="failed"?"error":"inactive",J=Z?` (${Z.toolUseCount} tools, ${Z.tokenCount} tokens)`:"";return bb.createElement(j,null,bb.createElement(z,{color:Y},"[",B,"] ",G,J))},renderOutput(A){return bb.createElement(j,null,bb.createElement(z,null,A))},getProgressMessage(A){let Q=A,B=Q.progress;if(!B)return null;let G=B.toolUseCount-Q.lastReportedToolCount,Z=B.tokenCount-Q.lastReportedTokenCount;if(G===0&&Z===0)return null;let Y=[];if(G>0)Y.push(`${G} new tool${G>1?"s":""} used`);if(Z>0)Y.push(`${Z} new tokens`);return`Agent ${A.id} progress: ${Y.join(", ")}. Read ${A.outputFile} to see full output.`}}});import{spawn as Qa3}from"node:child_process";function Ba3(A,Q,B){return{type:"callback",timeout:B,callback:async(G,Z,Y,J)=>{let I=A.replace(/\$\{CLAUDE_PLUGIN_ROOT\}/g,Q),X={...process.env,CLAUDE_PLUGIN_ROOT:Q,CLAUDE_PROJECT_DIR:pQ()};if(G.hook_event_name==="SessionStart"&&J!==void 0)X.CLAUDE_ENV_FILE=PmA(J);let W=JSON.stringify(G),K=Qa3(I,[],{env:X,shell:!0,signal:Y}),V="",E="";K.stdout.on("data",(H)=>{V+=H.toString()}),K.stderr.on("data",(H)=>{E+=H.toString()}),K.stdin.on("error",(H)=>{f(`Plugin hook stdin error for "${I}": ${H.message}`)}),K.stdin.write(W),K.stdin.end();let D;try{D=await new Promise((H,F)=>{K.on("close",(C)=>{H(C??1)}),K.on("error",F)})}catch(H){let F=H instanceof Error?H.message:String(H);return s(Error(`Plugin hook "${I}" failed to execute: ${F}`)),f(`Plugin hook spawn error: ${F}`),{suppressOutput:!1,systemMessage:`Plugin hook "${I}" failed to start: ${F}. Check that the command exists and is executable.`}}try{let H=V.trim();if(H.startsWith("{"))return JSON.parse(H)}catch(H){f(`Plugin hook "${I}" produced invalid JSON output: ${H instanceof Error?H.message:String(H)}. Falling back to exit code handling.`)}if(D===0)return{suppressOutput:!1};else if(D===2){let H=E.trim(),F=V.trim();return{decision:"block",reason:H?H:F?`Hook blocked with message: ${F}`:`Plugin hook "${I}" blocked this action (exit code 2) but provided no reason.`}}else{let H=E.trim(),F=V.trim(),C=[`Plugin hook "${I}" failed with exit code ${D}`];if(H)C.push(`stderr: ${H}`);if(F)C.push(`stdout: ${F}`);let U=C.join(`
bundles/ClaudeCodeCode/cli.js:1632:New messages: ${JSON.stringify(A)}`,signal:new AbortController().signal,options:{querySource:"background_task_summarize_delta",agents:[],isNonInteractiveSession:!1,hasAppendSystemPrompt:!1,mcpTools:[],agentIdOrSessionId:W0()}}),G=X1A(B);if(!G)return null;return Q9(G,"summary")}catch(B){return s(B instanceof Error?B:Error(String(B))),null}}function LI8(A,Q){let B=!0,G=1000,Z=async()=>{if(!B)return;try{let J=(await Q.getAppState()).tasks?.[A];if(!J||J.status!=="running")return;let I=await ZMA(J.sessionId),X=I.log.find((E)=>E.type==="result"),W=X?X.subtype==="success"?"completed":"failed":I.log.length>0?"running":"starting",K=I.log.slice(J.log.length),V=null;if(K.length>0){let E=J.deltaSummarySinceLastFlushToAttachment;V=await qI8(K,E);let D=K.map((H)=>{if(H.type==="assistant")return H.message.content.filter((F)=>F.type==="text").map((F)=>("text"in F)?F.text:"").join(`
bundles/ClaudeCodeCode/cli.js:1635:`)}if(VW(A,Q.setAppState,(E)=>({...E,status:W==="starting"?"running":W,log:I.log,todoList:NI8(I.log),deltaSummarySinceLastFlushToAttachment:V,endTime:X?Date.now():void 0})),X){let E=X.subtype==="success"?"completed":"failed";wI8(A,J.title,E,Q.setAppState);return}}catch(Y){s(Y instanceof Error?Y:Error(String(Y)))}if(B)setTimeout(Z,G)};return Z(),()=>{B=!1}}function UrB(A){return`https://claude.ai/code/${A}`}function $rB(A){return`claude --teleport ${A}`}var Bh,zrB;var W10=L(()=>{fA();EqA();h1();Y0();d_();RAA();WM();I1A();RG();HB();g0();cs();HrB();Bh=o(WA(),1);zrB={name:"RemoteAgentTask",type:"remote_agent",async spawn(A,Q){let{command:B,title:G}=A,{setAppState:Z,abortController:Y}=Q;f(`RemoteAgentTask spawning: ${G}`);let J=await YMA({initialMessage:B,description:G,signal:Y.signal});if(!J)throw Error("Failed to create remote session");let I=J.id,X=`r${I.substring(0,6)}`;yb(X);let W={...vb(X,"remote_agent",G),type:"remote_agent",status:"running",sessionId:I,command:B,title:J.title||G,todoList:[],log:[],deltaSummarySinceLastFlushToAttachment:null};fb(W,Z);let K=LI8(X,Q);return{taskId:X,cleanup:()=>{K()}}},async kill(A,Q){VW(A,Q.setAppState,(B)=>{if(B.status!=="running")return B;return{...B,status:"killed",endTime:Date.now()}}),f(`RemoteAgentTask ${A} marked as killed (local only)`)},renderStatus(A){let Q=A,B=Q.status,G=Q.title;return Bh.createElement(j,null,Bh.createElement(z,{color:B==="running"?"warning":B==="completed"?"success":B==="failed"?"error":"inactive"},"[",B,"] ",G))},renderOutput(A){return Bh.createElement(j,null,Bh.createElement(z,null,A))},getProgressMessage(A){let B=A.deltaSummarySinceLastFlushToAttachment;if(!B)return null;return`Remote task ${A.id} progress: ${B}. Read ${A.outputFile} to see full output.`}}});function MI8(){return[Vl,QA1,zrB]}function wrB(A){return MI8().find((Q)=>Q.type===A)}var NrB=L(()=>{DqA();BA1();W10()});function VW(A,Q,B){Q((G)=>{let Z=G.tasks?.[A];if(!Z)return G;return{...G,tasks:{...G.tasks,[A]:B(Z)}}})}function fb(A,Q){Q((B)=>({...B,tasks:{...B.tasks,[A.id]:A}}))}function qrB(A){if(A.type==="local_bash"){let Q=A;return{...Q,lastReportedStdoutLines:Q.stdoutLineCount,lastReportedStderrLines:Q.stderrLineCount}}if(A.type==="local_agent"){let Q=A;return{...Q,lastReportedToolCount:Q.progress?.toolUseCount??0,lastReportedTokenCount:Q.progress?.tokenCount??0}}return A}function LrB(A){let Q=[],B=[],G={},Z=A.tasks??{};for(let Y of Object.values(Z)){if(Y.notified&&Y.status!=="running")continue;let J=null;if(Y.status==="running"){let I=Jo1(Y.id,Y.outputOffset);if(I.content)J=I.content,G[Y.id]={...Y,outputOffset:I.newOffset};let W=wrB(Y.type)?.getProgressMessage(Y)??null;if(W)B.push({type:"task_progress",taskId:Y.id,taskType:Y.type,message:W})}if(Y.status!=="running"&&Y.status!=="pending"&&!Y.notified){let I=Jo1(Y.id,Y.outputOffset);if(I.content)J=I.content;Q.push({type:"task_status",taskId:Y.id,taskType:Y.type,status:Y.status,description:Y.description,deltaSummary:J}),G[Y.id]={...G[Y.id]??Y,notified:!0,outputOffset:I.newOffset}}}return{attachments:Q,progressAttachments:B,updatedTasks:G}}var RAA=L(()=>{WM();d_();NrB()});import{join as MrB}from"path";async function OrB(A,Q,B){if(B!=="repl_main_thread")return[];return[]}var OI8=1e4,RI8=300,K10;var RrB=L(()=>{rQ();g0();yL();XQ();h1();J4();K10=MrB(mQ(),"session-memory")});function _rB({processId:A,asyncResponse:Q,hookName:B,hookEvent:G,command:Z,shellCommand:Y,toolName:J}){let I=Q.asyncTimeout||15000;f(`Hooks: Registering async hook ${A} (${B}) with timeout ${I}ms`),Gh.set(A,{processId:A,hookName:B,hookEvent:G,toolName:J,command:Z,startTime:Date.now(),timeout:I,stdout:"",stderr:"",responseAttachmentSent:!1,shellCommand:Y})}function TrB(A,Q){let B=Gh.get(A);if(B)f(`Hooks: Adding stdout to ${A}: ${Q.substring(0,50)}...`),B.stdout+=Q;else f(`Hooks: Attempted to add output to unknown process ${A}`)}function jrB(A,Q){let B=Gh.get(A);if(B)f(`Hooks: Adding stderr to ${A}: ${Q.substring(0,50)}...`),B.stderr+=Q;else f(`Hooks: Attempted to add stderr to unknown process ${A}`)}async function PrB(){let A=[],Q=Gh.size;f(`Hooks: Found ${Q} total hooks in registry`);let B=[];for(let G of Gh.values()){if(f(`Hooks: Checking hook ${G.processId} (${G.hookName}) - attachmentSent: ${G.responseAttachmentSent}, stdout length: ${G.stdout.length}`),!G.shellCommand){f(`Hooks: Hook ${G.processId} has no shell command, removing from registry`),B.push(G.processId);continue}if(f(`Hooks: Hook shell status ${G.shellCommand.status}`),G.shellCommand.status==="killed"){f(`Hooks: Hook ${G.processId} is ${G.shellCommand.status}, removing from registry`),B.push(G.processId);continue}if(G.shellCommand.status!=="completed")continue;if(G.responseAttachmentSent||!G.stdout.trim()){f(`Hooks: Skipping hook ${G.processId} - already delivered/sent or no stdout`),B.push(G.processId);continue}let Z=G.stdout.split(`
bundles/ClaudeCodeCode/cli.js:1640:`)}function krB(A){return{type:"permission_request",requestId:A.requestId,workerId:A.workerId,workerName:A.workerName,workerColor:A.workerColor,toolName:A.toolName,toolUseId:A.toolUseId,description:A.description,input:A.input,permissionSuggestions:A.permissionSuggestions||[],createdAt:Date.now()}}function frB(A){return{type:"permission_response",requestId:A.requestId,decision:A.decision,timestamp:new Date().toISOString(),feedback:A.feedback,updatedInput:A.updatedInput,permissionUpdates:A.permissionUpdates}}function C10(A){try{let Q=JSON.parse(A);if(Q&&Q.type==="permission_request")return Q}catch{}return null}function z10(A){try{let Q=JSON.parse(A);if(Q&&Q.type==="permission_response")return Q}catch{}return null}function brB(A){return{type:"sandbox_permission_request",requestId:A.requestId,workerId:A.workerId,workerName:A.workerName,workerColor:A.workerColor,hostPattern:{host:A.host},createdAt:Date.now()}}function hrB(A){return{type:"sandbox_permission_response",requestId:A.requestId,host:A.host,allow:A.allow,timestamp:new Date().toISOString()}}function U10(A){try{let Q=JSON.parse(A);if(Q&&Q.type==="sandbox_permission_request")return Q}catch{}return null}function $10(A){try{let Q=JSON.parse(A);if(Q&&Q.type==="sandbox_permission_response")return Q}catch{}return null}var D10;var Zh=L(()=>{h1();Y0();D10=o(Gm(),1)});import{dirname as w10,parse as grB,resolve as jI8}from"path";import{randomUUID as PI8}from"node:crypto";async function vI8(A,Q,B,G,Z,Y){if(z0(process.env.CLAUDE_CODE_DISABLE_ATTACHMENTS))return[];let J=g9();setTimeout(()=>{J.abort()},1000);let I={...Q,abortController:J},X=Q.agentId===W0(),W=A?[yJ("at_mentioned_files",()=>lI8(A,I)),yJ("mcp_resources",()=>nI8(A,I)),yJ("agent_mentions",()=>Promise.resolve(iI8(A,Q.options.agentDefinitions.activeAgents)))]:[],K=await Promise.all(W),V=[yJ("changed_files",()=>aI8(I)),yJ("nested_memory",()=>oI8(I)),yJ("ultra_claude_md",async()=>mI8(Z)),yJ("plan_mode",()=>bI8(Z,Q)),yJ("plan_mode_exit",()=>Promise.resolve(hI8(Q))),yJ("todo_reminders",()=>YX8(Z,Q)),yJ("teammate_mailbox",async()=>WX8(Q)),yJ("team_context",async()=>KX8(Z??[])),yJ("critical_system_reminder",()=>Promise.resolve(gI8(Q)))],E=X?[yJ("ide_selection",async()=>dI8(B,Q)),yJ("ide_opened_file",async()=>pI8(B,Q)),yJ("output_style",async()=>Promise.resolve(uI8())),yJ("queued_commands",async()=>kI8(G)),yJ("diagnostics",async()=>BX8()),yJ("lsp_diagnostics",async()=>GX8()),yJ("unified_tasks",async()=>IX8(Q,Z)),yJ("async_hook_responses",async()=>XX8()),yJ("memory",async()=>OrB(Q,Z,Y)),yJ("token_usage",async()=>Promise.resolve(VX8(Z??[]))),yJ("budget_usd",async()=>Promise.resolve(EX8(Q.options.maxBudgetUsd)))]:[],[D,H]=await Promise.all([Promise.all(V),Promise.all(E)]);return[...K.flat(),...D.flat(),...H.flat()]}async function yJ(A,Q){let B=Date.now();try{let G=await Q(),Z=Date.now()-B,Y=G.reduce((J,I)=>{return J+JSON.stringify(I).length},0);if(Math.random()<0.05)r("tengu_attachment_compute_duration",{label:A,duration_ms:Z,attachment_size_bytes:Y,attachment_count:G.length});return G}catch(G){let Z=Date.now()-B;if(Math.random()<0.05)r("tengu_attachment_compute_duration",{label:A,duration_ms:Z,error:!0});return s(G),eN(`Attachment error in ${A}`,G),[]}}function kI8(A){if(!A)return[];return A.filter((Q)=>Q.mode==="prompt").map((Q)=>({type:"queued_command",prompt:Q.value,source_uuid:Q.uuid}))}function fI8(A){let Q=0,B=!1;for(let G=A.length-1;G>=0;G--){let Z=A[G];if(Z?.type==="assistant"){if(FQ1(Z))continue;Q++}else if(Z?.type==="attachment"&&(Z.attachment.type==="plan_mode"||Z.attachment.type==="plan_mode_reentry")){B=!0;break}}return{turnCount:Q,foundPlanModeAttachment:B}}async function bI8(A,Q){if((await Q.getAppState()).toolPermissionContext.mode!=="plan")return[];if(A&&A.length>0){let{turnCount:I,foundPlanModeAttachment:X}=fI8(A);if(X&&I<SI8.TURNS_BETWEEN_ATTACHMENTS)return[]}let Z=mF(Q.agentId),Y=dF(Q.agentId),J=[];if(gK0()&&Y!==null)J.push({type:"plan_mode_reentry",planFilePath:Z}),wj(!1);return J.push({type:"plan_mode",isSubAgent:Q.isSubAgent,planFilePath:Z,planExists:Y!==null}),J}function hI8(A){if(!uK0())return[];return Nj(!1),[{type:"plan_mode_exit",planFilePath:mF(A.agentId)}]}function gI8(A){let Q=A.criticalSystemReminder_EXPERIMENTAL;if(!Q)return[];return[{type:"critical_system_reminder",content:Q}]}function uI8(){let Q=NQ()?.outputStyle||"default";if(Q==="default")return[];return[{type:"output_style",style:Q}]}function mI8(A){return[]}async function dI8(A,Q){let B=crA(Q.options.mcpClients);if(!B||A?.lineStart===void 0||!A.text||!A.filePath)return[];let G=await Q.getAppState();if(gYA(A.filePath,G.toolPermissionContext))return[];return[{type:"selected_lines_in_ide",ideName:B,lineStart:A.lineStart,lineEnd:A.lineStart+A.lineCount-1,filename:A.filePath,content:A.text}]}function cI8(A,Q){let B=w10(jI8(A)),G=[],Z=B;while(Z!==Q&&Z!==grB(Z).root){if(Z.startsWith(Q))G.push(Z);Z=w10(Z)}G.reverse();let Y=[];Z=Q;while(Z!==grB(Z).root)Y.push(Z),Z=w10(Z);return Y.reverse(),{nestedDirs:G,cwdLevelDirs:Y}}function N10(A,Q){let B=[];for(let G of A)if(!Q.readFileState.has(G.path))B.push({type:"nested_memory",path:G.path,content:G}),Q.readFileState.set(G.path,{content:G.content,timestamp:Date.now(),offset:void 0,limit:void 0});return B}function mrB(A,Q,B){let G=[];try{if(!JT(A,B.toolPermissionContext))return G;let Z=new Set,Y=pQ(),J=$_B(A,Z);G.push(...N10(J,Q));let{nestedDirs:I,cwdLevelDirs:X}=cI8(A,Y);for(let W of I){let K=w_B(W,A,Z);G.push(...N10(K,Q))}for(let W of X){let K=N_B(W,A,Z);G.push(...N10(K,Q))}}catch(Z){s(Z)}return G}async function pI8(A,Q){if(!A?.filePath||A.text)return[];let B=await Q.getAppState();if(gYA(A.filePath,B.toolPermissionContext))return[];return[...mrB(A.filePath,Q,B),{type:"opened_file_in_ide",filename:A.filePath}]}async function lI8(A,Q){let B=rI8(A),G=await Q.getAppState();return(await Promise.all(B.map(async(Y)=>{try{let{filename:J,lineStart:I,lineEnd:X}=eI8(Y),W=t9(J);if(gYA(W,G.toolPermissionContext))return null;try{if(jA().statSync(W).isDirectory())try{let V=await Q4.call({command:`ls ${w6([W])}`,description:`Lists files in ${W}`},Q);r("tengu_at_mention_extracting_directory_success",{});let E=V.data.stdout;return{type:"directory",path:W,content:E}}catch{return null}}catch{}return await q10(W,Q,"tengu_at_mention_extracting_filename_success","tengu_at_mention_extracting_filename_error","at-mention",{offset:I,limit:X&&I?X-I+1:void 0})}catch{r("tengu_at_mention_extracting_filename_error",{})}}))).filter(Boolean)}function iI8(A,Q){let B=tI8(A);if(B.length===0)return[];return B.map((Z)=>{let Y=Z.replace("agent-",""),J=Q.find((I)=>I.agentType===Y);if(!J)return r("tengu_at_mention_agent_not_found",{}),null;return r("tengu_at_mention_agent_success",{}),{type:"agent_mention",agentType:J.agentType}}).filter((Z)=>Z!==null)}async function nI8(A,Q){let B=sI8(A);if(B.length===0)return[];let G=Q.options.mcpClients||[];return(await Promise.all(B.map(async(Y)=>{try{let[J,...I]=Y.split(":"),X=I.join(":");if(!J||!X)return r("tengu_at_mention_mcp_resource_error",{}),null;let W=G.find((E)=>E.name===J);if(!W||W.type!=="connected")return r("tengu_at_mention_mcp_resource_error",{}),null;let V=(Q.options.mcpResources?.[J]||[]).find((E)=>E.uri===X);if(!V)return r("tengu_at_mention_mcp_resource_error",{}),null;try{let E=await W.client.readResource({uri:X});return r("tengu_at_mention_mcp_resource_success",{}),{type:"mcp_resource",server:J,uri:X,name:V.name||X,description:V.description,content:E}}catch(E){return r("tengu_at_mention_mcp_resource_error",{}),s(E),null}}catch{return r("tengu_at_mention_mcp_resource_error",{}),null}}))).filter((Y)=>Y!==null)}async function aI8(A){let Q=await A.getAppState();return(await Promise.all(Yx(A.readFileState).map(async(G)=>{let Z=A.readFileState.get(G);if(!Z)return null;if(Z.offset!==void 0||Z.limit!==void 0)return null;let Y=t9(G);if(gYA(Y,Q.toolPermissionContext))return null;try{if(ZH(Y)<=Z.timestamp)return null;let J={file_path:Y};if(!(await V3.validateInput(J,A)).result)return null;let X=await V3.call(J,A);if(Y===Wl(A.agentId)){let W=jb(A.agentId);return{type:"todo",content:W,itemCount:W.length,context:"file-watch"}}if(X.data.type==="text"){if(Zo1(Z.content,X.data.file.content)==="")return null;return{type:"edited_text_file",filename:Y,snippet:Zo1(Z.content,X.data.file.content)}}if(X.data.type==="image")try{let W=await nd1(Y);return{type:"edited_image_file",filename:Y,content:W}}catch(W){return s(W),r("tengu_watched_file_compression_failed",{file:Y}),null}}catch{return r("tengu_watched_file_stat_error",{}),null}}))).filter((G)=>G!==null)}async function oI8(A){let Q=await A.getAppState(),B=[];if(A.nestedMemoryAttachmentTriggers&&A.nestedMemoryAttachmentTriggers.size>0){for(let G of A.nestedMemoryAttachmentTriggers){let Z=mrB(G,A,Q);B.push(...Z)}A.nestedMemoryAttachmentTriggers.clear()}return B}function rI8(A){let Q=/(^|\s)@"([^"]+)"/g,B=/(^|\s)@([^\s]+)\b/g,G=[],Z=[],Y;while((Y=Q.exec(A))!==null)if(Y[2])G.push(Y[2]);return(A.match(B)||[]).forEach((I)=>{let X=I.slice(I.indexOf("@")+1);if(!X.startsWith('"'))Z.push(X)}),[...new Set([...G,...Z])]}function sI8(A){let Q=/(^|\s)@([^\s]+:[^\s]+)\b/g,B=A.match(Q)||[];return[...new Set(B.map((G)=>G.slice(G.indexOf("@")+1)))]}function tI8(A){let Q=/(^|\s)@(agent-[\w:.@-]+)/g,B=A.match(Q)||[];return[...new Set(B.map((G)=>G.slice(G.indexOf("@")+1)))]}function eI8(A){let Q=A.match(/^([^#]+)(?:#L(\d+)(?:-(\d+))?)?$/);if(!Q)return{filename:A};let[,B,G,Z]=Q,Y=G?parseInt(G,10):void 0,J=Z?parseInt(Z,10):Y;return{filename:B??A,lineStart:Y,lineEnd:J}}function AX8(A){let Q=0,B=!1;for(let G=A.length-1;G>=0;G--){let Z=A[G];if(Z?.type==="attachment"&&Z.attachment.type==="ultramemory"){B=!0;break}if(Z?.type==="assistant")Q+=jWB(Z)}return B?Q:null}function QX8(A){if(!A||A.length===0)return!0;let Q=AX8(A);if(Q===null)return!0;return Q>=xI8.TOKEN_COOLDOWN}async function BX8(){let A=await Db.getNewDiagnostics();if(A.length===0)return[];return[{type:"diagnostics",files:A,isNew:!0}]}async function GX8(){f("LSP Diagnostics: getLSPDiagnosticAttachments called");try{let A=QLB();if(A.length===0)return[];f(`LSP Diagnostics: Found ${A.length} pending diagnostic set(s)`);let Q=A.map(({files:B})=>({type:"diagnostics",files:B,isNew:!0}));if(A.length>0)BLB(),f(`LSP Diagnostics: Cleared ${A.length} delivered diagnostic(s) from registry`);return f(`LSP Diagnostics: Returning ${Q.length} diagnostic attachment(s)`),Q}catch(A){let Q=A instanceof Error?A:Error(String(A));return s(Error(`Failed to get LSP diagnostic attachments: ${Q.message}`)),[]}}async function*uYA(A,Q,B,G,Z,Y){let J=await vI8(A,Q,B,G,Z,Y);if(J.length===0)return;r("tengu_attachments",{attachment_types:J.map((I)=>I.type)});for(let I of J)yield A4(I)}async function q10(A,Q,B,G,Z,Y){let{offset:J,limit:I}=Y??{},X=await Q.getAppState();if(gYA(A,X.toolPermissionContext))return null;if(Z==="at-mention"&&!joA(A))try{let K=jA().statSync(A);return r("tengu_attachment_file_too_large",{size_bytes:K.size,mode:Z}),null}catch{}let W=Q.readFileState.get(A);if(W&&Z==="at-mention")try{let K=ZH(A);if(W.timestamp<=K&&K===W.timestamp)return r(B,{}),{type:"already_read_file",filename:A,content:{type:"text",file:{filePath:A,content:W.content,numLines:W.content.split(`
bundles/ClaudeCodeCode/cli.js:1642:`).length}}}}catch{}try{let K={file_path:A,offset:J,limit:I};async function V(){if(Z==="compact")return{type:"compact_file_reference",filename:A};let D=await Q.getAppState();if(gYA(A,D.toolPermissionContext))return null;try{let H={file_path:A,offset:J??1,limit:TCA},F=await V3.call(H,Q);return r(B,{}),{type:"file",filename:A,content:F.data,truncated:!0}}catch{return r(G,{}),null}}let E=await V3.validateInput(K,Q);if(!E.result){if(E.meta?.fileSize)return await V();return null}try{let D=await V3.call(K,Q);return r(B,{}),{type:"file",filename:A,content:D.data}}catch(D){if(D instanceof _oA)return await V();throw D}}catch{return r(G,{}),null}}function A4(A){return{attachment:A,type:"attachment",uuid:PI8(),timestamp:new Date().toISOString()}}function ZX8(A){let Q=-1,B=-1,G=0,Z=0;for(let Y=A.length-1;Y>=0;Y--){let J=A[Y];if(J?.type==="assistant"){if(FQ1(J))continue;if(Q===-1)G++;if(B===-1)Z++;if(Q===-1&&"message"in J&&Array.isArray(J.message?.content)&&J.message.content.some((I)=>I.type==="tool_use"&&I.name==="TodoWrite"))Q=Y}else if(B===-1&&J?.type==="attachment"&&J.attachment.type==="todo_reminder")B=Y;if(Q!==-1&&B!==-1)break}return{turnsSinceLastTodoWrite:G,turnsSinceLastReminder:Z}}async function YX8(A,Q){if(!A||A.length===0)return[];let{turnsSinceLastTodoWrite:B,turnsSinceLastReminder:G}=ZX8(A);if(B>=urB.TURNS_SINCE_WRITE&&G>=urB.TURNS_BETWEEN_REMINDERS){let Z=jb(Q.agentId);return[{type:"todo_reminder",content:Z,itemCount:Z.length}]}return[]}function JX8(A){let Q=new Map;if(!A||A.length===0)return Q;let B=new Set,G=0;for(let Z=A.length-1;Z>=0;Z--){let Y=A[Z];if(Y?.type==="assistant"&&!FQ1(Y))G++;else if(Y?.type==="attachment"&&Y.attachment.type==="task_progress"){let J=Y.attachment.taskId;if(!B.has(J))Q.set(J,G),B.add(J)}}return Q}async function IX8(A,Q){let B=await A.getAppState(),{attachments:G,progressAttachments:Z,updatedTasks:Y}=LrB(B),J=JX8(Q),I=Z.filter((K)=>{return(J.get(K.taskId)??1/0)>=yI8});for(let K of I){let V=Y[K.taskId]??B.tasks?.[K.taskId];if(V)Y[K.taskId]=qrB(V)}if(Object.keys(Y).length>0)A.setAppState((K)=>({...K,tasks:{...K.tasks,...Y}}));let X=G.map((K)=>({type:"task_status",taskId:K.taskId,taskType:K.taskType,status:K.status,description:K.description,deltaSummary:K.deltaSummary})),W=I.map((K)=>({type:"task_progress",taskId:K.taskId,taskType:K.taskType,message:K.message}));return[...X,...W]}async function XX8(){let A=await PrB();if(A.length===0)return[];f(`Hooks: getAsyncHookResponseAttachments found ${A.length} responses`);let Q=A.map(({processId:B,response:G,hookName:Z,hookEvent:Y,toolName:J,stdout:I,stderr:X,exitCode:W})=>{return f(`Hooks: Creating attachment for ${B} (${Z}): ${JSON.stringify(G)}`),{type:"async_hook_response",processId:B,hookName:Z,hookEvent:Y,toolName:J,response:G,stdout:I,stderr:X,exitCode:W}});if(A.length>0){let B=A.map((G)=>G.processId);SrB(B),f(`Hooks: Removed ${B.length} delivered hooks from registry`)}return f(`Hooks: getAsyncHookResponseAttachments found ${Q.length} attachments`),Q}async function WX8(A){return[]}function KX8(A){let Q=process.env.CLAUDE_CODE_TEAM_NAME,B=process.env.CLAUDE_CODE_AGENT_ID,G=process.env.CLAUDE_CODE_AGENT_NAME;if(!Q||!B)return[];if(A.some((X)=>X.type==="assistant"))return[];let Y=process.env.HOME||process.env.USERPROFILE||".",J=`${Y}/.claude/teams/${Q}/config.json`,I=`${Y}/.claude/tasks/${Q}/`;return[{type:"team_context",agentId:B,agentName:G||B,teamName:Q,teamConfigPath:J,taskListPath:I}]}function VX8(A){if(!z0(process.env.CLAUDE_CODE_ENABLE_TOKEN_USAGE_ATTACHMENT))return[];let Q=mYA(),B=KW(A);return[{type:"token_usage",used:B,total:Q,remaining:Q-B}]}function EX8(A){if(A===void 0)return[];let Q=sV(),B=A-Q;return[{type:"budget_usd",used:Q,total:A,remaining:B}]}function DQ1(A){return A.attachment.type==="queued_command"}function drB(A){return A.type==="async_hook_response"&&A.hookEvent==="SessionStart"}function HQ1(A){if(A.type!=="hook_success"&&A.type!=="hook_non_blocking_error")return!1;return A.hookEvent==="SessionStart"}function gYA(A,Q){return SE(A,Q,"read","deny")!==null}var urB,SI8,xI8,yI8=3;var KM=L(()=>{T0();Cw();OZ();XQ();Kl();cF();PJ();IC();h1();yL();Y0();te();jB();OAA();QE();AV();_w();LZ();M9();cY();RAA();RrB();g0();pE();V10();PNA();Y0();HB();rQ();Rw();ol();Zh();urB={TURNS_SINCE_WRITE:7,TURNS_BETWEEN_REMINDERS:3},SI8={TURNS_BETWEEN_ATTACHMENTS:5},xI8={TOKEN_COOLDOWN:5000}});function L10(A){if(A==="Local")return"project (local)";return A.toLowerCase()}var crB;var M10=L(()=>{crB=["User","Project","Local","Managed","ExperimentalUltraClaudeMd"]});function lrB(A){let Q={toolRequests:new Map,toolResults:new Map,humanMessages:0,assistantMessages:0,localCommandOutputs:0,other:0,attachments:new Map,duplicateFileReads:new Map,total:0},B=new Map,G=new Map,Z=new Map;return A.forEach((J)=>{if(J.type==="attachment"){let I=J.attachment.type||"unknown";Q.attachments.set(I,(Q.attachments.get(I)||0)+1)}}),VY(A).forEach((J)=>{let{content:I}=J.message;if(typeof I==="string"){let X=OG(I);if(Q.total+=X,J.type==="user"&&I.includes("local-command-stdout"))Q.localCommandOutputs+=X;else Q[J.type==="user"?"humanMessages":"assistantMessages"]+=X}else I.forEach((X)=>DX8(X,J,Q,B,G,Z))}),Z.forEach((J,I)=>{if(J.count>1){let W=Math.floor(J.totalTokens/J.count)*(J.count-1);Q.duplicateFileReads.set(I,{count:J.count,tokens:W})}}),Q}function DX8(A,Q,B,G,Z,Y){let J=OG(JSON.stringify(A));switch(B.total+=J,A.type){case"text":if(Q.type==="user"&&"text"in A&&A.text.includes("local-command-stdout"))B.localCommandOutputs+=J;else B[Q.type==="user"?"humanMessages":"assistantMessages"]+=J;break;case"tool_use":{if("name"in A&&"id"in A){let I=A.name||"unknown";if(prB(B.toolRequests,I,J),G.set(A.id,I),I==="Read"&&"input"in A&&A.input&&typeof A.input==="object"&&"file_path"in A.input){let X=String(A.input.file_path);Z.set(A.id,X)}}break}case"tool_result":{if("tool_use_id"in A){let I=G.get(A.tool_use_id)||"unknown";if(prB(B.toolResults,I,J),I==="Read"){let X=Z.get(A.tool_use_id);if(X){let W=Y.get(X)||{count:0,totalTokens:0};Y.set(X,{count:W.count+1,totalTokens:W.totalTokens+J})}}}break}case"image":case"server_tool_use":case"web_search_tool_result":case"search_result":case"document":case"thinking":case"redacted_thinking":case"code_execution_tool_result":case"mcp_tool_use":case"mcp_tool_result":case"container_upload":case"web_fetch_tool_result":case"bash_code_execution_tool_result":case"text_editor_code_execution_tool_result":B.other+=J;break}}function prB(A,Q,B){A.set(Q,(A.get(Q)||0)+B)}function irB(A){let Q={total_tokens:A.total,human_message_tokens:A.humanMessages,assistant_message_tokens:A.assistantMessages,local_command_output_tokens:A.localCommandOutputs,other_tokens:A.other};A.attachments.forEach((G,Z)=>{Q[`attachment_${Z}_count`]=G}),A.toolRequests.forEach((G,Z)=>{Q[`tool_request_${Z}_tokens`]=G}),A.toolResults.forEach((G,Z)=>{Q[`tool_result_${Z}_tokens`]=G});let B=[...A.duplicateFileReads.values()].reduce((G,Z)=>G+Z.tokens,0);if(Q.duplicate_read_tokens=B,Q.duplicate_read_file_count=A.duplicateFileReads.size,A.total>0){Q.human_message_percent=Math.round(A.humanMessages/A.total*100),Q.assistant_message_percent=Math.round(A.assistantMessages/A.total*100),Q.local_command_output_percent=Math.round(A.localCommandOutputs/A.total*100),Q.duplicate_read_percent=Math.round(B/A.total*100);let G=[...A.toolRequests.values()].reduce((Y,J)=>Y+J,0),Z=[...A.toolResults.values()].reduce((Y,J)=>Y+J,0);Q.tool_request_percent=Math.round(G/A.total*100),Q.tool_result_percent=Math.round(Z/A.total*100),A.toolRequests.forEach((Y,J)=>{Q[`tool_request_${J}_percent`]=Math.round(Y/A.total*100)}),A.toolResults.forEach((Y,J)=>{Q[`tool_result_${J}_percent`]=Math.round(Y/A.total*100)})}return Q}var nrB=L(()=>{yL();HB()});async function CQ1(A,Q,B,G,Z=!1){try{if(A.length===0)throw Error(JMA);let Y=KW(A),J=lrB(A),I={};try{I=irB(J)}catch(k){s(k)}let X=await Q.getAppState();meA(X.toolPermissionContext,"summary"),Q.setSpinnerColor?.("claudeBlue_FOR_SYSTEM_SPINNER"),Q.setSpinnerShimmerColor?.("claudeBlueShimmer_FOR_SYSTEM_SPINNER"),Q.setSpinnerMessage?.("Running PreCompact hooks..."),Q.setSDKStatus?.("compacting");let W=await R10({trigger:Z?"auto":"manual",customInstructions:G??null,sessionId:Q.agentId},Q.abortController.signal);if(W.newCustomInstructions)G=G?`${G}
bundles/ClaudeCodeCode/cli.js:1644:${W.newCustomInstructions}`:W.newCustomInstructions;let K=W.userDisplayMessage;Q.setStreamMode?.("requesting"),Q.setResponseLength?.(()=>0),Q.setSpinnerMessage?.("Compacting conversation");let V=ma1(G),E=u0({content:V}),H=dYA({messages:VY([...IT(A),E]),systemPrompt:["You are a helpful AI assistant tasked with summarizing conversations."],maxThinkingTokens:0,tools:[V3],signal:Q.abortController.signal,options:{async getToolPermissionContext(){return(await Q.getAppState()).toolPermissionContext},model:g8(),toolChoice:void 0,isNonInteractiveSession:Q.options.isNonInteractiveSession,hasAppendSystemPrompt:Q.options.hasAppendSystemPrompt,maxOutputTokensOverride:yG1,querySource:"compact",agents:Q.options.agentDefinitions.activeAgents,mcpTools:[],agentIdOrSessionId:W0()}})[Symbol.asyncIterator](),F=await H.next(),C=!1,U;while(!F.done){let k=F.value;if(!C&&k.type==="stream_event"&&k.event.type==="content_block_start"&&k.event.content_block.type==="text")C=!0,Q.setStreamMode?.("responding");if(k.type==="stream_event"&&k.event.type==="content_block_delta"&&k.event.delta.type==="text_delta"){let c=k.event.delta.text.length;Q.setResponseLength?.((e)=>e+c)}if(k.type==="assistant")U=k;F=await H.next()}if(!U)throw Error("Failed to get summary response from streaming");let O=X1A(U);if(!O)throw r("tengu_compact_failed",{reason:"no_summary",preCompactTokenCount:Y}),Error("Failed to generate conversation summary - response did not contain valid text content");else if(O.startsWith(tW))throw r("tengu_compact_failed",{reason:"api_error",preCompactTokenCount:Y}),Error(O);else if(O.startsWith(JZA))throw r("tengu_compact_failed",{reason:"prompt_too_long",preCompactTokenCount:Y}),Error(zX8);let q=oRB(Q.readFileState);Q.readFileState.clear();let[M,_]=await Promise.all([$X8(q,Q,HX8),NX8(Q)]),T=[...M,..._],y=wX8(Q.agentId);if(y)T.push(y);let h=O10(Q.agentId);if(h)T.push(h);Q.setSpinnerMessage?.("Running SessionStart hooks...");let x=await WU("compact"),m=KW([U]),g=zAA(U);r("tengu_compact",{preCompactTokenCount:Y,postCompactTokenCount:m,compactionInputTokens:g?.input_tokens,compactionOutputTokens:g?.output_tokens,compactionCacheReadTokens:g?.cache_read_input_tokens??0,compactionCacheCreationTokens:g?.cache_creation_input_tokens??0,compactionTotalTokens:g?g.input_tokens+(g.cache_creation_input_tokens??0)+(g.cache_read_input_tokens??0)+g.output_tokens:0,...I});let t=zQ1(Z?"auto":"manual",Y??0),p=[u0({content:geA(O,B),isCompactSummary:!0,isVisibleInTranscriptOnly:!0})];return{boundaryMarker:t,summaryMessages:p,attachments:T,hookResults:x,userDisplayMessage:K,preCompactTokenCount:Y,postCompactTokenCount:m,compactionUsage:g}}catch(Y){throw UX8(Y,Q),Y}finally{Q.setStreamMode?.("requesting"),Q.setResponseLength?.(()=>0),Q.setSpinnerMessage?.(null),Q.setSDKStatus?.(null),Q.setSpinnerColor?.(null),Q.setSpinnerShimmerColor?.(null)}}function UX8(A,Q){if(!yKA(A,IMA)&&!yKA(A,JMA))Q.addNotification?.({key:"error-compacting-conversation",text:"Error compacting conversation",priority:"immediate",color:"error"})}async function $X8(A,Q,B){let G=Object.entries(A).map(([J,I])=>({filename:J,...I})).filter((J)=>!qX8(J.filename,Q.agentId)).sort((J,I)=>I.timestamp-J.timestamp).slice(0,B),Z=await Promise.all(G.map(async(J)=>{let I=await q10(J.filename,{...Q,fileReadingLimits:{maxTokens:CX8}},"tengu_post_compact_file_restore_success","tengu_post_compact_file_restore_error","compact");return I?A4(I):null})),Y=0;return Z.filter((J)=>{if(J===null)return!1;let I=OG(JSON.stringify(J));if(Y+I<=FX8)return Y+=I,!0;return!1})}function wX8(A){let Q=jb(A);if(Q.length===0)return null;return A4({type:"todo",content:Q,itemCount:Q.length,context:"post-compact"})}function O10(A){let Q=dF(A);if(!Q)return null;let B=mF(A);return A4({type:"plan_file_reference",planFilePath:B,planContent:Q})}async function NX8(A){let Q=await A.getAppState();return Object.values(Q.tasks).filter((G)=>G.type==="local_agent").flatMap((G)=>{if(G.retrieved)return[];let{status:Z}=G;if(Z==="completed"||Z==="failed"||Z==="killed")return[A4({type:"task_status",taskId:G.agentId,taskType:"local_agent",description:G.description,status:Z,deltaSummary:G.error??null})];return[]})}function qX8(A,Q){let B=Kp(A);try{let G=Kp(Wl(Q));if(B===G)return!0}catch{}try{let G=Kp(mF(Q));if(B===G)return!0}catch{}try{if(new Set(crB.map((Z)=>Kp(NAA(Z)))).has(B))return!0}catch{}return!1}var HX8=5,FX8=50000,CX8=5000,JMA="Not enough messages to compact.",zX8="Conversation too long. Press esc twice to go up a few messages and try again.",IMA="API Error: Request was aborted.";var XMA=L(()=>{RG();JM();HB();T0();eZ();Rw();Cw();_w();da1();l2();KM();Kl();xQ();cF();M9();M10();yL();nrB();h1();Tw();TAA();g0()});function trB(){return arB}function erB(A){arB=A}function AsB(){UQ1=Date.now()}function QsB(){UQ1=void 0}async function BsB(){let A=Date.now();while(UQ1){if(Date.now()-UQ1>MX8)return;if(Date.now()-A>LX8)return;await new Promise((B)=>setTimeout(B,1000))}}function GsB(){let A=jA(),Q=$Q1();if(!A.existsSync(Q))return null;return A.readFileSync(Q,{encoding:"utf-8"})}function ZsB(A){cYA={...cYA,...A}}function YsB(){return{...cYA}}function JsB(A){_10+=A}function IsB(A){orB+=A}function XsB(){rrB=_10}function WsB(){return srB}function KsB(){srB=!0}function VsB(){return orB>=cYA.minimumMessageTokensToInit}function EsB(){return _10-rrB>=cYA.minimumTokensBetweenUpdate}function DsB(){return cYA.toolCallsBetweenUpdates}var LX8=15000,MX8=60000,WMA,cYA,arB,UQ1,_10=0,orB=0,rrB=0,srB=!1;var T10=L(()=>{XQ();cY();WMA={minimumMessageTokensToInit:1e4,minimumTokensBetweenUpdate:5000,toolCallsBetweenUpdates:3},cYA={...WMA}});function OX8(A){return typeof A==="string"&&(A===wa1||A.includes(LeA))}function PX8(A,Q){if(!Q.some((G)=>G.type==="assistant")&&!S10.has(A)){if(b7("cc_microcompact_ext","mc_disabled",!1))S10.add(A)}return S10.has(A)}function CsB(A){if(!A.content)return 0;if(typeof A.content==="string")return OG(A.content);return A.content.reduce((Q,B)=>{if(B.type==="text")return Q+OG(B.text);else if(B.type==="image")return Q+FsB;return Q},0)}function SX8(A,Q){let B=HsB.get(A);if(B===void 0)B=CsB(Q),HsB.set(A,B);return B}function x10(A){let Q=0;for(let B of A){if(B.type!=="user"&&B.type!=="assistant")continue;if(!Array.isArray(B.message.content))continue;for(let G of B.message.content)if(G.type==="text")Q+=OG(G.text);else if(G.type==="tool_result")Q+=CsB(G);else if(G.type==="image")Q+=FsB;else Q+=OG(JSON.stringify(G))}return Math.ceil(Q*1.3333333333333333)}function xX8(A){return wQ1.push(A),()=>{wQ1=wQ1.filter((Q)=>Q!==A)}}function yX8(){wQ1.forEach((A)=>A())}async function Yh(A,Q,B){if(NQ1=!1,z0(process.env.DISABLE_MICROCOMPACT))return{messages:A};if(PX8(W0(),A))return{messages:A};z0(process.env.USE_API_CONTEXT_MANAGEMENT);let G=Q!==void 0,Z=G?Q:_X8,Y=[],J=new Map;for(let D of A)if((D.type==="user"||D.type==="assistant")&&Array.isArray(D.message.content)){for(let H of D.message.content)if(H.type==="tool_use"&&jX8.has(H.name)){if(!j10.has(H.id))Y.push(H.id)}else if(H.type==="tool_result"&&Y.includes(H.tool_use_id)){let F=SX8(H.tool_use_id,H);J.set(H.tool_use_id,F)}}let I=Y.slice(-TX8),X=Array.from(J.values()).reduce((D,H)=>D+H,0),W=0,K=new Set;for(let D of Y){if(I.includes(D))continue;if(X-W>Z)K.add(D),W+=J.get(D)||0}if(!G){let D=KW(A);if(!V1A(D).isAboveWarningThreshold||W<RX8)K.clear(),W=0}let V=(D)=>{return j10.has(D)||K.has(D)};if(K.size>0,K.size>0)A.filter((H)=>H&&H.type==="attachment"&&H.attachment.type==="memory"&&!P10.has(H.uuid)).map((H)=>({uuid:H.uuid})).forEach((H)=>P10.add(H.uuid));let E=[];for(let D of A){if(D.type==="attachment"&&P10.has(D.uuid))continue;if(D.type!=="user"&&D.type!=="assistant"){E.push(D);continue}if(!Array.isArray(D.message.content)){E.push(D);continue}if(D.type==="user"){let H=[],F=!1;for(let C of D.message.content)if(C.type==="tool_result"&&V(C.tool_use_id)&&C.content&&!OX8(C.content)){F=!0;let U=wa1;if(await JZ("tengu_compact_mc_files")){let O=await Na1(C.content,C.tool_use_id);if(!qa1(O))U=`${LeA}Tool result saved to: ${O.filepath}
bundles/ClaudeCodeCode/cli.js:1667:`)[0]??null,style:Y,verbose:J})}catch(I){return s(I),vJ.createElement(h0,{height:1},vJ.createElement(z,null,"(No changes)"))}}function LtB(A,Q){let{verbose:B}=Q;if(!B&&typeof A==="string"&&Q9(A,"tool_use_error")){if(Q9(A,"tool_use_error")?.includes("File has not been read yet"))return vJ.createElement(h0,null,vJ.createElement(z,{dimColor:!0},"File must be read first"));return vJ.createElement(h0,null,vJ.createElement(z,{color:"error"},"Error editing file"))}return vJ.createElement(K3,{result:A,verbose:B})}var vJ;var MtB=L(()=>{fA();hn1();DI();CtB();h4();M9();HB();OAA();XQ();h1();cF();vJ=o(WA(),1)});import{dirname as tX8,isAbsolute as vQ1,resolve as eX8,sep as AW8}from"path";var lE;var rl=L(()=>{T0();J4();MoA();M9();pB();g0();ef();OsB();OAA();cY();OZ();XQ();te();SNA();PNA();h1();Y0();qn1();HtB();JU();MtB();lE={name:m3,strict:!0,async description(){return"A tool for editing files"},async prompt(){return MsB},userFacingName:ztB,getToolUseSummary:UtB,isEnabled(){return!0},inputSchema:ILB,outputSchema:XLB,isConcurrencySafe(){return!1},isReadOnly(){return!1},getPath(A){return A.file_path},async checkPermissions(A,Q){let B=await Q.getAppState();return EAA(lE,A,B.toolPermissionContext)},renderToolUseMessage:$tB,renderToolUseProgressMessage:wtB,renderToolResultMessage:NtB,renderToolUseRejectedMessage:qtB,renderToolUseErrorMessage:LtB,async validateInput({file_path:A,old_string:Q,new_string:B,replace_all:G=!1},Z){if(Q===B)return{result:!1,behavior:"ask",message:"No changes to make: old_string and new_string are exactly the same.",errorCode:1};let Y=vQ1(A)?A:eX8(r1(),A),J=await Z.getAppState();if(SE(Y,J.toolPermissionContext,"edit","deny")!==null)return{result:!1,behavior:"ask",message:"File is in a directory that is denied by your permission settings.",errorCode:2};let X=jA();if(X.existsSync(Y)&&Q===""){if(X.readFileSync(Y,{encoding:LD(Y)}).replaceAll(`\r
bundles/ClaudeCodeCode/cli.js:1674:${Ep({content:W,startLine:K})}`}}}});var OtB="Replace the contents of a specific cell in a Jupyter notebook.",RtB="Completely replaces the contents of a specific cell in a Jupyter notebook (.ipynb file) with new source. Jupyter notebooks are interactive documents that combine code, text, and visualizations, commonly used for data analysis and scientific computing. The notebook_path parameter must be an absolute path, not a relative path. The cell_number is 0-indexed. Use edit_mode=insert to add a new cell at the index specified by cell_number. Use edit_mode=delete to delete the cell at the index specified by cell_number.";import{relative as QW8}from"path";function _tB({notebook_path:A,cell_id:Q,new_source:B,cell_type:G,edit_mode:Z="replace",verbose:Y}){let J=Z==="delete"?"delete":`${Z} cell in`;return iE.createElement(h0,null,iE.createElement(j,{flexDirection:"column"},iE.createElement(j,{flexDirection:"row"},iE.createElement(z,{color:"error"},"User rejected ",J," "),iE.createElement(z,{bold:!0,color:"error"},Y?A:QW8(r1(),A)),iE.createElement(z,{color:"error"}," at cell ",Q)),Z!=="delete"&&iE.createElement(j,{marginTop:1,flexDirection:"column"},iE.createElement(GM,{code:B,filePath:G==="markdown"?"file.md":"file.py",dim:!0}))))}var iE;var TtB=L(()=>{fA();pB();h4();sGA();iE=o(WA(),1)});function jtB(A){if(!A?.notebook_path)return null;return J8(A.notebook_path)}function PtB({notebook_path:A,cell_id:Q,new_source:B,cell_type:G,edit_mode:Z},{verbose:Y}){if(!A||!B||!G)return null;if(Y)return`${A}@${Q}, content: ${B.slice(0,30)}‚Ä¶, cell_type: ${G}, edit_mode: ${Z??"replace"}`;return`${J8(A)}@${Q}`}function StB(A,{verbose:Q}){return FY.createElement(_tB,{notebook_path:A.notebook_path,cell_id:A.cell_id,new_source:A.new_source,cell_type:A.cell_type,edit_mode:A.edit_mode,verbose:Q})}function xtB(A,{verbose:Q}){if(!Q&&typeof A==="string"&&Q9(A,"tool_use_error"))return FY.createElement(h0,null,FY.createElement(z,{color:"error"},"Error editing notebook"));return FY.createElement(K3,{result:A,verbose:Q})}function ytB(){return null}function vtB({cell_id:A,new_source:Q,error:B}){if(B)return FY.createElement(h0,null,FY.createElement(z,{color:"error"},B));return FY.createElement(h0,null,FY.createElement(j,{flexDirection:"column"},FY.createElement(z,null,"Updated cell ",FY.createElement(z,{bold:!0},A),":"),FY.createElement(j,{marginLeft:2},FY.createElement(GM,{code:Q,filePath:"notebook.py"}))))}var FY;var ktB=L(()=>{fA();sGA();TtB();h4();DI();HB();M9();FY=o(WA(),1)});import{extname as BW8,isAbsolute as ftB,resolve as btB}from"path";var GW8,ZW8,KT;var pYA=L(()=>{z2();vpA();M9();uI();pB();cY();XQ();JU();ktB();GW8=P.strictObject({notebook_path:P.string().describe("The absolute path to the Jupyter notebook file to edit (must be absolute, not relative)"),cell_id:P.string().optional().describe("The ID of the cell to edit. When inserting a new cell, the new cell will be inserted after the cell with this ID, or at the beginning if not specified."),new_source:P.string().describe("The new source for the cell"),cell_type:P.enum(["code","markdown"]).optional().describe("The type of the cell (code or markdown). If not specified, it defaults to the current cell type. If using edit_mode=insert, this is required."),edit_mode:P.enum(["replace","insert","delete"]).optional().describe("The type of edit to make (replace, insert, delete). Defaults to replace.")}),ZW8=P.object({new_source:P.string().describe("The new source code that was written to the cell"),cell_id:P.string().optional().describe("The ID of the cell that was edited"),cell_type:P.enum(["code","markdown"]).describe("The type of the cell"),language:P.string().describe("The programming language of the notebook"),edit_mode:P.string().describe("The edit mode that was used"),error:P.string().optional().describe("Error message if the operation failed")}),KT={name:IS,async description(){return OtB},async prompt(){return RtB},userFacingName(){return"Edit Notebook"},getToolUseSummary:jtB,isEnabled(){return!0},inputSchema:GW8,outputSchema:ZW8,isConcurrencySafe(){return!1},isReadOnly(){return!1},getPath(A){return A.notebook_path},async checkPermissions(A,Q){let B=await Q.getAppState();return EAA(KT,A,B.toolPermissionContext)},mapToolResultToToolResultBlockParam({cell_id:A,edit_mode:Q,new_source:B,error:G},Z){if(G)return{tool_use_id:Z,type:"tool_result",content:G,is_error:!0};switch(Q){case"replace":return{tool_use_id:Z,type:"tool_result",content:`Updated cell ${A} with ${B}`};case"insert":return{tool_use_id:Z,type:"tool_result",content:`Inserted cell ${A} with ${B}`};case"delete":return{tool_use_id:Z,type:"tool_result",content:`Deleted cell ${A}`};default:return{tool_use_id:Z,type:"tool_result",content:"Unknown edit mode"}}},renderToolUseMessage:PtB,renderToolUseRejectedMessage:StB,renderToolUseErrorMessage:xtB,renderToolUseProgressMessage:ytB,renderToolResultMessage:vtB,async validateInput({notebook_path:A,cell_type:Q,cell_id:B,edit_mode:G="replace"}){let Z=ftB(A)?A:btB(r1(),A),Y=jA();if(!Y.existsSync(Z))return{result:!1,message:"Notebook file does not exist.",errorCode:1};if(BW8(Z)!==".ipynb")return{result:!1,message:"File must be a Jupyter notebook (.ipynb file). For editing other file types, use the FileEdit tool.",errorCode:2};if(G!=="replace"&&G!=="insert"&&G!=="delete")return{result:!1,message:"Edit mode must be replace, insert, or delete.",errorCode:4};if(G==="insert"&&!Q)return{result:!1,message:"Cell type is required when using edit_mode=insert.",errorCode:5};let J=LD(Z),I=Y.readFileSync(Z,{encoding:J}),X=h8(I);if(!X)return{result:!1,message:"Notebook is not valid JSON.",errorCode:6};if(!B){if(G!=="insert")return{result:!1,message:"Cell ID must be specified when not inserting a new cell.",errorCode:7}}else if(X.cells.findIndex((K)=>K.id===B)===-1){let K=oCA(B);if(K!==void 0){if(!X.cells[K])return{result:!1,message:`Cell with index ${K} does not exist in notebook.`,errorCode:7}}else return{result:!1,message:`Cell with ID "${B}" not found in notebook.`,errorCode:8}}return{result:!0}},async call({notebook_path:A,new_source:Q,cell_id:B,cell_type:G,edit_mode:Z},{updateFileHistoryState:Y},J,I){let X=ftB(A)?A:btB(r1(),A);if(o7())await gGA(Y,X,I.uuid);try{let W=LD(X),K=jA().readFileSync(X,{encoding:W}),V=JSON.parse(K),E;if(!B)E=0;else{if(E=V.cells.findIndex((O)=>O.id===B),E===-1){let O=oCA(B);if(O!==void 0)E=O}if(Z==="insert")E+=1}let D=Z;if(D==="replace"&&E===V.cells.length){if(D="insert",!G)G="code"}let H=V.metadata.language_info?.name??"python",F=void 0;if(V.nbformat>4||V.nbformat===4&&V.nbformat_minor>=5){if(D==="insert")F=Math.random().toString(36).substring(2,15);else if(B!==null)F=B}if(D==="delete")V.cells.splice(E,1);else if(D==="insert"){let O;if(G==="markdown")O={cell_type:"markdown",id:F,source:Q,metadata:{}};else O={cell_type:"code",id:F,source:Q,metadata:{},execution_count:null,outputs:[]};V.cells.splice(E,0,O)}else{let O=V.cells[E];if(O.source=Q,O.cell_type==="code")O.execution_count=null,O.outputs=[];if(G&&G!==O.cell_type)O.cell_type=G}let C=DAA(X);return tGA(X,JSON.stringify(V,null,1),W,C),{data:{new_source:Q,cell_type:G??"code",language:H,edit_mode:D??"replace",cell_id:F||void 0,error:""}}}catch(W){if(W instanceof Error)return{data:{new_source:Q,cell_type:G??"code",language:"python",edit_mode:"replace",error:W.message,cell_id:B}};return{data:{new_source:Q,cell_type:G??"code",language:"python",edit_mode:"replace",error:"Unknown error occurred while editing notebook",cell_id:B}}}}}});function lYA(A,Q,B){function G(I,X){var W;Object.defineProperty(I,"_zod",{value:I._zod??{},enumerable:!1}),(W=I._zod).traits??(W.traits=new Set),I._zod.traits.add(A),Q(I,X);for(let K in J.prototype)if(!(K in I))Object.defineProperty(I,K,{value:J.prototype[K].bind(I)});I._zod.constr=J,I._zod.def=X}let Z=B?.Parent??Object;class Y extends Z{}Object.defineProperty(Y,"name",{value:A});function J(I){var X;let W=B?.Parent?new Y:this;G(W,I),(X=W._zod).deferred??(X.deferred=[]);for(let K of W._zod.deferred)K();return W}return Object.defineProperty(J,"init",{value:G}),Object.defineProperty(J,Symbol.hasInstance,{value:(I)=>{if(B?.Parent&&I instanceof B.Parent)return!0;return I?._zod?.traits?.has(A)}}),Object.defineProperty(J,"name",{value:A}),J}function F00(A){if(A)Object.assign(htB,A);return htB}var YW8,JW8,htB;var C00=L(()=>{YW8=Object.freeze({status:"aborted"});JW8=Symbol("zod_brand"),htB={}});function gtB(A){let Q=Object.values(A).filter((G)=>typeof G==="number");return Object.entries(A).filter(([G,Z])=>Q.indexOf(+G)===-1).map(([G,Z])=>Z)}function z00(A,Q="|"){return A.map((B)=>U00(B)).join(Q)}function utB(A,Q){if(typeof Q==="bigint")return Q.toString();return Q}function IW8(A){return{get value(){{let B=A();return Object.defineProperty(this,"value",{value:B}),B}throw Error("cached value already set")}}}function U00(A){if(typeof A==="bigint")return A.toString()+"n";if(typeof A==="string")return`"${A}"`;return`${A}`}var RqG,_qG,TqG;var EMA=L(()=>{RqG=Error.captureStackTrace?Error.captureStackTrace:(...A)=>{},_qG=IW8(()=>{if(typeof navigator<"u"&&navigator?.userAgent?.includes("Cloudflare"))return!1;try{return new Function(""),!0}catch(A){return!1}});TqG={safeint:[Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER],int32:[-2147483648,2147483647],uint32:[0,4294967295],float32:[-340282346638528860000000000000000000000,340282346638528860000000000000000000000],float64:[-Number.MAX_VALUE,Number.MAX_VALUE]}});function w00(A,Q=(B)=>B.message){let B={},G=[];for(let Z of A.issues)if(Z.path.length>0)B[Z.path[0]]=B[Z.path[0]]||[],B[Z.path[0]].push(Q(Z));else G.push(Q(Z));return{formErrors:G,fieldErrors:B}}function N00(A,Q){let B=Q||function(Y){return Y.message},G={_errors:[]},Z=(Y)=>{for(let J of Y.issues)if(J.code==="invalid_union"&&J.errors.length)J.errors.map((I)=>Z({issues:I}));else if(J.code==="invalid_key")Z({issues:J.issues});else if(J.code==="invalid_element")Z({issues:J.issues});else if(J.path.length===0)G._errors.push(B(J));else{let I=G,X=0;while(X<J.path.length){let W=J.path[X];if(X!==J.path.length-1)I[W]=I[W]||{_errors:[]};else I[W]=I[W]||{_errors:[]},I[W]._errors.push(B(J));I=I[W],X++}}};return Z(A),G}var mtB=(A,Q)=>{A.name="$ZodError",Object.defineProperty(A,"_zod",{value:A._zod,enumerable:!1}),Object.defineProperty(A,"issues",{value:Q,enumerable:!1}),Object.defineProperty(A,"message",{get(){return JSON.stringify(Q,utB,2)},enumerable:!0})},dtB,PqG;var ctB=L(()=>{C00();EMA();dtB=lYA("$ZodError",mtB),PqG=lYA("$ZodError",mtB,{Parent:Error})});var ptB=()=>{};var XW8="(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))",yqG;var itB=L(()=>{yqG=new RegExp(`^${XW8}$`)});var ntB=()=>{};var atB=()=>{};var otB=()=>{};function q00(){return{localeError:KW8()}}var WW8=(A)=>{let Q=typeof A;switch(Q){case"number":return Number.isNaN(A)?"NaN":"number";case"object":{if(Array.isArray(A))return"array";if(A===null)return"null";if(Object.getPrototypeOf(A)!==Object.prototype&&A.constructor)return A.constructor.name}}return Q},KW8=()=>{let A={string:{unit:"characters",verb:"to have"},file:{unit:"bytes",verb:"to have"},array:{unit:"items",verb:"to have"},set:{unit:"items",verb:"to have"}};function Q(G){return A[G]??null}let B={regex:"input",email:"email address",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO datetime",date:"ISO date",time:"ISO time",duration:"ISO duration",ipv4:"IPv4 address",ipv6:"IPv6 address",cidrv4:"IPv4 range",cidrv6:"IPv6 range",base64:"base64-encoded string",base64url:"base64url-encoded string",json_string:"JSON string",e164:"E.164 number",jwt:"JWT",template_literal:"input"};return(G)=>{switch(G.code){case"invalid_type":return`Invalid input: expected ${G.expected}, received ${WW8(G.input)}`;case"invalid_value":if(G.values.length===1)return`Invalid input: expected ${U00(G.values[0])}`;return`Invalid option: expected one of ${z00(G.values,"|")}`;case"too_big":{let Z=G.inclusive?"<=":"<",Y=Q(G.origin);if(Y)return`Too big: expected ${G.origin??"value"} to have ${Z}${G.maximum.toString()} ${Y.unit??"elements"}`;return`Too big: expected ${G.origin??"value"} to be ${Z}${G.maximum.toString()}`}case"too_small":{let Z=G.inclusive?">=":">",Y=Q(G.origin);if(Y)return`Too small: expected ${G.origin} to have ${Z}${G.minimum.toString()} ${Y.unit}`;return`Too small: expected ${G.origin} to be ${Z}${G.minimum.toString()}`}case"invalid_format":{let Z=G;if(Z.format==="starts_with")return`Invalid string: must start with "${Z.prefix}"`;if(Z.format==="ends_with")return`Invalid string: must end with "${Z.suffix}"`;if(Z.format==="includes")return`Invalid string: must include "${Z.includes}"`;if(Z.format==="regex")return`Invalid string: must match pattern ${Z.pattern}`;return`Invalid ${B[Z.format]??G.format}`}case"not_multiple_of":return`Invalid number: must be a multiple of ${G.divisor}`;case"unrecognized_keys":return`Unrecognized key${G.keys.length>1?"s":""}: ${z00(G.keys,", ")}`;case"invalid_key":return`Invalid key in ${G.origin}`;case"invalid_union":return"Invalid input";case"invalid_element":return`Invalid value in ${G.origin}`;default:return"Invalid input"}}};var rtB=L(()=>{EMA()});var L00=()=>{};class kQ1{constructor(){this._map=new WeakMap,this._idmap=new Map}add(A,...Q){let B=Q[0];if(this._map.set(A,B),B&&typeof B==="object"&&"id"in B){if(this._idmap.has(B.id))throw Error(`ID ${B.id} already exists in the registry`);this._idmap.set(B.id,A)}return this}remove(A){return this._map.delete(A),this}get(A){let Q=A._zod.parent;if(Q){let B={...this.get(Q)??{}};return delete B.id,{...B,...this._map.get(A)}}return this._map.get(A)}has(A){return this._map.has(A)}}function ttB(){return new kQ1}var VW8,EW8,M00;var O00=L(()=>{VW8=Symbol("ZodOutput"),EW8=Symbol("ZodInput");M00=ttB()});var etB=()=>{};var AeB=()=>{};class R00{constructor(A){this.counter=0,this.metadataRegistry=A?.metadata??M00,this.target=A?.target??"draft-2020-12",this.unrepresentable=A?.unrepresentable??"throw",this.override=A?.override??(()=>{}),this.io=A?.io??"output",this.seen=new Map}process(A,Q={path:[],schemaPath:[]}){var B;let G=A._zod.def,Z={guid:"uuid",url:"uri",datetime:"date-time",json_string:"json-string",regex:""},Y=this.seen.get(A);if(Y){if(Y.count++,Q.schemaPath.includes(A))Y.cycle=Q.path;return Y.schema}let J={schema:{},count:1,cycle:void 0,path:Q.path};this.seen.set(A,J);let I=A._zod.toJSONSchema?.();if(I)J.schema=I;else{let K={...Q,schemaPath:[...Q.schemaPath,A],path:Q.path},V=A._zod.parent;if(V)J.ref=V,this.process(V,K),this.seen.get(V).isParent=!0;else{let E=J.schema;switch(G.type){case"string":{let D=E;D.type="string";let{minimum:H,maximum:F,format:C,patterns:U,contentEncoding:O}=A._zod.bag;if(typeof H==="number")D.minLength=H;if(typeof F==="number")D.maxLength=F;if(C){if(D.format=Z[C]??C,D.format==="")delete D.format}if(O)D.contentEncoding=O;if(U&&U.size>0){let q=[...U];if(q.length===1)D.pattern=q[0].source;else if(q.length>1)J.schema.allOf=[...q.map((M)=>({...this.target==="draft-7"?{type:"string"}:{},pattern:M.source}))]}break}case"number":{let D=E,{minimum:H,maximum:F,format:C,multipleOf:U,exclusiveMaximum:O,exclusiveMinimum:q}=A._zod.bag;if(typeof C==="string"&&C.includes("int"))D.type="integer";else D.type="number";if(typeof q==="number")D.exclusiveMinimum=q;if(typeof H==="number"){if(D.minimum=H,typeof q==="number")if(q>=H)delete D.minimum;else delete D.exclusiveMinimum}if(typeof O==="number")D.exclusiveMaximum=O;if(typeof F==="number"){if(D.maximum=F,typeof O==="number")if(O<=F)delete D.maximum;else delete D.exclusiveMaximum}if(typeof U==="number")D.multipleOf=U;break}case"boolean":{let D=E;D.type="boolean";break}case"bigint":{if(this.unrepresentable==="throw")throw Error("BigInt cannot be represented in JSON Schema");break}case"symbol":{if(this.unrepresentable==="throw")throw Error("Symbols cannot be represented in JSON Schema");break}case"null":{E.type="null";break}case"any":break;case"unknown":break;case"undefined":case"never":{E.not={};break}case"void":{if(this.unrepresentable==="throw")throw Error("Void cannot be represented in JSON Schema");break}case"date":{if(this.unrepresentable==="throw")throw Error("Date cannot be represented in JSON Schema");break}case"array":{let D=E,{minimum:H,maximum:F}=A._zod.bag;if(typeof H==="number")D.minItems=H;if(typeof F==="number")D.maxItems=F;D.type="array",D.items=this.process(G.element,{...K,path:[...K.path,"items"]});break}case"object":{let D=E;D.type="object",D.properties={};let H=G.shape;for(let U in H)D.properties[U]=this.process(H[U],{...K,path:[...K.path,"properties",U]});let F=new Set(Object.keys(H)),C=new Set([...F].filter((U)=>{let O=G.shape[U]._zod;if(this.io==="input")return O.optin===void 0;else return O.optout===void 0}));if(C.size>0)D.required=Array.from(C);if(G.catchall?._zod.def.type==="never")D.additionalProperties=!1;else if(!G.catchall){if(this.io==="output")D.additionalProperties=!1}else if(G.catchall)D.additionalProperties=this.process(G.catchall,{...K,path:[...K.path,"additionalProperties"]});break}case"union":{let D=E;D.anyOf=G.options.map((H,F)=>this.process(H,{...K,path:[...K.path,"anyOf",F]}));break}case"intersection":{let D=E,H=this.process(G.left,{...K,path:[...K.path,"allOf",0]}),F=this.process(G.right,{...K,path:[...K.path,"allOf",1]}),C=(O)=>("allOf"in O)&&Object.keys(O).length===1,U=[...C(H)?H.allOf:[H],...C(F)?F.allOf:[F]];D.allOf=U;break}case"tuple":{let D=E;D.type="array";let H=G.items.map((U,O)=>this.process(U,{...K,path:[...K.path,"prefixItems",O]}));if(this.target==="draft-2020-12")D.prefixItems=H;else D.items=H;if(G.rest){let U=this.process(G.rest,{...K,path:[...K.path,"items"]});if(this.target==="draft-2020-12")D.items=U;else D.additionalItems=U}if(G.rest)D.items=this.process(G.rest,{...K,path:[...K.path,"items"]});let{minimum:F,maximum:C}=A._zod.bag;if(typeof F==="number")D.minItems=F;if(typeof C==="number")D.maxItems=C;break}case"record":{let D=E;D.type="object",D.propertyNames=this.process(G.keyType,{...K,path:[...K.path,"propertyNames"]}),D.additionalProperties=this.process(G.valueType,{...K,path:[...K.path,"additionalProperties"]});break}case"map":{if(this.unrepresentable==="throw")throw Error("Map cannot be represented in JSON Schema");break}case"set":{if(this.unrepresentable==="throw")throw Error("Set cannot be represented in JSON Schema");break}case"enum":{let D=E,H=gtB(G.entries);if(H.every((F)=>typeof F==="number"))D.type="number";if(H.every((F)=>typeof F==="string"))D.type="string";D.enum=H;break}case"literal":{let D=E,H=[];for(let F of G.values)if(F===void 0){if(this.unrepresentable==="throw")throw Error("Literal `undefined` cannot be represented in JSON Schema")}else if(typeof F==="bigint")if(this.unrepresentable==="throw")throw Error("BigInt literals cannot be represented in JSON Schema");else H.push(Number(F));else H.push(F);if(H.length===0);else if(H.length===1){let F=H[0];D.type=F===null?"null":typeof F,D.const=F}else{if(H.every((F)=>typeof F==="number"))D.type="number";if(H.every((F)=>typeof F==="string"))D.type="string";if(H.every((F)=>typeof F==="boolean"))D.type="string";if(H.every((F)=>F===null))D.type="null";D.enum=H}break}case"file":{let D=E,H={type:"string",format:"binary",contentEncoding:"binary"},{minimum:F,maximum:C,mime:U}=A._zod.bag;if(F!==void 0)H.minLength=F;if(C!==void 0)H.maxLength=C;if(U)if(U.length===1)H.contentMediaType=U[0],Object.assign(D,H);else D.anyOf=U.map((O)=>{return{...H,contentMediaType:O}});else Object.assign(D,H);break}case"transform":{if(this.unrepresentable==="throw")throw Error("Transforms cannot be represented in JSON Schema");break}case"nullable":{let D=this.process(G.innerType,K);E.anyOf=[D,{type:"null"}];break}case"nonoptional":{this.process(G.innerType,K),J.ref=G.innerType;break}case"success":{let D=E;D.type="boolean";break}case"default":{this.process(G.innerType,K),J.ref=G.innerType,E.default=JSON.parse(JSON.stringify(G.defaultValue));break}case"prefault":{if(this.process(G.innerType,K),J.ref=G.innerType,this.io==="input")E._prefault=JSON.parse(JSON.stringify(G.defaultValue));break}case"catch":{this.process(G.innerType,K),J.ref=G.innerType;let D;try{D=G.catchValue(void 0)}catch{throw Error("Dynamic catch values are not supported in JSON Schema")}E.default=D;break}case"nan":{if(this.unrepresentable==="throw")throw Error("NaN cannot be represented in JSON Schema");break}case"template_literal":{let D=E,H=A._zod.pattern;if(!H)throw Error("Pattern not found in template literal");D.type="string",D.pattern=H.source;break}case"pipe":{let D=this.io==="input"?G.in._zod.def.type==="transform"?G.out:G.in:G.out;this.process(D,K),J.ref=D;break}case"readonly":{this.process(G.innerType,K),J.ref=G.innerType,E.readOnly=!0;break}case"promise":{this.process(G.innerType,K),J.ref=G.innerType;break}case"optional":{this.process(G.innerType,K),J.ref=G.innerType;break}case"lazy":{let D=A._zod.innerType;this.process(D,K),J.ref=D;break}case"custom":{if(this.unrepresentable==="throw")throw Error("Custom types cannot be represented in JSON Schema");break}default:}}}let X=this.metadataRegistry.get(A);if(X)Object.assign(J.schema,X);if(this.io==="input"&&ZK(A))delete J.schema.examples,delete J.schema.default;if(this.io==="input"&&J.schema._prefault)(B=J.schema).default??(B.default=J.schema._prefault);return delete J.schema._prefault,this.seen.get(A).schema}emit(A,Q){let B={cycles:Q?.cycles??"ref",reused:Q?.reused??"inline",external:Q?.external??void 0},G=this.seen.get(A);if(!G)throw Error("Unprocessed schema. This is a bug in Zod.");let Z=(W)=>{let K=this.target==="draft-2020-12"?"$defs":"definitions";if(B.external){let H=B.external.registry.get(W[0])?.id;if(H)return{ref:B.external.uri(H)};let F=W[1].defId??W[1].schema.id??`schema${this.counter++}`;return W[1].defId=F,{defId:F,ref:`${B.external.uri("__shared")}#/${K}/${F}`}}if(W[1]===G)return{ref:"#"};let E=`${"#"}/${K}/`,D=W[1].schema.id??`__schema${this.counter++}`;return{defId:D,ref:E+D}},Y=(W)=>{if(W[1].schema.$ref)return;let K=W[1],{ref:V,defId:E}=Z(W);if(K.def={...K.schema},E)K.defId=E;let D=K.schema;for(let H in D)delete D[H];D.$ref=V};for(let W of this.seen.entries()){let K=W[1];if(A===W[0]){Y(W);continue}if(B.external){let E=B.external.registry.get(W[0])?.id;if(A!==W[0]&&E){Y(W);continue}}if(this.metadataRegistry.get(W[0])?.id){Y(W);continue}if(K.cycle){if(B.cycles==="throw")throw Error(`Cycle detected: #/${K.cycle?.join("/")}/<root>
bundles/ClaudeCodeCode/cli.js:1774:`,isMeta:!0}),...A]}async function U02(A,Q){if(N02())return;let[{tools:B},G,Z,Y]=await Promise.all([PtA(A),UH(Q),_V(),nE()]),J=Y.gitStatus?.length??0,I=Z.claudeMd?.length??0,X=J+I,W=g9();setTimeout(()=>W.abort(),1000);let K=r1(),V=AZA(Q),E=eGA(V,K),D=await pSA(K,W.signal,E),H=0,F=0,C=0,U=0,O=0,q=G.filter((_)=>!_.isMcp);H=B.length,U=q.length;let M=new Set;for(let _ of B){let T=_.name.split("__");if(T.length>=3&&T[1])M.add(T[1])}F=M.size;try{if(B.length>0){let{mcpToolTokens:_}=await _MA(B,async()=>Q,null);C=_}if(q.length>0)O=await F02(G,async()=>Q,null)}catch{}r("tengu_context_size",{git_status_size:J,claude_md_size:I,total_context_size:X,project_file_count_rounded:D,mcp_tools_count:H,mcp_servers_count:F,mcp_tools_tokens:C,non_mcp_tools_count:U,non_mcp_tools_tokens:O})}function $02(A,Q,B){switch(A.name){case HMA:{let G=dF(B);if(G)return{...Q,plan:G};return Q}case Q4.name:{let G=Q4.inputSchema.parse(Q),{command:Z,timeout:Y,description:J,run_in_background:I}=G,X=Z.replace(`cd ${r1()} && `,"");if(X=X.replace(/\\\\;/g,"\\;"),/^echo\s+["']?[^|&;><]*["']?$/i.test(X.trim()))r("tengu_bash_tool_simple_echo",{});return{command:X,description:J,...Y?{timeout:Y}:{},...J?{description:J}:{},...I?{run_in_background:I}:{},..."dangerouslyDisableSandbox"in G&&G.dangerouslyDisableSandbox?{dangerouslyDisableSandbox:G.dangerouslyDisableSandbox}:{}}}case lE.name:{let G=lE.inputSchema.parse(Q),{file_path:Z,edits:Y}=__B({file_path:G.file_path,edits:[{old_string:G.old_string,new_string:G.new_string,replace_all:G.replace_all}]});return{replace_all:Y[0].replace_all,file_path:Z,old_string:Y[0].old_string,new_string:Y[0].new_string}}case XW.name:{let G=XW.inputSchema.parse(Q);return{file_path:G.file_path,content:Go1(G.content)}}case VH:{let G=Q,Z=G.task_id??G.agentId??G.bash_id,Y=G.timeout??(typeof G.wait_up_to==="number"?G.wait_up_to*1000:void 0);return{task_id:Z??"",block:G.block??!0,timeout:Y??30000}}default:return Q}}function w02(A,Q){switch(A.name){case HMA:{if(Q&&typeof Q==="object"&&"plan"in Q){let{plan:B,...G}=Q;return G}return Q}default:return Q}}var kH8;var Xh=L(()=>{T00();J4();T0();HB();xj();pB();cY();pE();rl();OAA();Rb();LZ();cF();Y0();GB1();fv();ayA();$_();dx();$H();kH8=o(W02(),1)});var q02=L(()=>{T0();HB();RG();Xh();LZ();l2()});var L02=L(()=>{ar();pE();Rb();rl();pYA();h1();q02()});async function M02(A){let Q;do Q=await A.next();while(!Q.done);return Q.value}async function*GJA(A,Q=1/0){let B=(Y)=>{let J=Y.next().then(({done:I,value:X})=>({done:I,value:X,generator:Y,promise:J}));return J},G=[...A],Z=new Set;while(Z.size<Q&&G.length>0){let Y=G.shift();Z.add(B(Y))}while(Z.size>0){let{done:Y,value:J,generator:I,promise:X}=await Promise.race(Z);if(Z.delete(X),!Y){if(Z.add(B(I)),J!==void 0)yield J}else if(G.length>0){let W=G.shift();Z.add(B(W))}}}async function YB1(A){let Q=[];for await(let B of A)Q.push(B);return Q}async function*SQ0(A){for(let Q of A)yield Q}var sOG;var Xi=L(()=>{sOG=Symbol("NO_VALUE")});function O02(A){let Q=A.toLowerCase();return/\b(wtf|wth|ffs|omfg|shit(ty|tiest)?|dumbass|horrible|awful|piss(ed|ing)? off|piece of (shit|crap|junk)|what the (fuck|hell)|fucking? (broken|useless|terrible|awful|horrible)|fuck you|screw (this|you)|so frustrating|this sucks|damn it)\b/.test(Q)}function R02(A){let Q=A.toLowerCase().trim();if(Q==="continue")return!0;return/\b(keep going|go on)\b/.test(Q)}function _02(A){let Q=A.toLowerCase();return/\b(you'?re absolutely right|you'?re right)\b/.test(Q)}function IB1(){if(!xQ0)xQ0=qA("perf_hooks").performance;return xQ0}function bH8(){let A=IB1(),Q=A.getEntriesByType("mark");for(let B of Q)if(B.name.startsWith(jMA))A.clearMarks(B.name)}function vQ0(){if(!D4())return;if(!yQ0)return;if(TMA++,bH8(),IB1().mark(`${jMA}turn_start`),JB1)f(`[headlessProfiler] Started turn ${TMA}`)}function z1A(A){if(!D4())return;if(!yQ0)return;let Q=IB1();if(Q.mark(`${jMA}${A}`),JB1)f(`[headlessProfiler] Checkpoint: ${A} at ${Q.now().toFixed(1)}ms`)}function kQ0(){if(!D4())return;if(!yQ0)return;let B=IB1().getEntriesByType("mark").filter((K)=>K.name.startsWith(jMA));if(B.length===0)return;let G=new Map;for(let K of B){let V=K.name.slice(jMA.length);G.set(V,K.startTime)}let Z=G.get("turn_start");if(Z===void 0)return;let Y={turn_number:TMA},J=G.get("system_message_yielded");if(J!==void 0&&TMA===0)Y.time_to_system_message_ms=Math.round(J);let I=G.get("query_started");if(I!==void 0)Y.time_to_query_start_ms=Math.round(I-Z);let X=G.get("first_chunk");if(X!==void 0)Y.time_to_first_response_ms=Math.round(X-Z);let W=G.get("api_request_sent");if(I!==void 0&&W!==void 0)Y.query_overhead_ms=Math.round(W-I);if(Y.checkpoint_count=B.length,process.env.CLAUDE_CODE_ENTRYPOINT)Y.entrypoint=process.env.CLAUDE_CODE_ENTRYPOINT;if(T02)r("tengu_headless_latency",Y);if(JB1)f(`[headlessProfiler] Turn ${TMA} metrics: ${JSON.stringify(Y)}`)}var JB1,fH8=0.05,T02,yQ0,xQ0=null,jMA="headless_",TMA=-1;var PMA=L(()=>{Y0();T0();g0();JB1=process.env.CLAUDE_CODE_PROFILE_STARTUP==="1",T02=Math.random()<fH8,yQ0=JB1||T02});function XB1(A){j02.push(A)}async function P02(A,Q,B,G,Z,Y){let J={messages:A,systemPrompt:Q,userContext:B,systemContext:G,toolUseContext:Z,querySource:Y};for(let I of j02)try{await I(J)}catch(X){s(X instanceof Error?X:Error(`Post-sampling hook failed: ${X}`))}}var j02;var SMA=L(()=>{h1();j02=[]});var xMA=L(()=>{XQ();g0();rQ()});class fQ0{toolDefinitions;canUseTool;tools=[];toolUseContext;hasErrored=!1;progressAvailableResolve;constructor(A,Q,B){this.toolDefinitions=A;this.canUseTool=Q;this.toolUseContext=B}addTool(A,Q){let B=this.toolDefinitions.find((Y)=>Y.name===A.name);if(!B){this.tools.push({id:A.id,block:A,assistantMessage:Q,status:"completed",isConcurrencySafe:!0,pendingProgress:[],results:[u0({content:[{type:"tool_result",content:`<tool_use_error>Error: No such tool available: ${A.name}</tool_use_error>`,is_error:!0,tool_use_id:A.id}],toolUseResult:`Error: No such tool available: ${A.name}`})]});return}let G=B.inputSchema.safeParse(A.input),Z=G?.success?B.isConcurrencySafe(G.data):!1;this.tools.push({id:A.id,block:A,assistantMessage:Q,status:"queued",isConcurrencySafe:Z,pendingProgress:[]}),this.processQueue()}canExecuteTool(A){let Q=this.tools.filter((B)=>B.status==="executing");return Q.length===0||A&&Q.every((B)=>B.isConcurrencySafe)}async processQueue(){for(let A of this.tools){if(A.status!=="queued")continue;if(this.canExecuteTool(A.isConcurrencySafe))await this.executeTool(A);else if(!A.isConcurrencySafe)break}}createSyntheticErrorMessage(A,Q){if(Q==="user_interrupted")return u0({content:[{type:"tool_result",content:U1A,is_error:!0,tool_use_id:A}],toolUseResult:"User rejected tool use"});return u0({content:[{type:"tool_result",content:"<tool_use_error>Sibling tool call errored</tool_use_error>",is_error:!0,tool_use_id:A}],toolUseResult:"Sibling tool call errored"})}getAbortReason(){if(this.hasErrored)return"sibling_error";if(this.toolUseContext.abortController.signal.aborted)return"user_interrupted";return null}async executeTool(A){A.status="executing",this.toolUseContext.setInProgressToolUseIDs((Y)=>new Set([...Y,A.id]));let Q=[],B=[],Z=(async()=>{let Y=this.getAbortReason();if(Y){Q.push(this.createSyntheticErrorMessage(A.id,Y)),A.results=Q,A.contextModifiers=B,A.status="completed";return}let J=WB1(A.block,A.assistantMessage,this.canUseTool,this.toolUseContext),I=!1;for await(let X of J){let W=this.getAbortReason();if(W&&!I){Q.push(this.createSyntheticErrorMessage(A.id,W));break}if(X.message.type==="user"&&Array.isArray(X.message.message.content)&&X.message.message.content.some((V)=>V.type==="tool_result"&&V.is_error===!0))this.hasErrored=!0,I=!0;if(X.message)if(X.message.type==="progress"){if(A.pendingProgress.push(X.message),this.progressAvailableResolve)this.progressAvailableResolve(),this.progressAvailableResolve=void 0}else Q.push(X.message);if(X.contextModifier)B.push(X.contextModifier.modifyContext)}if(A.results=Q,A.contextModifiers=B,A.status="completed",!A.isConcurrencySafe&&B.length>0)for(let X of B)this.toolUseContext=X(this.toolUseContext)})();A.promise=Z,Z.finally(()=>{this.processQueue()})}*getCompletedResults(){for(let A of this.tools){while(A.pendingProgress.length>0)yield{message:A.pendingProgress.shift()};if(A.status==="yielded")continue;if(A.status==="completed"&&A.results){A.status="yielded";for(let Q of A.results)yield{message:Q};hH8(this.toolUseContext,A.id)}else if(A.status==="executing"&&!A.isConcurrencySafe)break}}hasPendingProgress(){return this.tools.some((A)=>A.pendingProgress.length>0)}async*getRemainingResults(){while(this.hasUnfinishedTools()){await this.processQueue();for(let A of this.getCompletedResults())yield A;if(this.hasExecutingTools()&&!this.hasCompletedResults()&&!this.hasPendingProgress()){let A=this.tools.filter((B)=>B.status==="executing"&&B.promise).map((B)=>B.promise),Q=new Promise((B)=>{this.progressAvailableResolve=B});if(A.length>0)await Promise.race([...A,Q])}}for(let A of this.getCompletedResults())yield A}hasCompletedResults(){return this.tools.some((A)=>A.status==="completed")}hasExecutingTools(){return this.tools.some((A)=>A.status==="executing")}hasUnfinishedTools(){return this.tools.some((A)=>A.status!=="yielded")}getUpdatedContext(){return this.toolUseContext}}function hH8(A,Q){A.setInProgressToolUseIDs((B)=>new Set([...B].filter((G)=>G!==Q)))}var S02=L(()=>{Wi();HB()});import{randomUUID as gH8}from"crypto";function KB1(A){return async(Q)=>{try{if(!await A.shouldRun(Q))return;let G=gH8(),Z=A.buildMessages(Q);Q.queryMessageCount=Z.length;let Y=A.systemPrompt?[A.systemPrompt]:Q.systemPrompt,I=A.useTools??!0?Q.toolUseContext.options.tools:[],X=A.getModel(),W=await Wh({messages:Z,systemPrompt:Y,maxThinkingTokens:0,tools:I,signal:g9().signal,options:{getToolPermissionContext:async()=>{return(await Q.toolUseContext.getAppState()).toolPermissionContext},model:X,toolChoice:void 0,isNonInteractiveSession:Q.toolUseContext.options.isNonInteractiveSession,hasAppendSystemPrompt:Q.toolUseContext.options.hasAppendSystemPrompt,temperatureOverride:0,agents:Q.toolUseContext.options.agentDefinitions.activeAgents,querySource:A.name,mcpTools:[],agentIdOrSessionId:Q.toolUseContext.agentId}}),K=W.message.content.filter((V)=>V.type==="text").map((V)=>V.text).join("").trim();try{let V=A.parseResponse(K,Q);A.logResult({type:"success",queryName:A.name,result:V,messageId:W.message.id,model:X,uuid:G},Q)}catch(V){A.logResult({type:"error",queryName:A.name,error:V,uuid:G},Q)}}catch(B){s(B instanceof Error?B:Error(`API query hook ${A.name} failed`))}}}var bQ0=L(()=>{RG();LZ();h1()});async function x02(){return}async function y02(A){if(hQ0)await hQ0(A)}var hQ0=null;var gQ0=L(()=>{bQ0();HB();T0();J4();l2();Xh()});function uH8(A){if(A instanceof I9){let Q=A.error;if(Q?.error?.message)return Q.error.message}return A instanceof Error?A.message:String(A)}function uQ0(A){let Q=new Set;A.forEach((B,G)=>Q.add(G));for(let[B,G]of Object.entries(mH8))if(G.prefixes?.some((Z)=>Array.from(Q).some((Y)=>Y.startsWith(Z))))return B;return}function mQ0(){return{...process.env.ANTHROPIC_BASE_URL?{baseUrl:process.env.ANTHROPIC_BASE_URL}:{},...process.env.ANTHROPIC_MODEL?{envModel:process.env.ANTHROPIC_MODEL}:{},...process.env.ANTHROPIC_SMALL_FAST_MODEL?{envSmallFastModel:process.env.ANTHROPIC_SMALL_FAST_MODEL}:{}}}function v02(){if(!{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.69",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues",BUILD_TIME:"2025-12-13T00:32:01Z"}.BUILD_TIME)return;let A=new Date({ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.69",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues",BUILD_TIME:"2025-12-13T00:32:01Z"}.BUILD_TIME).getTime();if(isNaN(A))return;return Math.floor((Date.now()-A)/60000)}function k02({model:A,messagesLength:Q,temperature:B,betas:G,permissionMode:Z,querySource:Y,queryTracking:J}){r("tengu_api_query",{model:A,messagesLength:Q,temperature:B,provider:pO(),buildAgeMins:v02(),...G?.length?{betas:G.join(",")}:{},permissionMode:Z,querySource:Y,...J?{queryChainId:J.chainId,queryDepth:J.depth}:{},...mQ0()})}function f02({error:A,model:Q,messageCount:B,messageTokens:G,durationMs:Z,durationMsIncludingRetries:Y,attempt:J,requestId:I,didFallBackToNonStreaming:X,promptCategory:W,headers:K,queryTracking:V,llmSpan:E}){let D=void 0;if(A instanceof I9&&A.headers)D=uQ0(A.headers);else if(K)D=uQ0(K);let H=uH8(A),F=A instanceof I9?String(A.status):void 0,C=cRB(A),U=QqA(A);if(U){let O=U.isSSLError?" (SSL error)":"";f(`Connection error details: code=${U.code}${O}, message=${U.message}`,{level:"error"})}s(A),r("tengu_api_error",{model:Q,error:H,status:F,errorType:C,messageCount:B,messageTokens:G,durationMs:Z,durationMsIncludingRetries:Y,attempt:J,provider:pO(),requestId:I||void 0,didFallBackToNonStreaming:X,...W?{promptCategory:W}:{},...D?{gateway:D}:{},...V?{queryChainId:V.chainId,queryDepth:V.depth}:{},...mQ0()}),zU("api_error",{model:Q,error:H,status_code:String(F),duration_ms:String(Z),attempt:String(J)}),ee1(E,{success:!1,statusCode:F?parseInt(F):void 0,error:H,attempt:J})}function dH8({model:A,preNormalizedModel:Q,messageCount:B,messageTokens:G,usage:Z,durationMs:Y,durationMsIncludingRetries:J,attempt:I,ttftMs:X,requestId:W,stopReason:K,costUSD:V,didFallBackToNonStreaming:E,querySource:D,gateway:H,queryTracking:F,permissionMode:C}){let U=D4(),O=process.argv.includes("-p")||process.argv.includes("--print");r("tengu_api_success",{model:A,...Q!==A?{preNormalizedModel:Q}:{},messageCount:B,messageTokens:G,inputTokens:Z.input_tokens,outputTokens:Z.output_tokens,cachedInputTokens:Z.cache_read_input_tokens??0,uncachedInputTokens:Z.cache_creation_input_tokens??0,durationMs:Y,durationMsIncludingRetries:J,attempt:I,ttftMs:X??void 0,buildAgeMins:v02(),provider:pO(),requestId:W??void 0,stop_reason:K??void 0,costUSD:V,didFallBackToNonStreaming:E,isNonInteractiveSession:U,print:O,isTTY:process.stdout.isTTY??!1,querySource:D,...H?{gateway:H}:{},...F?{queryChainId:F.chainId,queryDepth:F.depth}:{},permissionMode:C,...mQ0()})}function b02({model:A,preNormalizedModel:Q,start:B,startIncludingRetries:G,ttftMs:Z,usage:Y,attempt:J,messageCount:I,messageTokens:X,requestId:W,stopReason:K,didFallBackToNonStreaming:V,querySource:E,headers:D,costUSD:H,queryTracking:F,permissionMode:C,newMessages:U,llmSpan:O}){let q=D?uQ0(D):void 0,M=Date.now()-B,_=Date.now()-G;ZK0(_,M),dH8({model:A,preNormalizedModel:Q,messageCount:I,messageTokens:X,usage:Y,durationMs:M,durationMsIncludingRetries:_,attempt:J,ttftMs:Z,requestId:W,stopReason:K,costUSD:H,didFallBackToNonStreaming:V,querySource:E,gateway:q,queryTracking:F,permissionMode:C}),zU("api_request",{model:A,input_tokens:String(Y.input_tokens),output_tokens:String(Y.output_tokens),cache_read_tokens:String(Y.cache_read_input_tokens),cache_creation_tokens:String(Y.cache_creation_input_tokens),cost_usd:String(H),duration_ms:String(M)});let T,y,h;ee1(O,{success:!0,inputTokens:Y.input_tokens,outputTokens:Y.output_tokens,cacheReadTokens:Y.cache_read_input_tokens,cacheCreationTokens:Y.cache_creation_input_tokens,attempt:J,modelOutput:T,thinkingOutput:y,hasToolCall:h})}var mH8,$M;var yMA=L(()=>{VS();h1();Y0();hX();T0();ml();dl();g0();JM();YZA();mH8={litellm:{prefixes:["x-litellm-"]},helicone:{prefixes:["helicone-"]},portkey:{prefixes:["x-portkey-"]},"cloudflare-ai-gateway":{prefixes:["cf-aig-"]}};$M={input_tokens:0,cache_creation_input_tokens:0,cache_read_input_tokens:0,output_tokens:0,server_tool_use:{web_search_requests:0,web_fetch_requests:0},service_tier:"standard",cache_creation:{ephemeral_1h_input_tokens:0,ephemeral_5m_input_tokens:0}}});import{randomUUID as cH8}from"crypto";function VB1(A){return{systemPrompt:A.systemPrompt,userContext:A.userContext,systemContext:A.systemContext,toolUseContext:A.toolUseContext,forkContextMessages:A.messages}}function vMA(A,Q){let B=Q?.abortController??(Q?.shareAbortController?A.abortController:uV0(A.abortController)),G=Q?.getAppState?Q.getAppState:Q?.shareAbortController?A.getAppState:async()=>{let Z=await A.getAppState();if(Z.toolPermissionContext.shouldAvoidPermissionPrompts)return Z;return{...Z,toolPermissionContext:{...Z.toolPermissionContext,shouldAvoidPermissionPrompts:!0}}};return{readFileState:UAA(Q?.readFileState??A.readFileState),nestedMemoryAttachmentTriggers:new Set,toolDecisions:void 0,pendingSteeringAttachments:void 0,abortController:B,getAppState:G,setAppState:Q?.shareSetAppState?A.setAppState:()=>{},setMessages:()=>{},setInProgressToolUseIDs:()=>{},setResponseLength:Q?.shareSetResponseLength?A.setResponseLength:()=>{},updateFileHistoryState:()=>{},addNotification:void 0,setToolJSX:void 0,setStreamMode:void 0,setSpinnerMessage:void 0,setSpinnerColor:void 0,setSpinnerShimmerColor:void 0,setSDKStatus:void 0,openMessageSelector:void 0,options:Q?.options??A.options,messages:Q?.messages??A.messages,agentId:Q?.agentId??QAA(),isSubAgent:!0,queryTracking:{chainId:cH8(),depth:(A.queryTracking?.depth??-1)+1},fileReadingLimits:A.fileReadingLimits,userModified:A.userModified,criticalSystemReminder_EXPERIMENTAL:Q?.criticalSystemReminder_EXPERIMENTAL}}async function EB1({promptMessages:A,cacheSafeParams:Q,canUseTool:B,querySource:G,forkLabel:Z,overrides:Y,maxOutputTokens:J}){let I=Date.now(),X=[],W={...$M},{systemPrompt:K,userContext:V,systemContext:E,toolUseContext:D,forkContextMessages:H}=Q,F=vMA(D,Y),C=[...dQ0(H),...A];for await(let O of LU({messages:C,systemPrompt:K,userContext:V,systemContext:E,canUseTool:B,toolUseContext:F,querySource:G,maxOutputTokensOverride:J})){if(O.type==="stream_event"||O.type==="stream_request_start")continue;if(O.type==="assistant"){let M=O.message.usage;if(M)W=FB1(W,{input_tokens:M.input_tokens??0,cache_creation_input_tokens:M.cache_creation_input_tokens??0,cache_read_input_tokens:M.cache_read_input_tokens??0,output_tokens:M.output_tokens??0,server_tool_use:{web_search_requests:M.server_tool_use?.web_search_requests??0,web_fetch_requests:M.server_tool_use?.web_fetch_requests??0},service_tier:M.service_tier??"standard",cache_creation:{ephemeral_1h_input_tokens:M.cache_creation?.ephemeral_1h_input_tokens??0,ephemeral_5m_input_tokens:M.cache_creation?.ephemeral_5m_input_tokens??0}})}X.push(O)}let U=Date.now()-I;return pH8({forkLabel:Z,querySource:G,durationMs:U,messageCount:X.length,totalUsage:W,queryTracking:D.queryTracking}),{messages:X,totalUsage:W}}function pH8({forkLabel:A,querySource:Q,durationMs:B,messageCount:G,totalUsage:Z,queryTracking:Y}){let J=Z.input_tokens+Z.cache_creation_input_tokens+Z.cache_read_input_tokens,I=J>0?Z.cache_read_input_tokens/J:0;r("tengu_fork_agent_query",{forkLabel:A,querySource:Q,durationMs:B,messageCount:G,inputTokens:Z.input_tokens,outputTokens:Z.output_tokens,cacheReadInputTokens:Z.cache_read_input_tokens,cacheCreationInputTokens:Z.cache_creation_input_tokens,serviceTier:Z.service_tier,cacheCreationEphemeral1hTokens:Z.cache_creation.ephemeral_1h_input_tokens,cacheCreationEphemeral5mTokens:Z.cache_creation.ephemeral_5m_input_tokens,cacheHitRate:I,...Y?{queryChainId:Y.chainId,queryDepth:Y.depth}:{}})}var DB1=L(()=>{Wi();RG();yMA();T0();HB1();_w();rS();LZ()});async function h02(){if(D4())return;let A=process.env.CLAUDE_CODE_ENABLE_PROMPT_SUGGESTION;if(A==="false"){CB1=!1;return}if(A==="1"){CB1=!0;return}CB1=await JZ(lH8)}async function g02(A){if(!CB1||A.querySource!=="repl_main_thread")return;try{let Q=await nH8(A);if(!Q)return;if(aH8(Q))return;A.toolUseContext.setAppState((B)=>({...B,promptSuggestion:{text:Q,shownAt:0,acceptedAt:0}}))}catch(Q){s(Q instanceof Error?Q:Error("Prompt suggestion generation failed"))}}async function nH8(A){let Q=VB1(A),B=async()=>({behavior:"deny",message:"No tools needed for suggestion",decisionReason:{type:"other",reason:"suggestion only"}}),G=await EB1({promptMessages:[u0({content:iH8})],cacheSafeParams:Q,maxOutputTokens:16000,canUseTool:B,querySource:"prompt_suggestion",forkLabel:"prompt_suggestion"});for(let Z of G.messages){if(Z.type!=="assistant")continue;let Y=Z.message.content.find((J)=>J.type==="text");if(Y?.type==="text"&&Y.text.trim())return Y.text.trim()}return null}function aH8(A){let Q=A.toLowerCase(),B=[["empty",()=>!A],["done",()=>Q==="done"],["too_long",()=>A.length>=100],["has_formatting",()=>/[\n*]|\*\*/.test(A)],["error_message",()=>/prompt is too long|context length|token limit/.test(Q)],["gratitude",()=>/thanks|thank you|looks good|that worked|that's all/.test(Q)]];for(let[G,Z]of B)if(Z())return cQ0(G,A),!0;return!1}function cQ0(A,Q){r("tengu_prompt_suggestion",{outcome:"suppressed",reason:A,...!1})}var lH8="tengu_prompt_suggestion",CB1=!1,iH8=`You are now a prompt suggestion generator. The conversation above is context - your job is to suggest what Claude could help with next.
bundles/ClaudeCodeCode/cli.js:1780:Reply with ONLY the suggestion text, no quotes, no explanation, no markdown.`;var zB1=L(()=>{DB1();HB();J4();g0();T0();h1()});var kMA;var pQ0=L(()=>{kMA=class kMA{returned;queue=[];readResolve;readReject;isDone=!1;hasError;started=!1;constructor(A){this.returned=A}[Symbol.asyncIterator](){if(this.started)throw Error("Stream can only be iterated once");return this.started=!0,this}next(){if(this.queue.length>0)return Promise.resolve({done:!1,value:this.queue.shift()});if(this.isDone)return Promise.resolve({done:!0,value:void 0});if(this.hasError)return Promise.reject(this.hasError);return new Promise((A,Q)=>{this.readResolve=A,this.readReject=Q})}enqueue(A){if(this.readResolve){let Q=this.readResolve;this.readResolve=void 0,this.readReject=void 0,Q({done:!1,value:A})}else this.queue.push(A)}done(){if(this.isDone=!0,this.readResolve){let A=this.readResolve;this.readResolve=void 0,this.readReject=void 0,A({done:!0,value:void 0})}}error(A){if(this.hasError=A,this.readReject){let Q=this.readReject;this.readResolve=void 0,this.readReject=void 0,Q(A)}}return(){if(this.isDone=!0,this.returned)this.returned();return Promise.resolve({done:!0,value:void 0})}}});import{randomUUID as u02}from"crypto";function oH8(){return parseInt(process.env.CLAUDE_CODE_MAX_TOOL_USE_CONCURRENCY||"",10)||10}function*UB1(A,Q){for(let B of A){let G=B.message.content.filter((Z)=>Z.type==="tool_use");for(let Z of G)yield u0({content:[{type:"tool_result",content:Q,is_error:!0,tool_use_id:Z.id}],toolUseResult:Q})}}async function*LU({messages:A,systemPrompt:Q,userContext:B,systemContext:G,canUseTool:Z,toolUseContext:Y,autoCompactTracking:J,fallbackModel:I,stopHookActive:X,querySource:W,maxOutputTokensOverride:K}){let V=Y.options.sdkBetas;yield{type:"stream_request_start"},z1A("query_started");let E=Y.queryTracking?{chainId:Y.queryTracking.chainId,depth:Y.queryTracking.depth+1}:{chainId:u02(),depth:0},D=E.chainId;Y={...Y,queryTracking:E};let H=IT(A),F=J,C=await Yh(H,void 0,Y);if(H=C.messages,C.compactionInfo?.systemMessage)yield C.compactionInfo.systemMessage;let{compactionResult:U}=await wsB(H,Y,W);if(U){let{preCompactTokenCount:SA,postCompactTokenCount:yA,compactionUsage:ZA}=U;if(r("tengu_auto_compact_succeeded",{originalMessageCount:A.length,compactedMessageCount:U.summaryMessages.length+U.attachments.length+U.hookResults.length,preCompactTokenCount:SA,postCompactTokenCount:yA,compactionInputTokens:ZA?.input_tokens,compactionOutputTokens:ZA?.output_tokens,compactionCacheReadTokens:ZA?.cache_read_input_tokens??0,compactionCacheCreationTokens:ZA?.cache_creation_input_tokens??0,compactionTotalTokens:ZA?ZA.input_tokens+(ZA.cache_creation_input_tokens??0)+(ZA.cache_read_input_tokens??0)+ZA.output_tokens:0,queryChainId:D,queryDepth:E.depth}),!F?.compacted)F={compacted:!0,turnId:u02(),turnCounter:0};let GA=[U.boundaryMarker,...U.summaryMessages,...U.attachments,...U.hookResults,...U.messagesToKeep??[]];for(let zA of GA)yield zA;H=GA}Y={...Y,messages:H};let O=[],q=[],_=await JZ("tengu_streaming_tool_execution2")?new fQ0(Y.options.tools,Z,Y):null,T=await Y.getAppState(),y=T.toolPermissionContext.mode,h=tr({permissionMode:y,mainLoopModel:Y.options.mainLoopModel,exceeds200kTokens:y==="plan"&&heA(H)}),x=z02(Q,G),m=void 0,g=!0;try{while(g){g=!1;try{let SA=!1;for await(let yA of dYA({messages:C1A(H,B),systemPrompt:x,maxThinkingTokens:Y.options.maxThinkingTokens,tools:Y.options.tools,signal:Y.abortController.signal,options:{async getToolPermissionContext(){return(await Y.getAppState()).toolPermissionContext},model:h,toolChoice:void 0,isNonInteractiveSession:Y.options.isNonInteractiveSession,fallbackModel:I,sdkBetas:V,onStreamingFallback:()=>{SA=!0},querySource:W,agents:Y.options.agentDefinitions.activeAgents,hasAppendSystemPrompt:Y.options.hasAppendSystemPrompt,maxOutputTokensOverride:K,fetchOverride:m,mcpTools:T.mcp.tools,queryTracking:E,taskIntensityOverride:b10(),agentIdOrSessionId:Y.agentId}})){if(SA){for(let ZA of O)yield{type:"tombstone",message:ZA};r("tengu_orphaned_messages_tombstoned",{orphanedMessageCount:O.length,queryChainId:D,queryDepth:E.depth}),yield*UB1(O,"Streaming fallback triggered"),O.length=0}if(yield yA,yA.type==="assistant"){if(O.push(yA),_){let ZA=yA.message.content.filter((GA)=>GA.type==="tool_use");for(let GA of ZA)_.addTool(GA,yA)}}if(_){for(let ZA of _.getCompletedResults())if(ZA.message)yield ZA.message,q.push(...VY([ZA.message]).filter((GA)=>GA.type==="user"))}}}catch(SA){if(SA instanceof keA&&I){h=I,g=!0,yield*UB1(O,"Model fallback triggered"),O.length=0,Y.options.mainLoopModel=I,r("tengu_model_fallback_triggered",{original_model:SA.originalModel,fallback_model:I,entrypoint:"cli",queryChainId:D,queryDepth:E.depth}),yield YT(`Model fallback triggered: switching from ${SA.originalModel} to ${SA.fallbackModel}`,"info");continue}throw SA}}}catch(SA){s(SA instanceof Error?SA:Error(String(SA)));let yA=SA instanceof Error?SA.message:String(SA);r("tengu_query_error",{assistantMessages:O.length,toolUses:O.flatMap((ZA)=>ZA.message.content.filter((GA)=>GA.type==="tool_use")).length,queryChainId:D,queryDepth:E.depth}),yield*UB1(O,yA),yield fMA({toolUse:!1}),eN("Query error",SA);return}if(O.length>0)P02([...H,...O],Q,B,G,Y,W);if(O.some((SA)=>SA.message.content.some((yA)=>yA.type==="text"&&_02(yA.text))))r("tengu_model_response_keyword_detected",{is_overly_agreeable:!0,queryChainId:D,queryDepth:E.depth});if(Y.abortController.signal.aborted){if(!_)yield*UB1(O,"Interrupted by user");yield fMA({toolUse:!1});return}let p=O.flatMap((SA)=>SA.message.content.filter((yA)=>yA.type==="tool_use"));if(!O.length||!p.length){yield*sH8(H,O,Q,B,G,Z,Y,W,F,I,X),yield*rH8(H,O,Q,B,G,Z,Y,W,F,I);return}let k=!1,c=Y;if(_){r("tengu_streaming_tool_execution_used",{tool_count:p.length,queryChainId:D,queryDepth:E.depth});for await(let SA of _.getRemainingResults()){let yA=SA.message;if(!yA)continue;if(yield yA,yA&&yA.type==="attachment"&&yA.attachment.type==="hook_stopped_continuation")k=!0;q.push(...VY([yA]).filter((ZA)=>ZA.type==="user"))}c={..._.getUpdatedContext(),queryTracking:E}}else{r("tengu_streaming_tool_execution_not_used",{tool_count:p.length,queryChainId:D,queryDepth:E.depth});for await(let SA of iQ0(p,O,Z,Y)){if(SA.message){if(yield SA.message,SA.message.type==="attachment"&&SA.message.attachment.type==="hook_stopped_continuation")k=!0;q.push(...VY([SA.message]).filter((yA)=>yA.type==="user"))}if(SA.newContext)c={...SA.newContext,queryTracking:E}}}if(Y.abortController.signal.aborted){yield fMA({toolUse:!0});return}if(k)return;if(F?.compacted)F.turnCounter++,r("tengu_post_autocompact_turn",{turnId:F.turnId,turnCounter:F.turnCounter,queryChainId:D,queryDepth:E.depth});let AA=[...(await c.getAppState()).queuedCommands],VA=[];r("tengu_query_before_attachments",{messagesForQueryCount:H.length,assistantMessagesCount:O.length,toolResultsCount:q.length,queryChainId:D,queryDepth:E.depth});for await(let SA of uYA(null,c,null,AA,[...H,...O,...q],W))if(yield SA,q.push(SA),DQ1(SA))VA.push(SA);let OA=q.filter((SA)=>SA.type==="attachment"&&SA.attachment.type==="edited_text_file").length;r("tengu_query_after_attachments",{totalToolResultsCount:q.length,fileChangeAttachmentCount:OA,queryChainId:D,queryDepth:E.depth}),f_B(AA,c.setAppState);let EA={...c,pendingSteeringAttachments:VA.length>0?VA:void 0,queryTracking:E};yield*LU({messages:[...H,...O,...q],systemPrompt:Q,userContext:B,systemContext:G,canUseTool:Z,toolUseContext:EA,autoCompactTracking:F,fallbackModel:I,stopHookActive:X,querySource:W})}async function*rH8(A,Q,B,G,Z,Y,J,I,X,W){if(J.pendingSteeringAttachments&&J.pendingSteeringAttachments.length>0){let K=[];for(let V of J.pendingSteeringAttachments){let E=V.attachment;if(E.type==="queued_command"){let D=u0({content:E.prompt,isMeta:!0});K.push(D)}}if(K.length>0){let V={...J,pendingSteeringAttachments:void 0};r("tengu_steering_attachment_resending",{queryChainId:J.queryTracking?.chainId,queryDepth:J.queryTracking?.depth}),yield*LU({messages:[...A,...Q,...K],systemPrompt:B,userContext:G,systemContext:Z,canUseTool:Y,toolUseContext:V,autoCompactTracking:X,fallbackModel:W,querySource:I})}return}}async function*sH8(A,Q,B,G,Z,Y,J,I,X,W,K){let V=Date.now(),E={messages:[...A,...Q],systemPrompt:B,userContext:G,systemContext:Z,toolUseContext:J,querySource:I};if(y02(E),process.env.CLAUDE_CODE_ENABLE_PROMPT_SUGGESTION!=="false")g02(E);try{let D=[],F=(await J.getAppState()).toolPermissionContext.mode,C=AB0(F,J.abortController.signal,void 0,K??!1,J.agentId!==W0()?J.agentId:void 0,J,Q),U="",O=0,q=!1,M="",_=!1,T=[],y=[];for await(let h of C){if(h.message){if(yield h.message,h.message.type==="progress"&&h.message.toolUseID){U=h.message.toolUseID,O++;let x=h.message.data;if(x.command)y.push({command:x.command,promptText:x.promptText})}if(h.message.type==="attachment"){let x=h.message.attachment;if("hookEvent"in x&&(x.hookEvent==="Stop"||x.hookEvent==="SubagentStop")){if(x.type==="hook_non_blocking_error")T.push(x.stderr||`Exit code ${x.exitCode}`),_=!0;else if(x.type==="hook_error_during_execution")T.push(x.content),_=!0;else if(x.type==="hook_success"){if(x.stdout&&x.stdout.trim()||x.stderr&&x.stderr.trim())_=!0}}}}if(h.blockingError){let x=u0({content:rQ0(h.blockingError),isMeta:!0});D.push(x),yield x,_=!0,T.push(h.blockingError.blockingError)}if(h.preventContinuation)q=!0,M=h.stopReason||"Stop hook prevented continuation",yield A4({type:"hook_stopped_continuation",message:M,hookName:"Stop",toolUseID:U,hookEvent:"Stop"});if(J.abortController.signal.aborted){r("tengu_pre_stop_hooks_cancelled",{queryChainId:J.queryTracking?.chainId,queryDepth:J.queryTracking?.depth}),yield fMA({toolUse:!1});return}}if(O>0){if(yield p02(O,y,T,q,M,_,"suggestion",U),T.length>0)J.addNotification?.({key:"stop-hook-error",text:"Stop hook error occurred ¬∑ ctrl+o to see",priority:"immediate"})}if(q)return;if(D.length>0)yield*LU({messages:[...A,...Q,...D],systemPrompt:B,userContext:G,systemContext:Z,canUseTool:Y,toolUseContext:J,autoCompactTracking:X,fallbackModel:W,stopHookActive:!0,querySource:I})}catch(D){let H=Date.now()-V;r("tengu_stop_hook_error",{duration:H,queryChainId:J.queryTracking?.chainId,queryDepth:J.queryTracking?.depth}),yield YT(`Stop hook failed: ${D instanceof Error?D.message:String(D)}`,"warning")}}async function*iQ0(A,Q,B,G){let Z=G;for(let{isConcurrencySafe:Y,blocks:J}of tH8(A,Z))if(Y){let I={};for await(let X of AF8(J,Q,B,Z)){if(X.contextModifier){let{toolUseID:W,modifyContext:K}=X.contextModifier;if(!I[W])I[W]=[];I[W].push(K)}yield{message:X.message,newContext:Z}}for(let X of J){let W=I[X.id];if(!W)continue;for(let K of W)Z=K(Z)}yield{newContext:Z}}else for await(let I of eH8(J,Q,B,Z)){if(I.newContext)Z=I.newContext;yield{message:I.message,newContext:Z}}}function tH8(A,Q){return A.reduce((B,G)=>{let Z=Q.options.tools.find((I)=>I.name===G.name),Y=Z?.inputSchema.safeParse(G.input),J=Y?.success?Boolean(Z?.isConcurrencySafe(Y.data)):!1;if(J&&B[B.length-1]?.isConcurrencySafe)B[B.length-1].blocks.push(G);else B.push({isConcurrencySafe:J,blocks:[G]});return B},[])}async function*eH8(A,Q,B,G){let Z=G;for(let Y of A){G.setInProgressToolUseIDs((J)=>new Set([...J,Y.id]));for await(let J of WB1(Y,Q.find((I)=>I.message.content.some((X)=>X.type==="tool_use"&&X.id===Y.id)),B,Z)){if(J.contextModifier)Z=J.contextModifier.modifyContext(Z);yield{message:J.message,newContext:Z}}d02(G,Y.id)}}async function*AF8(A,Q,B,G){yield*GJA(A.map(async function*(Z){G.setInProgressToolUseIDs((Y)=>new Set([...Y,Z.id])),yield*WB1(Z,Q.find((Y)=>Y.message.content.some((J)=>J.type==="tool_use"&&J.id===Z.id)),B,G),d02(G,Z.id)}),oH8())}function d02(A,Q){A.setInProgressToolUseIDs((B)=>new Set([...B].filter((G)=>G!==Q)))}function QF8(A,Q){if(!A.startsWith("mcp__"))return;let B=KV(A);if(!B)return;let G=Q.find((Z)=>Z.name===B.serverName);if(G?.type==="connected")return G.config.type??"stdio";return}async function*WB1(A,Q,B,G){let Z=A.name,Y=AiQ(G.options.tools,Z),J=Q.message.id,I=Q.requestId,X=QF8(Z,G.options.mcpClients);if(!Y){r("tengu_tool_use_error",{error:`No such tool available: ${Z}`,toolName:Z,toolUseID:A.id,isMcp:Z.startsWith("mcp__"),queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}}),yield{message:u0({content:[{type:"tool_result",content:`<tool_use_error>Error: No such tool available: ${Z}</tool_use_error>`,is_error:!0,tool_use_id:A.id}],toolUseResult:`Error: No such tool available: ${Z}`})};return}let W=A.input;try{if(G.abortController.signal.aborted){r("tengu_tool_use_cancelled",{toolName:Y.name,toolUseID:A.id,isMcp:Y.isMcp??!1,queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}});let K=aQ0(A.id);yield{message:u0({content:[K],toolUseResult:ZJA})};return}for await(let K of BF8(Y,A.id,W,G,B,Q,J,I,X))yield K}catch(K){s(K instanceof Error?K:Error(String(K)));let V=K instanceof Error?K.message:String(K),D=`Error calling tool${Y?` (${Y.name})`:""}: ${V}`;yield{message:u0({content:[{type:"tool_result",content:`<tool_use_error>${D}</tool_use_error>`,is_error:!0,tool_use_id:A.id}],toolUseResult:D})}}}function BF8(A,Q,B,G,Z,Y,J,I,X){let W=new kMA;return GF8(A,Q,B,G,Z,Y,J,I,X,(K)=>{r("tengu_tool_use_progress",{messageID:J,toolName:A.name,isMcp:A.isMcp??!1,queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}}),W.enqueue({message:c02({toolUseID:K.toolUseID,parentToolUseID:Q,data:K.data})})}).then((K)=>{for(let V of K)W.enqueue(V)}).catch((K)=>{W.error(K)}).finally(()=>{W.done()}),W}async function GF8(A,Q,B,G,Z,Y,J,I,X,W){let K=A.inputSchema.safeParse(B);if(!K.success){let T=IF8(A.name,K.error);return r("tengu_tool_use_error",{error:"InputValidationError",errorDetails:T.slice(0,2000),messageID:J,toolName:A.name,isMcp:A.isMcp??!1,queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}}),[{message:u0({content:[{type:"tool_result",content:`<tool_use_error>InputValidationError: ${T}</tool_use_error>`,is_error:!0,tool_use_id:Q}],toolUseResult:`InputValidationError: ${K.error.message}`})}]}let V=await A.validateInput?.(K.data,G);if(V?.result===!1)return r("tengu_tool_use_error",{messageID:J,toolName:A.name,error:V.message,errorCode:V.errorCode,isMcp:A.isMcp??!1,queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}}),[{message:u0({content:[{type:"tool_result",content:`<tool_use_error>${V.message}</tool_use_error>`,is_error:!0,tool_use_id:Q}],toolUseResult:`Error: ${V.message}`})}];let E=[],D=K.data,H=!1,F,C;for await(let T of JF8(G,A,D,Q,Y.message.id,I,X))switch(T.type){case"message":if(T.message.message.type==="progress")W(T.message.message);else E.push(T.message);break;case"hookPermissionResult":C=T.hookPermissionResult;break;case"preventContinuation":H=T.shouldPreventContinuation;break;case"stopReason":F=T.stopReason;break;case"stop":return E.push({message:u0({content:[aQ0(Q)],toolUseResult:`Error: ${F}`})}),E}let U={};if(D&&typeof D==="object"){if(A.name===L8&&"file_path"in D)U.file_path=String(D.file_path);else if((A.name===m3||A.name===sX)&&"file_path"in D)U.file_path=String(D.file_path);else if(A.name===e9&&"command"in D){let T=D;U.full_command=T.command}}RiB(A.name,U),_iB();let O;if(C!==void 0&&C.behavior==="allow"&&!A.requiresUserInteraction?.())f(`Hook approved tool use for ${A.name}, bypassing permission check`),O=C;else if(C!==void 0&&C.behavior==="allow"&&A.requiresUserInteraction?.())f(`Hook approved tool use for ${A.name}, but tool requires user interaction`),O=await Z(A,D,G,Y,Q);else if(C!==void 0&&C.behavior==="deny")f(`Hook denied tool use for ${A.name}`),O=C;else{let T=C?.behavior==="ask"?C:void 0;O=await Z(A,D,G,Y,Q,T)}if(O.decisionReason?.type==="hook"&&O.decisionReason.hookName==="PermissionRequest"&&O.behavior!=="ask")E.push({message:A4({type:"hook_permission_decision",decision:O.behavior,toolUseID:Q,hookEvent:"PermissionRequest"})});if(O.behavior!=="allow"){let T=G.toolDecisions?.get(Q);AA0("reject",T?.source||"unknown"),M01(),r("tengu_tool_use_can_use_tool_rejected",{messageID:J,toolName:A.name,queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}});let y=O.message;if(H&&!y)y=`Execution stopped by PreToolUse hook${F?`: ${F}`:""}`;return E.push({message:u0({content:[{type:"tool_result",content:y,is_error:!0,tool_use_id:Q}],toolUseResult:`Error: ${y}`})}),E}r("tengu_tool_use_can_use_tool_allowed",{messageID:J,toolName:A.name,queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}}),D=O.updatedInput;let q={};if(A.name===e9&&"command"in D){let T=D;q={bash_command:T.command.trim().split(/\s+/)[0]||"",full_command:T.command,...T.timeout!==void 0&&{timeout:T.timeout},...T.description!==void 0&&{description:T.description},..."dangerouslyDisableSandbox"in T&&{dangerouslyDisableSandbox:T.dangerouslyDisableSandbox}}}let M=G.toolDecisions?.get(Q);AA0(M?.decision||"unknown",M?.source||"unknown"),TiB();let _=Date.now();try{let T=await A.call(D,{...G,userModified:O.userModified??!1},Z,Y,(c)=>{r("tengu_tool_use_progress",{messageID:Y.message.id,toolName:A.name,isMcp:A.isMcp??!1,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}}),W({toolUseID:c.toolUseID,data:c.data})}),y=Date.now()-_;if(vG1(y),T.data&&typeof T.data==="object"){let c={};if(A.name===L8&&"content"in T.data){if("file_path"in D)c.file_path=String(D.file_path);c.content=String(T.data.content)}if((A.name===m3||A.name===sX)&&"file_path"in D){if(c.file_path=String(D.file_path),A.name===m3&&"diff"in T.data)c.diff=String(T.data.diff);if(A.name===sX&&"content"in D)c.content=String(D.content)}if(A.name===e9&&"command"in D){let e=D;if(c.bash_command=e.command,"output"in T.data)c.output=String(T.data.output)}if(Object.keys(c).length>0)jiB("tool.output",c)}if(typeof T==="object"&&"structured_output"in T)E.push({message:A4({type:"structured_output",data:T.structured_output})});QA0({success:!0});let h=T.data&&typeof T.data==="object"?JSON.stringify(T.data):String(T.data??"");M01(h);let x=0;try{x=JSON.stringify(T.data).length}catch(c){s(c instanceof Error?c:Error(String(c)))}r("tengu_tool_use_success",{messageID:J,toolName:A.name,isMcp:A.isMcp??!1,durationMs:y,toolResultSizeBytes:x,queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}});let m=wM(A)?lQ0(A.name):null;zU("tool_result",{tool_name:A.name,success:"true",duration_ms:String(y),...Object.keys(q).length>0&&{tool_parameters:JSON.stringify(q)},tool_result_size_bytes:String(x),...M&&{decision_source:M.source,decision_type:M.decision},...m&&{mcp_server_scope:m}});let g=T.data,t=[],p=T.contextModifier;async function k(c){E.push({message:u0({content:[await MRB(A,c,Q)],toolUseResult:c}),contextModifier:p?{toolUseID:Q,modifyContext:p}:void 0})}if(!wM(A))await k(g);for await(let c of ZF8(G,A,Q,Y.message.id,O,g,I,X))if("updatedMCPToolOutput"in c){if(wM(A))g=c.updatedMCPToolOutput}else if(wM(A))t.push(c);else E.push(c);if(wM(A))await k(g);if(T.newMessages&&T.newMessages.length>0)for(let c of T.newMessages)E.push({message:c});if(H)E.push({message:A4({type:"hook_stopped_continuation",message:F||"Execution stopped by hook",hookName:`PreToolUse:${A.name}`,toolUseID:Q,hookEvent:"PreToolUse"})});for(let c of t)E.push(c);return E}catch(T){let y=Date.now()-_;if(vG1(y),QA0({success:!1,error:T instanceof Error?T.message:String(T)}),M01(),!(T instanceof UJ)){if(!(T instanceof uj))s(T instanceof Error?T:Error(String(T)));r("tengu_tool_use_error",{messageID:J,toolName:A.name,error:T instanceof Error?T.constructor.name:"UnknownError",isMcp:A.isMcp??!1,queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}});let g=wM(A)?lQ0(A.name):null;zU("tool_result",{tool_name:A.name,use_id:Q,success:"false",duration_ms:String(y),error:T instanceof Error?T.message:String(T),...Object.keys(q).length>0&&{tool_parameters:JSON.stringify(q)},...M&&{decision_source:M.source,decision_type:M.decision},...g&&{mcp_server_scope:g}})}let h=$B1(T),x=T instanceof UJ,m=[];for await(let g of YF8(G,A,Q,J,D,h,x,I,X))m.push(g);return[{message:u0({content:[{type:"tool_result",content:h,is_error:!0,tool_use_id:Q}],toolUseResult:`Error: ${h}`})},...m]}finally{if(M)G.toolDecisions?.delete(Q)}}async function*ZF8(A,Q,B,G,Z,Y,J,I){let X=Date.now();try{let K=(await A.getAppState()).toolPermissionContext.mode,V=Y;for await(let E of tQ0(Q.name,B,Z.updatedInput,V,A,K,A.abortController.signal))try{if(E.message?.type==="attachment"&&E.message.attachment.type==="hook_cancelled"){r("tengu_post_tool_hooks_cancelled",{toolName:Q.name,queryChainId:A.queryTracking?.chainId,queryDepth:A.queryTracking?.depth}),yield{message:A4({type:"hook_cancelled",hookName:`PostToolUse:${Q.name}`,toolUseID:B,hookEvent:"PostToolUse"})};continue}if(E.message)yield{message:E.message};if(E.blockingError)yield{message:A4({type:"hook_blocking_error",hookName:`PostToolUse:${Q.name}`,toolUseID:B,hookEvent:"PostToolUse",blockingError:E.blockingError})};if(E.preventContinuation){yield{message:A4({type:"hook_stopped_continuation",message:E.stopReason||"Execution stopped by PostToolUse hook",hookName:`PostToolUse:${Q.name}`,toolUseID:B,hookEvent:"PostToolUse"})};return}if(E.additionalContexts&&E.additionalContexts.length>0)yield{message:A4({type:"hook_additional_context",content:E.additionalContexts,hookName:`PostToolUse:${Q.name}`,toolUseID:B,hookEvent:"PostToolUse"})};if(E.updatedMCPToolOutput&&wM(Q))V=E.updatedMCPToolOutput,yield{updatedMCPToolOutput:V}}catch(D){let H=Date.now()-X;r("tengu_post_tool_hook_error",{messageID:G,toolName:Q.name,isMcp:Q.isMcp??!1,duration:H,queryChainId:A.queryTracking?.chainId,queryDepth:A.queryTracking?.depth,...I?{mcpServerType:I}:{},...J?{requestId:J}:{}}),yield{message:A4({type:"hook_error_during_execution",content:$B1(D),hookName:`PostToolUse:${Q.name}`,toolUseID:B,hookEvent:"PostToolUse"})}}}catch(W){s(W instanceof Error?W:Error(String(W)))}}async function*YF8(A,Q,B,G,Z,Y,J,I,X){let W=Date.now();try{let V=(await A.getAppState()).toolPermissionContext.mode;for await(let E of eQ0(Q.name,B,Z,Y,A,J,V,A.abortController.signal))try{if(E.message?.type==="attachment"&&E.message.attachment.type==="hook_cancelled"){r("tengu_post_tool_failure_hooks_cancelled",{toolName:Q.name,queryChainId:A.queryTracking?.chainId,queryDepth:A.queryTracking?.depth}),yield{message:A4({type:"hook_cancelled",hookName:`PostToolUseFailure:${Q.name}`,toolUseID:B,hookEvent:"PostToolUseFailure"})};continue}if(E.message)yield{message:E.message};if(E.blockingError)yield{message:A4({type:"hook_blocking_error",hookName:`PostToolUseFailure:${Q.name}`,toolUseID:B,hookEvent:"PostToolUseFailure",blockingError:E.blockingError})};if(E.additionalContexts&&E.additionalContexts.length>0)yield{message:A4({type:"hook_additional_context",content:E.additionalContexts,hookName:`PostToolUseFailure:${Q.name}`,toolUseID:B,hookEvent:"PostToolUseFailure"})}}catch(D){let H=Date.now()-W;r("tengu_post_tool_failure_hook_error",{messageID:G,toolName:Q.name,isMcp:Q.isMcp??!1,duration:H,queryChainId:A.queryTracking?.chainId,queryDepth:A.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}}),yield{message:A4({type:"hook_error_during_execution",content:$B1(D),hookName:`PostToolUseFailure:${Q.name}`,toolUseID:B,hookEvent:"PostToolUseFailure"})}}}catch(K){s(K instanceof Error?K:Error(String(K)))}}async function*JF8(A,Q,B,G,Z,Y,J){let I=Date.now();try{let X=await A.getAppState();for await(let W of sQ0(Q.name,G,B,A,X.toolPermissionContext.mode,A.abortController.signal))try{if(W.message)yield{type:"message",message:{message:W.message}};if(W.blockingError){let K=oQ0(`PreToolUse:${Q.name}`,W.blockingError);yield{type:"hookPermissionResult",hookPermissionResult:{behavior:"deny",message:K,decisionReason:{type:"hook",hookName:`PreToolUse:${Q.name}`,reason:K}}}}if(W.preventContinuation){if(yield{type:"preventContinuation",shouldPreventContinuation:!0},W.stopReason)yield{type:"stopReason",stopReason:W.stopReason}}if(W.permissionBehavior!==void 0){f(`Hook result has permissionBehavior=${W.permissionBehavior}`);let K={type:"hook",hookName:`PreToolUse:${Q.name}`,reason:W.hookPermissionDecisionReason};if(W.permissionBehavior==="allow")yield{type:"hookPermissionResult",hookPermissionResult:{behavior:"allow",updatedInput:W.updatedInput||B,decisionReason:K}};else yield{type:"hookPermissionResult",hookPermissionResult:{behavior:W.permissionBehavior,message:W.hookPermissionDecisionReason||`Hook PreToolUse:${Q.name} ${fRB(W.permissionBehavior)} this tool`,decisionReason:K}}}if(A.abortController.signal.aborted){r("tengu_pre_tool_hooks_cancelled",{toolName:Q.name,queryChainId:A.queryTracking?.chainId,queryDepth:A.queryTracking?.depth}),yield{type:"message",message:{message:A4({type:"hook_cancelled",hookName:`PreToolUse:${Q.name}`,toolUseID:G,hookEvent:"PreToolUse"})}},yield{type:"stop"};return}}catch(K){s(K instanceof Error?K:Error(String(K)));let V=Date.now()-I;r("tengu_pre_tool_hook_error",{messageID:Z,toolName:Q.name,isMcp:Q.isMcp??!1,duration:V,queryChainId:A.queryTracking?.chainId,queryDepth:A.queryTracking?.depth,...J?{mcpServerType:J}:{},...Y?{requestId:Y}:{}}),yield{type:"message",message:{message:A4({type:"hook_error_during_execution",content:$B1(K),hookName:`PreToolUse:${Q.name}`,toolUseID:G,hookEvent:"PreToolUse"})}},yield{type:"stop"}}}catch(X){s(X instanceof Error?X:Error(String(X))),yield{type:"stop"};return}}function $B1(A){if(A instanceof UJ)return A.message||NM;if(!(A instanceof Error))return String(A);let B=nQ0(A).filter(Boolean).join(`
bundles/ClaudeCodeCode/cli.js:1993:`))return!0;let B=Q.indexOf("#");if(B!==-1&&!(B>0&&Q[B-1]==="s"))return!0;if(/^!/.test(Q)||/[/\d$]!/.test(Q))return!0;if(/\d\s*~\s*\d|,\s*~\s*\d|\$\s*~\s*\d/.test(Q))return!0;if(/^,/.test(Q))return!0;if(/,\s*[+-]/.test(Q))return!0;if(/s\\/.test(Q)||/\\[|#%@]/.test(Q))return!0;if(/\\\/.*[wW]/.test(Q))return!0;if(/\/[^/]*\s+[wWeE]/.test(Q))return!0;if(/^s\//.test(Q)&&!/^s\/[^/]*\/[^/]*\/[^/]*$/.test(Q))return!0;if(/^s./.test(Q)&&/[wWeE]$/.test(Q)){if(!/^s([^\\\n]).*?\1.*?\1[^wWeE]*$/.test(Q))return!0}if(/^[wW]\s*\S+/.test(Q)||/^\d+\s*[wW]\s*\S+/.test(Q)||/^\$\s*[wW]\s*\S+/.test(Q)||/^\/[^/]*\/[IMim]*\s*[wW]\s*\S+/.test(Q)||/^\d+,\d+\s*[wW]\s*\S+/.test(Q)||/^\d+,\$\s*[wW]\s*\S+/.test(Q)||/^\/[^/]*\/[IMim]*,\/[^/]*\/[IMim]*\s*[wW]\s*\S+/.test(Q))return!0;if(/^e/.test(Q)||/^\d+\s*e/.test(Q)||/^\$\s*e/.test(Q)||/^\/[^/]*\/[IMim]*\s*e/.test(Q)||/^\d+,\d+\s*e/.test(Q)||/^\d+,\$\s*e/.test(Q)||/^\/[^/]*\/[IMim]*,\/[^/]*\/[IMim]*\s*e/.test(Q))return!0;let G=Q.match(/s([^\\\n]).*?\1.*?\1(.*?)$/);if(G){let Y=G[2]||"";if(Y.includes("w")||Y.includes("W"))return!0;if(Y.includes("e")||Y.includes("E"))return!0}if(Q.match(/y([^\\\n])/)){if(/[wWeE]/.test(Q))return!0}return!1}function yB2(A,Q){let B=TV(A.command);for(let G of B){let Z=G.trim();if(Z.split(/\s+/)[0]!=="sed")continue;let J=Q.mode==="acceptEdits";if(!SB0(Z,{allowFileWrites:J}))return{behavior:"ask",message:"sed command requires approval (contains potentially dangerous operations)",decisionReason:{type:"other",reason:"sed command contains operations that require explicit approval (e.g., write commands, execute commands)"}}}return{behavior:"passthrough",message:"No dangerous sed operations detected"}}var xB0=L(()=>{RU();QE()});function vB0(A){return[{type:"addRules",rules:[{toolName:Q4.name,ruleContent:A}],behavior:"allow",destination:"localSettings"}]}function zz8(A){return[{type:"addRules",rules:[{toolName:Q4.name,ruleContent:`${A}:*`}],behavior:"allow",destination:"localSettings"}]}function vB2(A){return/^[a-zA-Z0-9_-]{1,64}$/.test(A)}function kB2(A){return[{type:"addRules",rules:[{toolName:A,ruleContent:void 0}],behavior:"allow",destination:"localSettings"}]}function Uz8(A,Q){let B=L1A(A);if(!B)return null;try{if(TV(A).length>1)return null}catch{return null}let{server:G,toolName:Z}=B;if(!vB2(G)||!vB2(Z))return{behavior:"deny",message:"Invalid MCP server or tool name. Names must contain only letters, numbers, hyphens, and underscores.",decisionReason:{type:"other",reason:"Security: Invalid characters in MCP identifier"}};let Y=`mcp__${G}__${Z}`,J={name:Y},I=dB0(Q,J);if(I)return{behavior:"deny",message:`MCP tool ${G}/${Z} has been denied`,decisionReason:{type:"rule",rule:I}};let X=cB0(Q,J);if(X)return{behavior:"ask",message:JK(Y),decisionReason:{type:"rule",rule:X},suggestions:kB2(Y)};let W=mB0(Q,J);if(W)return{behavior:"allow",updatedInput:{command:A},decisionReason:{type:"rule",rule:W}};return{behavior:"ask",message:JK(Y),decisionReason:{type:"other",reason:"MCP tool requires permission"},suggestions:kB2(Y)}}function fB0(A){let Q=kB0(A);if(Q!==null)return{type:"prefix",prefix:Q};else return{type:"exact",command:A}}function yB0(A,Q,B){let G=A.command.trim(),Z=UT(G).commandWithoutRedirections,J=(B==="exact"?[G,Z]:[Z]).flatMap((I)=>{return process.env.ENABLE_BASH_WRAPPER_MATCHING||process.env.ENABLE_BASH_ENV_VAR_MATCHING,[I]});return Array.from(Q.entries()).filter(([I])=>{let X=fB0(I);return J.some((W)=>{switch(X.type){case"exact":return X.command===W;case"prefix":switch(B){case"exact":return X.prefix===W;case"prefix":if(W===X.prefix)return!0;return W.startsWith(X.prefix+" ")}}})}).map(([,I])=>I)}function bB0(A,Q,B){let G=jU(Q,Q4,"deny"),Z=yB0(A,G,B),Y=jU(Q,Q4,"ask"),J=yB0(A,Y,B),I=jU(Q,Q4,"allow"),X=yB0(A,I,B);return{matchingDenyRules:Z,matchingAskRules:J,matchingAllowRules:X}}function fB2(A,Q,B,G){let Z=hB0(A,Q);if(Z.behavior!=="passthrough")return Z;let Y=bB2(A,Q,G);if(Y.behavior==="deny"||Y.behavior==="ask")return Y;if(!z0(process.env.CLAUDE_CODE_DISABLE_COMMAND_INJECTION_CHECK)){let I=Ui(A.command);if(I.behavior!=="passthrough"){let X={type:"other",reason:I.behavior==="ask"&&I.message?I.message:"This command contains patterns that could pose security risks and requires approval"};return{behavior:"ask",message:JK(Q4.name,X),decisionReason:X,suggestions:[]}}}if(Y.behavior==="allow")return Y;let J=B?.commandPrefix?zz8(B.commandPrefix):vB0(A.command);return{...Y,suggestions:J}}function $z8(A,Q){let B=A.command.trim(),{matchingDenyRules:G,matchingAskRules:Z}=bB0(A,Q,"prefix");if(G[0]!==void 0)return{behavior:"deny",message:`Permission to use ${Q4.name} with command ${B} has been denied.`,decisionReason:{type:"rule",rule:G[0]}};if(Z[0]!==void 0)return{behavior:"ask",message:JK(Q4.name),decisionReason:{type:"rule",rule:Z[0]}};return{behavior:"allow",updatedInput:A,decisionReason:{type:"other",reason:"Auto-allowed with sandbox (autoAllowBashIfSandboxed enabled)"}}}async function gB0(A,Q,B=hB2){let G=await Q.getAppState(),Z=mI(A.command);if(!Z.success){let M={type:"other",reason:`Command contains malformed syntax that cannot be parsed: ${Z.error}`};return{behavior:"ask",decisionReason:M,message:JK(Q4.name,M)}}if(NB.isSandboxingEnabled()&&NB.isAutoAllowBashIfSandboxedEnabled()&&HJA(A)){let M=$z8(A,G.toolPermissionContext);if(M.behavior!=="passthrough")return M}let Y=hB0(A,G.toolPermissionContext);if(Y.behavior==="deny")return Y;let J=await $B2(A,(M)=>gB0(M,Q,B));if(J.behavior!=="passthrough")return J;let I=TV(A.command).filter((M)=>{if(M===`cd ${r1()}`)return!1;return!0}),X=I.filter((M)=>M.startsWith("cd "));if(X.length>1){let M={type:"other",reason:"Multiple directory changes in one command require approval for clarity"};return{behavior:"ask",decisionReason:M,message:JK(Q4.name,M)}}let W=X.length>0;G=await Q.getAppState();let K=I.map((M)=>{let _=Uz8(M,G.toolPermissionContext);if(_!==null)return _;return bB2({command:M},G.toolPermissionContext,W)});if(K.find((M)=>M.behavior==="deny")!==void 0)return{behavior:"deny",message:`Permission to use ${Q4.name} with command ${A.command} has been denied.`,decisionReason:{type:"subcommandResults",reasons:new Map(K.map((M,_)=>[I[_],M]))}};let E=jB0(A,r1(),G.toolPermissionContext,W);if(E.behavior!=="passthrough")return E;let D=K.find((M)=>M.behavior==="ask");if(D!==void 0)return D;if(Y.behavior==="allow")return Y;let H=z0(process.env.CLAUDE_CODE_DISABLE_COMMAND_INJECTION_CHECK)?!1:I.some((M)=>Ui(M).behavior!=="passthrough");if(K.every((M)=>M.behavior==="allow")&&!H)return{behavior:"allow",updatedInput:A,decisionReason:{type:"subcommandResults",reasons:new Map(K.map((M,_)=>[I[_],M]))}};let F=await B(A.command,Q.abortController.signal,Q.options.isNonInteractiveSession);if(Q.abortController.signal.aborted)throw new UJ;if(G=await Q.getAppState(),I.length===1)return fB2({command:I[0]},G.toolPermissionContext,F,W);let C=new Map;for(let M of I)C.set(M,fB2({...A,command:M},G.toolPermissionContext,F?.subcommandPrefixes.get(M),W));if(I.every((M)=>{return C.get(M)?.behavior==="allow"}))return{behavior:"allow",updatedInput:A,decisionReason:{type:"subcommandResults",reasons:C}};let U=new Map;for(let M of C.values())if(M.behavior==="ask"||M.behavior==="passthrough"){let _="suggestions"in M?M.suggestions:void 0,T=E8A(_);for(let y of T){let h=B5(y);U.set(h,y)}}let O={type:"subcommandResults",reasons:C},q=U.size>0?[{type:"addRules",rules:Array.from(U.values()),behavior:"allow",destination:"localSettings"}]:void 0;return{behavior:"passthrough",message:JK(Q4.name,O),decisionReason:O,suggestions:q}}var kB0=(A)=>{return A.match(/^(.+):\*$/)?.[1]??null},hB0=(A,Q)=>{let B=A.command.trim(),{matchingDenyRules:G,matchingAskRules:Z,matchingAllowRules:Y}=bB0(A,Q,"exact");if(G[0]!==void 0)return{behavior:"deny",message:`Permission to use ${Q4.name} with command ${B} has been denied.`,decisionReason:{type:"rule",rule:G[0]}};if(Z[0]!==void 0)return{behavior:"ask",message:JK(Q4.name),decisionReason:{type:"rule",rule:Z[0]}};if(Y[0]!==void 0)return{behavior:"allow",updatedInput:A,decisionReason:{type:"rule",rule:Y[0]}};let J={type:"other",reason:"This command requires approval"};return{behavior:"passthrough",message:JK(Q4.name,J),decisionReason:J,suggestions:vB0(B)}},bB2=(A,Q,B)=>{let G=A.command.trim(),Z=hB0(A,Q);if(Z.behavior==="deny"||Z.behavior==="ask")return Z;let{matchingDenyRules:Y,matchingAskRules:J,matchingAllowRules:I}=bB0(A,Q,"prefix");if(Y[0]!==void 0)return{behavior:"deny",message:`Permission to use ${Q4.name} with command ${G} has been denied.`,decisionReason:{type:"rule",rule:Y[0]}};if(J[0]!==void 0)return{behavior:"ask",message:JK(Q4.name),decisionReason:{type:"rule",rule:J[0]}};let X=jB0(A,r1(),Q,B);if(X.behavior!=="passthrough")return X;if(Z.behavior==="allow")return Z;if(I[0]!==void 0)return{behavior:"allow",updatedInput:A,decisionReason:{type:"rule",rule:I[0]}};let W=yB2(A,Q);if(W.behavior!=="passthrough")return W;let K=jB2(A,Q);if(K.behavior!=="passthrough")return K;if(Q4.isReadOnly(A))return{behavior:"allow",updatedInput:A,decisionReason:{type:"other",reason:"Read-only command is allowed"}};let V={type:"other",reason:"This command requires approval"};return{behavior:"passthrough",message:JK(Q4.name,V),decisionReason:V,suggestions:vB0(G)}};var uB0=L(()=>{pE();XI();pB1();RU();QE();eZ();pB();tK();oG();wB2();rQ();TB2();RU();PB2();xB0();CV()});import*as eB1 from"path";function wz8(A){switch(A.length){case 0:return"";case 1:return cA.bold(A[0]);case 2:return cA.bold(A[0])+" and "+cA.bold(A[1]);default:return cA.bold(A.slice(0,-1).join(", "))+", and "+cA.bold(A.slice(-1)[0])}}function gB2(A){let Q=wz8(A);if(Q.length>50)return"similar";else return Q}function tB1(A){if(A.length===0)return"";let Q=A.map((B)=>{let G=B.split("/").pop()||B;return cA.bold(G)+eB1.sep});if(Q.length===1)return Q[0];if(Q.length===2)return`${Q[0]} and ${Q[1]}`;return`${Q[0]}, ${Q[1]} and ${A.length-2} more`}function Nz8(A){let Q=A.filter((K)=>K.type==="addRules").flatMap((K)=>K.rules||[]),B=Q.filter((K)=>K.toolName==="Read"),G=Q.filter((K)=>K.toolName==="Bash"),Z=A.filter((K)=>K.type==="addDirectories").flatMap((K)=>K.directories||[]),Y=B.map((K)=>K.ruleContent?.replace("/**","")||"").filter((K)=>K),J=G.flatMap((K)=>{if(!K.ruleContent)return[];let V=kB0(K.ruleContent)??K.ruleContent,{commandWithoutRedirections:E,redirections:D}=UT(V);return D.length>0?E:V}),I=Z.length>0,X=Y.length>0,W=J.length>0;if(X&&!I&&!W){if(Y.length===1){let K=Y[0],V=K.split("/").pop()||K;return`Yes, allow reading from ${cA.bold(V)}${eB1.sep} from this project`}return`Yes, allow reading from ${tB1(Y)} from this project`}if(I&&!X&&!W){if(Z.length===1){let K=Z[0],V=K.split("/").pop()||K;return`Yes, and always allow access to ${cA.bold(V)}${eB1.sep} from this project`}return`Yes, and always allow access to ${tB1(Z)} from this project`}if(W&&!I&&!X)return`Yes, and don't ask again for ${gB2(J)} commands in ${cA.bold(pQ())}`;if((I||X)&&!W){let K=[...Z,...Y];if(I&&X)return`Yes, and always allow access to ${tB1(K)} from this project`}if((I||X)&&W){let K=[...Z,...Y],V=tB1(K),E=gB2(J);if(K.length===1&&J.length===1)return`Yes, and allow access to ${V} and ${E} commands`;return`Yes, and allow ${V} access and ${E} commands`}return null}function uB2({suggestions:A=[],onRejectFeedbackChange:Q}){let B=[{label:"Yes",value:"yes"}];if(A.length>0){let G=Nz8(A);if(G)B.push({label:G,value:"yes-apply-suggestions"})}return B.push({type:"input",label:"No",value:"no",placeholder:"Type here to tell Claude what to do differently",onChange:Q}),B}var mB2=L(()=>{t2();g0();uB0();RU()});function dB2(A){switch(A.type){case"rule":return`${cA.bold(B5(A.rule.ruleValue))} rule from ${dcA(A.rule.source)}`;case"mode":return`${Bf(A.mode)} mode`;case"sandboxOverride":return"Requires permission to bypass sandbox";case"workingDir":return A.reason;case"other":return A.reason;case"permissionPromptTool":return`${cA.bold(A.permissionPromptToolName)} permission prompt tool`;case"hook":return A.reason?`${cA.bold(A.hookName)} hook: ${A.reason}`:`${cA.bold(A.hookName)} hook`;case"asyncAgent":return A.reason;case"classifier":return`${cA.bold(A.classifier)} classifier: ${A.reason}`}}function qz8({title:A,decisionReason:Q}){let[B]=I2();function G(){switch(Q.type){case"subcommandResults":return z4.default.createElement(j,{flexDirection:"column"},Array.from(Q.reasons.entries()).map(([Z,Y])=>{let J=Y.behavior==="allow"?vB("success",B)(X1.tick):vB("error",B)(X1.cross);return z4.default.createElement(j,{flexDirection:"column",key:Z},z4.default.createElement(z,null,J," ",Z),Y.decisionReason!==void 0&&Y.decisionReason.type!=="subcommandResults"&&z4.default.createElement(z,null,"  ","‚éø","  ",dB2(Y.decisionReason)),Y.behavior==="ask"&&(()=>{let I=E8A(Y.suggestions);return I.length>0?z4.default.createElement(z,null,"  ","‚éø","  ","Suggested rules:"," ",I.map((X)=>cA.bold(B5(X))).join(", ")):null})())}));default:return z4.default.createElement(z,null,dB2(Q))}}return z4.default.createElement(j,{flexDirection:"column"},A&&z4.default.createElement(z,null,A),G())}function Lz8(A){if(!A)return[];return A.flatMap((Q)=>{switch(Q.type){case"addDirectories":return Q.directories;default:return[]}})}function Mz8(A){if(!A)return;for(let Q=A.length-1;Q>=0;Q--){let B=A[Q];if(B?.type==="setMode")return B.mode}return}function Oz8({suggestions:A,width:Q}){if(!A||A.length===0)return z4.default.createElement(j,{flexDirection:"row"},z4.default.createElement(j,{justifyContent:"flex-end",minWidth:Q},z4.default.createElement(z,{dimColor:!0},"Suggestions ")),z4.default.createElement(z,null,"None"));let B=E8A(A),G=Lz8(A),Z=Mz8(A);if(B.length===0&&G.length===0&&!Z)return z4.default.createElement(j,{flexDirection:"row"},z4.default.createElement(j,{justifyContent:"flex-end",minWidth:Q},z4.default.createElement(z,{dimColor:!0},"Suggestion ")),z4.default.createElement(z,null,"None"));return z4.default.createElement(j,{flexDirection:"column"},z4.default.createElement(j,{flexDirection:"row"},z4.default.createElement(j,{justifyContent:"flex-end",minWidth:Q},z4.default.createElement(z,{dimColor:!0},"Suggestions ")),z4.default.createElement(z,null," ")),B.length>0&&z4.default.createElement(j,{flexDirection:"row"},z4.default.createElement(j,{justifyContent:"flex-end",minWidth:Q},z4.default.createElement(z,{dimColor:!0}," Rules ")),z4.default.createElement(j,{flexDirection:"column"},B.map((Y,J)=>z4.default.createElement(z,{key:J},X1.bullet," ",B5(Y))))),G.length>0&&z4.default.createElement(j,{flexDirection:"row"},z4.default.createElement(j,{justifyContent:"flex-end",minWidth:Q},z4.default.createElement(z,{dimColor:!0}," Directories ")),z4.default.createElement(j,{flexDirection:"column"},G.map((Y,J)=>z4.default.createElement(z,{key:J},X1.bullet," ",Y)))),Z&&z4.default.createElement(j,{flexDirection:"row"},z4.default.createElement(j,{justifyContent:"flex-end",minWidth:Q},z4.default.createElement(z,{dimColor:!0}," Mode ")),z4.default.createElement(z,null,Bf(Z))))}function cB2({permissionResult:A}){let Q=A.decisionReason,B="suggestions"in A?A.suggestions:void 0,G=10;return z4.default.createElement(j,{flexDirection:"column"},z4.default.createElement(j,{flexDirection:"row"},z4.default.createElement(j,{justifyContent:"flex-end",minWidth:10},z4.default.createElement(z,{dimColor:!0},"Behavior ")),z4.default.createElement(z,null,A.behavior)),A.behavior!=="allow"&&z4.default.createElement(j,{flexDirection:"row"},z4.default.createElement(j,{justifyContent:"flex-end",minWidth:10},z4.default.createElement(z,{dimColor:!0},"Message ")),z4.default.createElement(z,null,A.message)),z4.default.createElement(j,{flexDirection:"row"},z4.default.createElement(j,{justifyContent:"flex-end",minWidth:10},z4.default.createElement(z,{dimColor:!0},"Reason ")),Q===void 0?z4.default.createElement(z,null,"undefined"):z4.default.createElement(qz8,{decisionReason:Q})),z4.default.createElement(Oz8,{suggestions:B,width:10}))}var z4;var pB2=L(()=>{fA();oG();t2();g2();Gw();tK();tI();z4=o(WA(),1)});function Rz8(A,Q){if(!A)return null;switch(A.type){case"rule":return{reasonString:`Permission rule ${cA.bold(B5(A.rule.ruleValue))} requires confirmation for this ${Q}.`,configString:A.rule.source==="policySettings"?void 0:"/permissions to update rules"};case"hook":{let B=A.reason?`:
bundles/ClaudeCodeCode/cli.js:2064:`.substring(0,Z);return B+Y+G}function xN8(A){return A!=null&&(typeof A==="string"||A.nodeType&&(A.nodeType===1||A.nodeType===9||A.nodeType===11))}$62.exports=h21});var g21;var E90=L(()=>{g21=new Set(["platform.claude.com","code.claude.com","modelcontextprotocol.io","github.com/anthropics","docs.python.org","en.cppreference.com","docs.oracle.com","learn.microsoft.com","developer.mozilla.org","go.dev","pkg.go.dev","www.php.net","docs.swift.org","kotlinlang.org","ruby-doc.org","doc.rust-lang.org","www.typescriptlang.org","react.dev","angular.io","vuejs.org","nextjs.org","expressjs.com","nodejs.org","bun.sh","jquery.com","getbootstrap.com","tailwindcss.com","d3js.org","threejs.org","redux.js.org","webpack.js.org","jestjs.io","reactrouter.com","docs.djangoproject.com","flask.palletsprojects.com","fastapi.tiangolo.com","pandas.pydata.org","numpy.org","www.tensorflow.org","pytorch.org","scikit-learn.org","matplotlib.org","requests.readthedocs.io","jupyter.org","laravel.com","symfony.com","wordpress.org","docs.spring.io","hibernate.org","tomcat.apache.org","gradle.org","maven.apache.org","asp.net","dotnet.microsoft.com","nuget.org","blazor.net","reactnative.dev","docs.flutter.dev","developer.apple.com","developer.android.com","keras.io","spark.apache.org","huggingface.co","www.kaggle.com","www.mongodb.com","redis.io","www.postgresql.org","dev.mysql.com","www.sqlite.org","graphql.org","prisma.io","docs.aws.amazon.com","cloud.google.com","learn.microsoft.com","kubernetes.io","www.docker.com","www.terraform.io","www.ansible.com","vercel.com/docs","docs.netlify.com","devcenter.heroku.com/","cypress.io","selenium.dev","docs.unity.com","docs.unrealengine.com","git-scm.com","nginx.org","httpd.apache.org"])});function L62(A){try{let Q=new URL(A),B=Q.hostname,G=Q.pathname;for(let Z of g21)if(Z.includes("/")){let[Y,...J]=Z.split("/"),I="/"+J.join("/");if(B===Y&&G.startsWith(I))return!0}else if(B===Z)return!0;return!1}catch{return!1}}function bN8(A){if(A.length>kN8)return!1;let Q;try{Q=new URL(A)}catch{return!1}if(Q.username||Q.password)return!1;if(Q.hostname.split(".").length<2)return!1;return!0}async function hN8(A){try{let Q=await wQ.get(`https://claude.ai/api/web/domain_info?domain=${encodeURIComponent(A)}`);if(Q.status===200)return Q.data.can_fetch===!0?{status:"allowed"}:{status:"blocked"};return{status:"check_failed",error:Error(`Domain check returned status ${Q.status}`)}}catch(Q){return s(Q),{status:"check_failed",error:Q}}}function gN8(A,Q){try{let B=new URL(A),G=new URL(Q);if(G.protocol!==B.protocol)return!1;if(G.port!==B.port)return!1;if(G.username||G.password)return!1;let Z=(I)=>I.replace(/^www\./,""),Y=Z(B.hostname),J=Z(G.hostname);return Y===J}catch(B){return!1}}async function M62(A,Q,B){try{return await wQ.get(A,{signal:Q,maxRedirects:0,responseType:"arraybuffer",maxContentLength:fN8,headers:{Accept:"text/markdown, text/html, */*"}})}catch(G){if(wQ.isAxiosError(G)&&G.response&&[301,302,307,308].includes(G.response.status)){let Z=G.response.headers.location;if(!Z)throw Error("Redirect missing Location header");let Y=new URL(Z,A).toString();if(B(A,Y))return M62(Y,Q,B);else return{type:"redirect",originalUrl:A,redirectUrl:Y,statusCode:G.response.status}}throw G}}function uN8(A){return"type"in A&&A.type==="redirect"}async function O62(A,Q){if(!bN8(A))throw Error("Invalid URL");let B=N62.get(A);if(B)return{bytes:B.bytes,code:B.code,codeText:B.codeText,content:B.content,contentType:B.contentType};let G,Z=A;try{if(G=new URL(A),G.protocol==="http:")G.protocol="https:",Z=G.toString();let K=G.hostname;if(!NQ().skipWebFetchPreflight)switch((await hN8(K)).status){case"allowed":break;case"blocked":throw new D90(K);case"check_failed":throw new H90(K)}}catch(K){if(s(K),K instanceof D90||K instanceof H90)throw K}let Y=await M62(Z,Q.signal,gN8);if(uN8(Y))return Y;let J=Buffer.from(Y.data).toString("utf-8"),I=Y.headers["content-type"]??"",X=Buffer.byteLength(J),W;if(I.includes("text/html"))W=new q62.default().turndown(J);else W=J;if(W.length>u21&&!OeA())W=W.substring(0,u21)+"...[content truncated]";return N62.set(A,{bytes:X,code:Y.status,codeText:Y.statusText,content:W,contentType:I}),{code:Y.status,codeText:Y.statusText,content:W,contentType:I,bytes:X}}async function R62(A,Q,B,G,Z){let Y=BaQ(Q,A,Z),J=await GW({systemPrompt:[],userPrompt:Y,signal:B,options:{querySource:"web_fetch_apply",agents:[],isNonInteractiveSession:G,hasAppendSystemPrompt:!1,mcpTools:[],agentIdOrSessionId:W0()}});if(B.aborted)throw new UJ;let{content:I}=J.message;if(I.length>0){let X=I[0];if("text"in X)return X.text}return"No response from model"}var q62,D90,H90,yN8=900000,vN8=52428800,N62,kN8=2000,fN8=10485760,u21=1e5;var _62=L(()=>{b8();_9A();RG();T0();eZ();h1();jB();g0();E90();HAA();q62=o(w62(),1);D90=class D90 extends Error{constructor(A){super(`Claude Code is unable to fetch from ${A}`);this.name="DomainBlockedError"}};H90=class H90 extends Error{constructor(A){super(`Unable to verify if domain ${A} is safe to fetch. This may be due to network restrictions or enterprise security policies blocking claude.ai.`);this.name="DomainCheckFailedError"}};N62=new Jq({maxSize:vN8,sizeCalculation:(A)=>Buffer.byteLength(A.content),ttl:yN8})});function T62({url:A,prompt:Q},{verbose:B}){if(!A)return null;if(B)return`url: "${A}"${B&&Q?`, prompt: "${Q}"`:""}`;return A}function j62(){return yU.default.createElement(m8,null)}function P62(A,{verbose:Q}){return yU.default.createElement(K3,{result:A,verbose:Q})}function S62(){return yU.default.createElement(h0,{height:1},yU.default.createElement(z,{dimColor:!0},"Fetching‚Ä¶"))}function x62({bytes:A,code:Q,codeText:B,result:G},Z,{verbose:Y}){let J=II(A);if(Y)return yU.default.createElement(j,{flexDirection:"column"},yU.default.createElement(h0,{height:1},yU.default.createElement(z,null,"Received ",yU.default.createElement(z,{bold:!0},J)," (",Q," ",B,")")),yU.default.createElement(j,{flexDirection:"column"},yU.default.createElement(z,null,G)));return yU.default.createElement(h0,{height:1},yU.default.createElement(z,null,"Received ",yU.default.createElement(z,{bold:!0},J)," (",Q," ",B,")"))}function y62(A){if(!A?.url)return null;return Q5(A.url,Bx)}var yU;var v62=L(()=>{fA();h4();lW();DI();M9();yU=o(WA(),1)});function cN8(A){try{let Q=IK.inputSchema.safeParse(A);if(!Q.success)return`input:${A.toString()}`;let{url:B}=Q.data;return`domain:${new URL(B).hostname}`}catch{return`input:${A.toString()}`}}var mN8,dN8,IK;var PJA=L(()=>{z2();_62();oG();E90();v62();mN8=P.strictObject({url:P.string().url().describe("The URL to fetch content from"),prompt:P.string().describe("The prompt to run on the fetched content")}),dN8=P.object({bytes:P.number().describe("Size of the fetched content in bytes"),code:P.number().describe("HTTP response code"),codeText:P.string().describe("HTTP response code text"),result:P.string().describe("Processed result from applying the prompt to the content"),durationMs:P.number().describe("Time taken to fetch and process the content"),url:P.string().describe("The URL that was fetched")});IK={name:rX,async description(A){let{url:Q}=A;try{return`Claude wants to fetch content from ${new URL(Q).hostname}`}catch{return"Claude wants to fetch content from this URL"}},userFacingName(){return"Fetch"},getToolUseSummary:y62,isEnabled(){return!0},inputSchema:mN8,outputSchema:dN8,isConcurrencySafe(){return!0},isReadOnly(){return!0},async checkPermissions(A,Q){let G=(await Q.getAppState()).toolPermissionContext;try{let{url:X}=A,W=new URL(X),K=W.hostname,V=W.pathname;for(let E of g21)if(E.includes("/")){let[D,...H]=E.split("/"),F="/"+H.join("/");if(K===D&&V.startsWith(F))return{behavior:"allow",updatedInput:A,decisionReason:{type:"other",reason:"Preapproved host and path"}}}else if(K===E)return{behavior:"allow",updatedInput:A,decisionReason:{type:"other",reason:"Preapproved host"}}}catch{}let Z=cN8(A),Y=jU(G,IK,"deny").get(Z);if(Y)return{behavior:"deny",message:`${IK.name} denied access to ${Z}.`,decisionReason:{type:"rule",rule:Y}};let J=jU(G,IK,"ask").get(Z);if(J)return{behavior:"ask",message:`Claude requested permissions to use ${IK.name}, but you haven't granted it yet.`,decisionReason:{type:"rule",rule:J}};let I=jU(G,IK,"allow").get(Z);if(I)return{behavior:"allow",updatedInput:A,decisionReason:{type:"rule",rule:I}};return{behavior:"ask",message:`Claude requested permissions to use ${IK.name}, but you haven't granted it yet.`}},async prompt(){return QaQ},async validateInput(A){let{url:Q}=A;try{new URL(Q)}catch{return{result:!1,message:`Error: Invalid URL "${Q}". The URL provided could not be parsed.`,meta:{reason:"invalid_url"},errorCode:1}}return{result:!0}},renderToolUseMessage:T62,renderToolUseRejectedMessage:j62,renderToolUseErrorMessage:P62,renderToolUseProgressMessage:S62,renderToolResultMessage:x62,async call({url:A,prompt:Q},{abortController:B,options:{isNonInteractiveSession:G}}){let Z=Date.now(),Y=await O62(A,B);if("type"in Y&&Y.type==="redirect"){let H=Y.statusCode===301?"Moved Permanently":Y.statusCode===308?"Permanent Redirect":Y.statusCode===307?"Temporary Redirect":"Found",F=`REDIRECT DETECTED: The URL redirects to a different host.[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "message-selector|sandbox-permission|tool-permission|worker-permission|elicitation|ide-onboarding" bundles/ClaudeAgentSDKCode/cli.js | head -n 40'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 37ms:[0m
[2m975:`))Q=Q.slice(0,-1)}return N_.prototype.equals.call(this,A,Q,B)};oq6=new N_;oq6.tokenize=function(A){return A.split(/(\S.+?[.!?])(?=\s+|$)/)};rq6=new N_;rq6.tokenize=function(A){return A.split(/([{}:;,]|\s+)/)};EwA=new N_;EwA.useLongestToken=!0;EwA.tokenize=foA.tokenize;EwA.castInput=function(A,Q){var{undefinedReplacement:B,stringifyReplacer:G}=Q,Z=G===void 0?function(Y,J){return typeof J>"u"?B:J}:G;return typeof A==="string"?A:JSON.stringify(kd1(A,null,null,Z),Z,"  ")};EwA.equals=function(A,Q,B){return N_.prototype.equals.call(EwA,A.replace(/,([\r\n])/g,"$1"),Q.replace(/,([\r\n])/g,"$1"),B)};fd1=new N_;fd1.tokenize=function(A){return A.slice()};fd1.join=fd1.removeEmpty=function(A){return A}});function FwA(A){return A.replaceAll("&",SWB).replaceAll("$",xWB)}function yWB(A){return A.replaceAll(SWB,"&").replaceAll(xWB,"$")}function CwA(A,Q){let B=0,G=0;if(A.length===0&&Q)B=Q.split(/\r?\n/).length;else B=A.reduce((Z,Y)=>Z+Y.lines.filter((J)=>J.startsWith("+")).length,0),G=A.reduce((Z,Y)=>Z+Y.lines.filter((J)=>J.startsWith("-")).length,0);wG1(B,G),MG1()?.add(B,{type:"added"}),MG1()?.add(G,{type:"removed"}),s("tengu_file_changed",{lines_added:B,lines_removed:G})}function vWB({filePath:A,oldContent:Q,newContent:B,ignoreWhitespace:G=!1,singleHunk:Z=!1}){return DwA(A,A,FwA(Q),FwA(B),void 0,void 0,{ignoreWhitespace:G,context:Z?1e5:PWB}).hunks.map((Y)=>({...Y,lines:Y.lines.map(yWB)}))}function hw({filePath:A,fileContents:Q,edits:B,ignoreWhitespace:G=!1}){let Z=FwA(O7A(Q));return DwA(A,A,Z,B.reduce((Y,J)=>{let{old_string:I,new_string:X}=J,W="replace_all"in J?J.replace_all:!1,K=FwA(O7A(I)),V=FwA(O7A(X));if(W)return Y.replaceAll(K,()=>V);else return Y.replace(K,()=>V)},Z),void 0,void 0,{context:PWB,ignoreWhitespace:G}).hunks.map((Y)=>({...Y,lines:Y.lines.map(yWB)}))}var PWB=3,SWB="<<:AMPERSAND_TOKEN:>>",xWB="<<:DOLLAR_TOKEN:>>";var Lb=q(()=>{HwA();EL();N9();_0();u0()});var jp="2025-06-18",boA,hoA="2.0",kWB,fWB,YL6,aL,WU,zwA,sS,oL,goA,bWB,uoA=(A)=>bWB.safeParse(A).success,hWB,gWB=(A)=>hWB.safeParse(A).success,uWB,UwA=(A)=>uWB.safeParse(A).success,eF,mWB,dWB=(A)=>mWB.safeParse(A).success,tS,Mb,moA,$wA,cWB,JL6,bd1,IL6,hd1,doA,pWB=(A)=>doA.safeParse(A).success,coA,XL6,poA,loA,ioA,lWB,iWB,gd1,nWB,aWB,WL6,KL6,xe,VL6,ud1,EL6,Pp,DL6,HL6,FL6,CL6,zL6,UL6,$L6,wwA,wL6,md1,dd1,cd1,NL6,qL6,oWB,LL6,pd1,ML6,OL6,RL6,noA,NwA,q_,Cl7,aoA,_L6,rWB,TL6,jL6,PL6,SL6,xL6,yL6,ld1,vL6,kL6,fL6,bL6,hL6,sWB,id1,gL6,uL6,mL6,nd1,dL6,ad1,od1,cL6,zl7,Ul7,$l7,wl7,Nl7,ql7,AC;var KV=q(()=>{C2();boA=[jp,"2025-03-26","2024-11-05","2024-10-07"],kWB=P.union([P.string(),P.number().int()]),fWB=P.string(),YL6=P.object({progressToken:P.optional(kWB)}).passthrough(),aL=P.object({_meta:P.optional(YL6)}).passthrough(),WU=P.object({method:P.string(),params:P.optional(aL)}),zwA=P.object({_meta:P.optional(P.object({}).passthrough())}).passthrough(),sS=P.object({method:P.string(),params:P.optional(zwA)}),oL=P.object({_meta:P.optional(P.object({}).passthrough())}).passthrough(),goA=P.union([P.string(),P.number().int()]),bWB=P.object({jsonrpc:P.literal(hoA),id:goA}).merge(WU).strict(),hWB=P.object({jsonrpc:P.literal(hoA)}).merge(sS).strict(),uWB=P.object({jsonrpc:P.literal(hoA),id:goA,result:oL}).strict();(function(A){A[A.ConnectionClosed=-32000]="ConnectionClosed",A[A.RequestTimeout=-32001]="RequestTimeout",A[A.ParseError=-32700]="ParseError",A[A.InvalidRequest=-32600]="InvalidRequest",A[A.MethodNotFound=-32601]="MethodNotFound",A[A.InvalidParams=-32602]="InvalidParams",A[A.InternalError=-32603]="InternalError"})(eF||(eF={}));mWB=P.object({jsonrpc:P.literal(hoA),id:goA,error:P.object({code:P.number().int(),message:P.string(),data:P.optional(P.unknown())})}).strict(),tS=P.union([bWB,hWB,uWB,mWB]),Mb=oL.strict(),moA=sS.extend({method:P.literal("notifications/cancelled"),params:zwA.extend({requestId:goA,reason:P.string().optional()})}),$wA=P.object({name:P.string(),title:P.optional(P.string())}).passthrough(),cWB=$wA.extend({version:P.string()}),JL6=P.object({experimental:P.optional(P.object({}).passthrough()),sampling:P.optional(P.object({}).passthrough()),elicitation:P.optional(P.object({}).passthrough()),roots:P.optional(P.object({listChanged:P.optional(P.boolean())}).passthrough())}).passthrough(),bd1=WU.extend({method:P.literal("initialize"),params:aL.extend({protocolVersion:P.string(),capabilities:JL6,clientInfo:cWB})}),IL6=P.object({experimental:P.optional(P.object({}).passthrough()),logging:P.optional(P.object({}).passthrough()),completions:P.optional(P.object({}).passthrough()),prompts:P.optional(P.object({listChanged:P.optional(P.boolean())}).passthrough()),resources:P.optional(P.object({subscribe:P.optional(P.boolean()),listChanged:P.optional(P.boolean())}).passthrough()),tools:P.optional(P.object({listChanged:P.optional(P.boolean())}).passthrough())}).passthrough(),hd1=oL.extend({protocolVersion:P.string(),capabilities:IL6,serverInfo:cWB,instructions:P.optional(P.string())}),doA=sS.extend({method:P.literal("notifications/initialized")}),coA=WU.extend({method:P.literal("ping")}),XL6=P.object({progress:P.number(),total:P.optional(P.number()),message:P.optional(P.string())}).passthrough(),poA=sS.extend({method:P.literal("notifications/progress"),params:zwA.merge(XL6).extend({progressToken:kWB})}),loA=WU.extend({params:aL.extend({cursor:P.optional(fWB)}).optional()}),ioA=oL.extend({nextCursor:P.optional(fWB)}),lWB=P.object({uri:P.string(),mimeType:P.optional(P.string()),_meta:P.optional(P.object({}).passthrough())}).passthrough(),iWB=lWB.extend({text:P.string()}),gd1=P.string().refine((A)=>{try{return atob(A),!0}catch(Q){return!1}},{message:"Invalid Base64 string"}),nWB=lWB.extend({blob:gd1}),aWB=$wA.extend({uri:P.string(),description:P.optional(P.string()),mimeType:P.optional(P.string()),_meta:P.optional(P.object({}).passthrough())}),WL6=$wA.extend({uriTemplate:P.string(),description:P.optional(P.string()),mimeType:P.optional(P.string()),_meta:P.optional(P.object({}).passthrough())}),KL6=loA.extend({method:P.literal("resources/list")}),xe=ioA.extend({resources:P.array(aWB)}),VL6=loA.extend({method:P.literal("resources/templates/list")}),ud1=ioA.extend({resourceTemplates:P.array(WL6)}),EL6=WU.extend({method:P.literal("resources/read"),params:aL.extend({uri:P.string()})}),Pp=oL.extend({contents:P.array(P.union([iWB,nWB]))}),DL6=sS.extend({method:P.literal("notifications/resources/list_changed")}),HL6=WU.extend({method:P.literal("resources/subscribe"),params:aL.extend({uri:P.string()})}),FL6=WU.extend({method:P.literal("resources/unsubscribe"),params:aL.extend({uri:P.string()})}),CL6=sS.extend({method:P.literal("notifications/resources/updated"),params:zwA.extend({uri:P.string()})}),zL6=P.object({name:P.string(),description:P.optional(P.string()),required:P.optional(P.boolean())}).passthrough(),UL6=$wA.extend({description:P.optional(P.string()),arguments:P.optional(P.array(zL6)),_meta:P.optional(P.object({}).passthrough())}),$L6=loA.extend({method:P.literal("prompts/list")}),wwA=ioA.extend({prompts:P.array(UL6)}),wL6=WU.extend({method:P.literal("prompts/get"),params:aL.extend({name:P.string(),arguments:P.optional(P.record(P.string()))})}),md1=P.object({type:P.literal("text"),text:P.string(),_meta:P.optional(P.object({}).passthrough())}).passthrough(),dd1=P.object({type:P.literal("image"),data:gd1,mimeType:P.string(),_meta:P.optional(P.object({}).passthrough())}).passthrough(),cd1=P.object({type:P.literal("audio"),data:gd1,mimeType:P.string(),_meta:P.optional(P.object({}).passthrough())}).passthrough(),NL6=P.object({type:P.literal("resource"),resource:P.union([iWB,nWB]),_meta:P.optional(P.object({}).passthrough())}).passthrough(),qL6=aWB.extend({type:P.literal("resource_link")}),oWB=P.union([md1,dd1,cd1,qL6,NL6]),LL6=P.object({role:P.enum(["user","assistant"]),content:oWB}).passthrough(),pd1=oL.extend({description:P.optional(P.string()),messages:P.array(LL6)}),ML6=sS.extend({method:P.literal("notifications/prompts/list_changed")}),OL6=P.object({title:P.optional(P.string()),readOnlyHint:P.optional(P.boolean()),destructiveHint:P.optional(P.boolean()),idempotentHint:P.optional(P.boolean()),openWorldHint:P.optional(P.boolean())}).passthrough(),RL6=$wA.extend({description:P.optional(P.string()),inputSchema:P.object({type:P.literal("object"),properties:P.optional(P.object({}).passthrough()),required:P.optional(P.array(P.string()))}).passthrough(),outputSchema:P.optional(P.object({type:P.literal("object"),properties:P.optional(P.object({}).passthrough()),required:P.optional(P.array(P.string()))}).passthrough()),annotations:P.optional(OL6),_meta:P.optional(P.object({}).passthrough())}),noA=loA.extend({method:P.literal("tools/list")}),NwA=ioA.extend({tools:P.array(RL6)}),q_=oL.extend({content:P.array(oWB).default([]),structuredContent:P.object({}).passthrough().optional(),isError:P.optional(P.boolean())}),Cl7=q_.or(oL.extend({toolResult:P.unknown()})),aoA=WU.extend({method:P.literal("tools/call"),params:aL.extend({name:P.string(),arguments:P.optional(P.record(P.unknown()))})}),_L6=sS.extend({method:P.literal("notifications/tools/list_changed")}),rWB=P.enum(["debug","info","notice","warning","error","critical","alert","emergency"]),TL6=WU.extend({method:P.literal("logging/setLevel"),params:aL.extend({level:rWB})}),jL6=sS.extend({method:P.literal("notifications/message"),params:zwA.extend({level:rWB,logger:P.optional(P.string()),data:P.unknown()})}),PL6=P.object({name:P.string().optional()}).passthrough(),SL6=P.object({hints:P.optional(P.array(PL6)),costPriority:P.optional(P.number().min(0).max(1)),speedPriority:P.optional(P.number().min(0).max(1)),intelligencePriority:P.optional(P.number().min(0).max(1))}).passthrough(),xL6=P.object({role:P.enum(["user","assistant"]),content:P.union([md1,dd1,cd1])}).passthrough(),yL6=WU.extend({method:P.literal("sampling/createMessage"),params:aL.extend({messages:P.array(xL6),systemPrompt:P.optional(P.string()),includeContext:P.optional(P.enum(["none","thisServer","allServers"])),temperature:P.optional(P.number()),maxTokens:P.number().int(),stopSequences:P.optional(P.array(P.string())),metadata:P.optional(P.object({}).passthrough()),modelPreferences:P.optional(SL6)})}),ld1=oL.extend({model:P.string(),stopReason:P.optional(P.enum(["endTurn","stopSequence","maxTokens"]).or(P.string())),role:P.enum(["user","assistant"]),content:P.discriminatedUnion("type",[md1,dd1,cd1])}),vL6=P.object({type:P.literal("boolean"),title:P.optional(P.string()),description:P.optional(P.string()),default:P.optional(P.boolean())}).passthrough(),kL6=P.object({type:P.literal("string"),title:P.optional(P.string()),description:P.optional(P.string()),minLength:P.optional(P.number()),maxLength:P.optional(P.number()),format:P.optional(P.enum(["email","uri","date","date-time"]))}).passthrough(),fL6=P.object({type:P.enum(["number","integer"]),title:P.optional(P.string()),description:P.optional(P.string()),minimum:P.optional(P.number()),maximum:P.optional(P.number())}).passthrough(),bL6=P.object({type:P.literal("string"),title:P.optional(P.string()),description:P.optional(P.string()),enum:P.array(P.string()),enumNames:P.optional(P.array(P.string()))}).passthrough(),hL6=P.union([vL6,kL6,fL6,bL6]),sWB=WU.extend({method:P.literal("elicitation/create"),params:aL.extend({message:P.string(),requestedSchema:P.object({type:P.literal("object"),properties:P.record(P.string(),hL6),required:P.optional(P.array(P.string()))}).passthrough()})}),id1=oL.extend({action:P.enum(["accept","decline","cancel"]),content:P.optional(P.record(P.string(),P.unknown()))}),gL6=P.object({type:P.literal("ref/resource"),uri:P.string()}).passthrough(),uL6=P.object({type:P.literal("ref/prompt"),name:P.string()}).passthrough(),mL6=WU.extend({method:P.literal("completion/complete"),params:aL.extend({ref:P.union([uL6,gL6]),argument:P.object({name:P.string(),value:P.string()}).passthrough(),context:P.optional(P.object({arguments:P.optional(P.record(P.string(),P.string()))}))})}),nd1=oL.extend({completion:P.object({values:P.array(P.string()).max(100),total:P.optional(P.number().int()),hasMore:P.optional(P.boolean())}).passthrough()}),dL6=P.object({uri:P.string().startsWith("file://"),name:P.optional(P.string()),_meta:P.optional(P.object({}).passthrough())}).passthrough(),ad1=WU.extend({method:P.literal("roots/list")}),od1=oL.extend({roots:P.array(dL6)}),cL6=sS.extend({method:P.literal("notifications/roots/list_changed")}),zl7=P.union([coA,bd1,mL6,TL6,wL6,$L6,KL6,VL6,EL6,HL6,FL6,aoA,noA]),Ul7=P.union([moA,poA,doA,cL6]),$l7=P.union([Mb,ld1,id1,od1]),wl7=P.union([coA,yL6,sWB,ad1]),Nl7=P.union([moA,poA,jL6,CL6,DL6,_L6,ML6]),ql7=P.union([Mb,hd1,nd1,pd1,wwA,xe,ud1,Pp,q_,NwA]);AC=class AC extends Error{constructor(A,Q,B){super(`MCP error ${A}: ${Q}`);this.code=A,this.data=B,this.name="McpError"}}});class qwA{constructor(A){this._options=A,this._requestMessageId=0,this._requestHandlers=new Map,this._requestHandlerAbortControllers=new Map,this._notificationHandlers=new Map,this._responseHandlers=new Map,this._progressHandlers=new Map,this._timeoutInfo=new Map,this._pendingDebouncedNotifications=new Set,this.setNotificationHandler(moA,(Q)=>{let B=this._requestHandlerAbortControllers.get(Q.params.requestId);B===null||B===void 0||B.abort(Q.params.reason)}),this.setNotificationHandler(poA,(Q)=>{this._onprogress(Q)}),this.setRequestHandler(coA,(Q)=>({}))}_setupTimeout(A,Q,B,G,Z=!1){this._timeoutInfo.set(A,{timeoutId:setTimeout(G,Q),startTime:Date.now(),timeout:Q,maxTotalTimeout:B,resetTimeoutOnProgress:Z,onTimeout:G})}_resetTimeout(A){let Q=this._timeoutInfo.get(A);if(!Q)return!1;let B=Date.now()-Q.startTime;if(Q.maxTotalTimeout&&B>=Q.maxTotalTimeout)throw this._timeoutInfo.delete(A),new AC(eF.RequestTimeout,"Maximum total timeout exceeded",{maxTotalTimeout:Q.maxTotalTimeout,totalElapsed:B});return clearTimeout(Q.timeoutId),Q.timeoutId=setTimeout(Q.onTimeout,Q.timeout),!0}_cleanupTimeout(A){let Q=this._timeoutInfo.get(A);if(Q)clearTimeout(Q.timeoutId),this._timeoutInfo.delete(A)}async connect(A){var Q,B,G;this._transport=A;let Z=(Q=this.transport)===null||Q===void 0?void 0:Q.onclose;this._transport.onclose=()=>{Z===null||Z===void 0||Z(),this._onclose()};let Y=(B=this.transport)===null||B===void 0?void 0:B.onerror;this._transport.onerror=(I)=>{Y===null||Y===void 0||Y(I),this._onerror(I)};let J=(G=this._transport)===null||G===void 0?void 0:G.onmessage;this._transport.onmessage=(I,X)=>{if(J===null||J===void 0||J(I,X),UwA(I)||dWB(I))this._onresponse(I);else if(uoA(I))this._onrequest(I,X);else if(gWB(I))this._onnotification(I);else this._onerror(Error(`Unknown message type: ${JSON.stringify(I)}`))},await this._transport.start()}_onclose(){var A;let Q=this._responseHandlers;this._responseHandlers=new Map,this._progressHandlers.clear(),this._pendingDebouncedNotifications.clear(),this._transport=void 0,(A=this.onclose)===null||A===void 0||A.call(this);let B=new AC(eF.ConnectionClosed,"Connection closed");for(let G of Q.values())G(B)}_onerror(A){var Q;(Q=this.onerror)===null||Q===void 0||Q.call(this,A)}_onnotification(A){var Q;let B=(Q=this._notificationHandlers.get(A.method))!==null&&Q!==void 0?Q:this.fallbackNotificationHandler;if(B===void 0)return;Promise.resolve().then(()=>B(A)).catch((G)=>this._onerror(Error(`Uncaught error in notification handler: ${G}`)))}_onrequest(A,Q){var B,G;let Z=(B=this._requestHandlers.get(A.method))!==null&&B!==void 0?B:this.fallbackRequestHandler,Y=this._transport;if(Z===void 0){Y===null||Y===void 0||Y.send({jsonrpc:"2.0",id:A.id,error:{code:eF.MethodNotFound,message:"Method not found"}}).catch((X)=>this._onerror(Error(`Failed to send an error response: ${X}`)));return}let J=new AbortController;this._requestHandlerAbortControllers.set(A.id,J);let I={signal:J.signal,sessionId:Y===null||Y===void 0?void 0:Y.sessionId,_meta:(G=A.params)===null||G===void 0?void 0:G._meta,sendNotification:(X)=>this.notification(X,{relatedRequestId:A.id}),sendRequest:(X,W,K)=>this.request(X,W,{...K,relatedRequestId:A.id}),authInfo:Q===null||Q===void 0?void 0:Q.authInfo,requestId:A.id,requestInfo:Q===null||Q===void 0?void 0:Q.requestInfo};Promise.resolve().then(()=>Z(A,I)).then((X)=>{if(J.signal.aborted)return;return Y===null||Y===void 0?void 0:Y.send({result:X,jsonrpc:"2.0",id:A.id})},(X)=>{var W;if(J.signal.aborted)return;return Y===null||Y===void 0?void 0:Y.send({jsonrpc:"2.0",id:A.id,error:{code:Number.isSafeInteger(X.code)?X.code:eF.InternalError,message:(W=X.message)!==null&&W!==void 0?W:"Internal error"}})}).catch((X)=>this._onerror(Error(`Failed to send response: ${X}`))).finally(()=>{this._requestHandlerAbortControllers.delete(A.id)})}_onprogress(A){let{progressToken:Q,...B}=A.params,G=Number(Q),Z=this._progressHandlers.get(G);if(!Z){this._onerror(Error(`Received a progress notification for an unknown token: ${JSON.stringify(A)}`));return}let Y=this._responseHandlers.get(G),J=this._timeoutInfo.get(G);if(J&&Y&&J.resetTimeoutOnProgress)try{this._resetTimeout(G)}catch(I){Y(I);return}Z(B)}_onresponse(A){let Q=Number(A.id),B=this._responseHandlers.get(Q);if(B===void 0){this._onerror(Error(`Received a response for an unknown message ID: ${JSON.stringify(A)}`));return}if(this._responseHandlers.delete(Q),this._progressHandlers.delete(Q),this._cleanupTimeout(Q),UwA(A))B(A);else{let G=new AC(A.error.code,A.error.message,A.error.data);B(G)}}get transport(){return this._transport}async close(){var A;await((A=this._transport)===null||A===void 0?void 0:A.close())}request(A,Q,B){let{relatedRequestId:G,resumptionToken:Z,onresumptiontoken:Y}=B!==null&&B!==void 0?B:{};return new Promise((J,I)=>{var X,W,K,V,E,D;if(!this._transport){I(Error("Not connected"));return}if(((X=this._options)===null||X===void 0?void 0:X.enforceStrictCapabilities)===!0)this.assertCapabilityForMethod(A.method);(W=B===null||B===void 0?void 0:B.signal)===null||W===void 0||W.throwIfAborted();let H=this._requestMessageId++,F={...A,jsonrpc:"2.0",id:H};if(B===null||B===void 0?void 0:B.onprogress)this._progressHandlers.set(H,B.onprogress),F.params={...A.params,_meta:{...((K=A.params)===null||K===void 0?void 0:K._meta)||{},progressToken:H}};let C=(M)=>{var L;this._responseHandlers.delete(H),this._progressHandlers.delete(H),this._cleanupTimeout(H),(L=this._transport)===null||L===void 0||L.send({jsonrpc:"2.0",method:"notifications/cancelled",params:{requestId:H,reason:String(M)}},{relatedRequestId:G,resumptionToken:Z,onresumptiontoken:Y}).catch((_)=>this._onerror(Error(`Failed to send cancellation: ${_}`))),I(M)};this._responseHandlers.set(H,(M)=>{var L;if((L=B===null||B===void 0?void 0:B.signal)===null||L===void 0?void 0:L.aborted)return;if(M instanceof Error)return I(M);try{let _=Q.parse(M.result);J(_)}catch(_){I(_)}}),(V=B===null||B===void 0?void 0:B.signal)===null||V===void 0||V.addEventListener("abort",()=>{var M;C((M=B===null||B===void 0?void 0:B.signal)===null||M===void 0?void 0:M.reason)});let $=(E=B===null||B===void 0?void 0:B.timeout)!==null&&E!==void 0?E:pL6,O=()=>C(new AC(eF.RequestTimeout,"Request timed out",{timeout:$}));this._setupTimeout(H,$,B===null||B===void 0?void 0:B.maxTotalTimeout,O,(D=B===null||B===void 0?void 0:B.resetTimeoutOnProgress)!==null&&D!==void 0?D:!1),this._transport.send(F,{relatedRequestId:G,resumptionToken:Z,onresumptiontoken:Y}).catch((M)=>{this._cleanupTimeout(H),I(M)})})}async notification(A,Q){var B,G;if(!this._transport)throw Error("Not connected");if(this.assertNotificationCapability(A.method),((G=(B=this._options)===null||B===void 0?void 0:B.debouncedNotificationMethods)!==null&&G!==void 0?G:[]).includes(A.method)&&!A.params&&!(Q===null||Q===void 0?void 0:Q.relatedRequestId)){if(this._pendingDebouncedNotifications.has(A.method))return;this._pendingDebouncedNotifications.add(A.method),Promise.resolve().then(()=>{var I;if(this._pendingDebouncedNotifications.delete(A.method),!this._transport)return;let X={...A,jsonrpc:"2.0"};(I=this._transport)===null||I===void 0||I.send(X,Q).catch((W)=>this._onerror(W))});return}let J={...A,jsonrpc:"2.0"};await this._transport.send(J,Q)}setRequestHandler(A,Q){let B=A.shape.method.value;this.assertRequestHandlerCapability(B),this._requestHandlers.set(B,(G,Z)=>{return Promise.resolve(Q(A.parse(G),Z))})}removeRequestHandler(A){this._requestHandlers.delete(A)}assertCanSetRequestHandler(A){if(this._requestHandlers.has(A))throw Error(`A request handler for ${A} already exists, which would be overridden`)}setNotificationHandler(A,Q){this._notificationHandlers.set(A.shape.method.value,(B)=>Promise.resolve(Q(A.parse(B))))}removeNotificationHandler(A){this._notificationHandlers.delete(A)}}function ooA(A,Q){return Object.entries(Q).reduce((B,[G,Z])=>{if(Z&&typeof Z==="object")B[G]=B[G]?{...B[G],...Z}:Z;else B[G]=Z;return B},{...A})}var pL6=60000;var rd1=q(()=>{KV()});var eWB=w((roA,tWB)=>{(function(A,Q){typeof roA==="object"&&typeof tWB<"u"?Q(roA):typeof define==="function"&&define.amd?define(["exports"],Q):Q(A.URI=A.URI||{})})(roA,function(A){function Q(){for(var V1=arguments.length,iA=Array(V1),z1=0;z1<V1;z1++)iA[z1]=arguments[z1];if(iA.length>1){iA[0]=iA[0].slice(0,-1);var A0=iA.length-1;for(var E0=1;E0<A0;++E0)iA[E0]=iA[E0].slice(1,-1);return iA[A0]=iA[A0].slice(1),iA.join("")}else return iA[0]}function B(V1){return"(?:"+V1+")"}function G(V1){return V1===void 0?"undefined":V1===null?"null":Object.prototype.toString.call(V1).split(" ").pop().split("]").shift().toLowerCase()}function Z(V1){return V1.toUpperCase()}function Y(V1){return V1!==void 0&&V1!==null?V1 instanceof Array?V1:typeof V1.length!=="number"||V1.split||V1.setInterval||V1.call?[V1]:Array.prototype.slice.call(V1):[]}function J(V1,iA){var z1=V1;if(iA)for(var A0 in iA)z1[A0]=iA[A0];return z1}function I(V1){var iA="[A-Za-z]",z1="[\\x0D]",A0="[0-9]",E0="[\\x22]",xQ=Q(A0,"[A-Fa-f]"),eB="[\\x0A]",X9="[\\x20]",Q9=B(B("%[EFef]"+xQ+"%"+xQ+xQ+"%"+xQ+xQ)+"|"+B("%[89A-Fa-f]"+xQ+"%"+xQ+xQ)+"|"+B("%"+xQ+xQ)),y4="[\\:\\/\\?\\#\\[\\]\\@]",B9="[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",$3=Q(y4,B9),w3=V1?"[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]":"[]",C4=V1?"[\\uE000-\\uF8FF]":"[]",O9=Q(iA,A0,"[\\-\\.\\_\\~]",w3),N3=B(iA+Q(iA,A0,"[\\+\\-\\.]")+"*"),p9=B(B(Q9+"|"+Q(O9,B9,"[\\:]"))+"*"),v5=B(B("25[0-5]")+"|"+B("2[0-4]"+A0)+"|"+B("1"+A0+A0)+"|"+B("[1-9]"+A0)+"|"+A0),M6=B(B("25[0-5]")+"|"+B("2[0-4]"+A0)+"|"+B("1"+A0+A0)+"|"+B("0?[1-9]"+A0)+"|0?0?"+A0),q3=B(M6+"\\."+M6+"\\."+M6+"\\."+M6),l9=B(xQ+"{1,4}"),s0=B(B(l9+"\\:"+l9)+"|"+q3),mQ=B(B(l9+"\\:")+"{6}"+s0),XB=B("\\:\\:"+B(l9+"\\:")+"{5}"+s0),e9=B(B(l9)+"?\\:\\:"+B(l9+"\\:")+"{4}"+s0),x2=B(B(B(l9+"\\:")+"{0,1}"+l9)+"?\\:\\:"+B(l9+"\\:")+"{3}"+s0),WG=B(B(B(l9+"\\:")+"{0,2}"+l9)+"?\\:\\:"+B(l9+"\\:")+"{2}"+s0),gG=B(B(B(l9+"\\:")+"{0,3}"+l9)+"?\\:\\:"+l9+"\\:"+s0),f6=B(B(B(l9+"\\:")+"{0,4}"+l9)+"?\\:\\:"+s0),b6=B(B(B(l9+"\\:")+"{0,5}"+l9)+"?\\:\\:"+l9),aA=B(B(B(l9+"\\:")+"{0,6}"+l9)+"?\\:\\:"),WA=B([mQ,XB,e9,x2,WG,gG,f6,b6,aA].join("|")),BA=B(B(O9+"|"+Q9)+"+"),xA=B(WA+"\\%25"+BA),fA=B(WA+B("\\%25|\\%(?!"+xQ+"{2})")+BA),uA=B("[vV]"+xQ+"+\\."+Q(O9,B9,"[\\:]")+"+"),w1=B("\\["+B(fA+"|"+WA+"|"+uA)+"\\]"),x1=B(B(Q9+"|"+Q(O9,B9))+"*"),k1=B(w1+"|"+q3+"(?!"+x1+")|"+x1),n1=B(A0+"*"),p1=B(B(p9+"@")+"?"+k1+B("\\:"+n1)+"?"),z0=B(Q9+"|"+Q(O9,B9,"[\\:\\@]")),qQ=B(z0+"*"),HB=B(z0+"+"),j2=B(B(Q9+"|"+Q(O9,B9,"[\\@]"))+"+"),A2=B(B("\\/"+qQ)+"*"),n2=B("\\/"+B(HB+A2)+"?"),L3=B(j2+A2),k5=B(HB+A2),N8="(?!"+z0+")",MW=B(A2+"|"+n2+"|"+L3+"|"+k5+"|"+N8),KG=B(B(z0+"|"+Q("[\\/\\?]",C4))+"*"),LI=B(B(z0+"|[\\/\\?]")+"*"),MI=B(B("\\/\\/"+p1+A2)+"|"+n2+"|"+k5+"|"+N8),OW=B(N3+"\\:"+MI+B("\\?"+KG)+"?"+B("\\#"+LI)+"?"),$5=B(B("\\/\\/"+p1+A2)+"|"+n2+"|"+L3+"|"+N8),VG=B($5+B("\\?"+KG)+"?"+B("\\#"+LI)+"?"),UK=B(OW+"|"+VG),NX=B(N3+"\\:"+MI+B("\\?"+KG)+"?"),qX="^("+N3+")\\:"+B(B("\\/\\/("+B("("+p9+")@")+"?("+k1+")"+B("\\:("+n1+")")+"?)")+"?("+A2+"|"+n2+"|"+k5+"|"+N8+")")+B("\\?("+KG+")")+"?"+B("\\#("+LI+")")+"?$",$K="^(){0}"+B(B("\\/\\/("+B("("+p9+")@")+"?("+k1+")"+B("\\:("+n1+")")+"?)")+"?("+A2+"|"+n2+"|"+L3+"|"+N8+")")+B("\\?("+KG+")")+"?"+B("\\#("+LI+")")+"?$",DZ="^("+N3+")\\:"+B(B("\\/\\/("+B("("+p9+")@")+"?("+k1+")"+B("\\:("+n1+")")+"?)")+"?("+A2+"|"+n2+"|"+k5+"|"+N8+")")+B("\\?("+KG+")")+"?$",OI="^"+B("\\#("+LI+")")+"?$",pN="^"+B("("+p9+")@")+"?("+k1+")"+B("\\:("+n1+")")+"?$";return{NOT_SCHEME:new RegExp(Q("[^]",iA,A0,"[\\+\\-\\.]"),"g"),NOT_USERINFO:new RegExp(Q("[^\\%\\:]",O9,B9),"g"),NOT_HOST:new RegExp(Q("[^\\%\\[\\]\\:]",O9,B9),"g"),NOT_PATH:new RegExp(Q("[^\\%\\/\\:\\@]",O9,B9),"g"),NOT_PATH_NOSCHEME:new RegExp(Q("[^\\%\\/\\@]",O9,B9),"g"),NOT_QUERY:new RegExp(Q("[^\\%]",O9,B9,"[\\:\\@\\/\\?]",C4),"g"),NOT_FRAGMENT:new RegExp(Q("[^\\%]",O9,B9,"[\\:\\@\\/\\?]"),"g"),ESCAPE:new RegExp(Q("[^]",O9,B9),"g"),UNRESERVED:new RegExp(O9,"g"),OTHER_CHARS:new RegExp(Q("[^\\%]",O9,$3),"g"),PCT_ENCODED:new RegExp(Q9,"g"),IPV4ADDRESS:new RegExp("^("+q3+")$"),IPV6ADDRESS:new RegExp("^\\[?("+WA+")"+B(B("\\%25|\\%(?!"+xQ+"{2})")+"("+BA+")")+"?\\]?$")}}var X=I(!1),W=I(!0),K=function(){function V1(iA,z1){var A0=[],E0=!0,xQ=!1,eB=void 0;try{for(var X9=iA[Symbol.iterator](),Q9;!(E0=(Q9=X9.next()).done);E0=!0)if(A0.push(Q9.value),z1&&A0.length===z1)break}catch(y4){xQ=!0,eB=y4}finally{try{if(!E0&&X9.return)X9.return()}finally{if(xQ)throw eB}}return A0}return function(iA,z1){if(Array.isArray(iA))return iA;else if(Symbol.iterator in Object(iA))return V1(iA,z1);else throw TypeError("Invalid attempt to destructure non-iterable instance")}}(),V=function(V1){if(Array.isArray(V1)){for(var iA=0,z1=Array(V1.length);iA<V1.length;iA++)z1[iA]=V1[iA];return z1}else return Array.from(V1)},E=2147483647,D=36,H=1,F=26,C=38,$=700,O=72,M=128,L="-",_=/^xn--/,T=/[^\0-\x7E]/,x=/[\x2E\u3002\uFF0E\uFF61]/g,b={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},v=D-H,m=Math.floor,u=String.fromCharCode;function e(V1){throw RangeError(b[V1])}function p(V1,iA){var z1=[],A0=V1.length;while(A0--)z1[A0]=iA(V1[A0]);return z1}function k(V1,iA){var z1=V1.split("@"),A0="";if(z1.length>1)A0=z1[0]+"@",V1=z1[1];V1=V1.replace(x,".");var E0=V1.split("."),xQ=p(E0,iA).join(".");return A0+xQ}function c(V1){var iA=[],z1=0,A0=V1.length;while(z1<A0){var E0=V1.charCodeAt(z1++);if(E0>=55296&&E0<=56319&&z1<A0){var xQ=V1.charCodeAt(z1++);if((xQ&64512)==56320)iA.push(((E0&1023)<<10)+(xQ&1023)+65536);else iA.push(E0),z1--}else iA.push(E0)}return iA}var t=function(iA){return String.fromCodePoint.apply(String,V(iA))},AA=function(iA){if(iA-48<10)return iA-22;if(iA-65<26)return iA-65;if(iA-97<26)return iA-97;return D},VA=function(iA,z1){return iA+22+75*(iA<26)-((z1!=0)<<5)},OA=function(iA,z1,A0){var E0=0;iA=A0?m(iA/$):iA>>1,iA+=m(iA/z1);for(;iA>v*F>>1;E0+=D)iA=m(iA/v);return m(E0+(v+1)*iA/(iA+C))},IA=function(iA){var z1=[],A0=iA.length,E0=0,xQ=M,eB=O,X9=iA.lastIndexOf(L);if(X9<0)X9=0;for(var Q9=0;Q9<X9;++Q9){if(iA.charCodeAt(Q9)>=128)e("not-basic");z1.push(iA.charCodeAt(Q9))}for(var y4=X9>0?X9+1:0;y4<A0;){var B9=E0;for(var $3=1,w3=D;;w3+=D){if(y4>=A0)e("invalid-input");var C4=AA(iA.charCodeAt(y4++));if(C4>=D||C4>m((E-E0)/$3))e("overflow");E0+=C4*$3;var O9=w3<=eB?H:w3>=eB+F?F:w3-eB;if(C4<O9)break;var N3=D-O9;if($3>m(E/N3))e("overflow");$3*=N3}var p9=z1.length+1;if(eB=OA(E0-B9,p9,B9==0),m(E0/p9)>E-xQ)e("overflow");xQ+=m(E0/p9),E0%=p9,z1.splice(E0++,0,xQ)}return String.fromCodePoint.apply(String,z1)},PA=function(iA){var z1=[];iA=c(iA);var A0=iA.length,E0=M,xQ=0,eB=O,X9=!0,Q9=!1,y4=void 0;try{for(var B9=iA[Symbol.iterator](),$3;!(X9=($3=B9.next()).done);X9=!0){var w3=$3.value;if(w3<128)z1.push(u(w3))}}catch(fA){Q9=!0,y4=fA}finally{try{if(!X9&&B9.return)B9.return()}finally{if(Q9)throw y4}}var C4=z1.length,O9=C4;if(C4)z1.push(L);while(O9<A0){var N3=E,p9=!0,v5=!1,M6=void 0;try{for(var q3=iA[Symbol.iterator](),l9;!(p9=(l9=q3.next()).done);p9=!0){var s0=l9.value;if(s0>=E0&&s0<N3)N3=s0}}catch(fA){v5=!0,M6=fA}finally{try{if(!p9&&q3.return)q3.return()}finally{if(v5)throw M6}}var mQ=O9+1;if(N3-E0>m((E-xQ)/mQ))e("overflow");xQ+=(N3-E0)*mQ,E0=N3;var XB=!0,e9=!1,x2=void 0;try{for(var WG=iA[Symbol.iterator](),gG;!(XB=(gG=WG.next()).done);XB=!0){var f6=gG.value;if(f6<E0&&++xQ>E)e("overflow");if(f6==E0){var b6=xQ;for(var aA=D;;aA+=D){var WA=aA<=eB?H:aA>=eB+F?F:aA-eB;if(b6<WA)break;var BA=b6-WA,xA=D-WA;z1.push(u(VA(WA+BA%xA,0))),b6=m(BA/xA)}z1.push(u(VA(b6,0))),eB=OA(xQ,mQ,O9==C4),xQ=0,++O9}}}catch(fA){e9=!0,x2=fA}finally{try{if(!XB&&WG.return)WG.return()}finally{if(e9)throw x2}}++xQ,++E0}return z1.join("")},kA=function(iA){return k(iA,function(z1){return _.test(z1)?IA(z1.slice(4).toLowerCase()):z1})},YA=function(iA){return k(iA,function(z1){return T.test(z1)?"xn--"+PA(z1):z1})},ZA={version:"2.1.0",ucs2:{decode:c,encode:t},decode:IA,encode:PA,toASCII:YA,toUnicode:kA},zA={};function bA(V1){var iA=V1.charCodeAt(0),z1=void 0;if(iA<16)z1="%0"+iA.toString(16).toUpperCase();else if(iA<128)z1="%"+iA.toString(16).toUpperCase();else if(iA<2048)z1="%"+(iA>>6|192).toString(16).toUpperCase()+"%"+(iA&63|128).toString(16).toUpperCase();else z1="%"+(iA>>12|224).toString(16).toUpperCase()+"%"+(iA>>6&63|128).toString(16).toUpperCase()+"%"+(iA&63|128).toString(16).toUpperCase();return z1}function TA(V1){var iA="",z1=0,A0=V1.length;while(z1<A0){var E0=parseInt(V1.substr(z1+1,2),16);if(E0<128)iA+=String.fromCharCode(E0),z1+=3;else if(E0>=194&&E0<224){if(A0-z1>=6){var xQ=parseInt(V1.substr(z1+4,2),16);iA+=String.fromCharCode((E0&31)<<6|xQ&63)}else iA+=V1.substr(z1,6);z1+=6}else if(E0>=224){if(A0-z1>=9){var eB=parseInt(V1.substr(z1+4,2),16),X9=parseInt(V1.substr(z1+7,2),16);iA+=String.fromCharCode((E0&15)<<12|(eB&63)<<6|X9&63)}else iA+=V1.substr(z1,9);z1+=9}else iA+=V1.substr(z1,3),z1+=3}return iA}function B1(V1,iA){function z1(A0){var E0=TA(A0);return!E0.match(iA.UNRESERVED)?A0:E0}if(V1.scheme)V1.scheme=String(V1.scheme).replace(iA.PCT_ENCODED,z1).toLowerCase().replace(iA.NOT_SCHEME,"");if(V1.userinfo!==void 0)V1.userinfo=String(V1.userinfo).replace(iA.PCT_ENCODED,z1).replace(iA.NOT_USERINFO,bA).replace(iA.PCT_ENCODED,Z);if(V1.host!==void 0)V1.host=String(V1.host).replace(iA.PCT_ENCODED,z1).toLowerCase().replace(iA.NOT_HOST,bA).replace(iA.PCT_ENCODED,Z);if(V1.path!==void 0)V1.path=String(V1.path).replace(iA.PCT_ENCODED,z1).replace(V1.scheme?iA.NOT_PATH:iA.NOT_PATH_NOSCHEME,bA).replace(iA.PCT_ENCODED,Z);if(V1.query!==void 0)V1.query=String(V1.query).replace(iA.PCT_ENCODED,z1).replace(iA.NOT_QUERY,bA).replace(iA.PCT_ENCODED,Z);if(V1.fragment!==void 0)V1.fragment=String(V1.fragment).replace(iA.PCT_ENCODED,z1).replace(iA.NOT_FRAGMENT,bA).replace(iA.PCT_ENCODED,Z);return V1}function JA(V1){return V1.replace(/^0*(.*)/,"$1")||"0"}function CA(V1,iA){var z1=V1.match(iA.IPV4ADDRESS)||[],A0=K(z1,2),E0=A0[1];if(E0)return E0.split(".").map(JA).join(".");else return V1}function MA(V1,iA){var z1=V1.match(iA.IPV6ADDRESS)||[],A0=K(z1,3),E0=A0[1],xQ=A0[2];if(E0){var eB=E0.toLowerCase().split("::").reverse(),X9=K(eB,2),Q9=X9[0],y4=X9[1],B9=y4?y4.split(":").map(JA):[],$3=Q9.split(":").map(JA),w3=iA.IPV4ADDRESS.test($3[$3.length-1]),C4=w3?7:8,O9=$3.length-C4,N3=Array(C4);for(var p9=0;p9<C4;++p9)N3[p9]=B9[p9]||$3[O9+p9]||"";if(w3)N3[C4-1]=CA(N3[C4-1],iA);var v5=N3.reduce(function(mQ,XB,e9){if(!XB||XB==="0"){var x2=mQ[mQ.length-1];if(x2&&x2.index+x2.length===e9)x2.length++;else mQ.push({index:e9,length:1})}return mQ},[]),M6=v5.sort(function(mQ,XB){return XB.length-mQ.length})[0],q3=void 0;if(M6&&M6.length>1){var l9=N3.slice(0,M6.index),s0=N3.slice(M6.index+M6.length);q3=l9.join(":")+"::"+s0.join(":")}else q3=N3.join(":");if(xQ)q3+="%"+xQ;return q3}else return V1}var NA=/^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i,UA="".match(/(){0}/)[1]===void 0;function LA(V1){var iA=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},z1={},A0=iA.iri!==!1?W:X;if(iA.reference==="suffix")V1=(iA.scheme?iA.scheme+":":"")+"//"+V1;var E0=V1.match(NA);if(E0){if(UA){if(z1.scheme=E0[1],z1.userinfo=E0[3],z1.host=E0[4],z1.port=parseInt(E0[5],10),z1.path=E0[6]||"",z1.query=E0[7],z1.fragment=E0[8],isNaN(z1.port))z1.port=E0[5]}else if(z1.scheme=E0[1]||void 0,z1.userinfo=V1.indexOf("@")!==-1?E0[3]:void 0,z1.host=V1.indexOf("//")!==-1?E0[4]:void 0,z1.port=parseInt(E0[5],10),z1.path=E0[6]||"",z1.query=V1.indexOf("?")!==-1?E0[7]:void 0,z1.fragment=V1.indexOf("#")!==-1?E0[8]:void 0,isNaN(z1.port))z1.port=V1.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/)?E0[4]:void 0;if(z1.host)z1.host=MA(CA(z1.host,A0),A0);if(z1.scheme===void 0&&z1.userinfo===void 0&&z1.host===void 0&&z1.port===void 0&&!z1.path&&z1.query===void 0)z1.reference="same-document";else if(z1.scheme===void 0)z1.reference="relative";else if(z1.fragment===void 0)z1.reference="absolute";else z1.reference="uri";if(iA.reference&&iA.reference!=="suffix"&&iA.reference!==z1.reference)z1.error=z1.error||"URI is not a "+iA.reference+" reference.";var xQ=zA[(iA.scheme||z1.scheme||"").toLowerCase()];if(!iA.unicodeSupport&&(!xQ||!xQ.unicodeSupport)){if(z1.host&&(iA.domainHost||xQ&&xQ.domainHost))try{z1.host=ZA.toASCII(z1.host.replace(A0.PCT_ENCODED,TA).toLowerCase())}catch(eB){z1.error=z1.error||"Host's domain name can not be converted to ASCII via punycode: "+eB}B1(z1,X)}else B1(z1,A0);if(xQ&&xQ.parse)xQ.parse(z1,iA)}else z1.error=z1.error||"URI can not be parsed.";return z1}function nA(V1,iA){var z1=iA.iri!==!1?W:X,A0=[];if(V1.userinfo!==void 0)A0.push(V1.userinfo),A0.push("@");if(V1.host!==void 0)A0.push(MA(CA(String(V1.host),z1),z1).replace(z1.IPV6ADDRESS,function(E0,xQ,eB){return"["+xQ+(eB?"%25"+eB:"")+"]"}));if(typeof V1.port==="number"||typeof V1.port==="string")A0.push(":"),A0.push(String(V1.port));return A0.length?A0.join(""):void 0}var gA=/^\.\.?\//,I1=/^\/\.(\/|$)/,q1=/^\/\.\.(\/|$)/,_A=/^\/?(?:.|\n)*?(?=\/|$)/;function Q1(V1){var iA=[];while(V1.length)if(V1.match(gA))V1=V1.replace(gA,"");else if(V1.match(I1))V1=V1.replace(I1,"/");else if(V1.match(q1))V1=V1.replace(q1,"/"),iA.pop();else if(V1==="."||V1==="..")V1="";else{var z1=V1.match(_A);if(z1){var A0=z1[0];V1=V1.slice(A0.length),iA.push(A0)}else throw Error("Unexpected dot segment condition")}return iA.join("")}function h1(V1){var iA=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},z1=iA.iri?W:X,A0=[],E0=zA[(iA.scheme||V1.scheme||"").toLowerCase()];if(E0&&E0.serialize)E0.serialize(V1,iA);if(V1.host){if(z1.IPV6ADDRESS.test(V1.host));else if(iA.domainHost||E0&&E0.domainHost)try{V1.host=!iA.iri?ZA.toASCII(V1.host.replace(z1.PCT_ENCODED,TA).toLowerCase()):ZA.toUnicode(V1.host)}catch(X9){V1.error=V1.error||"Host's domain name can not be converted to "+(!iA.iri?"ASCII":"Unicode")+" via punycode: "+X9}}if(B1(V1,z1),iA.reference!=="suffix"&&V1.scheme)A0.push(V1.scheme),A0.push(":");var xQ=nA(V1,iA);if(xQ!==void 0){if(iA.reference!=="suffix")A0.push("//");if(A0.push(xQ),V1.path&&V1.path.charAt(0)!=="/")A0.push("/")}if(V1.path!==void 0){var eB=V1.path;if(!iA.absolutePath&&(!E0||!E0.absolutePath))eB=Q1(eB);if(xQ===void 0)eB=eB.replace(/^\/\//,"/%2F");A0.push(eB)}if(V1.query!==void 0)A0.push("?"),A0.push(V1.query);if(V1.fragment!==void 0)A0.push("#"),A0.push(V1.fragment);return A0.join("")}function _1(V1,iA){var z1=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},A0=arguments[3],E0={};if(!A0)V1=LA(h1(V1,z1),z1),iA=LA(h1(iA,z1),z1);if(z1=z1||{},!z1.tolerant&&iA.scheme)E0.scheme=iA.scheme,E0.userinfo=iA.userinfo,E0.host=iA.host,E0.port=iA.port,E0.path=Q1(iA.path||""),E0.query=iA.query;else{if(iA.userinfo!==void 0||iA.host!==void 0||iA.port!==void 0)E0.userinfo=iA.userinfo,E0.host=iA.host,E0.port=iA.port,E0.path=Q1(iA.path||""),E0.query=iA.query;else{if(!iA.path)if(E0.path=V1.path,iA.query!==void 0)E0.query=iA.query;else E0.query=V1.query;else{if(iA.path.charAt(0)==="/")E0.path=Q1(iA.path);else{if((V1.userinfo!==void 0||V1.host!==void 0||V1.port!==void 0)&&!V1.path)E0.path="/"+iA.path;else if(!V1.path)E0.path=iA.path;else E0.path=V1.path.slice(0,V1.path.lastIndexOf("/")+1)+iA.path;E0.path=Q1(E0.path)}E0.query=iA.query}E0.userinfo=V1.userinfo,E0.host=V1.host,E0.port=V1.port}E0.scheme=V1.scheme}return E0.fragment=iA.fragment,E0}function V0(V1,iA,z1){var A0=J({scheme:"null"},z1);return h1(_1(LA(V1,A0),LA(iA,A0),A0,!0),A0)}function AQ(V1,iA){if(typeof V1==="string")V1=h1(LA(V1,iA),iA);else if(G(V1)==="object")V1=LA(h1(V1,iA),iA);return V1}function n0(V1,iA,z1){if(typeof V1==="string")V1=h1(LA(V1,z1),z1);else if(G(V1)==="object")V1=h1(V1,z1);if(typeof iA==="string")iA=h1(LA(iA,z1),z1);else if(G(iA)==="object")iA=h1(iA,z1);return V1===iA}function JQ(V1,iA){return V1&&V1.toString().replace(!iA||!iA.iri?X.ESCAPE:W.ESCAPE,bA)}function BQ(V1,iA){return V1&&V1.toString().replace(!iA||!iA.iri?X.PCT_ENCODED:W.PCT_ENCODED,TA)}var F1={scheme:"http",domainHost:!0,parse:function(iA,z1){if(!iA.host)iA.error=iA.error||"HTTP URIs must have a host.";return iA},serialize:function(iA,z1){var A0=String(iA.scheme).toLowerCase()==="https";if(iA.port===(A0?443:80)||iA.port==="")iA.port=void 0;if(!iA.path)iA.path="/";return iA}},eA={scheme:"https",domainHost:F1.domainHost,parse:F1.parse,serialize:F1.serialize};function K1(V1){return typeof V1.secure==="boolean"?V1.secure:String(V1.scheme).toLowerCase()==="wss"}var O1={scheme:"ws",domainHost:!0,parse:function(iA,z1){var A0=iA;return A0.secure=K1(A0),A0.resourceName=(A0.path||"/")+(A0.query?"?"+A0.query:""),A0.path=void 0,A0.query=void 0,A0},serialize:function(iA,z1){if(iA.port===(K1(iA)?443:80)||iA.port==="")iA.port=void 0;if(typeof iA.secure==="boolean")iA.scheme=iA.secure?"wss":"ws",iA.secure=void 0;if(iA.resourceName){var A0=iA.resourceName.split("?"),E0=K(A0,2),xQ=E0[0],eB=E0[1];iA.path=xQ&&xQ!=="/"?xQ:void 0,iA.query=eB,iA.resourceName=void 0}return iA.fragment=void 0,iA}},G0={scheme:"wss",domainHost:O1.domainHost,parse:O1.parse,serialize:O1.serialize},$0={},F0=!0,HA="[A-Za-z0-9\\-\\.\\_\\~"+(F0?"\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF":"")+"]",$A="[0-9A-Fa-f]",A1=B(B("%[EFef]"+$A+"%"+$A+$A+"%"+$A+$A)+"|"+B("%[89A-Fa-f]"+$A+"%"+$A+$A)+"|"+B("%"+$A+$A)),N1="[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]",C1="[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]",D1=Q(C1,"[\\\"\\\\]"),B0="[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]",i1=new RegExp(HA,"g"),P0=new RegExp(A1,"g"),IQ=new RegExp(Q("[^]",N1,"[\\.]","[\\\"]",D1),"g"),fB=new RegExp(Q("[^]",HA,B0),"g"),oQ=fB;function H2(V1){var iA=TA(V1);return!iA.match(i1)?V1:iA}var d0={scheme:"mailto",parse:function(iA,z1){var A0=iA,E0=A0.to=A0.path?A0.path.split(","):[];if(A0.path=void 0,A0.query){var xQ=!1,eB={},X9=A0.query.split("&");for(var Q9=0,y4=X9.length;Q9<y4;++Q9){var B9=X9[Q9].split("=");switch(B9[0]){case"to":var $3=B9[1].split(",");for(var w3=0,C4=$3.length;w3<C4;++w3)E0.push($3[w3]);break;case"subject":A0.subject=BQ(B9[1],z1);break;case"body":A0.body=BQ(B9[1],z1);break;default:xQ=!0,eB[BQ(B9[0],z1)]=BQ(B9[1],z1);break}}if(xQ)A0.headers=eB}A0.query=void 0;for(var O9=0,N3=E0.length;O9<N3;++O9){var p9=E0[O9].split("@");if(p9[0]=BQ(p9[0]),!z1.unicodeSupport)try{p9[1]=ZA.toASCII(BQ(p9[1],z1).toLowerCase())}catch(v5){A0.error=A0.error||"Email address's domain name can not be converted to ASCII via punycode: "+v5}else p9[1]=BQ(p9[1],z1).toLowerCase();E0[O9]=p9.join("@")}return A0},serialize:function(iA,z1){var A0=iA,E0=Y(iA.to);if(E0){for(var xQ=0,eB=E0.length;xQ<eB;++xQ){var X9=String(E0[xQ]),Q9=X9.lastIndexOf("@"),y4=X9.slice(0,Q9).replace(P0,H2).replace(P0,Z).replace(IQ,bA),B9=X9.slice(Q9+1);try{B9=!z1.iri?ZA.toASCII(BQ(B9,z1).toLowerCase()):ZA.toUnicode(B9)}catch(O9){A0.error=A0.error||"Email address's domain name can not be converted to "+(!z1.iri?"ASCII":"Unicode")+" via punycode: "+O9}E0[xQ]=y4+"@"+B9}A0.path=E0.join(",")}var $3=iA.headers=iA.headers||{};if(iA.subject)$3.subject=iA.subject;if(iA.body)$3.body=iA.body;var w3=[];for(var C4 in $3)if($3[C4]!==$0[C4])w3.push(C4.replace(P0,H2).replace(P0,Z).replace(fB,bA)+"="+$3[C4].replace(P0,H2).replace(P0,Z).replace(oQ,bA));if(w3.length)A0.query=w3.join("&");return A0}},NQ=/^([^\:]+)\:(.*)/,RB={scheme:"urn",parse:function(iA,z1){var A0=iA.path&&iA.path.match(NQ),E0=iA;if(A0){var xQ=z1.scheme||E0.scheme||"urn",eB=A0[1].toLowerCase(),X9=A0[2],Q9=xQ+":"+(z1.nid||eB),y4=zA[Q9];if(E0.nid=eB,E0.nss=X9,E0.path=void 0,y4)E0=y4.parse(E0,z1)}else E0.error=E0.error||"URN can not be parsed.";return E0},serialize:function(iA,z1){var A0=z1.scheme||iA.scheme||"urn",E0=iA.nid,xQ=A0+":"+(z1.nid||E0),eB=zA[xQ];if(eB)iA=eB.serialize(iA,z1);var X9=iA,Q9=iA.nss;return X9.path=(E0||z1.nid)+":"+Q9,X9}},z9=/^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/,JB={scheme:"urn:uuid",parse:function(iA,z1){var A0=iA;if(A0.uuid=A0.nss,A0.nss=void 0,!z1.tolerant&&(!A0.uuid||!A0.uuid.match(z9)))A0.error=A0.error||"UUID is not valid.";return A0},serialize:function(iA,z1){var A0=iA;return A0.nss=(iA.uuid||"").toLowerCase(),A0}};zA[F1.scheme]=F1,zA[eA.scheme]=eA,zA[O1.scheme]=O1,zA[G0.scheme]=G0,zA[d0.scheme]=d0,zA[RB.scheme]=RB,zA[JB.scheme]=JB,A.SCHEMES=zA,A.pctEncChar=bA,A.pctDecChars=TA,A.parse=LA,A.removeDotSegments=Q1,A.serialize=h1,A.resolveComponents=_1,A.resolve=V0,A.normalize=AQ,A.equal=n0,A.escapeComponent=JQ,A.unescapeComponent=BQ,Object.defineProperty(A,"__esModule",{value:!0})})});var soA=w((Rl7,AKB)=>{AKB.exports=function A(Q,B){if(Q===B)return!0;if(Q&&B&&typeof Q=="object"&&typeof B=="object"){if(Q.constructor!==B.constructor)return!1;var G,Z,Y;if(Array.isArray(Q)){if(G=Q.length,G!=B.length)return!1;for(Z=G;Z--!==0;)if(!A(Q[Z],B[Z]))return!1;return!0}if(Q.constructor===RegExp)return Q.source===B.source&&Q.flags===B.flags;if(Q.valueOf!==Object.prototype.valueOf)return Q.valueOf()===B.valueOf();if(Q.toString!==Object.prototype.toString)return Q.toString()===B.toString();if(Y=Object.keys(Q),G=Y.length,G!==Object.keys(B).length)return!1;for(Z=G;Z--!==0;)if(!Object.prototype.hasOwnProperty.call(B,Y[Z]))return!1;for(Z=G;Z--!==0;){var J=Y[Z];if(!A(Q[J],B[J]))return!1}return!0}return Q!==Q&&B!==B}});var BKB=w((_l7,QKB)=>{QKB.exports=function(Q){var B=0,G=Q.length,Z=0,Y;while(Z<G)if(B++,Y=Q.charCodeAt(Z++),Y>=55296&&Y<=56319&&Z<G){if(Y=Q.charCodeAt(Z),(Y&64512)==56320)Z++}return B}});var ye=w((Tl7,YKB)=>{YKB.exports={copy:lL6,checkDataType:sd1,checkDataTypes:iL6,coerceToTypes:nL6,toHash:ed1,getProperty:Ac1,escapeQuotes:Qc1,equal:soA(),ucs2length:BKB(),varOccurences:rL6,varReplace:sL6,schemaHasRules:tL6,schemaHasRulesExcept:eL6,schemaUnknownRules:AM6,toQuotedString:td1,getPathExpr:QM6,getPath:BM6,getData:YM6,unescapeFragment:JM6,unescapeJsonPointer:Gc1,escapeFragment:IM6,escapeJsonPointer:Bc1};function lL6(A,Q){Q=Q||{};for(var B in A)Q[B]=A[B];return Q}function sd1(A,Q,B,G){var Z=G?" !== ":" === ",Y=G?" || ":" && ",J=G?"!":"",I=G?"":"!";switch(A){case"null":return Q+Z+"null";case"array":return J+"Array.isArray("+Q+")";case"object":return"("+J+Q+Y+"typeof "+Q+Z+'"object"'+Y+I+"Array.isArray("+Q+"))";case"integer":return"(typeof "+Q+Z+'"number"'+Y+I+"("+Q+" % 1)"+Y+Q+Z+Q+(B?Y+J+"isFinite("+Q+")":"")+")";case"number":return"(typeof "+Q+Z+'"'+A+'"'+(B?Y+J+"isFinite("+Q+")":"")+")";default:return"typeof "+Q+Z+'"'+A+'"'}}function iL6(A,Q,B){switch(A.length){case 1:return sd1(A[0],Q,B,!0);default:var G="",Z=ed1(A);if(Z.array&&Z.object)G=Z.null?"(":"(!"+Q+" || ",G+="typeof "+Q+' !== "object")',delete Z.null,delete Z.array,delete Z.object;if(Z.number)delete Z.integer;for(var Y in Z)G+=(G?" && ":"")+sd1(Y,Q,B,!0);return G}}var GKB=ed1(["string","number","integer","boolean","null"]);function nL6(A,Q){if(Array.isArray(Q)){var B=[];for(var G=0;G<Q.length;G++){var Z=Q[G];if(GKB[Z])B[B.length]=Z;else if(A==="array"&&Z==="array")B[B.length]=Z}if(B.length)return B}else if(GKB[Q])return[Q];else if(A==="array"&&Q==="array")return["array"]}function ed1(A){var Q={};for(var B=0;B<A.length;B++)Q[A[B]]=!0;return Q}var aL6=/^[a-z$_][a-z$_0-9]*$/i,oL6=/'|\\/g;function Ac1(A){return typeof A=="number"?"["+A+"]":aL6.test(A)?"."+A:"['"+Qc1(A)+"']"}function Qc1(A){return A.replace(oL6,"\\$&").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/\f/g,"\\f").replace(/\t/g,"\\t")}function rL6(A,Q){Q+="[^0-9]";var B=A.match(new RegExp(Q,"g"));return B?B.length:0}function sL6(A,Q,B){return Q+="([^0-9])",B=B.replace(/\$/g,"$$$$"),A.replace(new RegExp(Q,"g"),B+"$1")}function tL6(A,Q){if(typeof A=="boolean")return!A;for(var B in A)if(Q[B])return!0}function eL6(A,Q,B){if(typeof A=="boolean")return!A&&B!="not";for(var G in A)if(G!=B&&Q[G])return!0}function AM6(A,Q){if(typeof A=="boolean")return;for(var B in A)if(!Q[B])return B}function td1(A){return"'"+Qc1(A)+"'"}function QM6(A,Q,B,G){var Z=B?"'/' + "+Q+(G?"":".replace(/~/g, '~0').replace(/\\//g, '~1')"):G?"'[' + "+Q+" + ']'":"'[\\'' + "+Q+" + '\\']'";return ZKB(A,Z)}function BM6(A,Q,B){var G=B?td1("/"+Bc1(Q)):td1(Ac1(Q));return ZKB(A,G)}var GM6=/^\/(?:[^~]|~0|~1)*$/,ZM6=/^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;function YM6(A,Q,B){var G,Z,Y,J;if(A==="")return"rootData";if(A[0]=="/"){if(!GM6.test(A))throw Error("Invalid JSON-pointer: "+A);Z=A,Y="rootData"}else{if(J=A.match(ZM6),!J)throw Error("Invalid JSON-pointer: "+A);if(G=+J[1],Z=J[2],Z=="#"){if(G>=Q)throw Error("Cannot access property/index "+G+" levels up, current level is "+Q);return B[Q-G]}if(G>Q)throw Error("Cannot access data "+G+" levels up, current level is "+Q);if(Y="data"+(Q-G||""),!Z)return Y}var I=Y,X=Z.split("/");for(var W=0;W<X.length;W++){var K=X[W];if(K)Y+=Ac1(Gc1(K)),I+=" && "+Y}return I}function ZKB(A,Q){if(A=='""')return Q;return(A+" + "+Q).replace(/([^\\])' \+ '/g,"$1")}function JM6(A){return Gc1(decodeURIComponent(A))}function IM6(A){return encodeURIComponent(Bc1(A))}function Bc1(A){return A.replace(/~/g,"~0").replace(/\//g,"~1")}function Gc1(A){return A.replace(/~1/g,"/").replace(/~0/g,"~")}});var Zc1=w((jl7,JKB)=>{var XM6=ye();JKB.exports=WM6;function WM6(A){XM6.copy(A,this)}});var XKB=w((Pl7,IKB)=>{var Sp=IKB.exports=function(A,Q,B){if(typeof Q=="function")B=Q,Q={};B=Q.cb||B;var G=typeof B=="function"?B:B.pre||function(){},Z=B.post||function(){};toA(Q,G,Z,A,"",A)};Sp.keywords={additionalItems:!0,items:!0,contains:!0,additionalProperties:!0,propertyNames:!0,not:!0};Sp.arrayKeywords={items:!0,allOf:!0,anyOf:!0,oneOf:!0};Sp.propsKeywords={definitions:!0,properties:!0,patternProperties:!0,dependencies:!0};Sp.skipKeywords={default:!0,enum:!0,const:!0,required:!0,maximum:!0,minimum:!0,exclusiveMaximum:!0,exclusiveMinimum:!0,multipleOf:!0,maxLength:!0,minLength:!0,pattern:!0,format:!0,maxItems:!0,minItems:!0,uniqueItems:!0,maxProperties:!0,minProperties:!0};function toA(A,Q,B,G,Z,Y,J,I,X,W){if(G&&typeof G=="object"&&!Array.isArray(G)){Q(G,Z,Y,J,I,X,W);for(var K in G){var V=G[K];if(Array.isArray(V)){if(K in Sp.arrayKeywords)for(var E=0;E<V.length;E++)toA(A,Q,B,V[E],Z+"/"+K+"/"+E,Y,Z,K,G,E)}else if(K in Sp.propsKeywords){if(V&&typeof V=="object")for(var D in V)toA(A,Q,B,V[D],Z+"/"+K+"/"+KM6(D),Y,Z,K,G,D)}else if(K in Sp.keywords||A.allKeys&&!(K in Sp.skipKeywords))toA(A,Q,B,V,Z+"/"+K,Y,Z,K,G)}B(G,Z,Y,J,I,X,W)}}function KM6(A){return A.replace(/~/g,"~0").replace(/\//g,"~1")}});var ZrA=w((Sl7,EKB)=>{var LwA=eWB(),WKB=soA(),BrA=ye(),eoA=Zc1(),VM6=XKB();EKB.exports=yp;yp.normalizeId=xp;yp.fullPath=ArA;yp.url=QrA;yp.ids=CM6;yp.inlineRef=Yc1;yp.schema=GrA;function yp(A,Q,B){var G=this._refs[B];if(typeof G=="string")if(this._refs[G])G=this._refs[G];else return yp.call(this,A,Q,G);if(G=G||this._schemas[B],G instanceof eoA)return Yc1(G.schema,this._opts.inlineRefs)?G.schema:G.validate||this._compile(G);var Z=GrA.call(this,Q,B),Y,J,I;if(Z)Y=Z.schema,Q=Z.root,I=Z.baseId;if(Y instanceof eoA)J=Y.validate||A.call(this,Y.schema,Q,void 0,I);else if(Y!==void 0)J=Yc1(Y,this._opts.inlineRefs)?Y:A.call(this,Y,Q,void 0,I);return J}function GrA(A,Q){var B=LwA.parse(Q),G=VKB(B),Z=ArA(this._getId(A.schema));if(Object.keys(A.schema).length===0||G!==Z){var Y=xp(G),J=this._refs[Y];if(typeof J=="string")return EM6.call(this,A,J,B);else if(J instanceof eoA){if(!J.validate)this._compile(J);A=J}else if(J=this._schemas[Y],J instanceof eoA){if(!J.validate)this._compile(J);if(Y==xp(Q))return{schema:J,root:A,baseId:Z};A=J}else return;if(!A.schema)return;Z=ArA(this._getId(A.schema))}return KKB.call(this,B,Z,A.schema,A)}function EM6(A,Q,B){var G=GrA.call(this,A,Q);if(G){var{schema:Z,baseId:Y}=G;A=G.root;var J=this._getId(Z);if(J)Y=QrA(Y,J);return KKB.call(this,B,Y,Z,A)}}var DM6=BrA.toHash(["properties","patternProperties","enum","dependencies","definitions"]);function KKB(A,Q,B,G){if(A.fragment=A.fragment||"",A.fragment.slice(0,1)!="/")return;var Z=A.fragment.split("/");for(var Y=1;Y<Z.length;Y++){var J=Z[Y];if(J){if(J=BrA.unescapeFragment(J),B=B[J],B===void 0)break;var I;if(!DM6[J]){if(I=this._getId(B),I)Q=QrA(Q,I);if(B.$ref){var X=QrA(Q,B.$ref),W=GrA.call(this,G,X);if(W)B=W.schema,G=W.root,Q=W.baseId}}}}if(B!==void 0&&B!==G.schema)return{schema:B,root:G,baseId:Q}}var HM6=BrA.toHash(["type","format","pattern","maxLength","minLength","maxProperties","minProperties","maxItems","minItems","maximum","minimum","uniqueItems","multipleOf","required","enum"]);function Yc1(A,Q){if(Q===!1)return!1;if(Q===void 0||Q===!0)return Jc1(A);else if(Q)return Ic1(A)<=Q}function Jc1(A){var Q;if(Array.isArray(A)){for(var B=0;B<A.length;B++)if(Q=A[B],typeof Q=="object"&&!Jc1(Q))return!1}else for(var G in A){if(G=="$ref")return!1;if(Q=A[G],typeof Q=="object"&&!Jc1(Q))return!1}return!0}function Ic1(A){var Q=0,B;if(Array.isArray(A))for(var G=0;G<A.length;G++){if(B=A[G],typeof B=="object")Q+=Ic1(B);if(Q==1/0)return 1/0}else for(var Z in A){if(Z=="$ref")return 1/0;if(HM6[Z])Q++;else{if(B=A[Z],typeof B=="object")Q+=Ic1(B)+1;if(Q==1/0)return 1/0}}return Q}function ArA(A,Q){if(Q!==!1)A=xp(A);var B=LwA.parse(A);return VKB(B)}function VKB(A){return LwA.serialize(A).split("#")[0]+"#"}var FM6=/#\/?$/;function xp(A){return A?A.replace(FM6,""):""}function QrA(A,Q){return Q=xp(Q),LwA.resolve(A,Q)}function CM6(A){var Q=xp(this._getId(A)),B={"":Q},G={"":ArA(Q,!1)},Z={},Y=this;return VM6(A,{allKeys:!0},function(J,I,X,W,K,V,E){if(I==="")return;var D=Y._getId(J),H=B[W],F=G[W]+"/"+K;if(E!==void 0)F+="/"+(typeof E=="number"?E:BrA.escapeFragment(E));if(typeof D=="string"){D=H=xp(H?LwA.resolve(H,D):D);var C=Y._refs[D];if(typeof C=="string")C=Y._refs[C];if(C&&C.schema){if(!WKB(J,C.schema))throw Error('id "'+D+'" resolves to more than one schema')}else if(D!=xp(F))if(D[0]=="#"){if(Z[D]&&!WKB(J,Z[D]))throw Error('id "'+D+'" resolves to more than one schema');Z[D]=J}else Y._refs[D]=F}B[I]=H,G[I]=F}),Z}});var YrA=w((xl7,HKB)=>{var Xc1=ZrA();HKB.exports={Validation:DKB(zM6),MissingRef:DKB(Wc1)};function zM6(A){this.message="validation failed",this.errors=A,this.ajv=this.validation=!0}Wc1.message=function(A,Q){return"can't resolve reference "+Q+" from id "+A};function Wc1(A,Q,B){this.message=B||Wc1.message(A,Q),this.missingRef=Xc1.url(A,Q),this.missingSchema=Xc1.normalizeId(Xc1.fullPath(this.missingRef))}function DKB(A){return A.prototype=Object.create(Error.prototype),A.prototype.constructor=A,A}});var Kc1=w((yl7,FKB)=>{FKB.exports=function(A,Q){if(!Q)Q={};if(typeof Q==="function")Q={cmp:Q};var B=typeof Q.cycles==="boolean"?Q.cycles:!1,G=Q.cmp&&function(Y){return function(J){return function(I,X){var W={key:I,value:J[I]},K={key:X,value:J[X]};return Y(W,K)}}}(Q.cmp),Z=[];return function Y(J){if(J&&J.toJSON&&typeof J.toJSON==="function")J=J.toJSON();if(J===void 0)return;if(typeof J=="number")return isFinite(J)?""+J:"null";if(typeof J!=="object")return JSON.stringify(J);var I,X;if(Array.isArray(J)){X="[";for(I=0;I<J.length;I++){if(I)X+=",";X+=Y(J[I])||"null"}return X+"]"}if(J===null)return"null";if(Z.indexOf(J)!==-1){if(B)return JSON.stringify("__cycle__");throw TypeError("Converting circular structure to JSON")}var W=Z.push(J)-1,K=Object.keys(J).sort(G&&G(J));X="";for(I=0;I<K.length;I++){var V=K[I],E=Y(J[V]);if(!E)continue;if(X)X+=",";X+=JSON.stringify(V)+":"+E}return Z.splice(W,1),"{"+X+"}"}(A)}});var Vc1=w((vl7,CKB)=>{CKB.exports=function(Q,B,G){var Z="",Y=Q.schema.$async===!0,J=Q.util.schemaHasRulesExcept(Q.schema,Q.RULES.all,"$ref"),I=Q.self._getId(Q.schema);if(Q.opts.strictKeywords){var X=Q.util.schemaUnknownRules(Q.schema,Q.RULES.keywords);if(X){var W="unknown keyword: "+X;if(Q.opts.strictKeywords==="log")Q.logger.warn(W);else throw Error(W)}}if(Q.isTop){if(Z+=" var validate = ",Y)Q.async=!0,Z+="async ";if(Z+="function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ",I&&(Q.opts.sourceCode||Q.opts.processCode))Z+=" "+("/*# sourceURL="+I+" */")+" "}if(typeof Q.schema=="boolean"||!(J||Q.schema.$ref)){var B="false schema",K=Q.level,V=Q.dataLevel,E=Q.schema[B],D=Q.schemaPath+Q.util.getProperty(B),H=Q.errSchemaPath+"/"+B,_=!Q.opts.allErrors,b,F="data"+(V||""),L="valid"+K;if(Q.schema===!1){if(Q.isTop)_=!0;else Z+=" var "+L+" = false; ";var C=C||[];if(C.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(b||"false schema")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(H)+" , params: {} ",Q.opts.messages!==!1)Z+=" , message: 'boolean schema is false' ";if(Q.opts.verbose)Z+=" , schema: false , parentSchema: validate.schema"+Q.schemaPath+" , data: "+F+" ";Z+=" } "}else Z+=" {} ";var $=Z;if(Z=C.pop(),!Q.compositeRule&&_)if(Q.async)Z+=" throw new ValidationError(["+$+"]); ";else Z+=" validate.errors = ["+$+"]; return false; ";else Z+=" var err = "+$+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "}else if(Q.isTop)if(Y)Z+=" return data; ";else Z+=" validate.errors = null; return true; ";else Z+=" var "+L+" = true; ";if(Q.isTop)Z+=" }; return validate; ";return Z}if(Q.isTop){var O=Q.isTop,K=Q.level=0,V=Q.dataLevel=0,F="data";if(Q.rootId=Q.resolve.fullPath(Q.self._getId(Q.root.schema)),Q.baseId=Q.baseId||Q.rootId,delete Q.isTop,Q.dataPathArr=[""],Q.schema.default!==void 0&&Q.opts.useDefaults&&Q.opts.strictDefaults){var M="default is ignored in the schema root";if(Q.opts.strictDefaults==="log")Q.logger.warn(M);else throw Error(M)}Z+=" var vErrors = null; ",Z+=" var errors = 0;     ",Z+=" if (rootData === undefined) rootData = data; "}else{var{level:K,dataLevel:V}=Q,F="data"+(V||"");if(I)Q.baseId=Q.resolve.url(Q.baseId,I);if(Y&&!Q.async)throw Error("async schema in sync schema");Z+=" var errs_"+K+" = errors;"}var L="valid"+K,_=!Q.opts.allErrors,T="",x="",b,v=Q.schema.type,m=Array.isArray(v);if(v&&Q.opts.nullable&&Q.schema.nullable===!0){if(m){if(v.indexOf("null")==-1)v=v.concat("null")}else if(v!="null")v=[v,"null"],m=!0}if(m&&v.length==1)v=v[0],m=!1;if(Q.schema.$ref&&J){if(Q.opts.extendRefs=="fail")throw Error('$ref: validation keywords used in schema at path "'+Q.errSchemaPath+'" (see option extendRefs)');else if(Q.opts.extendRefs!==!0)J=!1,Q.logger.warn('$ref: keywords ignored in schema at path "'+Q.errSchemaPath+'"')}if(Q.schema.$comment&&Q.opts.$comment)Z+=" "+Q.RULES.all.$comment.code(Q,"$comment");if(v){if(Q.opts.coerceTypes)var u=Q.util.coerceToTypes(Q.opts.coerceTypes,v);var e=Q.RULES.types[v];if(u||m||e===!0||e&&!_A(e)){var D=Q.schemaPath+".type",H=Q.errSchemaPath+"/type",D=Q.schemaPath+".type",H=Q.errSchemaPath+"/type",p=m?"checkDataTypes":"checkDataType";if(Z+=" if ("+Q.util[p](v,F,Q.opts.strictNumbers,!0)+") { ",u){var k="dataType"+K,c="coerced"+K;if(Z+=" var "+k+" = typeof "+F+"; var "+c+" = undefined; ",Q.opts.coerceTypes=="array")Z+=" if ("+k+" == 'object' && Array.isArray("+F+") && "+F+".length == 1) { "+F+" = "+F+"[0]; "+k+" = typeof "+F+"; if ("+Q.util.checkDataType(Q.schema.type,F,Q.opts.strictNumbers)+") "+c+" = "+F+"; } ";Z+=" if ("+c+" !== undefined) ; ";var t=u;if(t){var AA,VA=-1,OA=t.length-1;while(VA<OA)if(AA=t[VA+=1],AA=="string")Z+=" else if ("+k+" == 'number' || "+k+" == 'boolean') "+c+" = '' + "+F+"; else if ("+F+" === null) "+c+" = ''; ";else if(AA=="number"||AA=="integer"){if(Z+=" else if ("+k+" == 'boolean' || "+F+" === null || ("+k+" == 'string' && "+F+" && "+F+" == +"+F+" ",AA=="integer")Z+=" && !("+F+" % 1)";Z+=")) "+c+" = +"+F+"; "}else if(AA=="boolean")Z+=" else if ("+F+" === 'false' || "+F+" === 0 || "+F+" === null) "+c+" = false; else if ("+F+" === 'true' || "+F+" === 1) "+c+" = true; ";else if(AA=="null")Z+=" else if ("+F+" === '' || "+F+" === 0 || "+F+" === false) "+c+" = null; ";else if(Q.opts.coerceTypes=="array"&&AA=="array")Z+=" else if ("+k+" == 'string' || "+k+" == 'number' || "+k+" == 'boolean' || "+F+" == null) "+c+" = ["+F+"]; "}Z+=" else {   ";var C=C||[];if(C.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(b||"type")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(H)+" , params: { type: '",m)Z+=""+v.join(",");else Z+=""+v;if(Z+="' } ",Q.opts.messages!==!1){if(Z+=" , message: 'should be ",m)Z+=""+v.join(",");else Z+=""+v;Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+D+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+F+" ";Z+=" } "}else Z+=" {} ";var $=Z;if(Z=C.pop(),!Q.compositeRule&&_)if(Q.async)Z+=" throw new ValidationError(["+$+"]); ";else Z+=" validate.errors = ["+$+"]; return false; ";else Z+=" var err = "+$+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";Z+=" } if ("+c+" !== undefined) {  ";var IA=V?"data"+(V-1||""):"parentData",PA=V?Q.dataPathArr[V]:"parentDataProperty";if(Z+=" "+F+" = "+c+"; ",!V)Z+="if ("+IA+" !== undefined)";Z+=" "+IA+"["+PA+"] = "+c+"; } "}else{var C=C||[];if(C.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(b||"type")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(H)+" , params: { type: '",m)Z+=""+v.join(",");else Z+=""+v;if(Z+="' } ",Q.opts.messages!==!1){if(Z+=" , message: 'should be ",m)Z+=""+v.join(",");else Z+=""+v;Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+D+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+F+" ";Z+=" } "}else Z+=" {} ";var $=Z;if(Z=C.pop(),!Q.compositeRule&&_)if(Q.async)Z+=" throw new ValidationError(["+$+"]); ";else Z+=" validate.errors = ["+$+"]; return false; ";else Z+=" var err = "+$+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "}Z+=" } "}}if(Q.schema.$ref&&!J){if(Z+=" "+Q.RULES.all.$ref.code(Q,"$ref")+" ",_){if(Z+=" } if (errors === ",O)Z+="0";else Z+="errs_"+K;Z+=") { ",x+="}"}}else{var kA=Q.RULES;if(kA){var e,YA=-1,ZA=kA.length-1;while(YA<ZA)if(e=kA[YA+=1],_A(e)){if(e.type)Z+=" if ("+Q.util.checkDataType(e.type,F,Q.opts.strictNumbers)+") { ";if(Q.opts.useDefaults){if(e.type=="object"&&Q.schema.properties){var E=Q.schema.properties,zA=Object.keys(E),bA=zA;if(bA){var TA,B1=-1,JA=bA.length-1;while(B1<JA){TA=bA[B1+=1];var CA=E[TA];if(CA.default!==void 0){var MA=F+Q.util.getProperty(TA);if(Q.compositeRule){if(Q.opts.strictDefaults){var M="default is ignored for: "+MA;if(Q.opts.strictDefaults==="log")Q.logger.warn(M);else throw Error(M)}}else{if(Z+=" if ("+MA+" === undefined ",Q.opts.useDefaults=="empty")Z+=" || "+MA+" === null || "+MA+" === '' ";if(Z+=" ) "+MA+" = ",Q.opts.useDefaults=="shared")Z+=" "+Q.useDefault(CA.default)+" ";else Z+=" "+JSON.stringify(CA.default)+" ";Z+="; "}}}}}else if(e.type=="array"&&Array.isArray(Q.schema.items)){var NA=Q.schema.items;if(NA){var CA,VA=-1,UA=NA.length-1;while(VA<UA)if(CA=NA[VA+=1],CA.default!==void 0){var MA=F+"["+VA+"]";if(Q.compositeRule){if(Q.opts.strictDefaults){var M="default is ignored for: "+MA;if(Q.opts.strictDefaults==="log")Q.logger.warn(M);else throw Error(M)}}else{if(Z+=" if ("+MA+" === undefined ",Q.opts.useDefaults=="empty")Z+=" || "+MA+" === null || "+MA+" === '' ";if(Z+=" ) "+MA+" = ",Q.opts.useDefaults=="shared")Z+=" "+Q.useDefault(CA.default)+" ";else Z+=" "+JSON.stringify(CA.default)+" ";Z+="; "}}}}}var LA=e.rules;if(LA){var nA,gA=-1,I1=LA.length-1;while(gA<I1)if(nA=LA[gA+=1],Q1(nA)){var q1=nA.code(Q,nA.keyword,e.type);if(q1){if(Z+=" "+q1+" ",_)T+="}"}}}if(_)Z+=" "+T+" ",T="";if(e.type){if(Z+=" } ",v&&v===e.type&&!u){Z+=" else { ";var D=Q.schemaPath+".type",H=Q.errSchemaPath+"/type",C=C||[];if(C.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(b||"type")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(H)+" , params: { type: '",m)Z+=""+v.join(",");else Z+=""+v;if(Z+="' } ",Q.opts.messages!==!1){if(Z+=" , message: 'should be ",m)Z+=""+v.join(",");else Z+=""+v;Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+D+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+F+" ";Z+=" } "}else Z+=" {} ";var $=Z;if(Z=C.pop(),!Q.compositeRule&&_)if(Q.async)Z+=" throw new ValidationError(["+$+"]); ";else Z+=" validate.errors = ["+$+"]; return false; ";else Z+=" var err = "+$+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";Z+=" } "}}if(_){if(Z+=" if (errors === ",O)Z+="0";else Z+="errs_"+K;Z+=") { ",x+="}"}}}}if(_)Z+=" "+x+" ";if(O){if(Y)Z+=" if (errors === 0) return data;           ",Z+=" else throw new ValidationError(vErrors); ";else Z+=" validate.errors = vErrors; ",Z+=" return errors === 0;       ";Z+=" }; return validate;"}else Z+=" var "+L+" = errors === errs_"+K+";";function _A(_1){var V0=_1.rules;for(var AQ=0;AQ<V0.length;AQ++)if(Q1(V0[AQ]))return!0}function Q1(_1){return Q.schema[_1.keyword]!==void 0||_1.implements&&h1(_1)}function h1(_1){var V0=_1.implements;for(var AQ=0;AQ<V0.length;AQ++)if(Q.schema[V0[AQ]]!==void 0)return!0}return Z}});var NKB=w((kl7,wKB)=>{var JrA=ZrA(),XrA=ye(),UKB=YrA(),UM6=Kc1(),zKB=Vc1(),$M6=XrA.ucs2length,wM6=soA(),NM6=UKB.Validation;wKB.exports=Ec1;function Ec1(A,Q,B,G){var Z=this,Y=this._opts,J=[void 0],I={},X=[],W={},K=[],V={},E=[];Q=Q||{schema:A,refVal:J,refs:I};var D=qM6.call(this,A,Q,G),H=this._compilations[D.index];if(D.compiling)return H.callValidate=M;var F=this._formats,C=this.RULES;try{var $=L(A,Q,B,G);H.validate=$;var O=H.callValidate;if(O){if(O.schema=$.schema,O.errors=null,O.refs=$.refs,O.refVal=$.refVal,O.root=$.root,O.$async=$.$async,Y.sourceCode)O.source=$.source}return $}finally{LM6.call(this,A,Q,G)}function M(){var p=H.validate,k=p.apply(this,arguments);return M.errors=p.errors,k}function L(p,k,c,t){var AA=!k||k&&k.schema==p;if(k.schema!=Q.schema)return Ec1.call(Z,p,k,c,t);var VA=p.$async===!0,OA=zKB({isTop:!0,schema:p,isRoot:AA,baseId:t,root:k,schemaPath:"",errSchemaPath:"#",errorPath:'""',MissingRefError:UKB.MissingRef,RULES:C,validate:zKB,util:XrA,resolve:JrA,resolveRef:_,usePattern:m,useDefault:u,useCustomRule:e,opts:Y,formats:F,logger:Z.logger,self:Z});if(OA=IrA(J,RM6)+IrA(X,MM6)+IrA(K,OM6)+IrA(E,_M6)+OA,Y.processCode)OA=Y.processCode(OA,p);var IA;try{var PA=Function("self","RULES","formats","root","refVal","defaults","customRules","equal","ucs2length","ValidationError",OA);IA=PA(Z,C,F,Q,J,K,E,wM6,$M6,NM6),J[0]=IA}catch(kA){throw Z.logger.error("Error compiling schema, function code:",OA),kA}if(IA.schema=p,IA.errors=null,IA.refs=I,IA.refVal=J,IA.root=AA?IA:k,VA)IA.$async=!0;if(Y.sourceCode===!0)IA.source={code:OA,patterns:X,defaults:K};return IA}function _(p,k,c){k=JrA.url(p,k);var t=I[k],AA,VA;if(t!==void 0)return AA=J[t],VA="refVal["+t+"]",v(AA,VA);if(!c&&Q.refs){var OA=Q.refs[k];if(OA!==void 0)return AA=Q.refVal[OA],VA=T(k,AA),v(AA,VA)}VA=T(k);var IA=JrA.call(Z,L,Q,k);if(IA===void 0){var PA=B&&B[k];if(PA)IA=JrA.inlineRef(PA,Y.inlineRefs)?PA:Ec1.call(Z,PA,Q,B,p)}if(IA===void 0)x(k);else return b(k,IA),v(IA,VA)}function T(p,k){var c=J.length;return J[c]=k,I[p]=c,"refVal"+c}function x(p){delete I[p]}function b(p,k){var c=I[p];J[c]=k}function v(p,k){return typeof p=="object"||typeof p=="boolean"?{code:k,schema:p,inline:!0}:{code:k,$async:p&&!!p.$async}}function m(p){var k=W[p];if(k===void 0)k=W[p]=X.length,X[k]=p;return"pattern"+k}function u(p){switch(typeof p){case"boolean":case"number":return""+p;case"string":return XrA.toQuotedString(p);case"object":if(p===null)return"null";var k=UM6(p),c=V[k];if(c===void 0)c=V[k]=K.length,K[c]=p;return"default"+c}}function e(p,k,c,t){if(Z._opts.validateSchema!==!1){var AA=p.definition.dependencies;if(AA&&!AA.every(function(bA){return Object.prototype.hasOwnProperty.call(c,bA)}))throw Error("parent schema must have all required keywords: "+AA.join(","));var VA=p.definition.validateSchema;if(VA){var OA=VA(k);if(!OA){var IA="keyword schema is invalid: "+Z.errorsText(VA.errors);if(Z._opts.validateSchema=="log")Z.logger.error(IA);else throw Error(IA)}}}var PA=p.definition.compile,kA=p.definition.inline,YA=p.definition.macro,ZA;if(PA)ZA=PA.call(Z,k,c,t);else if(YA){if(ZA=YA.call(Z,k,c,t),Y.validateSchema!==!1)Z.validateSchema(ZA,!0)}else if(kA)ZA=kA.call(Z,t,p.keyword,k,c);else if(ZA=p.definition.validate,!ZA)return;if(ZA===void 0)throw Error('custom keyword "'+p.keyword+'"failed to compile');var zA=E.length;return E[zA]=ZA,{code:"customRule"+zA,validate:ZA}}}function qM6(A,Q,B){var G=$KB.call(this,A,Q,B);if(G>=0)return{index:G,compiling:!0};return G=this._compilations.length,this._compilations[G]={schema:A,root:Q,baseId:B},{index:G,compiling:!1}}function LM6(A,Q,B){var G=$KB.call(this,A,Q,B);if(G>=0)this._compilations.splice(G,1)}function $KB(A,Q,B){for(var G=0;G<this._compilations.length;G++){var Z=this._compilations[G];if(Z.schema==A&&Z.root==Q&&Z.baseId==B)return G}return-1}function MM6(A,Q){return"var pattern"+A+" = new RegExp("+XrA.toQuotedString(Q[A])+");"}function OM6(A){return"var default"+A+" = defaults["+A+"];"}function RM6(A,Q){return Q[A]===void 0?"":"var refVal"+A+" = refVal["+A+"];"}function _M6(A){return"var customRule"+A+" = customRules["+A+"];"}function IrA(A,Q){if(!A.length)return"";var B="";for(var G=0;G<A.length;G++)B+=Q(G,A);return B}});var LKB=w((fl7,qKB)=>{var WrA=qKB.exports=function(){this._cache={}};WrA.prototype.put=function(Q,B){this._cache[Q]=B};WrA.prototype.get=function(Q){return this._cache[Q]};WrA.prototype.del=function(Q){delete this._cache[Q]};WrA.prototype.clear=function(){this._cache={}}});var kKB=w((bl7,vKB)=>{var TM6=ye(),jM6=/^(\d\d\d\d)-(\d\d)-(\d\d)$/,PM6=[0,31,28,31,30,31,30,31,31,30,31,30,31],SM6=/^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i,MKB=/^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,xM6=/^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,yM6=/^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,OKB=/^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,RKB=/^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i,_KB=/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,TKB=/^(?:\/(?:[^~/]|~0|~1)*)*$/,jKB=/^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,PKB=/^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;vKB.exports=KrA;function KrA(A){return A=A=="full"?"full":"fast",TM6.copy(KrA[A])}KrA.fast={date:/^\d\d\d\d-[0-1]\d-[0-3]\d$/,time:/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,"date-time":/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,uri:/^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,"uri-reference":/^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,"uri-template":OKB,url:RKB,email:/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,hostname:MKB,ipv4:/^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,ipv6:/^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,regex:yKB,uuid:_KB,"json-pointer":TKB,"json-pointer-uri-fragment":jKB,"relative-json-pointer":PKB};KrA.full={date:SKB,time:xKB,"date-time":fM6,uri:hM6,"uri-reference":yM6,"uri-template":OKB,url:RKB,email:/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,hostname:MKB,ipv4:/^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,ipv6:/^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,regex:yKB,uuid:_KB,"json-pointer":TKB,"json-pointer-uri-fragment":jKB,"relative-json-pointer":PKB};function vM6(A){return A%4===0&&(A%100!==0||A%400===0)}function SKB(A){var Q=A.match(jM6);if(!Q)return!1;var B=+Q[1],G=+Q[2],Z=+Q[3];return G>=1&&G<=12&&Z>=1&&Z<=(G==2&&vM6(B)?29:PM6[G])}function xKB(A,Q){var B=A.match(SM6);if(!B)return!1;var G=B[1],Z=B[2],Y=B[3],J=B[5];return(G<=23&&Z<=59&&Y<=59||G==23&&Z==59&&Y==60)&&(!Q||J)}var kM6=/t|\s/i;function fM6(A){var Q=A.split(kM6);return Q.length==2&&SKB(Q[0])&&xKB(Q[1],!0)}var bM6=/\/|:/;function hM6(A){return bM6.test(A)&&xM6.test(A)}var gM6=/[^\\]\\Z/;function yKB(A){if(gM6.test(A))return!1;try{return new RegExp(A),!0}catch(Q){return!1}}});var bKB=w((hl7,fKB)=>{fKB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.errSchemaPath+"/"+B,W=!Q.opts.allErrors,K="data"+(J||""),V="valid"+Y,E,D;if(I=="#"||I=="#/")if(Q.isRoot)E=Q.async,D="validate";else E=Q.root.schema.$async===!0,D="root.refVal[0]";else{var H=Q.resolveRef(Q.baseId,I,Q.isRoot);if(H===void 0){var F=Q.MissingRefError.message(Q.baseId,I);if(Q.opts.missingRefs=="fail"){Q.logger.error(F);var C=C||[];if(C.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '$ref' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(X)+" , params: { ref: '"+Q.util.escapeQuotes(I)+"' } ",Q.opts.messages!==!1)Z+=" , message: 'can\\'t resolve reference "+Q.util.escapeQuotes(I)+"' ";if(Q.opts.verbose)Z+=" , schema: "+Q.util.toQuotedString(I)+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+K+" ";Z+=" } "}else Z+=" {} ";var $=Z;if(Z=C.pop(),!Q.compositeRule&&W)if(Q.async)Z+=" throw new ValidationError(["+$+"]); ";else Z+=" validate.errors = ["+$+"]; return false; ";else Z+=" var err = "+$+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(W)Z+=" if (false) { "}else if(Q.opts.missingRefs=="ignore"){if(Q.logger.warn(F),W)Z+=" if (true) { "}else throw new Q.MissingRefError(Q.baseId,I,F)}else if(H.inline){var O=Q.util.copy(Q);O.level++;var M="valid"+O.level;O.schema=H.schema,O.schemaPath="",O.errSchemaPath=I;var L=Q.validate(O).replace(/validate\.schema/g,H.code);if(Z+=" "+L+" ",W)Z+=" if ("+M+") { "}else E=H.$async===!0||Q.async&&H.$async!==!1,D=H.code}if(D){var C=C||[];if(C.push(Z),Z="",Q.opts.passContext)Z+=" "+D+".call(this, ";else Z+=" "+D+"( ";if(Z+=" "+K+", (dataPath || '')",Q.errorPath!='""')Z+=" + "+Q.errorPath;var _=J?"data"+(J-1||""):"parentData",T=J?Q.dataPathArr[J]:"parentDataProperty";Z+=" , "+_+" , "+T+", rootData)  ";var x=Z;if(Z=C.pop(),E){if(!Q.async)throw Error("async schema referenced by sync schema");if(W)Z+=" var "+V+"; ";if(Z+=" try { await "+x+"; ",W)Z+=" "+V+" = true; ";if(Z+=" } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ",W)Z+=" "+V+" = false; ";if(Z+=" } ",W)Z+=" if ("+V+") { "}else if(Z+=" if (!"+x+") { if (vErrors === null) vErrors = "+D+".errors; else vErrors = vErrors.concat("+D+".errors); errors = vErrors.length; } ",W)Z+=" else { "}return Z}});var gKB=w((gl7,hKB)=>{hKB.exports=function(Q,B,G){var Z=" ",Y=Q.schema[B],J=Q.schemaPath+Q.util.getProperty(B),I=Q.errSchemaPath+"/"+B,X=!Q.opts.allErrors,W=Q.util.copy(Q),K="";W.level++;var V="valid"+W.level,E=W.baseId,D=!0,H=Y;if(H){var F,C=-1,$=H.length-1;while(C<$)if(F=H[C+=1],Q.opts.strictKeywords?typeof F=="object"&&Object.keys(F).length>0||F===!1:Q.util.schemaHasRules(F,Q.RULES.all)){if(D=!1,W.schema=F,W.schemaPath=J+"["+C+"]",W.errSchemaPath=I+"/"+C,Z+="  "+Q.validate(W)+" ",W.baseId=E,X)Z+=" if ("+V+") { ",K+="}"}}if(X)if(D)Z+=" if (true) { ";else Z+=" "+K.slice(0,-1)+" ";return Z}});var mKB=w((ul7,uKB)=>{uKB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D="errs__"+Y,H=Q.util.copy(Q),F="";H.level++;var C="valid"+H.level,$=I.every(function(b){return Q.opts.strictKeywords?typeof b=="object"&&Object.keys(b).length>0||b===!1:Q.util.schemaHasRules(b,Q.RULES.all)});if($){var O=H.baseId;Z+=" var "+D+" = errors; var "+E+" = false;  ";var M=Q.compositeRule;Q.compositeRule=H.compositeRule=!0;var L=I;if(L){var _,T=-1,x=L.length-1;while(T<x)_=L[T+=1],H.schema=_,H.schemaPath=X+"["+T+"]",H.errSchemaPath=W+"/"+T,Z+="  "+Q.validate(H)+" ",H.baseId=O,Z+=" "+E+" = "+E+" || "+C+"; if (!"+E+") { ",F+="}"}if(Q.compositeRule=H.compositeRule=M,Z+=" "+F+" if (!"+E+") {   var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'anyOf' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: {} ",Q.opts.messages!==!1)Z+=" , message: 'should match some schema in anyOf' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";if(Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(vErrors); ";else Z+=" validate.errors = vErrors; return false; ";if(Z+=" } else {  errors = "+D+"; if (vErrors !== null) { if ("+D+") vErrors.length = "+D+"; else vErrors = null; } ",Q.opts.allErrors)Z+=" } "}else if(K)Z+=" if (true) { ";return Z}});var cKB=w((ml7,dKB)=>{dKB.exports=function(Q,B,G){var Z=" ",Y=Q.schema[B],J=Q.errSchemaPath+"/"+B,I=!Q.opts.allErrors,X=Q.util.toQuotedString(Y);if(Q.opts.$comment===!0)Z+=" console.log("+X+");";else if(typeof Q.opts.$comment=="function")Z+=" self._opts.$comment("+X+", "+Q.util.toQuotedString(J)+", validate.root.schema);";return Z}});var lKB=w((dl7,pKB)=>{pKB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D=Q.opts.$data&&I&&I.$data,H;if(D)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",H="schema"+Y;else H=I;if(!D)Z+=" var schema"+Y+" = validate.schema"+X+";";Z+="var "+E+" = equal("+V+", schema"+Y+"); if (!"+E+") {   ";var F=F||[];if(F.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'const' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { allowedValue: schema"+Y+" } ",Q.opts.messages!==!1)Z+=" , message: 'should be equal to constant' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var C=Z;if(Z=F.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+C+"]); ";else Z+=" validate.errors = ["+C+"]; return false; ";else Z+=" var err = "+C+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" }",K)Z+=" else { ";return Z}});var nKB=w((cl7,iKB)=>{iKB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D="errs__"+Y,H=Q.util.copy(Q),F="";H.level++;var C="valid"+H.level,$="i"+Y,O=H.dataLevel=Q.dataLevel+1,M="data"+O,L=Q.baseId,_=Q.opts.strictKeywords?typeof I=="object"&&Object.keys(I).length>0||I===!1:Q.util.schemaHasRules(I,Q.RULES.all);if(Z+="var "+D+" = errors;var "+E+";",_){var T=Q.compositeRule;Q.compositeRule=H.compositeRule=!0,H.schema=I,H.schemaPath=X,H.errSchemaPath=W,Z+=" var "+C+" = false; for (var "+$+" = 0; "+$+" < "+V+".length; "+$+"++) { ",H.errorPath=Q.util.getPathExpr(Q.errorPath,$,Q.opts.jsonPointers,!0);var x=V+"["+$+"]";H.dataPathArr[O]=$;var b=Q.validate(H);if(H.baseId=L,Q.util.varOccurences(b,M)<2)Z+=" "+Q.util.varReplace(b,M,x)+" ";else Z+=" var "+M+" = "+x+"; "+b+" ";Z+=" if ("+C+") break; }  ",Q.compositeRule=H.compositeRule=T,Z+=" "+F+" if (!"+C+") {"}else Z+=" if ("+V+".length == 0) {";var v=v||[];if(v.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'contains' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: {} ",Q.opts.messages!==!1)Z+=" , message: 'should contain a valid item' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var m=Z;if(Z=v.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+m+"]); ";else Z+=" validate.errors = ["+m+"]; return false; ";else Z+=" var err = "+m+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" } else { ",_)Z+="  errors = "+D+"; if (vErrors !== null) { if ("+D+") vErrors.length = "+D+"; else vErrors = null; } ";if(Q.opts.allErrors)Z+=" } ";return Z}});var oKB=w((pl7,aKB)=>{aKB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="errs__"+Y,D=Q.util.copy(Q),H="";D.level++;var F="valid"+D.level,C={},$={},O=Q.opts.ownProperties;for(T in I){if(T=="__proto__")continue;var M=I[T],L=Array.isArray(M)?$:C;L[T]=M}Z+="var "+E+" = errors;";var _=Q.errorPath;Z+="var missing"+Y+";";for(var T in $)if(L=$[T],L.length){if(Z+=" if ( "+V+Q.util.getProperty(T)+" !== undefined ",O)Z+=" && Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(T)+"') ";if(K){Z+=" && ( ";var x=L;if(x){var b,v=-1,m=x.length-1;while(v<m){if(b=x[v+=1],v)Z+=" || ";var u=Q.util.getProperty(b),e=V+u;if(Z+=" ( ( "+e+" === undefined ",O)Z+=" || ! Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(b)+"') ";Z+=") && (missing"+Y+" = "+Q.util.toQuotedString(Q.opts.jsonPointers?b:u)+") ) "}}Z+=")) {  ";var p="missing"+Y,k="' + "+p+" + '";if(Q.opts._errorDataPathProperty)Q.errorPath=Q.opts.jsonPointers?Q.util.getPathExpr(_,p,!0):_+" + "+p;var c=c||[];if(c.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'dependencies' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { property: '"+Q.util.escapeQuotes(T)+"', missingProperty: '"+k+"', depsCount: "+L.length+", deps: '"+Q.util.escapeQuotes(L.length==1?L[0]:L.join(", "))+"' } ",Q.opts.messages!==!1){if(Z+=" , message: 'should have ",L.length==1)Z+="property "+Q.util.escapeQuotes(L[0]);else Z+="properties "+Q.util.escapeQuotes(L.join(", "));Z+=" when property "+Q.util.escapeQuotes(T)+" is present' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var t=Z;if(Z=c.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+t+"]); ";else Z+=" validate.errors = ["+t+"]; return false; ";else Z+=" var err = "+t+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "}else{Z+=" ) { ";var AA=L;if(AA){var b,VA=-1,OA=AA.length-1;while(VA<OA){b=AA[VA+=1];var u=Q.util.getProperty(b),k=Q.util.escapeQuotes(b),e=V+u;if(Q.opts._errorDataPathProperty)Q.errorPath=Q.util.getPath(_,b,Q.opts.jsonPointers);if(Z+=" if ( "+e+" === undefined ",O)Z+=" || ! Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(b)+"') ";if(Z+=") {  var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'dependencies' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { property: '"+Q.util.escapeQuotes(T)+"', missingProperty: '"+k+"', depsCount: "+L.length+", deps: '"+Q.util.escapeQuotes(L.length==1?L[0]:L.join(", "))+"' } ",Q.opts.messages!==!1){if(Z+=" , message: 'should have ",L.length==1)Z+="property "+Q.util.escapeQuotes(L[0]);else Z+="properties "+Q.util.escapeQuotes(L.join(", "));Z+=" when property "+Q.util.escapeQuotes(T)+" is present' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "}}}if(Z+=" }   ",K)H+="}",Z+=" else { "}Q.errorPath=_;var IA=D.baseId;for(var T in C){var M=C[T];if(Q.opts.strictKeywords?typeof M=="object"&&Object.keys(M).length>0||M===!1:Q.util.schemaHasRules(M,Q.RULES.all)){if(Z+=" "+F+" = true; if ( "+V+Q.util.getProperty(T)+" !== undefined ",O)Z+=" && Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(T)+"') ";if(Z+=") { ",D.schema=M,D.schemaPath=X+Q.util.getProperty(T),D.errSchemaPath=W+"/"+Q.util.escapeFragment(T),Z+="  "+Q.validate(D)+" ",D.baseId=IA,Z+=" }  ",K)Z+=" if ("+F+") { ",H+="}"}}if(K)Z+="   "+H+" if ("+E+" == errors) {";return Z}});var sKB=w((ll7,rKB)=>{rKB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D=Q.opts.$data&&I&&I.$data,H;if(D)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",H="schema"+Y;else H=I;var F="i"+Y,C="schema"+Y;if(!D)Z+=" var "+C+" = validate.schema"+X+";";if(Z+="var "+E+";",D)Z+=" if (schema"+Y+" === undefined) "+E+" = true; else if (!Array.isArray(schema"+Y+")) "+E+" = false; else {";if(Z+=""+E+" = false;for (var "+F+"=0; "+F+"<"+C+".length; "+F+"++) if (equal("+V+", "+C+"["+F+"])) { "+E+" = true; break; }",D)Z+="  }  ";Z+=" if (!"+E+") {   ";var $=$||[];if($.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'enum' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { allowedValues: schema"+Y+" } ",Q.opts.messages!==!1)Z+=" , message: 'should be equal to one of the allowed values' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var O=Z;if(Z=$.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+O+"]); ";else Z+=" validate.errors = ["+O+"]; return false; ";else Z+=" var err = "+O+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" }",K)Z+=" else { ";return Z}});var eKB=w((il7,tKB)=>{tKB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||"");if(Q.opts.format===!1){if(K)Z+=" if (true) { ";return Z}var E=Q.opts.$data&&I&&I.$data,D;if(E)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",D="schema"+Y;else D=I;var H=Q.opts.unknownFormats,F=Array.isArray(H);if(E){var C="format"+Y,$="isObject"+Y,O="formatType"+Y;if(Z+=" var "+C+" = formats["+D+"]; var "+$+" = typeof "+C+" == 'object' && !("+C+" instanceof RegExp) && "+C+".validate; var "+O+" = "+$+" && "+C+".type || 'string'; if ("+$+") { ",Q.async)Z+=" var async"+Y+" = "+C+".async; ";if(Z+=" "+C+" = "+C+".validate; } if (  ",E)Z+=" ("+D+" !== undefined && typeof "+D+" != 'string') || ";if(Z+=" (",H!="ignore"){if(Z+=" ("+D+" && !"+C+" ",F)Z+=" && self._opts.unknownFormats.indexOf("+D+") == -1 ";Z+=") || "}if(Z+=" ("+C+" && "+O+" == '"+G+"' && !(typeof "+C+" == 'function' ? ",Q.async)Z+=" (async"+Y+" ? await "+C+"("+V+") : "+C+"("+V+")) ";else Z+=" "+C+"("+V+") ";Z+=" : "+C+".test("+V+"))))) {"}else{var C=Q.formats[I];if(!C)if(H=="ignore"){if(Q.logger.warn('unknown format "'+I+'" ignored in schema at path "'+Q.errSchemaPath+'"'),K)Z+=" if (true) { ";return Z}else if(F&&H.indexOf(I)>=0){if(K)Z+=" if (true) { ";return Z}else throw Error('unknown format "'+I+'" is used in schema at path "'+Q.errSchemaPath+'"');var $=typeof C=="object"&&!(C instanceof RegExp)&&C.validate,O=$&&C.type||"string";if($){var M=C.async===!0;C=C.validate}if(O!=G){if(K)Z+=" if (true) { ";return Z}if(M){if(!Q.async)throw Error("async format in sync schema");var L="formats"+Q.util.getProperty(I)+".validate";Z+=" if (!(await "+L+"("+V+"))) { "}else{Z+=" if (! ";var L="formats"+Q.util.getProperty(I);if($)L+=".validate";if(typeof C=="function")Z+=" "+L+"("+V+") ";else Z+=" "+L+".test("+V+") ";Z+=") { "}}var _=_||[];if(_.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'format' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { format:  ",E)Z+=""+D;else Z+=""+Q.util.toQuotedString(I);if(Z+="  } ",Q.opts.messages!==!1){if(Z+=` , message: 'should match format "`,E)Z+="' + "+D+" + '";else Z+=""+Q.util.escapeQuotes(I);Z+=`"' `}if(Q.opts.verbose){if(Z+=" , schema:  ",E)Z+="validate.schema"+X;else Z+=""+Q.util.toQuotedString(I);Z+="         , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" "}Z+=" } "}else Z+=" {} ";var T=Z;if(Z=_.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+T+"]); ";else Z+=" validate.errors = ["+T+"]; return false; ";else Z+=" var err = "+T+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" } ",K)Z+=" else { ";return Z}});var QVB=w((nl7,AVB)=>{AVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D="errs__"+Y,H=Q.util.copy(Q);H.level++;var F="valid"+H.level,C=Q.schema.then,$=Q.schema.else,O=C!==void 0&&(Q.opts.strictKeywords?typeof C=="object"&&Object.keys(C).length>0||C===!1:Q.util.schemaHasRules(C,Q.RULES.all)),M=$!==void 0&&(Q.opts.strictKeywords?typeof $=="object"&&Object.keys($).length>0||$===!1:Q.util.schemaHasRules($,Q.RULES.all)),L=H.baseId;if(O||M){var _;H.createErrors=!1,H.schema=I,H.schemaPath=X,H.errSchemaPath=W,Z+=" var "+D+" = errors; var "+E+" = true;  ";var T=Q.compositeRule;if(Q.compositeRule=H.compositeRule=!0,Z+="  "+Q.validate(H)+" ",H.baseId=L,H.createErrors=!0,Z+="  errors = "+D+"; if (vErrors !== null) { if ("+D+") vErrors.length = "+D+"; else vErrors = null; }  ",Q.compositeRule=H.compositeRule=T,O){if(Z+=" if ("+F+") {  ",H.schema=Q.schema.then,H.schemaPath=Q.schemaPath+".then",H.errSchemaPath=Q.errSchemaPath+"/then",Z+="  "+Q.validate(H)+" ",H.baseId=L,Z+=" "+E+" = "+F+"; ",O&&M)_="ifClause"+Y,Z+=" var "+_+" = 'then'; ";else _="'then'";if(Z+=" } ",M)Z+=" else { "}else Z+=" if (!"+F+") { ";if(M){if(H.schema=Q.schema.else,H.schemaPath=Q.schemaPath+".else",H.errSchemaPath=Q.errSchemaPath+"/else",Z+="  "+Q.validate(H)+" ",H.baseId=L,Z+=" "+E+" = "+F+"; ",O&&M)_="ifClause"+Y,Z+=" var "+_+" = 'else'; ";else _="'else'";Z+=" } "}if(Z+=" if (!"+E+") {   var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'if' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { failingKeyword: "+_+" } ",Q.opts.messages!==!1)Z+=` , message: 'should match "' + `+_+` + '" schema' `;if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";if(Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(vErrors); ";else Z+=" validate.errors = vErrors; return false; ";if(Z+=" }   ",K)Z+=" else { "}else if(K)Z+=" if (true) { ";return Z}});var GVB=w((al7,BVB)=>{BVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D="errs__"+Y,H=Q.util.copy(Q),F="";H.level++;var C="valid"+H.level,$="i"+Y,O=H.dataLevel=Q.dataLevel+1,M="data"+O,L=Q.baseId;if(Z+="var "+D+" = errors;var "+E+";",Array.isArray(I)){var _=Q.schema.additionalItems;if(_===!1){Z+=" "+E+" = "+V+".length <= "+I.length+"; ";var T=W;W=Q.errSchemaPath+"/additionalItems",Z+="  if (!"+E+") {   ";var x=x||[];if(x.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'additionalItems' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { limit: "+I.length+" } ",Q.opts.messages!==!1)Z+=" , message: 'should NOT have more than "+I.length+" items' ";if(Q.opts.verbose)Z+=" , schema: false , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var b=Z;if(Z=x.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+b+"]); ";else Z+=" validate.errors = ["+b+"]; return false; ";else Z+=" var err = "+b+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" } ",W=T,K)F+="}",Z+=" else { "}var v=I;if(v){var m,u=-1,e=v.length-1;while(u<e)if(m=v[u+=1],Q.opts.strictKeywords?typeof m=="object"&&Object.keys(m).length>0||m===!1:Q.util.schemaHasRules(m,Q.RULES.all)){Z+=" "+C+" = true; if ("+V+".length > "+u+") { ";var p=V+"["+u+"]";H.schema=m,H.schemaPath=X+"["+u+"]",H.errSchemaPath=W+"/"+u,H.errorPath=Q.util.getPathExpr(Q.errorPath,u,Q.opts.jsonPointers,!0),H.dataPathArr[O]=u;var k=Q.validate(H);if(H.baseId=L,Q.util.varOccurences(k,M)<2)Z+=" "+Q.util.varReplace(k,M,p)+" ";else Z+=" var "+M+" = "+p+"; "+k+" ";if(Z+=" }  ",K)Z+=" if ("+C+") { ",F+="}"}}if(typeof _=="object"&&(Q.opts.strictKeywords?typeof _=="object"&&Object.keys(_).length>0||_===!1:Q.util.schemaHasRules(_,Q.RULES.all))){H.schema=_,H.schemaPath=Q.schemaPath+".additionalItems",H.errSchemaPath=Q.errSchemaPath+"/additionalItems",Z+=" "+C+" = true; if ("+V+".length > "+I.length+") {  for (var "+$+" = "+I.length+"; "+$+" < "+V+".length; "+$+"++) { ",H.errorPath=Q.util.getPathExpr(Q.errorPath,$,Q.opts.jsonPointers,!0);var p=V+"["+$+"]";H.dataPathArr[O]=$;var k=Q.validate(H);if(H.baseId=L,Q.util.varOccurences(k,M)<2)Z+=" "+Q.util.varReplace(k,M,p)+" ";else Z+=" var "+M+" = "+p+"; "+k+" ";if(K)Z+=" if (!"+C+") break; ";if(Z+=" } }  ",K)Z+=" if ("+C+") { ",F+="}"}}else if(Q.opts.strictKeywords?typeof I=="object"&&Object.keys(I).length>0||I===!1:Q.util.schemaHasRules(I,Q.RULES.all)){H.schema=I,H.schemaPath=X,H.errSchemaPath=W,Z+="  for (var "+$+" = 0; "+$+" < "+V+".length; "+$+"++) { ",H.errorPath=Q.util.getPathExpr(Q.errorPath,$,Q.opts.jsonPointers,!0);var p=V+"["+$+"]";H.dataPathArr[O]=$;var k=Q.validate(H);if(H.baseId=L,Q.util.varOccurences(k,M)<2)Z+=" "+Q.util.varReplace(k,M,p)+" ";else Z+=" var "+M+" = "+p+"; "+k+" ";if(K)Z+=" if (!"+C+") break; ";Z+=" }"}if(K)Z+=" "+F+" if ("+D+" == errors) {";return Z}});var Dc1=w((ol7,ZVB)=>{ZVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,L,V="data"+(J||""),E=Q.opts.$data&&I&&I.$data,D;if(E)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",D="schema"+Y;else D=I;var H=B=="maximum",F=H?"exclusiveMaximum":"exclusiveMinimum",C=Q.schema[F],$=Q.opts.$data&&C&&C.$data,O=H?"<":">",M=H?">":"<",L=void 0;if(!(E||typeof I=="number"||I===void 0))throw Error(B+" must be number");if(!($||C===void 0||typeof C=="number"||typeof C=="boolean"))throw Error(F+" must be number or boolean");if($){var _=Q.util.getData(C.$data,J,Q.dataPathArr),T="exclusive"+Y,x="exclType"+Y,b="exclIsNumber"+Y,v="op"+Y,m="' + "+v+" + '";Z+=" var schemaExcl"+Y+" = "+_+"; ",_="schemaExcl"+Y,Z+=" var "+T+"; var "+x+" = typeof "+_+"; if ("+x+" != 'boolean' && "+x+" != 'undefined' && "+x+" != 'number') { ";var L=F,u=u||[];if(u.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(L||"_exclusiveLimit")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: {} ",Q.opts.messages!==!1)Z+=" , message: '"+F+" should be boolean' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var e=Z;if(Z=u.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+e+"]); ";else Z+=" validate.errors = ["+e+"]; return false; ";else Z+=" var err = "+e+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" } else if ( ",E)Z+=" ("+D+" !== undefined && typeof "+D+" != 'number') || ";if(Z+=" "+x+" == 'number' ? ( ("+T+" = "+D+" === undefined || "+_+" "+O+"= "+D+") ? "+V+" "+M+"= "+_+" : "+V+" "+M+" "+D+" ) : ( ("+T+" = "+_+" === true) ? "+V+" "+M+"= "+D+" : "+V+" "+M+" "+D+" ) || "+V+" !== "+V+") { var op"+Y+" = "+T+" ? '"+O+"' : '"+O+"='; ",I===void 0)L=F,W=Q.errSchemaPath+"/"+F,D=_,E=$}else{var b=typeof C=="number",m=O;if(b&&E){var v="'"+m+"'";if(Z+=" if ( ",E)Z+=" ("+D+" !== undefined && typeof "+D+" != 'number') || ";Z+=" ( "+D+" === undefined || "+C+" "+O+"= "+D+" ? "+V+" "+M+"= "+C+" : "+V+" "+M+" "+D+" ) || "+V+" !== "+V+") { "}else{if(b&&I===void 0)T=!0,L=F,W=Q.errSchemaPath+"/"+F,D=C,M+="=";else{if(b)D=Math[H?"min":"max"](C,I);if(C===(b?D:!0))T=!0,L=F,W=Q.errSchemaPath+"/"+F,M+="=";else T=!1,m+="="}var v="'"+m+"'";if(Z+=" if ( ",E)Z+=" ("+D+" !== undefined && typeof "+D+" != 'number') || ";Z+=" "+V+" "+M+" "+D+" || "+V+" !== "+V+") { "}}L=L||B;var u=u||[];if(u.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(L||"_limit")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { comparison: "+v+", limit: "+D+", exclusive: "+T+" } ",Q.opts.messages!==!1)if(Z+=" , message: 'should be "+m+" ",E)Z+="' + "+D;else Z+=""+D+"'";if(Q.opts.verbose){if(Z+=" , schema:  ",E)Z+="validate.schema"+X;else Z+=""+I;Z+="         , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" "}Z+=" } "}else Z+=" {} ";var e=Z;if(Z=u.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+e+"]); ";else Z+=" validate.errors = ["+e+"]; return false; ";else Z+=" var err = "+e+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" } ",K)Z+=" else { ";return Z}});var Hc1=w((rl7,YVB)=>{YVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,F,V="data"+(J||""),E=Q.opts.$data&&I&&I.$data,D;if(E)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",D="schema"+Y;else D=I;if(!(E||typeof I=="number"))throw Error(B+" must be number");var H=B=="maxItems"?">":"<";if(Z+="if ( ",E)Z+=" ("+D+" !== undefined && typeof "+D+" != 'number') || ";Z+=" "+V+".length "+H+" "+D+") { ";var F=B,C=C||[];if(C.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(F||"_limitItems")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { limit: "+D+" } ",Q.opts.messages!==!1){if(Z+=" , message: 'should NOT have ",B=="maxItems")Z+="more";else Z+="fewer";if(Z+=" than ",E)Z+="' + "+D+" + '";else Z+=""+I;Z+=" items' "}if(Q.opts.verbose){if(Z+=" , schema:  ",E)Z+="validate.schema"+X;else Z+=""+I;Z+="         , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" "}Z+=" } "}else Z+=" {} ";var $=Z;if(Z=C.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+$+"]); ";else Z+=" validate.errors = ["+$+"]; return false; ";else Z+=" var err = "+$+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+="} ",K)Z+=" else { ";return Z}});var Fc1=w((sl7,JVB)=>{JVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,F,V="data"+(J||""),E=Q.opts.$data&&I&&I.$data,D;if(E)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",D="schema"+Y;else D=I;if(!(E||typeof I=="number"))throw Error(B+" must be number");var H=B=="maxLength"?">":"<";if(Z+="if ( ",E)Z+=" ("+D+" !== undefined && typeof "+D+" != 'number') || ";if(Q.opts.unicode===!1)Z+=" "+V+".length ";else Z+=" ucs2length("+V+") ";Z+=" "+H+" "+D+") { ";var F=B,C=C||[];if(C.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(F||"_limitLength")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { limit: "+D+" } ",Q.opts.messages!==!1){if(Z+=" , message: 'should NOT be ",B=="maxLength")Z+="longer";else Z+="shorter";if(Z+=" than ",E)Z+="' + "+D+" + '";else Z+=""+I;Z+=" characters' "}if(Q.opts.verbose){if(Z+=" , schema:  ",E)Z+="validate.schema"+X;else Z+=""+I;Z+="         , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" "}Z+=" } "}else Z+=" {} ";var $=Z;if(Z=C.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+$+"]); ";else Z+=" validate.errors = ["+$+"]; return false; ";else Z+=" var err = "+$+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+="} ",K)Z+=" else { ";return Z}});var Cc1=w((tl7,IVB)=>{IVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,F,V="data"+(J||""),E=Q.opts.$data&&I&&I.$data,D;if(E)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",D="schema"+Y;else D=I;if(!(E||typeof I=="number"))throw Error(B+" must be number");var H=B=="maxProperties"?">":"<";if(Z+="if ( ",E)Z+=" ("+D+" !== undefined && typeof "+D+" != 'number') || ";Z+=" Object.keys("+V+").length "+H+" "+D+") { ";var F=B,C=C||[];if(C.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(F||"_limitProperties")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { limit: "+D+" } ",Q.opts.messages!==!1){if(Z+=" , message: 'should NOT have ",B=="maxProperties")Z+="more";else Z+="fewer";if(Z+=" than ",E)Z+="' + "+D+" + '";else Z+=""+I;Z+=" properties' "}if(Q.opts.verbose){if(Z+=" , schema:  ",E)Z+="validate.schema"+X;else Z+=""+I;Z+="         , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" "}Z+=" } "}else Z+=" {} ";var $=Z;if(Z=C.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+$+"]); ";else Z+=" validate.errors = ["+$+"]; return false; ";else Z+=" var err = "+$+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+="} ",K)Z+=" else { ";return Z}});var WVB=w((el7,XVB)=>{XVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E=Q.opts.$data&&I&&I.$data,D;if(E)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",D="schema"+Y;else D=I;if(!(E||typeof I=="number"))throw Error(B+" must be number");if(Z+="var division"+Y+";if (",E)Z+=" "+D+" !== undefined && ( typeof "+D+" != 'number' || ";if(Z+=" (division"+Y+" = "+V+" / "+D+", ",Q.opts.multipleOfPrecision)Z+=" Math.abs(Math.round(division"+Y+") - division"+Y+") > 1e-"+Q.opts.multipleOfPrecision+" ";else Z+=" division"+Y+" !== parseInt(division"+Y+") ";if(Z+=" ) ",E)Z+="  )  ";Z+=" ) {   ";var H=H||[];if(H.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'multipleOf' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { multipleOf: "+D+" } ",Q.opts.messages!==!1)if(Z+=" , message: 'should be multiple of ",E)Z+="' + "+D;else Z+=""+D+"'";if(Q.opts.verbose){if(Z+=" , schema:  ",E)Z+="validate.schema"+X;else Z+=""+I;Z+="         , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" "}Z+=" } "}else Z+=" {} ";var F=Z;if(Z=H.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+F+"]); ";else Z+=" validate.errors = ["+F+"]; return false; ";else Z+=" var err = "+F+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+="} ",K)Z+=" else { ";return Z}});var VVB=w((Ai7,KVB)=>{KVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="errs__"+Y,D=Q.util.copy(Q);D.level++;var H="valid"+D.level;if(Q.opts.strictKeywords?typeof I=="object"&&Object.keys(I).length>0||I===!1:Q.util.schemaHasRules(I,Q.RULES.all)){D.schema=I,D.schemaPath=X,D.errSchemaPath=W,Z+=" var "+E+" = errors;  ";var F=Q.compositeRule;Q.compositeRule=D.compositeRule=!0,D.createErrors=!1;var C;if(D.opts.allErrors)C=D.opts.allErrors,D.opts.allErrors=!1;if(Z+=" "+Q.validate(D)+" ",D.createErrors=!0,C)D.opts.allErrors=C;Q.compositeRule=D.compositeRule=F,Z+=" if ("+H+") {   ";var $=$||[];if($.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'not' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: {} ",Q.opts.messages!==!1)Z+=" , message: 'should NOT be valid' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var O=Z;if(Z=$.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+O+"]); ";else Z+=" validate.errors = ["+O+"]; return false; ";else Z+=" var err = "+O+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" } else {  errors = "+E+"; if (vErrors !== null) { if ("+E+") vErrors.length = "+E+"; else vErrors = null; } ",Q.opts.allErrors)Z+=" } "}else{if(Z+="  var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'not' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: {} ",Q.opts.messages!==!1)Z+=" , message: 'should NOT be valid' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";if(Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",K)Z+=" if (false) { "}return Z}});var DVB=w((Qi7,EVB)=>{EVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D="errs__"+Y,H=Q.util.copy(Q),F="";H.level++;var C="valid"+H.level,$=H.baseId,O="prevValid"+Y,M="passingSchemas"+Y;Z+="var "+D+" = errors , "+O+" = false , "+E+" = false , "+M+" = null; ";var L=Q.compositeRule;Q.compositeRule=H.compositeRule=!0;var _=I;if(_){var T,x=-1,b=_.length-1;while(x<b){if(T=_[x+=1],Q.opts.strictKeywords?typeof T=="object"&&Object.keys(T).length>0||T===!1:Q.util.schemaHasRules(T,Q.RULES.all))H.schema=T,H.schemaPath=X+"["+x+"]",H.errSchemaPath=W+"/"+x,Z+="  "+Q.validate(H)+" ",H.baseId=$;else Z+=" var "+C+" = true; ";if(x)Z+=" if ("+C+" && "+O+") { "+E+" = false; "+M+" = ["+M+", "+x+"]; } else { ",F+="}";Z+=" if ("+C+") { "+E+" = "+O+" = true; "+M+" = "+x+"; }"}}if(Q.compositeRule=H.compositeRule=L,Z+=""+F+"if (!"+E+") {   var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'oneOf' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { passingSchemas: "+M+" } ",Q.opts.messages!==!1)Z+=" , message: 'should match exactly one schema in oneOf' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";if(Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(vErrors); ";else Z+=" validate.errors = vErrors; return false; ";if(Z+="} else {  errors = "+D+"; if (vErrors !== null) { if ("+D+") vErrors.length = "+D+"; else vErrors = null; }",Q.opts.allErrors)Z+=" } ";return Z}});var FVB=w((Bi7,HVB)=>{HVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E=Q.opts.$data&&I&&I.$data,D;if(E)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",D="schema"+Y;else D=I;var H=E?"(new RegExp("+D+"))":Q.usePattern(I);if(Z+="if ( ",E)Z+=" ("+D+" !== undefined && typeof "+D+" != 'string') || ";Z+=" !"+H+".test("+V+") ) {   ";var F=F||[];if(F.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'pattern' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { pattern:  ",E)Z+=""+D;else Z+=""+Q.util.toQuotedString(I);if(Z+="  } ",Q.opts.messages!==!1){if(Z+=` , message: 'should match pattern "`,E)Z+="' + "+D+" + '";else Z+=""+Q.util.escapeQuotes(I);Z+=`"' `}if(Q.opts.verbose){if(Z+=" , schema:  ",E)Z+="validate.schema"+X;else Z+=""+Q.util.toQuotedString(I);Z+="         , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" "}Z+=" } "}else Z+=" {} ";var C=Z;if(Z=F.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+C+"]); ";else Z+=" validate.errors = ["+C+"]; return false; ";else Z+=" var err = "+C+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+="} ",K)Z+=" else { ";return Z}});var zVB=w((Gi7,CVB)=>{CVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="errs__"+Y,D=Q.util.copy(Q),H="";D.level++;var F="valid"+D.level,C="key"+Y,$="idx"+Y,O=D.dataLevel=Q.dataLevel+1,M="data"+O,L="dataProperties"+Y,_=Object.keys(I||{}).filter(VA),T=Q.schema.patternProperties||{},x=Object.keys(T).filter(VA),b=Q.schema.additionalProperties,v=_.length||x.length,m=b===!1,u=typeof b=="object"&&Object.keys(b).length,e=Q.opts.removeAdditional,p=m||u||e,k=Q.opts.ownProperties,c=Q.baseId,t=Q.schema.required;if(t&&!(Q.opts.$data&&t.$data)&&t.length<Q.opts.loopRequired)var AA=Q.util.toHash(t);function VA(BQ){return BQ!=="__proto__"}if(Z+="var "+E+" = errors;var "+F+" = true;",k)Z+=" var "+L+" = undefined;";if(p){if(k)Z+=" "+L+" = "+L+" || Object.keys("+V+"); for (var "+$+"=0; "+$+"<"+L+".length; "+$+"++) { var "+C+" = "+L+"["+$+"]; ";else Z+=" for (var "+C+" in "+V+") { ";if(v){if(Z+=" var isAdditional"+Y+" = !(false ",_.length)if(_.length>8)Z+=" || validate.schema"+X+".hasOwnProperty("+C+") ";else{var OA=_;if(OA){var IA,PA=-1,kA=OA.length-1;while(PA<kA)IA=OA[PA+=1],Z+=" || "+C+" == "+Q.util.toQuotedString(IA)+" "}}if(x.length){var YA=x;if(YA){var ZA,zA=-1,bA=YA.length-1;while(zA<bA)ZA=YA[zA+=1],Z+=" || "+Q.usePattern(ZA)+".test("+C+") "}}Z+=" ); if (isAdditional"+Y+") { "}if(e=="all")Z+=" delete "+V+"["+C+"]; ";else{var TA=Q.errorPath,B1="' + "+C+" + '";if(Q.opts._errorDataPathProperty)Q.errorPath=Q.util.getPathExpr(Q.errorPath,C,Q.opts.jsonPointers);if(m)if(e)Z+=" delete "+V+"["+C+"]; ";else{Z+=" "+F+" = false; ";var JA=W;W=Q.errSchemaPath+"/additionalProperties";var CA=CA||[];if(CA.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'additionalProperties' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { additionalProperty: '"+B1+"' } ",Q.opts.messages!==!1){if(Z+=" , message: '",Q.opts._errorDataPathProperty)Z+="is an invalid additional property";else Z+="should NOT have additional properties";Z+="' "}if(Q.opts.verbose)Z+=" , schema: false , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var MA=Z;if(Z=CA.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+MA+"]); ";else Z+=" validate.errors = ["+MA+"]; return false; ";else Z+=" var err = "+MA+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(W=JA,K)Z+=" break; "}else if(u)if(e=="failing"){Z+=" var "+E+" = errors;  ";var NA=Q.compositeRule;Q.compositeRule=D.compositeRule=!0,D.schema=b,D.schemaPath=Q.schemaPath+".additionalProperties",D.errSchemaPath=Q.errSchemaPath+"/additionalProperties",D.errorPath=Q.opts._errorDataPathProperty?Q.errorPath:Q.util.getPathExpr(Q.errorPath,C,Q.opts.jsonPointers);var UA=V+"["+C+"]";D.dataPathArr[O]=C;var LA=Q.validate(D);if(D.baseId=c,Q.util.varOccurences(LA,M)<2)Z+=" "+Q.util.varReplace(LA,M,UA)+" ";else Z+=" var "+M+" = "+UA+"; "+LA+" ";Z+=" if (!"+F+") { errors = "+E+"; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete "+V+"["+C+"]; }  ",Q.compositeRule=D.compositeRule=NA}else{D.schema=b,D.schemaPath=Q.schemaPath+".additionalProperties",D.errSchemaPath=Q.errSchemaPath+"/additionalProperties",D.errorPath=Q.opts._errorDataPathProperty?Q.errorPath:Q.util.getPathExpr(Q.errorPath,C,Q.opts.jsonPointers);var UA=V+"["+C+"]";D.dataPathArr[O]=C;var LA=Q.validate(D);if(D.baseId=c,Q.util.varOccurences(LA,M)<2)Z+=" "+Q.util.varReplace(LA,M,UA)+" ";else Z+=" var "+M+" = "+UA+"; "+LA+" ";if(K)Z+=" if (!"+F+") break; "}Q.errorPath=TA}if(v)Z+=" } ";if(Z+=" }  ",K)Z+=" if ("+F+") { ",H+="}"}var nA=Q.opts.useDefaults&&!Q.compositeRule;if(_.length){var gA=_;if(gA){var IA,I1=-1,q1=gA.length-1;while(I1<q1){IA=gA[I1+=1];var _A=I[IA];if(Q.opts.strictKeywords?typeof _A=="object"&&Object.keys(_A).length>0||_A===!1:Q.util.schemaHasRules(_A,Q.RULES.all)){var Q1=Q.util.getProperty(IA),UA=V+Q1,h1=nA&&_A.default!==void 0;D.schema=_A,D.schemaPath=X+Q1,D.errSchemaPath=W+"/"+Q.util.escapeFragment(IA),D.errorPath=Q.util.getPath(Q.errorPath,IA,Q.opts.jsonPointers),D.dataPathArr[O]=Q.util.toQuotedString(IA);var LA=Q.validate(D);if(D.baseId=c,Q.util.varOccurences(LA,M)<2){LA=Q.util.varReplace(LA,M,UA);var _1=UA}else{var _1=M;Z+=" var "+M+" = "+UA+"; "}if(h1)Z+=" "+LA+" ";else{if(AA&&AA[IA]){if(Z+=" if ( "+_1+" === undefined ",k)Z+=" || ! Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(IA)+"') ";Z+=") { "+F+" = false; ";var TA=Q.errorPath,JA=W,V0=Q.util.escapeQuotes(IA);if(Q.opts._errorDataPathProperty)Q.errorPath=Q.util.getPath(TA,IA,Q.opts.jsonPointers);W=Q.errSchemaPath+"/required";var CA=CA||[];if(CA.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'required' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { missingProperty: '"+V0+"' } ",Q.opts.messages!==!1){if(Z+=" , message: '",Q.opts._errorDataPathProperty)Z+="is a required property";else Z+="should have required property \\'"+V0+"\\'";Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var MA=Z;if(Z=CA.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+MA+"]); ";else Z+=" validate.errors = ["+MA+"]; return false; ";else Z+=" var err = "+MA+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";W=JA,Q.errorPath=TA,Z+=" } else { "}else if(K){if(Z+=" if ( "+_1+" === undefined ",k)Z+=" || ! Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(IA)+"') ";Z+=") { "+F+" = true; } else { "}else{if(Z+=" if ("+_1+" !== undefined ",k)Z+=" &&   Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(IA)+"') ";Z+=" ) { "}Z+=" "+LA+" } "}}if(K)Z+=" if ("+F+") { ",H+="}"}}}if(x.length){var AQ=x;if(AQ){var ZA,n0=-1,JQ=AQ.length-1;while(n0<JQ){ZA=AQ[n0+=1];var _A=T[ZA];if(Q.opts.strictKeywords?typeof _A=="object"&&Object.keys(_A).length>0||_A===!1:Q.util.schemaHasRules(_A,Q.RULES.all)){if(D.schema=_A,D.schemaPath=Q.schemaPath+".patternProperties"+Q.util.getProperty(ZA),D.errSchemaPath=Q.errSchemaPath+"/patternProperties/"+Q.util.escapeFragment(ZA),k)Z+=" "+L+" = "+L+" || Object.keys("+V+"); for (var "+$+"=0; "+$+"<"+L+".length; "+$+"++) { var "+C+" = "+L+"["+$+"]; ";else Z+=" for (var "+C+" in "+V+") { ";Z+=" if ("+Q.usePattern(ZA)+".test("+C+")) { ",D.errorPath=Q.util.getPathExpr(Q.errorPath,C,Q.opts.jsonPointers);var UA=V+"["+C+"]";D.dataPathArr[O]=C;var LA=Q.validate(D);if(D.baseId=c,Q.util.varOccurences(LA,M)<2)Z+=" "+Q.util.varReplace(LA,M,UA)+" ";else Z+=" var "+M+" = "+UA+"; "+LA+" ";if(K)Z+=" if (!"+F+") break; ";if(Z+=" } ",K)Z+=" else "+F+" = true; ";if(Z+=" }  ",K)Z+=" if ("+F+") { ",H+="}"}}}}if(K)Z+=" "+H+" if ("+E+" == errors) {";return Z}});var $VB=w((Zi7,UVB)=>{UVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="errs__"+Y,D=Q.util.copy(Q),H="";D.level++;var F="valid"+D.level;if(Z+="var "+E+" = errors;",Q.opts.strictKeywords?typeof I=="object"&&Object.keys(I).length>0||I===!1:Q.util.schemaHasRules(I,Q.RULES.all)){D.schema=I,D.schemaPath=X,D.errSchemaPath=W;var C="key"+Y,$="idx"+Y,O="i"+Y,M="' + "+C+" + '",L=D.dataLevel=Q.dataLevel+1,_="data"+L,T="dataProperties"+Y,x=Q.opts.ownProperties,b=Q.baseId;if(x)Z+=" var "+T+" = undefined; ";if(x)Z+=" "+T+" = "+T+" || Object.keys("+V+"); for (var "+$+"=0; "+$+"<"+T+".length; "+$+"++) { var "+C+" = "+T+"["+$+"]; ";else Z+=" for (var "+C+" in "+V+") { ";Z+=" var startErrs"+Y+" = errors; ";var v=C,m=Q.compositeRule;Q.compositeRule=D.compositeRule=!0;var u=Q.validate(D);if(D.baseId=b,Q.util.varOccurences(u,_)<2)Z+=" "+Q.util.varReplace(u,_,v)+" ";else Z+=" var "+_+" = "+v+"; "+u+" ";if(Q.compositeRule=D.compositeRule=m,Z+=" if (!"+F+") { for (var "+O+"=startErrs"+Y+"; "+O+"<errors; "+O+"++) { vErrors["+O+"].propertyName = "+C+"; }   var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'propertyNames' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { propertyName: '"+M+"' } ",Q.opts.messages!==!1)Z+=" , message: 'property name \\'"+M+"\\' is invalid' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";if(Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(vErrors); ";else Z+=" validate.errors = vErrors; return false; ";if(K)Z+=" break; ";Z+=" } }"}if(K)Z+=" "+H+" if ("+E+" == errors) {";return Z}});var NVB=w((Yi7,wVB)=>{wVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D=Q.opts.$data&&I&&I.$data,H;if(D)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",H="schema"+Y;else H=I;var F="schema"+Y;if(!D)if(I.length<Q.opts.loopRequired&&Q.schema.properties&&Object.keys(Q.schema.properties).length){var C=[],$=I;if($){var O,M=-1,L=$.length-1;while(M<L){O=$[M+=1];var _=Q.schema.properties[O];if(!(_&&(Q.opts.strictKeywords?typeof _=="object"&&Object.keys(_).length>0||_===!1:Q.util.schemaHasRules(_,Q.RULES.all))))C[C.length]=O}}}else var C=I;if(D||C.length){var T=Q.errorPath,x=D||C.length>=Q.opts.loopRequired,b=Q.opts.ownProperties;if(K)if(Z+=" var missing"+Y+"; ",x){if(!D)Z+=" var "+F+" = validate.schema"+X+"; ";var v="i"+Y,m="schema"+Y+"["+v+"]",u="' + "+m+" + '";if(Q.opts._errorDataPathProperty)Q.errorPath=Q.util.getPathExpr(T,m,Q.opts.jsonPointers);if(Z+=" var "+E+" = true; ",D)Z+=" if (schema"+Y+" === undefined) "+E+" = true; else if (!Array.isArray(schema"+Y+")) "+E+" = false; else {";if(Z+=" for (var "+v+" = 0; "+v+" < "+F+".length; "+v+"++) { "+E+" = "+V+"["+F+"["+v+"]] !== undefined ",b)Z+=" &&   Object.prototype.hasOwnProperty.call("+V+", "+F+"["+v+"]) ";if(Z+="; if (!"+E+") break; } ",D)Z+="  }  ";Z+="  if (!"+E+") {   ";var e=e||[];if(e.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'required' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { missingProperty: '"+u+"' } ",Q.opts.messages!==!1){if(Z+=" , message: '",Q.opts._errorDataPathProperty)Z+="is a required property";else Z+="should have required property \\'"+u+"\\'";Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var p=Z;if(Z=e.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+p+"]); ";else Z+=" validate.errors = ["+p+"]; return false; ";else Z+=" var err = "+p+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";Z+=" } else { "}else{Z+=" if ( ";var k=C;if(k){var c,v=-1,t=k.length-1;while(v<t){if(c=k[v+=1],v)Z+=" || ";var AA=Q.util.getProperty(c),VA=V+AA;if(Z+=" ( ( "+VA+" === undefined ",b)Z+=" || ! Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(c)+"') ";Z+=") && (missing"+Y+" = "+Q.util.toQuotedString(Q.opts.jsonPointers?c:AA)+") ) "}}Z+=") {  ";var m="missing"+Y,u="' + "+m+" + '";if(Q.opts._errorDataPathProperty)Q.errorPath=Q.opts.jsonPointers?Q.util.getPathExpr(T,m,!0):T+" + "+m;var e=e||[];if(e.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'required' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { missingProperty: '"+u+"' } ",Q.opts.messages!==!1){if(Z+=" , message: '",Q.opts._errorDataPathProperty)Z+="is a required property";else Z+="should have required property \\'"+u+"\\'";Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var p=Z;if(Z=e.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+p+"]); ";else Z+=" validate.errors = ["+p+"]; return false; ";else Z+=" var err = "+p+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";Z+=" } else { "}else if(x){if(!D)Z+=" var "+F+" = validate.schema"+X+"; ";var v="i"+Y,m="schema"+Y+"["+v+"]",u="' + "+m+" + '";if(Q.opts._errorDataPathProperty)Q.errorPath=Q.util.getPathExpr(T,m,Q.opts.jsonPointers);if(D){if(Z+=" if ("+F+" && !Array.isArray("+F+")) {  var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'required' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { missingProperty: '"+u+"' } ",Q.opts.messages!==!1){if(Z+=" , message: '",Q.opts._errorDataPathProperty)Z+="is a required property";else Z+="should have required property \\'"+u+"\\'";Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if ("+F+" !== undefined) { "}if(Z+=" for (var "+v+" = 0; "+v+" < "+F+".length; "+v+"++) { if ("+V+"["+F+"["+v+"]] === undefined ",b)Z+=" || ! Object.prototype.hasOwnProperty.call("+V+", "+F+"["+v+"]) ";if(Z+=") {  var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'required' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { missingProperty: '"+u+"' } ",Q.opts.messages!==!1){if(Z+=" , message: '",Q.opts._errorDataPathProperty)Z+="is a required property";else Z+="should have required property \\'"+u+"\\'";Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";if(Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ",D)Z+="  }  "}else{var OA=C;if(OA){var c,IA=-1,PA=OA.length-1;while(IA<PA){c=OA[IA+=1];var AA=Q.util.getProperty(c),u=Q.util.escapeQuotes(c),VA=V+AA;if(Q.opts._errorDataPathProperty)Q.errorPath=Q.util.getPath(T,c,Q.opts.jsonPointers);if(Z+=" if ( "+VA+" === undefined ",b)Z+=" || ! Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(c)+"') ";if(Z+=") {  var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'required' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { missingProperty: '"+u+"' } ",Q.opts.messages!==!1){if(Z+=" , message: '",Q.opts._errorDataPathProperty)Z+="is a required property";else Z+="should have required property \\'"+u+"\\'";Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "}}}Q.errorPath=T}else if(K)Z+=" if (true) {";return Z}});var LVB=w((Ji7,qVB)=>{qVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D=Q.opts.$data&&I&&I.$data,H;if(D)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",H="schema"+Y;else H=I;if((I||D)&&Q.opts.uniqueItems!==!1){if(D)Z+=" var "+E+"; if ("+H+" === false || "+H+" === undefined) "+E+" = true; else if (typeof "+H+" != 'boolean') "+E+" = false; else { ";Z+=" var i = "+V+".length , "+E+" = true , j; if (i > 1) { ";var F=Q.schema.items&&Q.schema.items.type,C=Array.isArray(F);if(!F||F=="object"||F=="array"||C&&(F.indexOf("object")>=0||F.indexOf("array")>=0))Z+=" outer: for (;i--;) { for (j = i; j--;) { if (equal("+V+"[i], "+V+"[j])) { "+E+" = false; break outer; } } } ";else{Z+=" var itemIndices = {}, item; for (;i--;) { var item = "+V+"[i]; ";var $="checkDataType"+(C?"s":"");if(Z+=" if ("+Q.util[$](F,"item",Q.opts.strictNumbers,!0)+") continue; ",C)Z+=` if (typeof item == 'string') item = '"' + item; `;Z+=" if (typeof itemIndices[item] == 'number') { "+E+" = false; j = itemIndices[item]; break; } itemIndices[item] = i; } "}if(Z+=" } ",D)Z+="  }  ";Z+=" if (!"+E+") {   ";var O=O||[];if(O.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'uniqueItems' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { i: i, j: j } ",Q.opts.messages!==!1)Z+=" , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";if(Q.opts.verbose){if(Z+=" , schema:  ",D)Z+="validate.schema"+X;else Z+=""+I;Z+="         , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" "}Z+=" } "}else Z+=" {} ";var M=Z;if(Z=O.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+M+"]); ";else Z+=" validate.errors = ["+M+"]; return false; ";else Z+=" var err = "+M+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" } ",K)Z+=" else { "}else if(K)Z+=" if (true) { ";return Z}});var OVB=w((Ii7,MVB)=>{MVB.exports={$ref:bKB(),allOf:gKB(),anyOf:mKB(),$comment:cKB(),const:lKB(),contains:nKB(),dependencies:oKB(),enum:sKB(),format:eKB(),if:QVB(),items:GVB(),maximum:Dc1(),minimum:Dc1(),maxItems:Hc1(),minItems:Hc1(),maxLength:Fc1(),minLength:Fc1(),maxProperties:Cc1(),minProperties:Cc1(),multipleOf:WVB(),not:VVB(),oneOf:DVB(),pattern:FVB(),properties:zVB(),propertyNames:$VB(),required:NVB(),uniqueItems:LVB(),validate:Vc1()}});var TVB=w((Xi7,_VB)=>{var RVB=OVB(),zc1=ye().toHash;_VB.exports=function(){var Q=[{type:"number",rules:[{maximum:["exclusiveMaximum"]},{minimum:["exclusiveMinimum"]},"multipleOf","format"]},{type:"string",rules:["maxLength","minLength","pattern","format"]},{type:"array",rules:["maxItems","minItems","items","contains","uniqueItems"]},{type:"object",rules:["maxProperties","minProperties","required","dependencies","propertyNames",{properties:["additionalProperties","patternProperties"]}]},{rules:["$ref","const","enum","not","anyOf","oneOf","allOf","if"]}],B=["type","$comment"],G=["$schema","$id","id","$data","$async","title","description","default","definitions","examples","readOnly","writeOnly","contentMediaType","contentEncoding","additionalItems","then","else"],Z=["number","integer","string","array","object","boolean","null"];return Q.all=zc1(B),Q.types=zc1(Z),Q.forEach(function(Y){if(Y.rules=Y.rules.map(function(J){var I;if(typeof J=="object"){var X=Object.keys(J)[0];I=J[X],J=X,I.forEach(function(K){B.push(K),Q.all[K]=!0})}B.push(J);var W=Q.all[J]={keyword:J,code:RVB[J],implements:I};return W}),Q.all.$comment={keyword:"$comment",code:RVB.$comment},Y.type)Q.types[Y.type]=Y}),Q.keywords=zc1(B.concat(G)),Q.custom={},Q}});var SVB=w((Wi7,PVB)=>{var jVB=["multipleOf","maximum","exclusiveMaximum","minimum","exclusiveMinimum","maxLength","minLength","pattern","additionalItems","maxItems","minItems","uniqueItems","maxProperties","minProperties","required","additionalProperties","enum","format","const"];PVB.exports=function(A,Q){for(var B=0;B<Q.length;B++){A=JSON.parse(JSON.stringify(A));var G=Q[B].split("/"),Z=A,Y;for(Y=1;Y<G.length;Y++)Z=Z[G[Y]];for(Y=0;Y<jVB.length;Y++){var J=jVB[Y],I=Z[J];if(I)Z[J]={anyOf:[I,{$ref:"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"}]}}}return A}});var vVB=w((Ki7,yVB)=>{var uM6=YrA().MissingRef;yVB.exports=xVB;function xVB(A,Q,B){var G=this;if(typeof this._opts.loadSchema!="function")throw Error("options.loadSchema should be a function");if(typeof Q=="function")B=Q,Q=void 0;var Z=Y(A).then(function(){var I=G._addSchema(A,void 0,Q);return I.validate||J(I)});if(B)Z.then(function(I){B(null,I)},B);return Z;function Y(I){var X=I.$schema;return X&&!G.getSchema(X)?xVB.call(G,{$ref:X},!0):Promise.resolve()}function J(I){try{return G._compile(I)}catch(W){if(W instanceof uM6)return X(W);throw W}function X(W){var K=W.missingSchema;if(D(K))throw Error("Schema "+K+" is loaded but "+W.missingRef+" cannot be resolved");var V=G._loadingSchemas[K];if(!V)V=G._loadingSchemas[K]=G._opts.loadSchema(K),V.then(E,E);return V.then(function(H){if(!D(K))return Y(H).then(function(){if(!D(K))G.addSchema(H,K,void 0,Q)})}).then(function(){return J(I)});function E(){delete G._loadingSchemas[K]}function D(H){return G._refs[H]||G._schemas[H]}}}}});var fVB=w((Vi7,kVB)=>{kVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V,E="data"+(J||""),D="valid"+Y,H="errs__"+Y,F=Q.opts.$data&&I&&I.$data,C;if(F)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",C="schema"+Y;else C=I;var $=this,O="definition"+Y,M=$.definition,L="",_,T,x,b,v;if(F&&M.$data){v="keywordValidate"+Y;var m=M.validateSchema;Z+=" var "+O+" = RULES.custom['"+B+"'].definition; var "+v+" = "+O+".validate;"}else{if(b=Q.useCustomRule($,I,Q.schema,Q),!b)return;C="validate.schema"+X,v=b.code,_=M.compile,T=M.inline,x=M.macro}var u=v+".errors",e="i"+Y,p="ruleErr"+Y,k=M.async;if(k&&!Q.async)throw Error("async keyword in sync schema");if(!(T||x))Z+=""+u+" = null;";if(Z+="var "+H+" = errors;var "+D+";",F&&M.$data){if(L+="}",Z+=" if ("+C+" === undefined) { "+D+" = true; } else { ",m)L+="}",Z+=" "+D+" = "+O+".validateSchema("+C+"); if ("+D+") { "}if(T)if(M.statements)Z+=" "+b.validate+" ";else Z+=" "+D+" = "+b.validate+"; ";else if(x){var c=Q.util.copy(Q),L="";c.level++;var t="valid"+c.level;c.schema=b.validate,c.schemaPath="";var AA=Q.compositeRule;Q.compositeRule=c.compositeRule=!0;var VA=Q.validate(c).replace(/validate\.schema/g,v);Q.compositeRule=c.compositeRule=AA,Z+=" "+VA}else{var OA=OA||[];if(OA.push(Z),Z="",Z+="  "+v+".call( ",Q.opts.passContext)Z+="this";else Z+="self";if(_||M.schema===!1)Z+=" , "+E+" ";else Z+=" , "+C+" , "+E+" , validate.schema"+Q.schemaPath+" ";if(Z+=" , (dataPath || '')",Q.errorPath!='""')Z+=" + "+Q.errorPath;var IA=J?"data"+(J-1||""):"parentData",PA=J?Q.dataPathArr[J]:"parentDataProperty";Z+=" , "+IA+" , "+PA+" , rootData )  ";var kA=Z;if(Z=OA.pop(),M.errors===!1){if(Z+=" "+D+" = ",k)Z+="await ";Z+=""+kA+"; "}else if(k)u="customErrors"+Y,Z+=" var "+u+" = null; try { "+D+" = await "+kA+"; } catch (e) { "+D+" = false; if (e instanceof ValidationError) "+u+" = e.errors; else throw e; } ";else Z+=" "+u+" = null; "+D+" = "+kA+"; "}if(M.modifying)Z+=" if ("+IA+") "+E+" = "+IA+"["+PA+"];";if(Z+=""+L,M.valid){if(K)Z+=" if (true) { "}else{if(Z+=" if ( ",M.valid===void 0)if(Z+=" !",x)Z+=""+t;else Z+=""+D;else Z+=" "+!M.valid+" ";Z+=") { ",V=$.keyword;var OA=OA||[];OA.push(Z),Z="";var OA=OA||[];if(OA.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(V||"custom")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { keyword: '"+$.keyword+"' } ",Q.opts.messages!==!1)Z+=` , message: 'should pass "`+$.keyword+`" keyword validation' `;if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+E+" ";Z+=" } "}else Z+=" {} ";var YA=Z;if(Z=OA.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+YA+"]); ";else Z+=" validate.errors = ["+YA+"]; return false; ";else Z+=" var err = "+YA+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";var ZA=Z;if(Z=OA.pop(),T)if(M.errors){if(M.errors!="full"){if(Z+="  for (var "+e+"="+H+"; "+e+"<errors; "+e+"++) { var "+p+" = vErrors["+e+"]; if ("+p+".dataPath === undefined) "+p+".dataPath = (dataPath || '') + "+Q.errorPath+"; if ("+p+".schemaPath === undefined) { "+p+'.schemaPath = "'+W+'"; } ',Q.opts.verbose)Z+=" "+p+".schema = "+C+"; "+p+".data = "+E+"; ";Z+=" } "}}else if(M.errors===!1)Z+=" "+ZA+" ";else{if(Z+=" if ("+H+" == errors) { "+ZA+" } else {  for (var "+e+"="+H+"; "+e+"<errors; "+e+"++) { var "+p+" = vErrors["+e+"]; if ("+p+".dataPath === undefined) "+p+".dataPath = (dataPath || '') + "+Q.errorPath+"; if ("+p+".schemaPath === undefined) { "+p+'.schemaPath = "'+W+'"; } ',Q.opts.verbose)Z+=" "+p+".schema = "+C+"; "+p+".data = "+E+"; ";Z+=" } } "}else if(x){if(Z+="   var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: '"+(V||"custom")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { keyword: '"+$.keyword+"' } ",Q.opts.messages!==!1)Z+=` , message: 'should pass "`+$.keyword+`" keyword validation' `;if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+E+" ";Z+=" } "}else Z+=" {} ";if(Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(vErrors); ";else Z+=" validate.errors = vErrors; return false; "}else if(M.errors===!1)Z+=" "+ZA+" ";else{if(Z+=" if (Array.isArray("+u+")) { if (vErrors === null) vErrors = "+u+"; else vErrors = vErrors.concat("+u+"); errors = vErrors.length;  for (var "+e+"="+H+"; "+e+"<errors; "+e+"++) { var "+p+" = vErrors["+e+"]; if ("+p+".dataPath === undefined) "+p+".dataPath = (dataPath || '') + "+Q.errorPath+";  "+p+'.schemaPath = "'+W+'";  ',Q.opts.verbose)Z+=" "+p+".schema = "+C+"; "+p+".data = "+E+"; ";Z+=" } } else { "+ZA+" } "}if(Z+=" } ",K)Z+=" else { "}return Z}});var Uc1=w((Ei7,mM6)=>{mM6.exports={$schema:"http://json-schema.org/draft-07/schema#",$id:"http://json-schema.org/draft-07/schema#",title:"Core schema meta-schema",definitions:{schemaArray:{type:"array",minItems:1,items:{$ref:"#"}},nonNegativeInteger:{type:"integer",minimum:0},nonNegativeIntegerDefault0:{allOf:[{$ref:"#/definitions/nonNegativeInteger"},{default:0}]},simpleTypes:{enum:["array","boolean","integer","null","number","object","string"]},stringArray:{type:"array",items:{type:"string"},uniqueItems:!0,default:[]}},type:["object","boolean"],properties:{$id:{type:"string",format:"uri-reference"},$schema:{type:"string",format:"uri"},$ref:{type:"string",format:"uri-reference"},$comment:{type:"string"},title:{type:"string"},description:{type:"string"},default:!0,readOnly:{type:"boolean",default:!1},examples:{type:"array",items:!0},multipleOf:{type:"number",exclusiveMinimum:0},maximum:{type:"number"},exclusiveMaximum:{type:"number"},minimum:{type:"number"},exclusiveMinimum:{type:"number"},maxLength:{$ref:"#/definitions/nonNegativeInteger"},minLength:{$ref:"#/definitions/nonNegativeIntegerDefault0"},pattern:{type:"string",format:"regex"},additionalItems:{$ref:"#"},items:{anyOf:[{$ref:"#"},{$ref:"#/definitions/schemaArray"}],default:!0},maxItems:{$ref:"#/definitions/nonNegativeInteger"},minItems:{$ref:"#/definitions/nonNegativeIntegerDefault0"},uniqueItems:{type:"boolean",default:!1},contains:{$ref:"#"},maxProperties:{$ref:"#/definitions/nonNegativeInteger"},minProperties:{$ref:"#/definitions/nonNegativeIntegerDefault0"},required:{$ref:"#/definitions/stringArray"},additionalProperties:{$ref:"#"},definitions:{type:"object",additionalProperties:{$ref:"#"},default:{}},properties:{type:"object",additionalProperties:{$ref:"#"},default:{}},patternProperties:{type:"object",additionalProperties:{$ref:"#"},propertyNames:{format:"regex"},default:{}},dependencies:{type:"object",additionalProperties:{anyOf:[{$ref:"#"},{$ref:"#/definitions/stringArray"}]}},propertyNames:{$ref:"#"},const:!0,enum:{type:"array",items:!0,minItems:1,uniqueItems:!0},type:{anyOf:[{$ref:"#/definitions/simpleTypes"},{type:"array",items:{$ref:"#/definitions/simpleTypes"},minItems:1,uniqueItems:!0}]},format:{type:"string"},contentMediaType:{type:"string"},contentEncoding:{type:"string"},if:{$ref:"#"},then:{$ref:"#"},else:{$ref:"#"},allOf:{$ref:"#/definitions/schemaArray"},anyOf:{$ref:"#/definitions/schemaArray"},oneOf:{$ref:"#/definitions/schemaArray"},not:{$ref:"#"}},default:!0}});var gVB=w((Di7,hVB)=>{var bVB=Uc1();hVB.exports={$id:"https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",definitions:{simpleTypes:bVB.definitions.simpleTypes},type:"object",dependencies:{schema:["validate"],$data:["validate"],statements:["inline"],valid:{not:{required:["macro"]}}},properties:{type:bVB.properties.type,schema:{type:"boolean"},statements:{type:"boolean"},dependencies:{type:"array",items:{type:"string"}},metaSchema:{type:"object"},modifying:{type:"boolean"},valid:{type:"boolean"},$data:{type:"boolean"},async:{type:"boolean"},errors:{anyOf:[{type:"boolean"},{const:"full"}]}}}});var mVB=w((Hi7,uVB)=>{var dM6=/^[a-z_$][a-z0-9_$-]*$/i,cM6=fVB(),pM6=gVB();uVB.exports={add:lM6,get:iM6,remove:nM6,validate:$c1};function lM6(A,Q){var B=this.RULES;if(B.keywords[A])throw Error("Keyword "+A+" is already defined");if(!dM6.test(A))throw Error("Keyword "+A+" is not a valid identifier");if(Q){this.validateKeyword(Q,!0);var G=Q.type;if(Array.isArray(G))for(var Z=0;Z<G.length;Z++)J(A,G[Z],Q);else J(A,G,Q);var Y=Q.metaSchema;if(Y){if(Q.$data&&this._opts.$data)Y={anyOf:[Y,{$ref:"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"}]};Q.validateSchema=this.compile(Y,!0)}}B.keywords[A]=B.all[A]=!0;function J(I,X,W){var K;for(var V=0;V<B.length;V++){var E=B[V];if(E.type==X){K=E;break}}if(!K)K={type:X,rules:[]},B.push(K);var D={keyword:I,definition:W,custom:!0,code:cM6,implements:W.implements};K.rules.push(D),B.custom[I]=D}return this}function iM6(A){var Q=this.RULES.custom[A];return Q?Q.definition:this.RULES.keywords[A]||!1}function nM6(A){var Q=this.RULES;delete Q.keywords[A],delete Q.all[A],delete Q.custom[A];for(var B=0;B<Q.length;B++){var G=Q[B].rules;for(var Z=0;Z<G.length;Z++)if(G[Z].keyword==A){G.splice(Z,1);break}}return this}function $c1(A,Q){$c1.errors=null;var B=this._validateKeyword=this._validateKeyword||this.compile(pM6,!0);if(B(A))return!0;if($c1.errors=B.errors,Q)throw Error("custom keyword definition is invalid: "+this.errorsText(B.errors));else return!1}});var dVB=w((Fi7,aM6)=>{aM6.exports={$schema:"http://json-schema.org/draft-07/schema#",$id:"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",description:"Meta-schema for $data reference (JSON Schema extension proposal)",type:"object",required:["$data"],properties:{$data:{type:"string",anyOf:[{format:"relative-json-pointer"},{format:"json-pointer"}]}},additionalProperties:!1}});var HrA=w((Ci7,sVB)=>{var pVB=NKB(),ve=ZrA(),oM6=LKB(),lVB=Zc1(),rM6=Kc1(),sM6=kKB(),tM6=TVB(),iVB=SVB(),nVB=ye();sVB.exports=XI;XI.prototype.validate=AO6;XI.prototype.compile=QO6;XI.prototype.addSchema=BO6;XI.prototype.addMetaSchema=GO6;XI.prototype.validateSchema=ZO6;XI.prototype.getSchema=JO6;XI.prototype.removeSchema=XO6;XI.prototype.addFormat=CO6;XI.prototype.errorsText=FO6;XI.prototype._addSchema=WO6;XI.prototype._compile=KO6;XI.prototype.compileAsync=vVB();var DrA=mVB();XI.prototype.addKeyword=DrA.add;XI.prototype.getKeyword=DrA.get;XI.prototype.removeKeyword=DrA.remove;XI.prototype.validateKeyword=DrA.validate;var aVB=YrA();XI.ValidationError=aVB.Validation;XI.MissingRefError=aVB.MissingRef;XI.$dataMetaSchema=iVB;var ErA="http://json-schema.org/draft-07/schema",cVB=["removeAdditional","useDefaults","coerceTypes","strictDefaults"],eM6=["/properties"];function XI(A){if(!(this instanceof XI))return new XI(A);if(A=this._opts=nVB.copy(A)||{},qO6(this),this._schemas={},this._refs={},this._fragments={},this._formats=sM6(A.format),this._cache=A.cache||new oM6,this._loadingSchemas={},this._compilations=[],this.RULES=tM6(),this._getId=VO6(A),A.loopRequired=A.loopRequired||1/0,A.errorDataPath=="property")A._errorDataPathProperty=!0;if(A.serialize===void 0)A.serialize=rM6;if(this._metaOpts=NO6(this),A.formats)$O6(this);if(A.keywords)wO6(this);if(zO6(this),typeof A.meta=="object")this.addMetaSchema(A.meta);if(A.nullable)this.addKeyword("nullable",{metaSchema:{type:"boolean"}});UO6(this)}function AO6(A,Q){var B;if(typeof A=="string"){if(B=this.getSchema(A),!B)throw Error('no schema with key or ref "'+A+'"')}else{var G=this._addSchema(A);B=G.validate||this._compile(G)}var Z=B(Q);if(B.$async!==!0)this.errors=B.errors;return Z}function QO6(A,Q){var B=this._addSchema(A,void 0,Q);return B.validate||this._compile(B)}function BO6(A,Q,B,G){if(Array.isArray(A)){for(var Z=0;Z<A.length;Z++)this.addSchema(A[Z],void 0,B,G);return this}var Y=this._getId(A);if(Y!==void 0&&typeof Y!="string")throw Error("schema id must be string");return Q=ve.normalizeId(Q||Y),rVB(this,Q),this._schemas[Q]=this._addSchema(A,B,G,!0),this}function GO6(A,Q,B){return this.addSchema(A,Q,B,!0),this}function ZO6(A,Q){var B=A.$schema;if(B!==void 0&&typeof B!="string")throw Error("$schema must be a string");if(B=B||this._opts.defaultMeta||YO6(this),!B)return this.logger.warn("meta-schema not available"),this.errors=null,!0;var G=this.validate(B,A);if(!G&&Q){var Z="schema is invalid: "+this.errorsText();if(this._opts.validateSchema=="log")this.logger.error(Z);else throw Error(Z)}return G}function YO6(A){var Q=A._opts.meta;return A._opts.defaultMeta=typeof Q=="object"?A._getId(Q)||Q:A.getSchema(ErA)?ErA:void 0,A._opts.defaultMeta}function JO6(A){var Q=oVB(this,A);switch(typeof Q){case"object":return Q.validate||this._compile(Q);case"string":return this.getSchema(Q);case"undefined":return IO6(this,A)}}function IO6(A,Q){var B=ve.schema.call(A,{schema:{}},Q);if(B){var{schema:G,root:Z,baseId:Y}=B,J=pVB.call(A,G,Z,void 0,Y);return A._fragments[Q]=new lVB({ref:Q,fragment:!0,schema:G,root:Z,baseId:Y,validate:J}),J}}function oVB(A,Q){return Q=ve.normalizeId(Q),A._schemas[Q]||A._refs[Q]||A._fragments[Q]}function XO6(A){if(A instanceof RegExp)return VrA(this,this._schemas,A),VrA(this,this._refs,A),this;switch(typeof A){case"undefined":return VrA(this,this._schemas),VrA(this,this._refs),this._cache.clear(),this;case"string":var Q=oVB(this,A);if(Q)this._cache.del(Q.cacheKey);return delete this._schemas[A],delete this._refs[A],this;case"object":var B=this._opts.serialize,G=B?B(A):A;this._cache.del(G);var Z=this._getId(A);if(Z)Z=ve.normalizeId(Z),delete this._schemas[Z],delete this._refs[Z]}return this}function VrA(A,Q,B){for(var G in Q){var Z=Q[G];if(!Z.meta&&(!B||B.test(G)))A._cache.del(Z.cacheKey),delete Q[G]}}function WO6(A,Q,B,G){if(typeof A!="object"&&typeof A!="boolean")throw Error("schema should be object or boolean");var Z=this._opts.serialize,Y=Z?Z(A):A,J=this._cache.get(Y);if(J)return J;G=G||this._opts.addUsedSchema!==!1;var I=ve.normalizeId(this._getId(A));if(I&&G)rVB(this,I);var X=this._opts.validateSchema!==!1&&!Q,W;if(X&&!(W=I&&I==ve.normalizeId(A.$schema)))this.validateSchema(A,!0);var K=ve.ids.call(this,A),V=new lVB({id:I,schema:A,localRefs:K,cacheKey:Y,meta:B});if(I[0]!="#"&&G)this._refs[I]=V;if(this._cache.put(Y,V),X&&W)this.validateSchema(A,!0);return V}function KO6(A,Q){if(A.compiling){if(A.validate=Z,Z.schema=A.schema,Z.errors=null,Z.root=Q?Q:Z,A.schema.$async===!0)Z.$async=!0;return Z}A.compiling=!0;var B;if(A.meta)B=this._opts,this._opts=this._metaOpts;var G;try{G=pVB.call(this,A.schema,Q,A.localRefs)}catch(Y){throw delete A.validate,Y}finally{if(A.compiling=!1,A.meta)this._opts=B}return A.validate=G,A.refs=G.refs,A.refVal=G.refVal,A.root=G.root,G;function Z(){var Y=A.validate,J=Y.apply(this,arguments);return Z.errors=Y.errors,J}}function VO6(A){switch(A.schemaId){case"auto":return HO6;case"id":return EO6;default:return DO6}}function EO6(A){if(A.$id)this.logger.warn("schema $id ignored",A.$id);return A.id}function DO6(A){if(A.id)this.logger.warn("schema id ignored",A.id);return A.$id}function HO6(A){if(A.$id&&A.id&&A.$id!=A.id)throw Error("schema $id is different from id");return A.$id||A.id}function FO6(A,Q){if(A=A||this.errors,!A)return"No errors";Q=Q||{};var B=Q.separator===void 0?", ":Q.separator,G=Q.dataVar===void 0?"data":Q.dataVar,Z="";for(var Y=0;Y<A.length;Y++){var J=A[Y];if(J)Z+=G+J.dataPath+" "+J.message+B}return Z.slice(0,-B.length)}function CO6(A,Q){if(typeof Q=="string")Q=new RegExp(Q);return this._formats[A]=Q,this}function zO6(A){var Q;if(A._opts.$data)Q=dVB(),A.addMetaSchema(Q,Q.$id,!0);if(A._opts.meta===!1)return;var B=Uc1();if(A._opts.$data)B=iVB(B,eM6);A.addMetaSchema(B,ErA,!0),A._refs["http://json-schema.org/schema"]=ErA}function UO6(A){var Q=A._opts.schemas;if(!Q)return;if(Array.isArray(Q))A.addSchema(Q);else for(var B in Q)A.addSchema(Q[B],B)}function $O6(A){for(var Q in A._opts.formats){var B=A._opts.formats[Q];A.addFormat(Q,B)}}function wO6(A){for(var Q in A._opts.keywords){var B=A._opts.keywords[Q];A.addKeyword(Q,B)}}function rVB(A,Q){if(A._schemas[Q]||A._refs[Q])throw Error('schema with key or id "'+Q+'" already exists')}function NO6(A){var Q=nVB.copy(A._opts);for(var B=0;B<cVB.length;B++)delete Q[cVB[B]];return Q}function qO6(A){var Q=A._opts.logger;if(Q===!1)A.logger={log:wc1,warn:wc1,error:wc1};else{if(Q===void 0)Q=console;if(!(typeof Q=="object"&&Q.log&&Q.warn&&Q.error))throw Error("logger must implement log, warn and error methods");A.logger=Q}}function wc1(){}});var tVB,FrA;var eVB=q(()=>{rd1();KV();tVB=o(HrA(),1);FrA=class FrA extends qwA{constructor(A,Q){var B;super(Q);this._clientInfo=A,this._cachedToolOutputValidators=new Map,this._capabilities=(B=Q===null||Q===void 0?void 0:Q.capabilities)!==null&&B!==void 0?B:{},this._ajv=new tVB.default}registerCapabilities(A){if(this.transport)throw Error("Cannot register capabilities after connecting to transport");this._capabilities=ooA(this._capabilities,A)}assertCapability(A,Q){var B;if(!((B=this._serverCapabilities)===null||B===void 0?void 0:B[A]))throw Error(`Server does not support ${A} (required for ${Q})`)}async connect(A,Q){if(await super.connect(A),A.sessionId!==void 0)return;try{let B=await this.request({method:"initialize",params:{protocolVersion:jp,capabilities:this._capabilities,clientInfo:this._clientInfo}},hd1,Q);if(B===void 0)throw Error(`Server sent invalid initialize result: ${B}`);if(!boA.includes(B.protocolVersion))throw Error(`Server's protocol version is not supported: ${B.protocolVersion}`);if(this._serverCapabilities=B.capabilities,this._serverVersion=B.serverInfo,A.setProtocolVersion)A.setProtocolVersion(B.protocolVersion);this._instructions=B.instructions,await this.notification({method:"notifications/initialized"})}catch(B){throw this.close(),B}}getServerCapabilities(){return this._serverCapabilities}getServerVersion(){return this._serverVersion}getInstructions(){return this._instructions}assertCapabilityForMethod(A){var Q,B,G,Z,Y;switch(A){case"logging/setLevel":if(!((Q=this._serverCapabilities)===null||Q===void 0?void 0:Q.logging))throw Error(`Server does not support logging (required for ${A})`);break;case"prompts/get":case"prompts/list":if(!((B=this._serverCapabilities)===null||B===void 0?void 0:B.prompts))throw Error(`Server does not support prompts (required for ${A})`);break;case"resources/list":case"resources/templates/list":case"resources/read":case"resources/subscribe":case"resources/unsubscribe":if(!((G=this._serverCapabilities)===null||G===void 0?void 0:G.resources))throw Error(`Server does not support resources (required for ${A})`);if(A==="resources/subscribe"&&!this._serverCapabilities.resources.subscribe)throw Error(`Server does not support resource subscriptions (required for ${A})`);break;case"tools/call":case"tools/list":if(!((Z=this._serverCapabilities)===null||Z===void 0?void 0:Z.tools))throw Error(`Server does not support tools (required for ${A})`);break;case"completion/complete":if(!((Y=this._serverCapabilities)===null||Y===void 0?void 0:Y.completions))throw Error(`Server does not support completions (required for ${A})`);break;case"initialize":break;case"ping":break}}assertNotificationCapability(A){var Q;switch(A){case"notifications/roots/list_changed":if(!((Q=this._capabilities.roots)===null||Q===void 0?void 0:Q.listChanged))throw Error(`Client does not support roots list changed notifications (required for ${A})`);break;case"notifications/initialized":break;case"notifications/cancelled":break;case"notifications/progress":break}}assertRequestHandlerCapability(A){switch(A){case"sampling/createMessage":if(!this._capabilities.sampling)throw Error(`Client does not support sampling capability (required for ${A})`);break;case"elicitation/create":if(!this._capabilities.elicitation)throw Error(`Client does not support elicitation capability (required for ${A})`);break;case"roots/list":if(!this._capabilities.roots)throw Error(`Client does not support roots capability (required for ${A})`);break;case"ping":break}}async ping(A){return this.request({method:"ping"},Mb,A)}async complete(A,Q){return this.request({method:"completion/complete",params:A},nd1,Q)}async setLoggingLevel(A,Q){return this.request({method:"logging/setLevel",params:{level:A}},Mb,Q)}async getPrompt(A,Q){return this.request({method:"prompts/get",params:A},pd1,Q)}async listPrompts(A,Q){return this.request({method:"prompts/list",params:A},wwA,Q)}async listResources(A,Q){return this.request({method:"resources/list",params:A},xe,Q)}async listResourceTemplates(A,Q){return this.request({method:"resources/templates/list",params:A},ud1,Q)}async readResource(A,Q){return this.request({method:"resources/read",params:A},Pp,Q)}async subscribeResource(A,Q){return this.request({method:"resources/subscribe",params:A},Mb,Q)}async unsubscribeResource(A,Q){return this.request({method:"resources/unsubscribe",params:A},Mb,Q)}async callTool(A,Q=q_,B){let G=await this.request({method:"tools/call",params:A},Q,B),Z=this.getToolOutputValidator(A.name);if(Z){if(!G.structuredContent&&!G.isError)throw new AC(eF.InvalidRequest,`Tool ${A.name} has an output schema but did not return structured content`);if(G.structuredContent)try{if(!Z(G.structuredContent))throw new AC(eF.InvalidParams,`Structured content does not match the tool's output schema: ${this._ajv.errorsText(Z.errors)}`)}catch(Y){if(Y instanceof AC)throw Y;throw new AC(eF.InvalidParams,`Failed to validate structured content: ${Y instanceof Error?Y.message:String(Y)}`)}}return G}cacheToolOutputSchemas(A){this._cachedToolOutputValidators.clear();for(let Q of A)if(Q.outputSchema)try{let B=this._ajv.compile(Q.outputSchema);this._cachedToolOutputValidators.set(Q.name,B)}catch(B){}}getToolOutputValidator(A){return this._cachedToolOutputValidators.get(A)}async listTools(A,Q){let B=await this.request({method:"tools/list",params:A},NwA,Q);return this.cacheToolOutputSchemas(B.tools),B}async sendRootsListChanged(){return this.notification({method:"notifications/roots/list_changed"})}}});class MwA{append(A){this._buffer=this._buffer?Buffer.concat([this._buffer,A]):A}readMessage(){if(!this._buffer)return null;let A=this._buffer.indexOf(`
2293:`})});function b32(){return null}function h32(){return null}function g32(){return null}function u32(){return xOA.createElement(l8,null)}function m32(A,{verbose:Q}){return xOA.createElement(D6,{result:A,verbose:Q})}var xOA;var d32=q(()=>{II();lW();xOA=o(KA(),1)});var VN8,EN8,li;var o21=q(()=>{C2();VC();pB();rG();SOA();f32();d32();_0();VN8=P.object({command:P.string().describe('The slash command to execute with its arguments, e.g., "/review-pr 123"')}),EN8=P.object({success:P.boolean().describe("Whether the slash command is valid"),commandName:P.string().describe("The name of the slash command")}),li={name:PT,inputSchema:VN8,outputSchema:EN8,description:async({command:A})=>`Execute slash command: ${A}`,prompt:async()=>k32(s1()),userFacingName:()=>PT,isConcurrencySafe:()=>!1,isEnabled:()=>!0,isReadOnly:()=>!1,async validateInput({command:A},Q){let B=xJA(A);if(!B)return{result:!1,message:`Invalid slash command format: ${A}`,errorCode:1};let{commandName:G}=B,Z=await OC(s1());if(!ch(G,Z))return{result:!1,message:`Unknown slash command: ${G}`,errorCode:2};let Y=FN(G,Z);if(!Y)return{result:!1,message:`Could not load slash command: ${G}`,errorCode:3};if(Y.disableModelInvocation)return{result:!1,message:`Slash command ${G} cannot be used with ${PT} tool due to disable-model-invocation`,errorCode:4};if(Y.type!=="prompt")return{result:!1,message:`Slash command ${G} is not a prompt-based command`,errorCode:5};return{result:!0}},async checkPermissions({command:A},Q){let{commandName:B}=xJA(A)||{commandName:"unknown"},Z=(await Q.getAppState()).toolPermissionContext,Y=await OC(s1()),J=FN(B,Y),I=(E)=>{if(E===A)return!0;if(E.endsWith(":*")){let D=E.slice(0,-2);return A.startsWith(D)}return!1},X=mU(Z,li,"deny");for(let[E,D]of X.entries())if(I(E))return{behavior:"deny",message:"Slash command execution blocked by permission rules",decisionReason:{type:"rule",rule:D}};let W=mU(Z,li,"allow");for(let[E,D]of W.entries())if(I(E))return{behavior:"allow",updatedInput:{command:A},decisionReason:{type:"rule",rule:D}};let K=[{type:"addRules",rules:[{toolName:PT,ruleContent:A}],behavior:"allow",destination:"localSettings"}],V=A.indexOf(" ");if(V>0){let E=A.substring(0,V);K.push({type:"addRules",rules:[{toolName:PT,ruleContent:`${E}:*`}],behavior:"allow",destination:"localSettings"})}return{behavior:"ask",message:`Execute slash command: /${B}`,decisionReason:void 0,suggestions:K,metadata:{command:J}}},async call({command:A},Q,B,G){let{commandName:Z,args:Y}=xJA(A),J=await OC(s1()),I=await p21(Z,Y,J,Q);if(!I.shouldQuery)throw Error("Command processing failed");let X=I.allowedTools||[],W=I.model,K=I.maxThinkingTokens,V=Hx().has(Z)?Z:"custom";s("tengu_slash_command_tool_invocation",{command_name:V});let E=i21(G,PT),D=l21(I.messages.filter((H)=>H.type!=="progress"),E);return{data:{success:!0,commandName:Z},newMessages:D,contextModifier(H){let F=H;if(X.length>0)F={...F,async getAppState(){let C=await Q.getAppState();return{...C,toolPermissionContext:{...C.toolPermissionContext,alwaysAllowRules:{...C.toolPermissionContext.alwaysAllowRules,command:[...new Set([...C.toolPermissionContext.alwaysAllowRules.command||[],...X])]}}}}};if(W)F={...F,options:{...F.options,mainLoopModel:W}};if(K!==void 0)F={...F,options:{...F.options,maxThinkingTokens:K}};return F}}},mapToolResultToToolResultBlockParam(A,Q){return{type:"tool_result",tool_use_id:Q,content:`Launching command: /${A.commandName}`}},renderToolResultMessage:b32,renderToolUseMessage:h32,renderToolUseProgressMessage:g32,renderToolUseRejectedMessage:u32,renderToolUseErrorMessage:m32}});function c32(A){let{toolUseConfirm:Q,onDone:B,onReject:G,verbose:Z}=A,J=((E)=>{let D=pi.inputSchema.safeParse(E);if(!D.success)return r(Error(`Failed to parse skill tool input: ${D.error.message}`)),"";return D.data.skill})(Q.input),I=Q.permissionResult.behavior==="ask"&&Q.permissionResult.metadata&&"command"in Q.permissionResult.metadata?Q.permissionResult.metadata.command:void 0,X=lM.useMemo(()=>({completion_type:"tool_use_single",language_name:"none"}),[]);bU(Q,X);let W=cQ(),K=lM.useMemo(()=>{let E=[{label:"Yes",value:"yes"}],D={label:`Yes, and don't ask again for ${pA.bold(J)} in ${pA.bold(W)}`,value:"yes-exact"},H=J.indexOf(" "),F=[];if(H>0){let $=J.substring(0,H);F.push({label:`Yes, and don't ask again for ${pA.bold($+":*")} commands in ${pA.bold(W)}`,value:"yes-prefix"})}let C={label:`No, and tell Claude what to do differently ${pA.bold("(esc)")}`,value:"no"};return[...E,D,...F,C]},[J,W]),V=(E)=>{switch(E){case"yes":QJ({completion_type:"tool_use_single",event:"accept",metadata:{language_name:"none",message_id:Q.assistantMessage.message.id,platform:QQ.platform}}),Q.onAllow(Q.input,[]),B();break;case"yes-exact":{QJ({completion_type:"tool_use_single",event:"accept",metadata:{language_name:"none",message_id:Q.assistantMessage.message.id,platform:QQ.platform}}),Q.onAllow(Q.input,[{type:"addRules",rules:[{toolName:YN,ruleContent:J}],behavior:"allow",destination:"localSettings"}]),B();break}case"yes-prefix":{QJ({completion_type:"tool_use_single",event:"accept",metadata:{language_name:"none",message_id:Q.assistantMessage.message.id,platform:QQ.platform}});let D=J.indexOf(" "),H=D>0?J.substring(0,D):J;Q.onAllow(Q.input,[{type:"addRules",rules:[{toolName:YN,ruleContent:`${H}:*`}],behavior:"allow",destination:"localSettings"}]),B();break}case"no":QJ({completion_type:"tool_use_single",event:"reject",metadata:{language_name:"none",message_id:Q.assistantMessage.message.id,platform:QQ.platform}}),Q.onReject(),G(),B();break}};return lM.default.createElement(fZ,{title:`Use skill "${J}"?`},lM.default.createElement(z,null,"Claude may use instructions, code, or files from this Skill."),lM.default.createElement(j,{flexDirection:"column",paddingX:2,paddingY:1},lM.default.createElement(z,{dimColor:!0},I?.description)),lM.default.createElement(j,{flexDirection:"column"},lM.default.createElement(MH,{permissionResult:Q.permissionResult,toolType:"tool"}),lM.default.createElement(z,null,"Do you want to proceed?"),lM.default.createElement(S0,{options:K,onChange:V,onCancel:()=>V("no")})))}var lM;var p32=q(()=>{hA();G6();PU();Si();R8();u0();o2();xi();hh();n21();g1();lM=o(KA(),1)});function l32(A){let{toolUseConfirm:Q,onDone:B,onReject:G,verbose:Z}=A,J=((E)=>{let D=li.inputSchema.safeParse(E);if(!D.success)return r(Error(`Failed to parse slash command tool input: ${D.error.message}`)),"";return D.data.command})(Q.input),I=Q.permissionResult.behavior==="ask"&&Q.permissionResult.metadata&&"command"in Q.permissionResult.metadata?Q.permissionResult.metadata.command:void 0,X=iM.useMemo(()=>({completion_type:"tool_use_single",language_name:"none"}),[]);bU(Q,X);let W=cQ(),K=iM.useMemo(()=>{let E=[{label:"Yes",value:"yes"}],D={label:`Yes, and don't ask again for ${pA.bold(J)} in ${pA.bold(W)}`,value:"yes-exact"},H=J.indexOf(" "),F=[];if(H>0){let $=J.substring(0,H);F.push({label:`Yes, and don't ask again for ${pA.bold($+":*")} commands in ${pA.bold(W)}`,value:"yes-prefix"})}let C={label:`No, and tell Claude what to do differently ${pA.bold("(esc)")}`,value:"no"};return[...E,D,...F,C]},[J,W]),V=(E)=>{switch(E){case"yes":QJ({completion_type:"tool_use_single",event:"accept",metadata:{language_name:"none",message_id:Q.assistantMessage.message.id,platform:QQ.platform}}),Q.onAllow(Q.input,[]),B();break;case"yes-exact":{QJ({completion_type:"tool_use_single",event:"accept",metadata:{language_name:"none",message_id:Q.assistantMessage.message.id,platform:QQ.platform}}),Q.onAllow(Q.input,[{type:"addRules",rules:[{toolName:PT,ruleContent:J}],behavior:"allow",destination:"localSettings"}]),B();break}case"yes-prefix":{QJ({completion_type:"tool_use_single",event:"accept",metadata:{language_name:"none",message_id:Q.assistantMessage.message.id,platform:QQ.platform}});let D=J.indexOf(" "),H=D>0?J.substring(0,D):J;Q.onAllow(Q.input,[{type:"addRules",rules:[{toolName:PT,ruleContent:`${H}:*`}],behavior:"allow",destination:"localSettings"}]),B();break}case"no":QJ({completion_type:"tool_use_single",event:"reject",metadata:{language_name:"none",message_id:Q.assistantMessage.message.id,platform:QQ.platform}}),Q.onReject(),G(),B();break}};return iM.default.createElement(fZ,{title:PT},iM.default.createElement(j,{flexDirection:"column",paddingX:2,paddingY:1},iM.default.createElement(z,null,J),iM.default.createElement(z,{dimColor:!0},I?.description)),iM.default.createElement(j,{flexDirection:"column"},iM.default.createElement(MH,{permissionResult:Q.permissionResult,toolType:"tool"}),iM.default.createElement(z,null,"Do you want to proceed?"),iM.default.createElement(S0,{options:K,onChange:V,onCancel:()=>V("no")})))}var iM;var i32=q(()=>{hA();G6();PU();Si();R8();u0();o2();xi();hh();o21();g1();iM=o(KA(),1)});function HN8({answers:A}){return yJ.createElement(j,{flexDirection:"column",marginTop:1},yJ.createElement(j,{flexDirection:"row"},yJ.createElement(z,{color:zS("default")},YX,"¬†"),yJ.createElement(z,null,"User answered Claude's questions:")),yJ.createElement(h0,null,yJ.createElement(j,{flexDirection:"column"},Object.entries(A).map(([Q,B])=>yJ.createElement(z,{key:Q,color:"inactive"},"¬∑ ",Q," ‚Üí ",B)))))}var yJ,DN8,n32,Z90,GhG,r21;var s21=q(()=>{C2();hA();g4();nx();Mw();u0();sQ();yJ=o(KA(),1),DN8=P.object({label:P.string().describe("The display text for this option that the user will see and select. Should be concise (1-5 words) and clearly describe the choice."),description:P.string().describe("Explanation of what this option means or what will happen if chosen. Useful for providing context about trade-offs or implications.")}),n32=P.object({question:P.string().describe('The complete question to ask the user. Should be clear, specific, and end with a question mark. Example: "Which library should we use for date formatting?" If multiSelect is true, phrase it accordingly, e.g. "Which features do you want to enable?"'),header:P.string().describe(`Very short label displayed as a chip/tag (max ${r42} chars). Examples: "Auth method", "Library", "Approach".`),options:P.array(DN8).min(2).max(4).describe("The available choices for this question. Must have 2-4 options. Each option should be a distinct, mutually exclusive choice (unless multiSelect is enabled). There should be no 'Other' option, that will be provided automatically."),multiSelect:P.boolean().describe("Set to true to allow the user to select multiple options instead of just one. Use when choices are not mutually exclusive.")}),Z90=P.strictObject({questions:P.array(n32).min(1).max(4).describe("Questions to ask the user (1-4 questions)"),answers:P.record(P.string(),P.string()).optional().describe("User answers collected by the permission component")}).refine((A)=>{let Q=A.questions.map((B)=>B.question);if(Q.length!==new Set(Q).size)return!1;for(let B of A.questions){let G=B.options.map((Z)=>Z.label);if(G.length!==new Set(G).size)return!1}return!0},{message:"Question texts must be unique, option labels must be unique within each question"}),GhG=P.object({questions:P.array(n32).describe("The questions that were asked"),answers:P.record(P.string(),P.string()).describe("The answers provided by the user (question text -> answer string; multi-select answers are comma-separated)")});r21={name:CI,async description(){return s42},async prompt(){return t42},inputSchema:Z90,userFacingName(){return""},isEnabled(){return PBA()||C0(process.env.CLAUDE_CODE_ENABLE_ASK_USER_QUESTION_TOOL)},isConcurrencySafe(){return!0},isReadOnly(){return!0},requiresUserInteraction(){return!0},async checkPermissions(A){return{behavior:"ask",message:"Answer questions?",updatedInput:A}},renderToolUseMessage(){return null},renderToolUseProgressMessage(){return null},renderToolResultMessage({answers:A},Q){return yJ.createElement(HN8,{answers:A})},renderToolUseRejectedMessage(){return yJ.createElement(j,{flexDirection:"row",marginTop:1},yJ.createElement(z,{color:zS("default")},YX,"¬†"),yJ.createElement(z,null,"User declined to answer questions"))},renderToolUseErrorMessage(){return null},async call({questions:A,answers:Q={}},B){return{data:{questions:A,answers:Q}}},mapToolResultToToolResultBlockParam({answers:A},Q){return{type:"tool_result",content:`User has answered your questions: ${Object.entries(A).map(([G,Z])=>`"${G}"="${Z}"`).join(", ")}. You can now continue with the user's answers in mind.`,tool_use_id:Q}}}});function FN8(A,Q){switch(Q.type){case"next-question":return{...A,currentQuestionIndex:A.currentQuestionIndex+1,isInTextInput:!1};case"prev-question":return{...A,currentQuestionIndex:Math.max(0,A.currentQuestionIndex-1),isInTextInput:!1};case"update-question-state":{let B=A.questionStates[Q.questionText],G={selectedValue:Q.updates.selectedValue??B?.selectedValue??(Q.isMultiSelect?[]:void 0),textInputValue:Q.updates.textInputValue??B?.textInputValue??""};return{...A,questionStates:{...A.questionStates,[Q.questionText]:G}}}case"set-answer":{let B={...A,answers:{...A.answers,[Q.questionText]:Q.answer}};if(Q.shouldAdvance)return{...B,currentQuestionIndex:B.currentQuestionIndex+1,isInTextInput:!1};return B}case"set-text-input-mode":return{...A,isInTextInput:Q.isInInput}}}function a32(){let[A,Q]=ii.useReducer(FN8,CN8),B=ii.useCallback(()=>{Q({type:"next-question"})},[]),G=ii.useCallback(()=>{Q({type:"prev-question"})},[]),Z=ii.useCallback((I,X,W)=>{Q({type:"update-question-state",questionText:I,updates:X,isMultiSelect:W})},[]),Y=ii.useCallback((I,X,W=!0)=>{Q({type:"set-answer",questionText:I,answer:X,shouldAdvance:W})},[]),J=ii.useCallback((I)=>{Q({type:"set-text-input-mode",isInInput:I})},[]);return{currentQuestionIndex:A.currentQuestionIndex,answers:A.answers,questionStates:A.questionStates,isInTextInput:A.isInTextInput,nextQuestion:B,prevQuestion:G,updateQuestionState:Z,setAnswer:Y,setTextInputMode:J}}var ii,CN8;var o32=q(()=>{ii=o(KA(),1);CN8={currentQuestionIndex:0,answers:{},questionStates:{},isInTextInput:!1}});function t21({questions:A,currentQuestionIndex:Q,answers:B,hideSubmitTab:G=!1}){let{columns:Z}=SB(),Y=nM.useMemo(()=>{let W=G?"":` ${X1.tick} Submit `,K=2,V=2,E=qG("‚Üê ")+qG(" ‚Üí")+qG(W),D=Z-E;if(D<=0)return A.map((b,v)=>{let m=b?.header||`Q${v+1}`;return v===Q?m.slice(0,3):""});let H=A.map((b,v)=>b?.header||`Q${v+1}`);if(H.map((b)=>4+qG(b)).reduce((b,v)=>b+v,0)<=D)return H;let $=H[Q]||"",O=4+qG($),M=6,L=Math.min(O,D/2),_=D-L,T=A.length-1,x=Math.max(M,Math.floor(_/Math.max(T,1)));return H.map((b,v)=>{if(v===Q){let m=L-2-2;if(qG(b)<=m)return b;let u=b;while(qG(u+"‚Ä¶")>m&&u.length>1)u=u.slice(0,-1);return u+"‚Ä¶"}else{let m=x-2-2;if(qG(b)<=m)return b;let u=b;while(qG(u+"‚Ä¶")>m&&u.length>1)u=u.slice(0,-1);return u.length>0?u+"‚Ä¶":b[0]+"‚Ä¶"}})},[A,Q,Z,G]),J=A.length===1&&G;return nM.default.createElement(j,{flexDirection:"row",marginBottom:1},!J&&nM.default.createElement(z,{color:Q===0?"inactive":void 0},"‚Üê"," "),A.map((I,X)=>{let W=X===Q,V=I?.question&&!!B[I.question]?X1.checkboxOn:X1.checkboxOff,E=Y[X]||I?.header||`Q${X+1}`;return nM.default.createElement(j,{key:I?.question||`question-${X}`},W?nM.default.createElement(z,{backgroundColor:"permission",color:"inverseText"}," ",V," ",E," "):nM.default.createElement(z,null," ",V," ",E," "))}),!G&&nM.default.createElement(j,{key:"submit"},Q===A.length?nM.default.createElement(z,{backgroundColor:"permission",color:"inverseText"}," ",X1.tick," Submit"," "):nM.default.createElement(z,null," ",X1.tick," Submit ")),!J&&nM.default.createElement(z,{color:Q===A.length?"inactive":void 0}," ","‚Üí"))}var nM;var Y90=q(()=>{v2();hA();y3();$s();nM=o(KA(),1)});function r32({question:A,questions:Q,currentQuestionIndex:B,answers:G,questionStates:Z,hideSubmitTab:Y=!1,onUpdateQuestionState:J,onAnswer:I,onTextInputFocus:X,onCancel:W,onSubmit:K}){let V=CN.useCallback(($)=>{X($==="__other__")},[X]),E=A.options.map(($)=>({type:"text",value:$.label,label:$.label,description:$.description})),D=A.question,H=Z[D],F={type:"input",value:"__other__",label:"Other",placeholder:A.multiSelect?"Type something":"Type something.",initialValue:H?.textInputValue??"",onChange:($)=>{J(D,{textInputValue:$},A.multiSelect??!1)}},C=[...E,F];return CN.default.createElement(j,{flexDirection:"column",marginTop:1},CN.default.createElement(a8,{dividerColor:"inactive"}),CN.default.createElement(j,{flexDirection:"column",paddingTop:0},CN.default.createElement(t21,{questions:Q,currentQuestionIndex:B,answers:G,hideSubmitTab:Y}),CN.default.createElement(qYA,{title:A.question,color:"text"}),CN.default.createElement(j,{marginTop:1},A.multiSelect?CN.default.createElement(sa1,{key:A.question,options:C,defaultValue:Z[A.question]?.selectedValue,onChange:($)=>{J(D,{selectedValue:$},!0);let O=$.includes("__other__")?Z[D]?.textInputValue:void 0,M=$.filter((L)=>L!=="__other__").concat(O?[O]:[]);I(D,M,void 0,!1)},onFocus:V,onCancel:W,submitButtonText:B===Q.length-1?"Submit":"Next",onSubmit:K}):CN.default.createElement(S0,{key:A.question,options:C,defaultValue:Z[A.question]?.selectedValue,onChange:($)=>{J(D,{selectedValue:$},!1);let O=$==="__other__"?Z[D]?.textInputValue:void 0;I(D,$,O)},onFocus:V,onCancel:W,layout:"compact-vertical"})),CN.default.createElement(j,{marginTop:1},CN.default.createElement(z,{color:"inactive",dimColor:!0},"Enter to select ¬∑ Tab/Arrow keys to navigate ¬∑ Esc to cancel"))))}var CN;var s32=q(()=>{hA();G6();T01();Y90();AK();CN=o(KA(),1)});function t32({questions:A,currentQuestionIndex:Q,answers:B,allQuestionsAnswered:G,permissionResult:Z,onFinalResponse:Y}){return hV.default.createElement(j,{flexDirection:"column",marginTop:1},hV.default.createElement(a8,{dividerColor:"inactive"}),hV.default.createElement(j,{flexDirection:"column",borderTop:!0,borderColor:"inactive",paddingTop:0},hV.default.createElement(t21,{questions:A,currentQuestionIndex:Q,answers:B}),hV.default.createElement(qYA,{title:"Review your answers",color:"text"}),hV.default.createElement(j,{flexDirection:"column",marginTop:1},!G&&hV.default.createElement(j,{marginBottom:1},hV.default.createElement(z,{color:"warning"},X1.warning," You have not answered all questions")),Object.keys(B).length>0&&hV.default.createElement(j,{flexDirection:"column",marginBottom:1},A.filter((J)=>J?.question&&B[J.question]).map((J)=>{let I=B[J?.question];return hV.default.createElement(j,{key:J?.question||"answer",flexDirection:"column",marginLeft:1},hV.default.createElement(z,null,X1.bullet," ",J?.question||"Question"),hV.default.createElement(j,{marginLeft:2},hV.default.createElement(z,{color:"success"},X1.arrowRight," ",I)))})),hV.default.createElement(MH,{permissionResult:Z,toolType:"tool"}),hV.default.createElement(z,{color:"inactive"},"Ready to submit your answers?"),hV.default.createElement(j,{marginTop:1},hV.default.createElement(S0,{options:[{type:"text",label:"Submit answers",value:"submit"},{type:"text",label:"Cancel",value:"cancel"}],onChange:(J)=>Y(J),onCancel:()=>Y("cancel")})))))}var hV;var e32=q(()=>{v2();hA();G6();T01();hh();Y90();AK();hV=o(KA(),1)});function A62({toolUseConfirm:A,onDone:Q,onReject:B}){let G=Z90.safeParse(A.input),Z=G.success?G.data.questions||[]:[],Y=a32(),{currentQuestionIndex:J,answers:I,questionStates:X,isInTextInput:W,nextQuestion:K,prevQuestion:V,updateQuestionState:E,setAnswer:D,setTextInputMode:H}=Y,F=J<(Z?.length||0)?Z?.[J]:null,C=J===(Z?.length||0),$=Z?.every((x)=>x?.question&&!!I[x.question])??!1,O=Z.length===1&&!Z[0]?.multiSelect,M=o1A.useCallback(()=>{Q(),B(),A.onReject()},[Q,B,A]),L=o1A.useCallback((x)=>{let b={...A.input,answers:x};Q(),A.onAllow(b,[])},[A,Q]),_=o1A.useCallback((x,b,v,m=!0)=>{let u,e=Array.isArray(b);if(e)u=b.join(", ");else u=v||b;let p=Z.length===1;if(!e&&p&&m){let k={...I,[x]:u};L(k);return}D(x,u,m)},[D,Z.length,I,L]);function T(x){if(x==="cancel"){M();return}if(x==="submit")L(I)}if(f1((x,b)=>{if(W&&!C)return;if(b.return)return;if((b.leftArrow||b.shift&&b.tab)&&J>0)V();let v=O?(Z?.length||1)-1:Z?.length||0;if((b.rightArrow||b.tab&&!b.shift)&&J<v)K()}),F)return o1A.default.createElement(r32,{question:F,questions:Z,currentQuestionIndex:J,answers:I,questionStates:X,hideSubmitTab:O,onUpdateQuestionState:E,onAnswer:_,onTextInputFocus:H,onCancel:M,onSubmit:K});if(C)return o1A.default.createElement(t32,{questions:Z,currentQuestionIndex:J,answers:I,allQuestionsAnswered:$,permissionResult:A.permissionResult,onFinalResponse:T});return null}var o1A;var Q62=q(()=>{hA();s21();o32();s32();e32();o1A=o(KA(),1)});function zN8(A){switch(A){case AD:return YQ2;case JW:return JB2;case M9:return BB2;case JK:return p42;case zT:return a42;case HN:return D32;case POA:return L32;case pi:return c32;case li:return l32;case r21:return A62;case UM:case Ux:case H6:return XB2;default:return tB1}}function UN8(A){let Q=A.tool.userFacingName(A.input);if(A.tool===HN)return"Claude Code needs your approval for the plan";if(A.tool===POA)return"Claude Code wants to enter plan mode";if(!Q||Q.trim()==="")return"Claude Code needs your attention";return`Claude needs your permission to use ${Q}`}function B62({toolUseConfirm:A,toolUseContext:Q,onDone:B,onReject:G,verbose:Z,workerBadge:Y}){f1((X,W)=>{if(W.ctrl&&X==="c")B(),G(),A.onReject()});let J=UN8(A);WJA(J,"permission_prompt");let I=zN8(A.tool);return J90.createElement(I,{toolUseContext:Q,toolUseConfirm:A,onDone:B,onReject:G,verbose:Z,workerBadge:Y})}var J90;var G62=q(()=>{hA();Vi();rb();xV();JQ2();GB2();OB0();xB1();IB2();WB2();pYA();GqA();QqA();bw();SJA();l42();o42();jOA();H32();Q90();M32();n21();o21();p32();i32();s21();Q62();J90=o(KA(),1)});function wN8(A){if(yOA(A))return P.enum(A.enum);if(A.type==="string"){let Q=P.string();if(A.minLength!==void 0)Q=Q.min(A.minLength,{message:`Must be at least ${A.minLength} character${A.minLength===1?"":"s"}`});if(A.maxLength!==void 0)Q=Q.max(A.maxLength,{message:`Must be at most ${A.maxLength} character${A.maxLength===1?"":"s"}`});switch(A.format){case"email":Q=Q.email({message:"Please enter a valid email address"});break;case"uri":Q=Q.url({message:"Please enter a valid URI"});break;case"date":Q=Q.date("Please enter a valid date (YYYY-MM-DD)");break;case"date-time":Q=Q.datetime({offset:!0,message:"Please enter a valid date-time (YYYY-MM-DDTHH:MM:SSZ)"});break;default:break}return Q}if(A.type==="number"||A.type==="integer"){let Q=P.coerce.number();if(A.type==="integer")Q=Q.int();if(A.minimum!==void 0)Q=Q.min(A.minimum,{message:`Must be at least ${A.minimum}`});if(A.maximum!==void 0)Q=Q.max(A.maximum,{message:`Must be at most ${A.maximum}`});return Q}if(A.type==="boolean")return P.coerce.boolean();throw Error(`Unsupported schema: ${JSON.stringify(A)}`)}function I90(A,Q){let G=wN8(Q).safeParse(A);if(G.success)return{value:G.data,isValid:!0};return{isValid:!1,error:G.error.errors.map((Z)=>Z.message).join("; ")}}function Z62(A){if(A.type==="string"){if(!NN8(A))return;let{description:Q,example:B}=$N8[A.format]||{};return`${Q}, e.g. ${B}`}if(A.type==="number"||A.type==="integer"){let Q=A.type==="integer",B=(G)=>Number.isInteger(G)&&!Q?`${G}.0`:String(G);if(A.minimum!==void 0&&A.maximum!==void 0)return`(${A.type} between ${B(A.minimum)} and ${B(A.maximum)})`;else if(A.minimum!==void 0)return`(${A.type} >= ${B(A.minimum)})`;else if(A.maximum!==void 0)return`(${A.type} <= ${B(A.maximum)})`;else{let G=A.type==="integer"?"42":"3.14";return`(${A.type}, e.g. ${G})`}}return}var $N8,yOA=(A)=>{return A.type==="string"&&"enum"in A},NN8=(A)=>{return A.type==="string"&&"format"in A&&typeof A.format==="string"};var Y62=q(()=>{C2();$N8={email:{description:"email address",example:"user@example.com"},uri:{description:"URI",example:"https://example.com"},date:{description:"date",example:"2024-03-15"},"date-time":{description:"date-time",example:"2024-03-15T14:30:00Z"}}});function e21(){return C9.default.createElement(z,{italic:!0,dimColor:!0},"<unset>")}function I62({serverName:A,request:Q,onResponse:B,signal:G}){let{message:Z,requestedSchema:Y}=Q,[J,I]=C9.useState(null),[X,W]=C9.useState(()=>{let OA={};if(Y.properties){for(let[IA,PA]of Object.entries(Y.properties))if(typeof PA==="object"&&PA!==null){if(PA.default!==void 0)OA[IA]=PA.default}}return OA}),[K,V]=C9.useState(()=>{let OA={};for(let[IA,PA]of Object.entries(Y.properties))if(J62(PA)&&PA?.default!==void 0){let kA=I90(String(PA.default),PA);if(!kA.isValid&&kA.error)OA[IA]=kA.error}return OA});C9.useEffect(()=>{if(!G)return;let OA=()=>{B("cancel")};if(G.aborted){OA();return}return G.addEventListener("abort",OA),()=>{G.removeEventListener("abort",OA)}},[G,B]);let E=C9.useMemo(()=>{let OA=Y.required??[];return Object.entries(Y.properties).map(([IA,PA])=>({name:IA,schema:PA,isRequired:OA.includes(IA)}))},[Y]),[D,H]=C9.useState(0),[F,C]=C9.useState(),[$,O]=C9.useState(""),[M,L]=C9.useState(0),{columns:_}=SB(),T=D!==void 0?E[D]:void 0,x=T&&J62(T.schema);jQ(),WJA("Claude Code needs your input","elicitation_dialog");function b(OA){let IA=E.length+2,PA=D??(J==="accept"?E.length:J==="decline"?E.length+1:void 0),kA=PA!==void 0?(PA+(OA==="up"?IA-1:1))%IA:0;if(kA<E.length)H(kA),I(null);else H(void 0),I(kA===E.length?"accept":"decline")}function v(OA,IA){W((PA)=>{let kA={...PA};if(IA===void 0)delete kA[OA];else kA[OA]=IA;return kA})}function m(OA,IA){V((PA)=>{let kA={...PA};if(IA)kA[OA]=IA;else delete kA[OA];return kA})}function u(OA){if(!OA)return;v(OA,void 0),m(OA),C(void 0),O(""),L(0)}function e(OA){if(!T)return;if(OA.trim()===""&&(T.schema.type!=="string"||("format"in T.schema)&&T.schema.format!==void 0)){u(T.name),b("down");return}let PA=I90(OA,T.schema);v(T.name,PA.isValid?PA.value:OA),m(T.name,PA.isValid?void 0:PA.error),C(void 0),O(""),L(0),b("down")}function p(){if(!T)return;C(void 0),O(""),L(0)}f1((OA,IA)=>{if(T&&F===T.name){if(yOA(T?.schema))return;if(x){if(IA.escape&&$===""){p();return}}}else{if(IA.escape){B("cancel");return}if(IA.return&&J==="accept"){if(k()&&Object.keys(K).length===0)B("accept",X);return}if(IA.return&&J==="decline"){B("decline");return}if(IA.upArrow||IA.downArrow){b(IA.upArrow?"up":"down");return}if(T){let{schema:PA,name:kA,isRequired:YA}=T,ZA=X[kA];if(IA.backspace&&!YA){u(T.name);return}if(IA.return){if(PA.type==="boolean"){v(kA,!(ZA??!1)),b("down");return}if(C(kA),x){let zA=ZA!==void 0?String(ZA):"";O(zA),L(zA.length)}}}}},{isActive:!0});let k=()=>{let OA=Y.required||[];for(let IA of OA){let PA=X[IA];if(PA===void 0||PA===null||PA==="")return!1}return!0},c=()=>{if(!E.length)return null;return C9.default.createElement(j,{flexDirection:"column",gap:1},E.map((OA,IA)=>{let{name:PA,schema:kA,isRequired:YA}=OA,ZA=IA===D&&!J,zA=X[PA],bA=(()=>{if(!ZA||F!==void 0)return null;let B1=kA.type==="boolean"?"toggle":yOA(kA)?"select":"edit",JA=zA===void 0||YA?`(Press Enter to ${B1})`:`(Press Enter to ${B1}, Backspace to unset)`;return C9.default.createElement(z,{dimColor:!0}," ",JA)})(),TA=(B1,JA)=>{return C9.default.createElement(j,{key:PA,flexDirection:"column"},C9.default.createElement(j,{gap:1,paddingLeft:ZA?0:2},ZA&&C9.default.createElement(z,{color:"success"},X1.pointer),C9.default.createElement(j,{flexGrow:1,flexDirection:"column"},B1,kA.description&&C9.default.createElement(j,{marginLeft:2},C9.default.createElement(z,{dimColor:!0},kA.description)),JA&&C9.default.createElement(j,{marginLeft:2},C9.default.createElement(z,{color:"error",bold:!0},X1.warning," ",JA)))))};if(yOA(kA)){let B1=kA.enum.map((JA,CA)=>({label:kA.enumNames?.[CA]??JA,value:JA}));if(ZA&&F===PA)return C9.default.createElement(j,{key:PA,flexDirection:"column"},C9.default.createElement(z,{color:"success"},kA.title||PA,YA&&C9.default.createElement(z,{color:"error"},"*"),kA.description&&C9.default.createElement(z,{dimColor:!0}," - ",kA.description)),C9.default.createElement(S0,{options:B1,defaultValue:zA!==void 0?zA:kA.default??kA.enum[0],onChange:(JA)=>{v(PA,JA),C(void 0),b("down")},onCancel:()=>{C(void 0)}}));else{let JA=kA.enum.findIndex((MA)=>MA===zA),CA=zA!==void 0?JA>=0&&kA.enumNames?.[JA]?kA.enumNames[JA]:zA:C9.default.createElement(e21,null);return TA(C9.default.createElement(z,{color:ZA?"success":void 0},kA.title||PA,YA&&C9.default.createElement(z,{color:"error"},"*"),": ",CA,bA))}}else if(kA.type==="boolean")return TA(C9.default.createElement(z,{color:ZA?"success":void 0},kA.title||PA,YA&&C9.default.createElement(z,{color:"error"},"*"),":"," ",zA!==void 0?zA?`${X1.tick} Yes`:`${X1.cross} No`:C9.default.createElement(e21,null),bA));else if(x){let B1=K[PA],JA=Z62(kA);if(ZA&&F===PA)return TA(C9.default.createElement(j,{flexDirection:"column"},C9.default.createElement(z,{color:"success"},kA.title||PA,YA&&C9.default.createElement(z,{color:"error"},"*"),":",JA&&C9.default.createElement(z,{dimColor:!0},` ${JA}`)),C9.default.createElement(j,{marginLeft:2},C9.default.createElement(G3,{value:$,onChange:O,onSubmit:e,onExit:p,placeholder:`Enter ${kA.type}‚Ä¶`,columns:Math.min(_-6,80),cursorOffset:M,onChangeCursorOffset:L,focus:!0,showCursor:!0,multiline:kA.type==="string"}))));return TA(C9.default.createElement(z,{color:ZA?"success":void 0},kA.title||PA,YA&&C9.default.createElement(z,{color:"error"},"*"),":"," ",zA===void 0?C9.default.createElement(e21,null):String(zA),bA),B1)}else return TA(C9.default.createElement(z,{color:ZA?"success":void 0},kA.title||PA,YA&&C9.default.createElement(z,{color:"error"},"*"),":"," ",zA===void 0?C9.default.createElement(e21,null):String(zA),bA))}))},t=(OA)=>{return Y.properties[OA]?.title??OA},AA=Object.keys(K),VA=(Y.required||[]).filter((OA)=>X[OA]===void 0);return C9.default.createElement(j,{flexDirection:"column",gap:1,padding:1,borderStyle:"round",borderColor:"permission"},C9.default.createElement(z,{bold:!0},X1.info," MCP Server ‚Äú",A,"‚Äù requests your input"),C9.default.createElement(j,{padding:1},C9.default.createElement(z,null,Z)),c(),E.length>0&&C9.default.createElement(C9.default.Fragment,null,VA.length>0&&C9.default.createElement(z,{color:"error"},X1.warning," Missing required fields:"," ",VA.map(t).join(", ")),AA.length>0&&C9.default.createElement(z,{color:"error"},X1.warning," Validation errors in:"," ",AA.map(t).join(", ")),C9.default.createElement(z,{bold:!0,color:J==="accept"?"success":void 0,inverse:J==="accept"},"Accept"),C9.default.createElement(z,{bold:!0,color:J==="decline"?"error":void 0,inverse:J==="decline"},"Decline"),C9.default.createElement(z,{dimColor:!0},"Press ‚Üë‚Üì to navigate ¬∑ Enter to edit ¬∑ Esc to cancel / go back")))}var C9,J62=(A)=>["string","number","integer"].includes(A.type);var X62=q(()=>{hA();v2();o9();xB1();K8();Y62();lY();y3();C9=o(KA(),1)});function yJA(A){let[Q,B]=A91.useState(!1);return A91.useEffect(()=>{B(!1);let G=setTimeout(()=>{B(!0)},A);return()=>clearTimeout(G)},[A]),Q}var A91;var Q91=q(()=>{A91=o(KA(),1)});import{homedir as B91}from"os";import{join as G91}from"path";function Z91(){return process.env.XDG_STATE_HOME??G91(B91(),".local","state")}function W62(){return process.env.XDG_CACHE_HOME??G91(B91(),".cache")}function K62(){return process.env.XDG_DATA_HOME??G91(B91(),".local","share")}function V62(){return G91(B91(),".local","bin")}var X90=()=>{};import{homedir as Y91}from"os";import{join as W90}from"path";function ni(){let A=process.env.ZDOTDIR||Y91();return{zsh:W90(A,".zshrc"),bash:W90(Y91(),".bashrc"),fish:W90(Y91(),".config/fish/config.fish")}}function J91(A){let Q=!1;return{filtered:A.filter((G)=>{if(E62.test(G)){let Z=G.match(/alias\s+claude\s*=\s*["']([^"']+)["']/);if(!Z)Z=G.match(/alias\s+claude\s*=\s*([^#\n]+)/);if(Z&&Z[1]){if(Z[1].trim()===VCQ)return Q=!0,!1}}return!0}),hadAlias:Q}}function vOA(A){let Q=jA();try{if(!Q.existsSync(A))return null;return Q.readFileSync(A,{encoding:"utf8"}).split(`
2666:`);if(B(F)){let $=new Set(V.map((O)=>O.id));Z((O)=>({...O,inbox:{messages:O.inbox.messages.filter((M)=>!$.has(M.id))}}))}else f("[InboxPoller] Submission rejected, keeping messages queued")},[A,Q,B,Z,G,I]);let X=!!o61(G);X7(J,X?$85:null),c0A.useEffect(()=>{if(o61(G))J()},[J,G])}var c0A,$85=1000;var xN2=q(()=>{jV();jh();Q0();f2();c0A=o(KA(),1)});function vN2({autoConnectIdeFlag:A,ideToInstallExtension:Q,setDynamicMcpConfig:B,setShowIdeOnboarding:G,setIDEInstallationState:Z}){yN2.useEffect(()=>{function Y(J){if(!J)return;if(!((c1().autoConnectIde||A||BW()||Q||C0(process.env.CLAUDE_CODE_AUTO_CONNECT_IDE))&&!Iz(process.env.CLAUDE_CODE_AUTO_CONNECT_IDE)))return;B((W)=>{if(W?.ide)return W;return{...W,ide:{type:J.url.startsWith("ws:")?"ws-ide":"sse-ide",url:J.url,ideName:J.name,authToken:J.authToken,ideRunningInWindows:J.ideRunningInWindows,scope:"dynamic"}}})}uEB(Y,Q,()=>G(!0),(J)=>Z(J))},[A,Q,B,G,Z])}var yN2;var kN2=q(()=>{vQ();RJ();sQ();yN2=o(KA(),1)});var p_A=q(()=>{Q3();pB();YQ();aI();Q0();vQ()});var m50;var fN2=q(()=>{hA();K8();p_A();kG();xy();Q3();_0();Ox();m50=o(KA(),1)});var e7Z;var bN2=q(()=>{fN2();pY();e7Z=o(KA(),1)});function q85(){return Gs(N85)??"Goodbye!"}var w85,N85,L85,r61;var d50=q(()=>{luA();pY();p_A();bN2();w85=o(KA(),1),N85=["Goodbye!","See ya!","Bye!","Catch you later!"];L85={type:"local-jsx",name:"exit",aliases:["quit"],description:"Exit the REPL",isEnabled:()=>!0,isHidden:!1,async call(A){return A(q85()),await E6(0,"prompt_input_exit"),null},userFacingName(){return"exit"}},r61=L85});function hN2(){let[A,Q]=dT.useState(nD.getInstance().getStatus());if(dT.useEffect(()=>{return nD.getInstance().subscribe(Q)},[]),!A.isAuthenticating&&!A.error&&A.output.length===0)return null;if(!A.isAuthenticating&&!A.error)return null;return dT.default.createElement(j,{flexDirection:"column",borderStyle:"round",borderColor:"permission",paddingX:1,marginY:1},dT.default.createElement(z,{bold:!0,color:"permission"},"AWS Authentication"),A.output.length>0&&dT.default.createElement(j,{flexDirection:"column",marginTop:1},A.output.slice(-5).map((B,G)=>dT.default.createElement(z,{key:G,dimColor:!0},B))),A.error&&dT.default.createElement(j,{marginTop:1},dT.default.createElement(z,{color:"error"},A.error)))}var dT;var gN2=q(()=>{hA();dT=o(KA(),1)});import{randomUUID as uN2}from"crypto";function s61({hideThanksAfterMs:A,onOpen:Q,onSelect:B}){let[G,Z]=Nn.useState("closed"),Y=Nn.useRef(uN2()),J=Nn.useCallback(()=>{Z("thanks"),setTimeout(()=>Z("closed"),A)},[A]),I=Nn.useCallback(()=>{if(G!=="closed")return;Z("open"),Y.current=uN2(),Q(Y.current)},[G,Q]),X=Nn.useCallback((W)=>{if(W==="dismissed")Z("closed");else J();B(Y.current,W)},[J,B]);return{state:G,open:I,handleSelect:X}}var Nn;var c50=q(()=>{Nn=o(KA(),1)});function mN2(A,Q,B,G="session"){let Z=Y$.useRef("unknown");Z.current=cIA(A)?.message?.id||"unknown";let[Y,J]=RQ(),I=k01("tengu_feedback_survey_config",M85),X=Y$.useRef(Date.now()),W=Y$.useRef(B),K=Y$.useRef(B);K.current=B;let V=Y$.useCallback((L,_)=>{J((T)=>({...T,feedbackSurvey:{timeLastShown:L,submitCountAtLastAppearance:_}}))},[J]),E=Y$.useCallback((L)=>{V(Date.now(),K.current),s("tengu_feedback_survey_event",{event_type:"appeared",appearance_id:L,last_assistant_message_id:Z.current,survey_type:G})},[V,G]),D=Y$.useCallback((L,_)=>{V(Date.now(),K.current),s("tengu_feedback_survey_event",{event_type:"responded",appearance_id:L,response:_,last_assistant_message_id:Z.current,survey_type:G})},[V,G]),{state:H,open:F,handleSelect:C}=s61({hideThanksAfterMs:I.hideThanksAfterMs,onOpen:E,onSelect:D}),$=c8(),O=Y$.useMemo(()=>{if(I.onForModels.length===0)return!1;if(I.onForModels.includes("*"))return!0;return I.onForModels.includes($)},[I.onForModels,$]),M=Y$.useMemo(()=>{if(H!=="closed")return!1;if(Q)return!1;if(process.env.CLAUDE_FORCE_DISPLAY_SURVEY&&!Y.feedbackSurvey.timeLastShown)return!0;if(!O)return!1;if(C0(process.env.CLAUDE_CODE_DISABLE_FEEDBACK_SURVEY))return!1;if(iX())return!1;if(Y.feedbackSurvey.timeLastShown){if(Y.feedbackSurvey.submitCountAtLastAppearance!==null&&B<Y.feedbackSurvey.submitCountAtLastAppearance+I.minUserTurnsBetweenFeedback)return!1}else{if(Date.now()-X.current<I.minTimeBeforeFeedbackMs)return!1;if(B<W.current+I.minUserTurnsBeforeFeedback)return!1}if(Math.random()>I.probability)return!1;let L=c1().feedbackSurveyState;if(L?.lastShownTime){if(Date.now()-L.lastShownTime<I.minTimeBetweenGlobalFeedbackMs)return!1}return!0},[H,Q,O,Y.feedbackSurvey.timeLastShown,Y.feedbackSurvey.submitCountAtLastAppearance,B,I.minTimeBetweenGlobalFeedbackMs,I.minUserTurnsBetweenFeedback,I.minTimeBeforeFeedbackMs,I.minUserTurnsBeforeFeedback,I.probability]);return Y$.useEffect(()=>{if(M)F()},[M,F]),{state:H,handleSelect:C}}var Y$,M85;var dN2=q(()=>{w4();_0();br();vQ();d2();sQ();f2();KB();c50();Y$=o(KA(),1),M85={minTimeBeforeFeedbackMs:600000,minTimeBetweenGlobalFeedbackMs:1e8,minUserTurnsBeforeFeedback:5,minUserTurnsBetweenFeedback:10,hideThanksAfterMs:3000,onForModels:["*"],probability:0.005}});function T85(A,Q){let B=A.findIndex((G)=>G.uuid===Q);if(B===-1)return!1;for(let G=B+1;G<A.length;G++){let Z=A[G];if(Z&&(Z.type==="user"||Z.type==="assistant"))return!0}return!1}function cN2(A,Q){let[B,G]=xN.useState(null),Z=xN.useRef(new Set),Y=xN.useRef(null),J=xN.useCallback(async(E)=>{let D=await LQ1();s("tengu_post_compact_survey_event",{event_type:"appeared",appearance_id:E,session_memory_compaction_enabled:D})},[]),I=xN.useCallback(async(E,D)=>{let H=await LQ1();s("tengu_post_compact_survey_event",{event_type:"responded",appearance_id:E,response:D,session_memory_compaction_enabled:H})},[]),{state:X,open:W,handleSelect:K}=s61({hideThanksAfterMs:O85,onOpen:J,onSelect:I});xN.useEffect(()=>{JZ(R85).then(G)},[]);let V=xN.useMemo(()=>new Set(A.filter((E)=>lb(E)).map((E)=>E.uuid)),[A]);return xN.useEffect(()=>{if(X!=="closed"||Q)return;if(B!==!0)return;if(iX())return;if(C0(process.env.CLAUDE_CODE_DISABLE_FEEDBACK_SURVEY))return;if(Y.current!==null){if(T85(A,Y.current)){if(Y.current=null,Math.random()<_85)W();return}}let E=Array.from(V).filter((D)=>!Z.current.has(D));if(E.length>0)Z.current=new Set(V),Y.current=E[E.length-1]},[V,X,Q,B,A,W]),{state:X,handleSelect:K}}var xN,O85=3000,R85="tengu_post_compact_survey",_85=0.2;var pN2=q(()=>{w4();_0();br();sQ();KB();c50();OQ1();xN=o(KA(),1)});function lN2({onSelect:A,inputValue:Q,setInputValue:B,message:G=S85}){let Z=pV.useRef(Q);return pV.useEffect(()=>{if(Q!==Z.current){let Y=Q.slice(-1);if(p50(Y))B(Q.slice(0,-1)),A(P85[Y])}},[Q,A,B]),pV.default.createElement(j,{flexDirection:"column",marginTop:1},pV.default.createElement(j,null,pV.default.createElement(z,null,pA.cyan("‚óè ")),pV.default.createElement(z,{bold:!0},G)),pV.default.createElement(j,{marginLeft:2},pV.default.createElement(j,{width:10},pV.default.createElement(z,null,pA.cyan("1"),": Bad")),pV.default.createElement(j,{width:10},pV.default.createElement(z,null,pA.cyan("2"),": Fine")),pV.default.createElement(j,{width:10},pV.default.createElement(z,null,pA.cyan("3"),": Good")),pV.default.createElement(j,null,pV.default.createElement(z,null,pA.cyan("0"),": Dismiss"))))}var pV,j85,P85,p50=(A)=>j85.includes(A),S85="How is Claude doing this session? (optional)";var iN2=q(()=>{o2();hA();pV=o(KA(),1),j85=["0","1","2","3"],P85={"0":"dismissed","1":"bad","2":"fine","3":"good"}});function l50({state:A,handleSelect:Q,inputValue:B,setInputValue:G,message:Z}){if(A==="closed")return null;if(A==="thanks")return l_A.default.createElement(j,{marginTop:1,flexDirection:"column"},l_A.default.createElement(z,{color:"success"},"‚úì Thanks for helping make Claude better!"),l_A.default.createElement(z,{dimColor:!0},"Use ","/feedback"," to share detailed feedback or file a bug."));if(B&&!p50(B))return null;return l_A.default.createElement(lN2,{onSelect:Q,inputValue:B,setInputValue:G,message:Z})}var l_A;var nN2=q(()=>{hA();iN2();l_A=o(KA(),1)});function oN2(){let{addNotification:A}=fG();aN2.useEffect(()=>{Hy().then((Q)=>{Q.forEach((B,G)=>{let Z="low";if(B.type==="error"||B.userActionRequired)Z="high";else if(B.type==="path"||B.type==="alias")Z="medium";A({key:`install-message-${G}-${B.type}`,text:B.message,priority:Z,color:B.type==="error"?"error":"warning"})})})},[A])}var aN2;var rN2=q(()=>{TC();Fy();aN2=o(KA(),1)});var i50=()=>{};var sN2,t61;var n50=q(()=>{rd1();KV();sN2=o(HrA(),1);t61=class t61 extends qwA{constructor(A,Q){var B;super(Q);this._serverInfo=A,this._capabilities=(B=Q===null||Q===void 0?void 0:Q.capabilities)!==null&&B!==void 0?B:{},this._instructions=Q===null||Q===void 0?void 0:Q.instructions,this.setRequestHandler(bd1,(G)=>this._oninitialize(G)),this.setNotificationHandler(doA,()=>{var G;return(G=this.oninitialized)===null||G===void 0?void 0:G.call(this)})}registerCapabilities(A){if(this.transport)throw Error("Cannot register capabilities after connecting to transport");this._capabilities=ooA(this._capabilities,A)}assertCapabilityForMethod(A){var Q,B,G;switch(A){case"sampling/createMessage":if(!((Q=this._clientCapabilities)===null||Q===void 0?void 0:Q.sampling))throw Error(`Client does not support sampling (required for ${A})`);break;case"elicitation/create":if(!((B=this._clientCapabilities)===null||B===void 0?void 0:B.elicitation))throw Error(`Client does not support elicitation (required for ${A})`);break;case"roots/list":if(!((G=this._clientCapabilities)===null||G===void 0?void 0:G.roots))throw Error(`Client does not support listing roots (required for ${A})`);break;case"ping":break}}assertNotificationCapability(A){switch(A){case"notifications/message":if(!this._capabilities.logging)throw Error(`Server does not support logging (required for ${A})`);break;case"notifications/resources/updated":case"notifications/resources/list_changed":if(!this._capabilities.resources)throw Error(`Server does not support notifying about resources (required for ${A})`);break;case"notifications/tools/list_changed":if(!this._capabilities.tools)throw Error(`Server does not support notifying of tool list changes (required for ${A})`);break;case"notifications/prompts/list_changed":if(!this._capabilities.prompts)throw Error(`Server does not support notifying of prompt list changes (required for ${A})`);break;case"notifications/cancelled":break;case"notifications/progress":break}}assertRequestHandlerCapability(A){switch(A){case"sampling/createMessage":if(!this._capabilities.sampling)throw Error(`Server does not support sampling (required for ${A})`);break;case"logging/setLevel":if(!this._capabilities.logging)throw Error(`Server does not support logging (required for ${A})`);break;case"prompts/get":case"prompts/list":if(!this._capabilities.prompts)throw Error(`Server does not support prompts (required for ${A})`);break;case"resources/list":case"resources/templates/list":case"resources/read":if(!this._capabilities.resources)throw Error(`Server does not support resources (required for ${A})`);break;case"tools/call":case"tools/list":if(!this._capabilities.tools)throw Error(`Server does not support tools (required for ${A})`);break;case"ping":case"initialize":break}}async _oninitialize(A){let Q=A.params.protocolVersion;return this._clientCapabilities=A.params.capabilities,this._clientVersion=A.params.clientInfo,{protocolVersion:boA.includes(Q)?Q:jp,capabilities:this.getCapabilities(),serverInfo:this._serverInfo,...this._instructions&&{instructions:this._instructions}}}getClientCapabilities(){return this._clientCapabilities}getClientVersion(){return this._clientVersion}getCapabilities(){return this._capabilities}async ping(){return this.request({method:"ping"},Mb)}async createMessage(A,Q){return this.request({method:"sampling/createMessage",params:A},ld1,Q)}async elicitInput(A,Q){let B=await this.request({method:"elicitation/create",params:A},id1,Q);if(B.action==="accept"&&B.content)try{let G=new sN2.default,Z=G.compile(A.requestedSchema);if(!Z(B.content))throw new AC(eF.InvalidParams,`Elicitation response content does not match requested schema: ${G.errorsText(Z.errors)}`)}catch(G){if(G instanceof AC)throw G;throw new AC(eF.InternalError,`Error validating elicitation response: ${G}`)}return B}async listRoots(A,Q){return this.request({method:"roots/list",params:A},od1,Q)}async sendLoggingMessage(A){return this.notification({method:"notifications/message",params:A})}async sendResourceUpdated(A){return this.notification({method:"notifications/resources/updated",params:A})}async sendResourceListChanged(){return this.notification({method:"notifications/resources/list_changed"})}async sendToolListChanged(){return this.notification({method:"notifications/tools/list_changed"})}async sendPromptListChanged(){return this.notification({method:"notifications/prompts/list_changed"})}}});import{promises as x85}from"fs";import{platform as tN2,tmpdir as y85,userInfo as v85}from"os";import{join as k85}from"path";import{createConnection as f85}from"net";class b85{socket=null;connected=!1;connecting=!1;responseCallback=null;responseBuffer=Buffer.alloc(0);reconnectAttempts=0;maxReconnectAttempts=10;reconnectDelay=1000;reconnectTimer=null;context;constructor(A){this.context=A}async connect(){let{serverName:A,logger:Q}=this.context;if(this.connecting){Q.info(`[${A}] Already connecting, skipping duplicate attempt`);return}this.closeSocket(),this.connecting=!0;let B=this.getSecureSocketPath();Q.info(`[${A}] Attempting to connect to: ${B}`);try{await this.validateSocketSecurity(B)}catch(G){this.connecting=!1,Q.info(`[${A}] Security validation failed:`,G);return}this.socket=f85(B),this.socket.on("connect",()=>{this.connected=!0,this.connecting=!1,this.reconnectAttempts=0,Q.info(`[${A}] Successfully connected to bridge server`)}),this.socket.on("data",(G)=>{this.responseBuffer=Buffer.concat([this.responseBuffer,G]);while(this.responseBuffer.length>=4){let Z=this.responseBuffer.readUInt32LE(0);if(this.responseBuffer.length<4+Z)break;let Y=this.responseBuffer.slice(4,4+Z);this.responseBuffer=this.responseBuffer.slice(4+Z);try{let J=JSON.parse(Y.toString("utf-8"));this.handleResponse(J)}catch(J){Q.info(`[${A}] Failed to parse response:`,J)}}}),this.socket.on("error",(G)=>{if(Q.info(`[${A}] Socket error:`,G),this.connected=!1,this.connecting=!1,G.code&&["ECONNREFUSED","ECONNRESET","EPIPE"].includes(G.code))this.scheduleReconnect()}),this.socket.on("close",()=>{this.connected=!1,this.connecting=!1,this.scheduleReconnect()})}scheduleReconnect(){let{serverName:A,logger:Q}=this.context;if(this.reconnectTimer){Q.info(`[${A}] Reconnect already scheduled, skipping`);return}if(this.reconnectAttempts>=this.maxReconnectAttempts){Q.info(`[${A}] Max reconnection attempts reached`),this.cleanup();return}this.reconnectAttempts++;let B=Math.min(this.reconnectDelay*Math.pow(1.5,this.reconnectAttempts-1),30000);Q.info(`[${A}] Reconnecting in ${Math.round(B)}ms (attempt ${this.reconnectAttempts})`),this.reconnectTimer=setTimeout(()=>{this.reconnectTimer=null,this.connect()},B)}handleResponse(A){if(this.responseCallback){let Q=this.responseCallback;this.responseCallback=null,Q(A)}}async ensureConnected(){let{serverName:A}=this.context;if(this.connected&&this.socket)return!0;if(!this.socket&&!this.connecting)await this.connect();return new Promise((Q,B)=>{let G=setTimeout(()=>{B(new e61(`[${A}] Connection attempt timed out after 5000ms`))},5000),Z=()=>{if(this.connected)clearTimeout(G),Q(!0);else setTimeout(Z,100)};Z()})}async sendRequest(A,Q=30000){let{serverName:B}=this.context;if(!this.socket)throw new e61(`[${B}] Cannot send request: not connected`);let G=this.socket;return new Promise((Z,Y)=>{let J=setTimeout(()=>{this.responseCallback=null,Y(Error(`[${B}] Tool request timed out after ${Q}ms`))},Q);this.responseCallback=(V)=>{clearTimeout(J),Z(V)};let I=JSON.stringify(A),X=Buffer.from(I,"utf-8"),W=Buffer.allocUnsafe(4);W.writeUInt32LE(X.length,0);let K=Buffer.concat([W,X]);G.write(K)})}async callTool(A,Q){let B={method:"execute_tool",params:{client_id:"desktop",tool:A,args:Q}};return await this.sendRequest(B)}isConnected(){return this.connected}closeSocket(){if(this.socket)this.socket.removeAllListeners(),this.socket.end(),this.socket.destroy(),this.socket=null;this.connected=!1,this.connecting=!1}cleanup(){if(this.reconnectTimer)clearTimeout(this.reconnectTimer),this.reconnectTimer=null;this.closeSocket(),this.reconnectAttempts=0,this.responseBuffer=Buffer.alloc(0),this.responseCallback=null}disconnect(){this.cleanup()}getSecureSocketPath(){let A=v85().username||"default";if(tN2()==="win32")return`\\\\.\\pipe\\claude-mcp-browser-bridge-${A}`;else return k85(y85(),`claude-mcp-browser-bridge-${A}`)}async validateSocketSecurity(A){let{serverName:Q,logger:B}=this.context;if(tN2()==="win32")return;try{let G=await x85.stat(A);if(!G.isSocket())throw Error(`[${Q}] Path exists but it's not a socket: ${A}`);let Z=G.mode&511;if(Z!==384)throw Error(`[${Q}] Insecure socket permissions: ${Z.toString(8)} (expected 0600). Socket may have been tampered with. `);let Y=process.getuid?.();if(Y!==void 0&&G.uid!==Y)throw Error(`Socket not owned by current user (uid: ${Y}, socket uid: ${G.uid}). Potential security risk.`);B.info(`[${Q}] Socket security validation passed`)}catch(G){if(G.code==="ENOENT"){B.info(`[${Q}] Socket not found, will be created by server`);return}throw G}}}var e61;var a50=q(()=>{e61=class e61 extends Error{constructor(A){super(A);this.name="SocketConnectionError"}}});var eN2=q(()=>{a50()});var Aq2=q(()=>{n50();KV();i50();a50();eN2()});var A81=q(()=>{i50();Aq2()});import{chmod as HZZ,mkdir as FZZ,readFile as CZZ,writeFile as zZZ,readdir as g85,access as Qq2}from"fs/promises";import{homedir as u85}from"os";import{join as i_A}from"path";function Q81(A){return!1}async function Gq2(){return!1}function m85(){let A=pQ(),Q=u85();switch(A){case"macos":return i_A(Q,"Library","Application Support","Google","Chrome");case"windows":{let B=i_A(Q,"AppData","Local");return i_A(B,"Google","Chrome","User Data")}case"linux":return i_A(Q,".config","google-chrome");default:return null}}var Bq2="com.anthropic.claude_code_browser_extension",_ZZ,TZZ;var B81=q(()=>{Z8();Q0();Q3();sQ();A81();r7A();_ZZ=`${Bq2}.json`,TZZ=`HKCU\\Software\\Google\\Chrome\\NativeMessagingHosts\\${Bq2}`});function d85(){if(process.argv.includes("--chrome"))return!0;if(process.argv.includes("--no-chrome"))return!1;return}function Zq2(){let{addNotification:A}=fG();ZO.useEffect(()=>{return},[A])}var ZO;var Yq2=q(()=>{hA();B81();TC();g1();V2();ZO=o(KA(),1)});function Jq2(){return c1().tipsHistory||{}}function c85(A){i0((Q)=>{if(Q.tipsHistory===A)return Q;return{...Q,tipsHistory:A}})}function Iq2(A){let Q=Jq2(),B=c1().numStartups;Q[A]=B,c85(Q)}function p85(A){return Jq2()[A]||0}function G81(A){let Q=p85(A);if(Q===0)return 1/0;return c1().numStartups-Q}var r50=q(()=>{vQ()});function Z81(A){if(A.includes("@")){let Q=A.split("@");return{name:Q[0]||"",marketplace:Q[1]}}return{name:A}}function uy(A){if(A==="managed")throw Error("Cannot install plugins to managed scope");return i85[A]}function Wq2(A){return Xq2[A]}var Xq2,i85;var pIA=q(()=>{Xq2={policySettings:"managed",userSettings:"user",projectSettings:"project",localSettings:"local",flagSettings:"flag"};i85={user:"userSettings",project:"projectSettings",local:"localSettings"}});import{dirname as gZZ,join as qn}from"path";function n_A(){return qn(uQ(),"plugins","installed_plugins.json")}function n85(){return qn(uQ(),"plugins","installed_plugins_v2.json")}function a85(){if(s50)return;let A=jA(),Q=n_A(),B=n85();try{let G=A.existsSync(B),Z=A.existsSync(Q);if(G){A.renameSync(B,Q),f("Renamed installed_plugins_v2.json to installed_plugins.json");let Y=J$();Kq2(Y)}else if(Z){let Y=A.readFileSync(Q,{encoding:"utf-8"}),J=JSON.parse(Y);if((typeof J?.version==="number"?J.version:1)===1){let X=mwA.parse(J),W=A70(X);A.writeFileSync(Q,JSON.stringify(W,null,2),{encoding:"utf-8",flush:!0}),f(`Converted installed_plugins.json from V1 to V2 format (${Object.keys(X.plugins).length} plugins)`),Kq2(W)}}s50=!0}catch(G){let Z=G instanceof Error?G.message:String(G);f(`Failed to migrate plugin files: ${Z}`,{level:"error"}),r(G instanceof Error?G:Error(`Failed to migrate plugin files: ${Z}`)),s50=!0}}function Kq2(A){let Q=jA(),B=o7A();if(!Q.existsSync(B))return;try{let G=new Set;for(let Y of Object.values(A.plugins))for(let J of Y)G.add(J.installPath);let Z=Q.readdirSync(B);for(let Y of Z){if(!Y.isDirectory())continue;let J=Y.name,I=qn(B,J);if(Q.readdirSync(I).some((K)=>{if(!K.isDirectory())return!1;let V=qn(I,K.name);return Q.readdirSync(V).some((D)=>D.isDirectory())}))continue;if(!G.has(I))Q.rmSync(I,{recursive:!0,force:!0}),f(`Cleaned up legacy cache directory: ${J}`)}}catch(G){let Z=G instanceof Error?G.message:String(G);f(`Failed to clean up legacy cache: ${Z}`,{level:"warn"})}}function e50(){let A=jA(),Q=n_A();if(!A.existsSync(Q))return null;let B=A.readFileSync(Q,{encoding:"utf-8"}),G=JSON.parse(B);return{version:typeof G?.version==="number"?G.version:1,data:G}}function A70(A){let Q={};for(let[B,G]of Object.entries(A.plugins)){let Z=eS(B,G.version);Q[B]=[{scope:"user",installPath:Z,version:G.version,installedAt:G.installedAt,lastUpdated:G.lastUpdated,gitCommitSha:G.gitCommitSha,isLocal:G.isLocal}]}return{version:2,plugins:Q}}function J$(){if(my!==null)return my;let A=n_A();try{let Q=e50();if(Q){if(Q.version===2){let Z=dwA.parse(Q.data);return my=Z,f(`Loaded ${Object.keys(Z.plugins).length} installed plugins from ${A}`),Z}let B=mwA.parse(Q.data),G=A70(B);return my=G,f(`Loaded and converted ${Object.keys(B.plugins).length} plugins from V1 format`),G}return f("installed_plugins.json doesn't exist, returning empty V2 object"),my={version:2,plugins:{}},my}catch(Q){let B=Q instanceof Error?Q.message:String(Q);return f(`Failed to load installed_plugins.json: ${B}. Starting with empty state.`,{level:"error"}),r(Q instanceof Error?Q:Error(`Failed to load installed_plugins.json: ${B}`)),my={version:2,plugins:{}},my}}function Q70(A){let Q=jA(),B=n_A();try{let G=qn(uQ(),"plugins");if(!Q.existsSync(G))Q.mkdirSync(G);let Z=JSON.stringify(A,null,2);Q.writeFileSync(B,Z,{encoding:"utf-8",flush:!0}),my=A,f(`Saved ${Object.keys(A.plugins).length} installed plugins to ${B}`)}catch(G){let Z=G instanceof Error?G.message:String(G);throw r(G instanceof Error?G:Error(`Failed to save installed_plugins.json: ${Z}`)),G}}function Eq2(A,Q,B){let G=J$(),Z=G.plugins[A];if(!Z)return;if(G.plugins[A]=Z.filter((Y)=>!(Y.scope===Q&&Y.projectPath===B)),G.plugins[A].length===0)delete G.plugins[A];Q70(G),f(`Removed installation for ${A} at scope ${Q}`)}function B70(){if(t50===null)t50=J$();return t50}function J81(){try{let A=e50();if(A){if(A.version===2)return dwA.parse(A.data);let Q=mwA.parse(A.data);return A70(Q)}return{version:2,plugins:{}}}catch(A){let Q=A instanceof Error?A.message:String(A);return f(`Failed to load installed plugins from disk: ${Q}`,{level:"error"}),{version:2,plugins:{}}}}function Dq2(A,Q,B,G,Z){let Y=J81(),J=Y.plugins[A];if(!J){f(`Cannot update ${A} on disk: plugin not found in installed plugins`);return}let I=J.find((X)=>X.scope===Q&&X.projectPath===B);if(I){I.installPath=G,I.version=Z,I.lastUpdated=new Date().toISOString();let X=jA(),W=n_A();X.writeFileSync(W,JSON.stringify(Y,null,2),{encoding:"utf-8",flush:!0}),my=null,f(`Updated ${A} on disk to version ${Z} at ${G}`)}else f(`Cannot update ${A} on disk: no installation for scope ${Q}`)}async function Hq2(){a85();try{await Z70()}catch(Q){r(Q instanceof Error?Q:Error(String(Q)))}let A=B70();f(`Initialized versioned plugins system with ${Object.keys(A.plugins).length} plugins`)}function o85(A){let B=J$().plugins[A];if(!B||B.length===0)return;let G=B[0];if(!G)return;return{version:G.version||"unknown",installedAt:G.installedAt||new Date().toISOString(),lastUpdated:G.lastUpdated,installPath:G.installPath,gitCommitSha:G.gitCommitSha,isLocal:G.isLocal}}function I$(A){return o85(A)!==void 0}function G70(A,Q,B="user",G){let Z=J$(),Y={scope:B,installPath:Q.installPath,version:Q.version,installedAt:Q.installedAt,lastUpdated:Q.lastUpdated,gitCommitSha:Q.gitCommitSha,isLocal:Q.isLocal,...G&&{projectPath:G}},J=Z.plugins[A]||[],I=J.findIndex((W)=>W.scope===B&&W.projectPath===G),X=I>=0;if(X)J[I]=Y;else J.push(Y);Z.plugins[A]=J,Q70(Z),f(`${X?"Updated":"Added"} installed plugin: ${A} (scope: ${B})`)}async function Y81(A){try{let Q=await EQ("git",["-C",A,"rev-parse","HEAD"]);if(Q.code===0&&Q.stdout)return Q.stdout.trim();return}catch(Q){f(`Failed to get git commit SHA from ${A}: ${Q}`);return}}function Vq2(A,Q){let B=jA(),G=qn(A,".claude-plugin","plugin.json");if(!B.existsSync(G))return"unknown";try{let Z=B.readFileSync(G,{encoding:"utf-8"});return JSON.parse(Z).version||"unknown"}catch{return f(`Could not read version from manifest for ${Q}`),"unknown"}}async function Z70(){let Q=CQ().enabledPlugins||{};if(Object.keys(Q).length===0)return;let B=e50(),G=B!==null;if(G&&B?.version===2&&B){let D=dwA.safeParse(B.data);if(D?.success){let H=D.data.plugins;if(Object.keys(Q).filter((C)=>C.includes("@")).every((C)=>{let $=H[C];return $&&$.length>0})){f("All plugins already exist, skipping migration");return}}}f(G?"Syncing installed_plugins.json with enabledPlugins from all settings.json files":"Creating installed_plugins.json from settings.json files");let Y=jA(),J=new Date().toISOString(),I=s1(),X=new Map,W=["userSettings","projectSettings","localSettings"];for(let D of W){let F=uB(D)?.enabledPlugins||{};for(let C of Object.keys(F)){if(!C.includes("@"))continue;let $=Wq2(D);X.set(C,{scope:$,projectPath:$==="user"?void 0:I})}}let K={};if(G)K={...J$().plugins};let V=0,E=0;for(let[D,H]of X){let F=K[D];if(F&&F.length>0){let C=F[0];if(C&&(C.scope!==H.scope||C.projectPath!==H.projectPath)){if(C.scope=H.scope,H.projectPath)C.projectPath=H.projectPath;else delete C.projectPath;C.lastUpdated=J,V++,f(`Updated ${D} scope to ${H.scope} (settings.json is source of truth)`)}}else{let C=D.split("@"),$=C[0];if(!$||C.length!==2)continue;try{let O=await VH(D);if(!O){f(`Plugin ${D} not found in any marketplace, skipping`);continue}let{entry:M,marketplaceInstallLocation:L}=O,_,T="unknown",x=void 0,b=!1;if(typeof M.source==="string")b=!0,_=qn(L,M.source),T=Vq2(_,D),x=await Y81(_);else{let v=o7A(),m=$.replace(/[^a-zA-Z0-9-_]/g,"-"),u=qn(v,m);if(!Y.existsSync(u)){f(`External plugin ${D} not in cache, skipping`);continue}_=u,T=Vq2(u,D),x=await Y81(u)}if(T==="unknown"&&M.version)T=M.version;if(T==="unknown"&&x)T=x.substring(0,12);K[D]=[{scope:H.scope,installPath:b?_:eS(D,T),version:T,installedAt:J,lastUpdated:J,gitCommitSha:x,isLocal:b,...H.projectPath&&{projectPath:H.projectPath}}],E++,f(`Added ${D} with scope ${H.scope}`)}catch(O){f(`Failed to add plugin ${D}: ${O}`)}}}if(!G||V>0||E>0)Q70({version:2,plugins:K}),f(`Sync completed: ${E} added, ${V} updated in installed_plugins.json`)}var s50=!1,my=null,t50=null;var cT=q(()=>{YQ();Q0();g1();sQ();sL();gB();pIA();pB();GW();Q3();aW()});async function r85(){return"claude-code-plugins"in await _5()}async function I81(A){let Q=[...s85,...t85],B=await Promise.all(Q.map((G)=>G.isRelevant(A)));return Q.filter((G,Z)=>B[Z]).filter((G)=>G81(G.id)>=G.cooldownSessions)}var s85,t85;var Y70=q(()=>{o2();vQ();w4();aI();cT();aW();d2();G8A();R8();RJ();Z8();Wc();gB();r50();x8();UU();Q0();kFA();nw();s85=[{id:"new-user-warmup",content:async()=>"Start with small features or bug fixes, tell Claude to propose a plan, and verify its suggested edits",cooldownSessions:3,async isRelevant(){return c1().numStartups<10}},{id:"plan-mode-for-complex-tasks",content:async()=>`Use Plan Mode to prepare for a complex request before making changes. Press ${pz.displayText} twice to enable.`,cooldownSessions:5,isRelevant:async()=>{let A=c1();return(A.lastPlanModeUse?(Date.now()-A.lastPlanModeUse)/86400000:1/0)>7}},{id:"default-permission-mode-config",content:async()=>"Use /config to change your default permission mode (including Plan Mode)",cooldownSessions:10,isRelevant:async()=>{try{let A=c1(),Q=CQ(),B=Boolean(A.lastPlanModeUse),G=Boolean(Q?.permissions?.defaultMode);return B&&!G}catch(A){return f(`Failed to check default-permission-mode-config tip relevance: ${A}`,{level:"warn"}),!1}}},{id:"git-worktrees",content:async()=>"Use git worktrees to run multiple Claude sessions in parallel.",cooldownSessions:10,isRelevant:async()=>{try{let A=c1();return await sCA()<=1&&A.numStartups>50}catch(A){return!1}}},{id:"terminal-setup",content:async()=>QQ.terminal==="Apple_Terminal"?"Run /terminal-setup to enable convenient terminal integration like Option + Enter for new line and more":"Run /terminal-setup to enable convenient terminal integration like Shift + Enter for new line and more",cooldownSessions:10,async isRelevant(){let A=c1();if(QQ.terminal==="Apple_Terminal")return Ic.isEnabled()&&!A.optionAsMetaKeyInstalled;return Ic.isEnabled()&&!A.shiftEnterKeyBindingInstalled}},{id:"shift-enter",content:async()=>QQ.terminal==="Apple_Terminal"?"Press Option+Enter to send a multi-line message":"Press Shift+Enter to send a multi-line message",cooldownSessions:10,async isRelevant(){let A=c1();return Boolean((QQ.terminal==="Apple_Terminal"?A.optionAsMetaKeyInstalled:A.shiftEnterKeyBindingInstalled)&&A.numStartups>3)}},{id:"shift-enter-setup",content:async()=>QQ.terminal==="Apple_Terminal"?"Run /terminal-setup to enable Option+Enter for new lines":"Run /terminal-setup to enable Shift+Enter for new lines",cooldownSessions:10,async isRelevant(){if(!zCA())return!1;let A=c1();return!(QQ.terminal==="Apple_Terminal"?A.optionAsMetaKeyInstalled:A.shiftEnterKeyBindingInstalled)}},{id:"memory-command",content:async()=>"Use /memory to view and manage Claude memory",cooldownSessions:15,async isRelevant(){return c1().memoryUsageCount<=0}},{id:"theme-command",content:async()=>"Use /theme to change the color theme",cooldownSessions:20,isRelevant:async()=>!0},{id:"colorterm-truecolor",content:async()=>"Try setting environment variable COLORTERM=truecolor for richer colors",cooldownSessions:30,isRelevant:async()=>!process.env.COLORTERM&&pA.level<3},{id:"status-line",content:async()=>"Use /statusline to set up a custom status line that will display beneath the input box",cooldownSessions:25,isRelevant:async()=>CQ().statusLine===void 0},{id:"stickers-command",content:async()=>"Use /stickers to order Claude Code swag",cooldownSessions:20,isRelevant:async()=>!0},{id:"prompt-queue",content:async()=>"Hit Enter to queue up additional messages while Claude is working.",cooldownSessions:5,async isRelevant(){return c1().promptQueueUseCount<=3}},{id:"enter-to-steer-in-relatime",content:async()=>"Send messages to Claude while it works to steer Claude in real-time",cooldownSessions:20,isRelevant:async()=>!0},{id:"todo-list",content:async()=>"Ask Claude to create a todo list when working on complex tasks to track progress and remain on track",cooldownSessions:20,isRelevant:async()=>!0},{id:"vscode-command-install",content:async()=>`Open the Command Palette (Cmd+Shift+P) and run "Shell Command: Install '${QQ.terminal==="vscode"?"code":QQ.terminal}' command in PATH" to enable IDE integration`,cooldownSessions:0,async isRelevant(){if(!ywA())return!1;if(pQ()!=="macos")return!1;switch(QQ.terminal){case"vscode":return!hEB();case"cursor":return!fEB();case"windsurf":return!bEB();default:return!1}}},{id:"ide-upsell-external-terminal",content:async()=>"Connect Claude to your IDE ¬∑ /ide",cooldownSessions:4,async isRelevant(){if(BW())return!1;if(drA().length!==0)return!1;return prA().length>0}},{id:"# for memory",content:async()=>"Want Claude to remember something? Hit # to add preferences, tools, and instructions to Claude's memory",cooldownSessions:10,isRelevant:async()=>c1().memoryUsageCount<=10},{id:"install-github-app",content:async()=>"Run /install-github-app to tag @claude right from your Github issues and PRs",cooldownSessions:10,isRelevant:async()=>!c1().githubActionSetupCount},{id:"install-slack-app",content:async()=>"Run /install-slack-app to use Claude in Slack",cooldownSessions:10,isRelevant:async()=>await JZ("code_slack_app_install_banner")&&!c1().slackAppInstallCount},{id:"permissions",content:async()=>"Use /permissions to pre-approve and pre-deny bash, edit, and MCP tools",cooldownSessions:10,async isRelevant(){return c1().numStartups>10}},{id:"drag-and-drop-images",content:async()=>"Did you know you can drag and drop image files into your terminal?",cooldownSessions:10,isRelevant:async()=>!0},{id:"paste-images-mac",content:async()=>"Paste images into Claude Code using control+v (not cmd+v!)",cooldownSessions:10,isRelevant:async()=>pQ()==="macos"},{id:"double-esc",content:async()=>"Double-tap esc to rewind the conversation to a previous point in time",cooldownSessions:10,isRelevant:async()=>!t7()},{id:"double-esc-code-restore",content:async()=>"Double-tap esc to rewind the code and/or conversation to a previous point in time",cooldownSessions:10,isRelevant:async()=>t7()},{id:"continue",content:async()=>"Run claude --continue or claude --resume to resume a conversation",cooldownSessions:10,isRelevant:async()=>!0},{id:"rename-conversation",content:async()=>"Name your conversations with /rename to find them easily in /resume later",cooldownSessions:15,isRelevant:async()=>cb()&&c1().numStartups>10},{id:"custom-commands",content:async()=>"Create custom slash commands by adding .md files to .claude/commands/ in your project or ~/.claude/commands/ for commands that work in any project",cooldownSessions:15,async isRelevant(){return c1().numStartups>10}},{id:"shift-tab",content:async()=>`Hit ${pz.displayText} to cycle between default mode, auto-accept edit mode, and plan mode`,cooldownSessions:10,isRelevant:async()=>!0},{id:"image-paste",content:async()=>`Use ${bs.displayText} to paste images from your clipboard`,cooldownSessions:20,isRelevant:async()=>!0},{id:"config-thinking-mode",content:async()=>"Use /config to set your default thinking mode preference",cooldownSessions:10,isRelevant:async()=>!0},{id:"ultrathink-keyword",content:async()=>"Type 'ultrathink' in your message to enable thinking for just that turn",cooldownSessions:10,isRelevant:async()=>!0},{id:"custom-agents",content:async()=>"Use /agents to optimize specific tasks. Eg. Software Architect, Code Writer, Code Reviewer",cooldownSessions:15,async isRelevant(){return c1().numStartups>5}},{id:"opusplan-mode-reminder",content:async()=>`Your default model setting is Opus Plan Mode. Press ${pz.displayText} twice to activate Plan Mode and plan with Claude Opus.`,cooldownSessions:2,async isRelevant(){let A=c1(),B=Ws()==="opusplan",G=A.lastPlanModeUse?(Date.now()-A.lastPlanModeUse)/86400000:1/0;return B&&G>3}},{id:"frontend-design-plugin",content:async(A)=>{let Q=await r85(),B=yB("suggestion",A.theme);if(!Q)return`Working with HTML/CSS? Add the frontend-design plugin:
2669:${B("/plugin install frontend-design@claude-code-plugins")}`},cooldownSessions:3,async isRelevant(A){if(I$("frontend-design@claude-code-plugins"))return!1;if(!A?.readFileState)return!1;return wx(A.readFileState).some((B)=>/\.(html|css|htm)$/i.test(B))}}],t85=[]});function e85(A){if(A.length===0)return;if(A.length===1)return A[0];let Q=A.map((B)=>({tip:B,sessions:G81(B.id)}));return Q.sort((B,G)=>G.sessions-B.sessions),Q[0]?.tip}async function Fq2(A){if(CQ().spinnerTipsEnabled===!1)return;let Q=await I81(A);if(Q.length===0)return;return e85(Q)}function Cq2(A){Iq2(A.id),s("tengu_tip_shown",{tipIdLength:A.id,cooldownSessions:A.cooldownSessions})}var zq2=q(()=>{r50();_0();vQ();gB();mIA();Y70()});function $q2(){let[A,Q]=RQ(),{toolPermissionContext:B}=A;Uq2.useEffect(()=>{J70(B,Q)},[])}var Uq2,J70;var wq2=q(()=>{p2();f2();a1A();Uq2=o(KA(),1),J70=Z0(async(A,Q)=>{if(!A.isBypassPermissionsModeAvailable)return;if(!await I70())return;Q((G)=>{return{...G,toolPermissionContext:a_A(G.toolPermissionContext)}})})});function Nq2(A,Q,B){let G=X81.useRef(!1);X81.useEffect(()=>{if(!t7()||G.current)return;if(G.current=!0,A)dGA(A,B)},[Q,A,B])}var X81;var qq2=q(()=>{UU();X81=o(KA(),1)});function Lq2({hostPattern:{host:A},onUserResponse:Q}){function B(Z){switch(Z){case"yes":Q({allow:!0,persistToSettings:!1});break;case"yes-dont-ask-again":Q({allow:!0,persistToSettings:!0});break;case"no":Q({allow:!1,persistToSettings:!1});break}}let G=[{label:"Yes",value:"yes"},{label:`Yes, and don't ask again for ${pA.bold(A)}`,value:"yes-dont-ask-again"},{label:`No, and tell Claude what to do differently ${pA.bold("(esc)")}`,value:"no"}];return EK.createElement(fZ,{title:"Network request outside of sandbox"},EK.createElement(j,{flexDirection:"column",paddingX:2,paddingY:1},EK.createElement(j,null,EK.createElement(z,{dimColor:!0},"Host:"),EK.createElement(z,null," ",A)),EK.createElement(j,{marginTop:1},EK.createElement(z,null,"Do you want to allow this connection?")),EK.createElement(j,null,EK.createElement(S0,{options:G,onChange:B,onCancel:()=>{Q({allow:!1,persistToSettings:!1})}}))))}var EK;var Mq2=q(()=>{hA();K8();PU();o2();_0();EK=o(KA(),1)});var A55,bYZ,W81=604800000,Oq2=86400000,X70;var o_A=q(()=>{A55=Math.pow(10,8)*24*60*60*1000,bYZ=-A55,X70=Symbol.for("constructDateFrom")});function X$(A,Q){if(typeof A==="function")return A(Q);if(A&&typeof A==="object"&&X70 in A)return A[X70](Q);if(A instanceof Date)return new A.constructor(Q);return new Date(Q)}var Ln=q(()=>{o_A()});function $I(A,Q){return X$(Q||A,A)}var yN=q(()=>{Ln()});var Rq2=()=>{};var _q2=()=>{};var Tq2=()=>{};var jq2=()=>{};var Pq2=()=>{};var Sq2=()=>{};var xq2=()=>{};var yq2=()=>{};var vq2=()=>{};function Mn(){return Q55}var Q55;var r_A=q(()=>{Q55={}});function $g(A,Q){let B=Mn(),G=Q?.weekStartsOn??Q?.locale?.options?.weekStartsOn??B.weekStartsOn??B.locale?.options?.weekStartsOn??0,Z=$I(A,Q?.in),Y=Z.getDay(),J=(Y<G?7:0)+Y-G;return Z.setDate(Z.getDate()-J),Z.setHours(0,0,0,0),Z}var lIA=q(()=>{r_A();yN()});function p0A(A,Q){return $g(A,{...Q,weekStartsOn:1})}var s_A=q(()=>{lIA()});function K81(A,Q){let B=$I(A,Q?.in),G=B.getFullYear(),Z=X$(B,0);Z.setFullYear(G+1,0,4),Z.setHours(0,0,0,0);let Y=p0A(Z),J=X$(B,0);J.setFullYear(G,0,4),J.setHours(0,0,0,0);let I=p0A(J);if(B.getTime()>=Y.getTime())return G+1;else if(B.getTime()>=I.getTime())return G;else return G-1}var V81=q(()=>{Ln();s_A();yN()});function W70(A){let Q=$I(A),B=new Date(Date.UTC(Q.getFullYear(),Q.getMonth(),Q.getDate(),Q.getHours(),Q.getMinutes(),Q.getSeconds(),Q.getMilliseconds()));return B.setUTCFullYear(Q.getFullYear()),+A-+B}var kq2=q(()=>{yN()});function fq2(A,...Q){let B=X$.bind(null,A||Q.find((G)=>typeof G==="object"));return Q.map(B)}var bq2=q(()=>{Ln()});function K70(A,Q){let B=$I(A,Q?.in);return B.setHours(0,0,0,0),B}var V70=q(()=>{yN()});function hq2(A,Q,B){let[G,Z]=fq2(B?.in,A,Q),Y=K70(G),J=K70(Z),I=+Y-W70(Y),X=+J-W70(J);return Math.round((I-X)/Oq2)}var E70=q(()=>{kq2();bq2();o_A();V70()});function gq2(A,Q){let B=K81(A,Q),G=X$(Q?.in||A,0);return G.setFullYear(B,0,4),G.setHours(0,0,0,0),p0A(G)}var D70=q(()=>{Ln();V81();s_A()});var uq2=()=>{};var mq2=()=>{};var dq2=()=>{};var cq2=()=>{};var pq2=()=>{};var lq2=()=>{};var iq2=()=>{};var nq2=()=>{};var aq2=()=>{};var oq2=()=>{};var rq2=()=>{};var sq2=()=>{};var tq2=()=>{};var eq2=()=>{};var AL2=()=>{};var QL2=()=>{};var BL2=()=>{};var GL2=()=>{};function ZL2(A){return A instanceof Date||typeof A==="object"&&Object.prototype.toString.call(A)==="[object Date]"}var H70=()=>{};function YL2(A){return!(!ZL2(A)&&typeof A!=="number"||isNaN(+$I(A)))}var F70=q(()=>{H70();yN()});var JL2=()=>{};var IL2=()=>{};var XL2=()=>{};var WL2=()=>{};var KL2=()=>{};var VL2=()=>{};var EL2=()=>{};var DL2=()=>{};var HL2=()=>{};var FL2=()=>{};var CL2=()=>{};var zL2=()=>{};var UL2=()=>{};var $L2=()=>{};var wL2=()=>{};var NL2=()=>{};var qL2=()=>{};var LL2=()=>{};var ML2=()=>{};var OL2=()=>{};var RL2=()=>{};var _L2=()=>{};var TL2=()=>{};var jL2=()=>{};var PL2=()=>{};var SL2=()=>{};var xL2=()=>{};var yL2=()=>{};var vL2=()=>{};var kL2=()=>{};var fL2=()=>{};var bL2=()=>{};var hL2=()=>{};function gL2(A,Q){let B=$I(A,Q?.in);return B.setFullYear(B.getFullYear(),0,1),B.setHours(0,0,0,0),B}var C70=q(()=>{yN()});var uL2=()=>{};var mL2=()=>{};var dL2=()=>{};var cL2=()=>{};var pL2=()=>{};var lL2=()=>{};var iL2=()=>{};var nL2=()=>{};var aL2=()=>{};var oL2=()=>{};var rL2=()=>{};var sL2=()=>{};var tL2=()=>{};var B55,eL2=(A,Q,B)=>{let G,Z=B55[A];if(typeof Z==="string")G=Z;else if(Q===1)G=Z.one;else G=Z.other.replace("{{count}}",Q.toString());if(B?.addSuffix)if(B.comparison&&B.comparison>0)return"in "+G;else return G+" ago";return G};var AM2=q(()=>{B55={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"less than a minute",other:"less than {{count}} minutes"},xMinutes:{one:"1 minute",other:"{{count}} minutes"},aboutXHours:{one:"about 1 hour",other:"about {{count}} hours"},xHours:{one:"1 hour",other:"{{count}} hours"},xDays:{one:"1 day",other:"{{count}} days"},aboutXWeeks:{one:"about 1 week",other:"about {{count}} weeks"},xWeeks:{one:"1 week",other:"{{count}} weeks"},aboutXMonths:{one:"about 1 month",other:"about {{count}} months"},xMonths:{one:"1 month",other:"{{count}} months"},aboutXYears:{one:"about 1 year",other:"about {{count}} years"},xYears:{one:"1 year",other:"{{count}} years"},overXYears:{one:"over 1 year",other:"over {{count}} years"},almostXYears:{one:"almost 1 year",other:"almost {{count}} years"}}});function E81(A){return(Q={})=>{let B=Q.width?String(Q.width):A.defaultWidth;return A.formats[B]||A.formats[A.defaultWidth]}}var G55,Z55,Y55,QM2;var BM2=q(()=>{G55={full:"EEEE, MMMM do, y",long:"MMMM do, y",medium:"MMM d, y",short:"MM/dd/yyyy"},Z55={full:"h:mm:ss a zzzz",long:"h:mm:ss a z",medium:"h:mm:ss a",short:"h:mm a"},Y55={full:"{{date}} 'at' {{time}}",long:"{{date}} 'at' {{time}}",medium:"{{date}}, {{time}}",short:"{{date}}, {{time}}"},QM2={date:E81({formats:G55,defaultWidth:"full"}),time:E81({formats:Z55,defaultWidth:"full"}),dateTime:E81({formats:Y55,defaultWidth:"full"})}});var J55,GM2=(A,Q,B,G)=>J55[A];var ZM2=q(()=>{J55={lastWeek:"'last' eeee 'at' p",yesterday:"'yesterday at' p",today:"'today at' p",tomorrow:"'tomorrow at' p",nextWeek:"eeee 'at' p",other:"P"}});function iIA(A){return(Q,B)=>{let G=B?.context?String(B.context):"standalone",Z;if(G==="formatting"&&A.formattingValues){let J=A.defaultFormattingWidth||A.defaultWidth,I=B?.width?String(B.width):J;Z=A.formattingValues[I]||A.formattingValues[J]}else{let J=A.defaultWidth,I=B?.width?String(B.width):A.defaultWidth;Z=A.values[I]||A.values[J]}let Y=A.argumentCallback?A.argumentCallback(Q):Q;return Z[Y]}}var I55,X55,W55,K55,V55,E55,D55=(A,Q)=>{let B=Number(A),G=B%100;if(G>20||G<10)switch(G%10){case 1:return B+"st";case 2:return B+"nd";case 3:return B+"rd"}return B+"th"},YM2;var JM2=q(()=>{I55={narrow:["B","A"],abbreviated:["BC","AD"],wide:["Before Christ","Anno Domini"]},X55={narrow:["1","2","3","4"],abbreviated:["Q1","Q2","Q3","Q4"],wide:["1st quarter","2nd quarter","3rd quarter","4th quarter"]},W55={narrow:["J","F","M","A","M","J","J","A","S","O","N","D"],abbreviated:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],wide:["January","February","March","April","May","June","July","August","September","October","November","December"]},K55={narrow:["S","M","T","W","T","F","S"],short:["Su","Mo","Tu","We","Th","Fr","Sa"],abbreviated:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],wide:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]},V55={narrow:{am:"a",pm:"p",midnight:"mi",noon:"n",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},abbreviated:{am:"AM",pm:"PM",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},wide:{am:"a.m.",pm:"p.m.",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"}},E55={narrow:{am:"a",pm:"p",midnight:"mi",noon:"n",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"},abbreviated:{am:"AM",pm:"PM",midnight:"midnight",noon:"noon",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"},wide:{am:"a.m.",pm:"p.m.",midnight:"midnight",noon:"noon",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"}},YM2={ordinalNumber:D55,era:iIA({values:I55,defaultWidth:"wide"}),quarter:iIA({values:X55,defaultWidth:"wide",argumentCallback:(A)=>A-1}),month:iIA({values:W55,defaultWidth:"wide"}),day:iIA({values:K55,defaultWidth:"wide"}),dayPeriod:iIA({values:V55,defaultWidth:"wide",formattingValues:E55,defaultFormattingWidth:"wide"})}});function nIA(A){return(Q,B={})=>{let G=B.width,Z=G&&A.matchPatterns[G]||A.matchPatterns[A.defaultMatchWidth],Y=Q.match(Z);if(!Y)return null;let J=Y[0],I=G&&A.parsePatterns[G]||A.parsePatterns[A.defaultParseWidth],X=Array.isArray(I)?F55(I,(V)=>V.test(J)):H55(I,(V)=>V.test(J)),W;W=A.valueCallback?A.valueCallback(X):X,W=B.valueCallback?B.valueCallback(W):W;let K=Q.slice(J.length);return{value:W,rest:K}}}function H55(A,Q){for(let B in A)if(Object.prototype.hasOwnProperty.call(A,B)&&Q(A[B]))return B;return}function F55(A,Q){for(let B=0;B<A.length;B++)if(Q(A[B]))return B;return}function IM2(A){return(Q,B={})=>{let G=Q.match(A.matchPattern);if(!G)return null;let Z=G[0],Y=Q.match(A.parsePattern);if(!Y)return null;let J=A.valueCallback?A.valueCallback(Y[0]):Y[0];J=B.valueCallback?B.valueCallback(J):J;let I=Q.slice(Z.length);return{value:J,rest:I}}}var C55,z55,U55,$55,w55,N55,q55,L55,M55,O55,R55,_55,XM2;var WM2=q(()=>{C55=/^(\d+)(th|st|nd|rd)?/i,z55=/\d+/i,U55={narrow:/^(b|a)/i,abbreviated:/^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,wide:/^(before christ|before common era|anno domini|common era)/i},$55={any:[/^b/i,/^(a|c)/i]},w55={narrow:/^[1234]/i,abbreviated:/^q[1234]/i,wide:/^[1234](th|st|nd|rd)? quarter/i},N55={any:[/1/i,/2/i,/3/i,/4/i]},q55={narrow:/^[jfmasond]/i,abbreviated:/^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,wide:/^(january|february|march|april|may|june|july|august|september|october|november|december)/i},L55={narrow:[/^j/i,/^f/i,/^m/i,/^a/i,/^m/i,/^j/i,/^j/i,/^a/i,/^s/i,/^o/i,/^n/i,/^d/i],any:[/^ja/i,/^f/i,/^mar/i,/^ap/i,/^may/i,/^jun/i,/^jul/i,/^au/i,/^s/i,/^o/i,/^n/i,/^d/i]},M55={narrow:/^[smtwf]/i,short:/^(su|mo|tu|we|th|fr|sa)/i,abbreviated:/^(sun|mon|tue|wed|thu|fri|sat)/i,wide:/^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i},O55={narrow:[/^s/i,/^m/i,/^t/i,/^w/i,/^t/i,/^f/i,/^s/i],any:[/^su/i,/^m/i,/^tu/i,/^w/i,/^th/i,/^f/i,/^sa/i]},R55={narrow:/^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,any:/^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i},_55={any:{am:/^a/i,pm:/^p/i,midnight:/^mi/i,noon:/^no/i,morning:/morning/i,afternoon:/afternoon/i,evening:/evening/i,night:/night/i}},XM2={ordinalNumber:IM2({matchPattern:C55,parsePattern:z55,valueCallback:(A)=>parseInt(A,10)}),era:nIA({matchPatterns:U55,defaultMatchWidth:"wide",parsePatterns:$55,defaultParseWidth:"any"}),quarter:nIA({matchPatterns:w55,defaultMatchWidth:"wide",parsePatterns:N55,defaultParseWidth:"any",valueCallback:(A)=>A+1}),month:nIA({matchPatterns:q55,defaultMatchWidth:"wide",parsePatterns:L55,defaultParseWidth:"any"}),day:nIA({matchPatterns:M55,defaultMatchWidth:"wide",parsePatterns:O55,defaultParseWidth:"any"}),dayPeriod:nIA({matchPatterns:R55,defaultMatchWidth:"any",parsePatterns:_55,defaultParseWidth:"any"})}});var z70;var KM2=q(()=>{AM2();BM2();ZM2();JM2();WM2();z70={code:"en-US",formatDistance:eL2,formatLong:QM2,formatRelative:GM2,localize:YM2,match:XM2,options:{weekStartsOn:0,firstWeekContainsDate:1}}});var VM2=q(()=>{KM2()});function EM2(A,Q){let B=$I(A,Q?.in);return hq2(B,gL2(B))+1}var U70=q(()=>{E70();C70();yN()});function DM2(A,Q){let B=$I(A,Q?.in),G=+p0A(B)-+gq2(B);return Math.round(G/W81)+1}var $70=q(()=>{o_A();s_A();D70();yN()});function D81(A,Q){let B=$I(A,Q?.in),G=B.getFullYear(),Z=Mn(),Y=Q?.firstWeekContainsDate??Q?.locale?.options?.firstWeekContainsDate??Z.firstWeekContainsDate??Z.locale?.options?.firstWeekContainsDate??1,J=X$(Q?.in||A,0);J.setFullYear(G+1,0,Y),J.setHours(0,0,0,0);let I=$g(J,Q),X=X$(Q?.in||A,0);X.setFullYear(G,0,Y),X.setHours(0,0,0,0);let W=$g(X,Q);if(+B>=+I)return G+1;else if(+B>=+W)return G;else return G-1}var H81=q(()=>{r_A();Ln();lIA();yN()});function HM2(A,Q){let B=Mn(),G=Q?.firstWeekContainsDate??Q?.locale?.options?.firstWeekContainsDate??B.firstWeekContainsDate??B.locale?.options?.firstWeekContainsDate??1,Z=D81(A,Q),Y=X$(Q?.in||A,0);return Y.setFullYear(Z,0,G),Y.setHours(0,0,0,0),$g(Y,Q)}var w70=q(()=>{r_A();Ln();H81();lIA()});function FM2(A,Q){let B=$I(A,Q?.in),G=+$g(B,Q)-+HM2(B,Q);return Math.round(G/W81)+1}var N70=q(()=>{o_A();lIA();w70();yN()});function V7(A,Q){let B=A<0?"-":"",G=Math.abs(A).toString().padStart(Q,"0");return B+G}var wg;var CM2=q(()=>{wg={y(A,Q){let B=A.getFullYear(),G=B>0?B:1-B;return V7(Q==="yy"?G%100:G,Q.length)},M(A,Q){let B=A.getMonth();return Q==="M"?String(B+1):V7(B+1,2)},d(A,Q){return V7(A.getDate(),Q.length)},a(A,Q){let B=A.getHours()/12>=1?"pm":"am";switch(Q){case"a":case"aa":return B.toUpperCase();case"aaa":return B;case"aaaaa":return B[0];case"aaaa":default:return B==="am"?"a.m.":"p.m."}},h(A,Q){return V7(A.getHours()%12||12,Q.length)},H(A,Q){return V7(A.getHours(),Q.length)},m(A,Q){return V7(A.getMinutes(),Q.length)},s(A,Q){return V7(A.getSeconds(),Q.length)},S(A,Q){let B=Q.length,G=A.getMilliseconds(),Z=Math.trunc(G*Math.pow(10,B-3));return V7(Z,Q.length)}}});function zM2(A,Q=""){let B=A>0?"-":"+",G=Math.abs(A),Z=Math.trunc(G/60),Y=G%60;if(Y===0)return B+String(Z);return B+String(Z)+Q+V7(Y,2)}function UM2(A,Q){if(A%60===0)return(A>0?"-":"+")+V7(Math.abs(A)/60,2);return l0A(A,Q)}function l0A(A,Q=""){let B=A>0?"-":"+",G=Math.abs(A),Z=V7(Math.trunc(G/60),2),Y=V7(G%60,2);return B+Z+Q+Y}var aIA,q70;var $M2=q(()=>{U70();$70();V81();N70();H81();CM2();aIA={am:"am",pm:"pm",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},q70={G:function(A,Q,B){let G=A.getFullYear()>0?1:0;switch(Q){case"G":case"GG":case"GGG":return B.era(G,{width:"abbreviated"});case"GGGGG":return B.era(G,{width:"narrow"});case"GGGG":default:return B.era(G,{width:"wide"})}},y:function(A,Q,B){if(Q==="yo"){let G=A.getFullYear(),Z=G>0?G:1-G;return B.ordinalNumber(Z,{unit:"year"})}return wg.y(A,Q)},Y:function(A,Q,B,G){let Z=D81(A,G),Y=Z>0?Z:1-Z;if(Q==="YY"){let J=Y%100;return V7(J,2)}if(Q==="Yo")return B.ordinalNumber(Y,{unit:"year"});return V7(Y,Q.length)},R:function(A,Q){let B=K81(A);return V7(B,Q.length)},u:function(A,Q){let B=A.getFullYear();return V7(B,Q.length)},Q:function(A,Q,B){let G=Math.ceil((A.getMonth()+1)/3);switch(Q){case"Q":return String(G);case"QQ":return V7(G,2);case"Qo":return B.ordinalNumber(G,{unit:"quarter"});case"QQQ":return B.quarter(G,{width:"abbreviated",context:"formatting"});case"QQQQQ":return B.quarter(G,{width:"narrow",context:"formatting"});case"QQQQ":default:return B.quarter(G,{width:"wide",context:"formatting"})}},q:function(A,Q,B){let G=Math.ceil((A.getMonth()+1)/3);switch(Q){case"q":return String(G);case"qq":return V7(G,2);case"qo":return B.ordinalNumber(G,{unit:"quarter"});case"qqq":return B.quarter(G,{width:"abbreviated",context:"standalone"});case"qqqqq":return B.quarter(G,{width:"narrow",context:"standalone"});case"qqqq":default:return B.quarter(G,{width:"wide",context:"standalone"})}},M:function(A,Q,B){let G=A.getMonth();switch(Q){case"M":case"MM":return wg.M(A,Q);case"Mo":return B.ordinalNumber(G+1,{unit:"month"});case"MMM":return B.month(G,{width:"abbreviated",context:"formatting"});case"MMMMM":return B.month(G,{width:"narrow",context:"formatting"});case"MMMM":default:return B.month(G,{width:"wide",context:"formatting"})}},L:function(A,Q,B){let G=A.getMonth();switch(Q){case"L":return String(G+1);case"LL":return V7(G+1,2);case"Lo":return B.ordinalNumber(G+1,{unit:"month"});case"LLL":return B.month(G,{width:"abbreviated",context:"standalone"});case"LLLLL":return B.month(G,{width:"narrow",context:"standalone"});case"LLLL":default:return B.month(G,{width:"wide",context:"standalone"})}},w:function(A,Q,B,G){let Z=FM2(A,G);if(Q==="wo")return B.ordinalNumber(Z,{unit:"week"});return V7(Z,Q.length)},I:function(A,Q,B){let G=DM2(A);if(Q==="Io")return B.ordinalNumber(G,{unit:"week"});return V7(G,Q.length)},d:function(A,Q,B){if(Q==="do")return B.ordinalNumber(A.getDate(),{unit:"date"});return wg.d(A,Q)},D:function(A,Q,B){let G=EM2(A);if(Q==="Do")return B.ordinalNumber(G,{unit:"dayOfYear"});return V7(G,Q.length)},E:function(A,Q,B){let G=A.getDay();switch(Q){case"E":case"EE":case"EEE":return B.day(G,{width:"abbreviated",context:"formatting"});case"EEEEE":return B.day(G,{width:"narrow",context:"formatting"});case"EEEEEE":return B.day(G,{width:"short",context:"formatting"});case"EEEE":default:return B.day(G,{width:"wide",context:"formatting"})}},e:function(A,Q,B,G){let Z=A.getDay(),Y=(Z-G.weekStartsOn+8)%7||7;switch(Q){case"e":return String(Y);case"ee":return V7(Y,2);case"eo":return B.ordinalNumber(Y,{unit:"day"});case"eee":return B.day(Z,{width:"abbreviated",context:"formatting"});case"eeeee":return B.day(Z,{width:"narrow",context:"formatting"});case"eeeeee":return B.day(Z,{width:"short",context:"formatting"});case"eeee":default:return B.day(Z,{width:"wide",context:"formatting"})}},c:function(A,Q,B,G){let Z=A.getDay(),Y=(Z-G.weekStartsOn+8)%7||7;switch(Q){case"c":return String(Y);case"cc":return V7(Y,Q.length);case"co":return B.ordinalNumber(Y,{unit:"day"});case"ccc":return B.day(Z,{width:"abbreviated",context:"standalone"});case"ccccc":return B.day(Z,{width:"narrow",context:"standalone"});case"cccccc":return B.day(Z,{width:"short",context:"standalone"});case"cccc":default:return B.day(Z,{width:"wide",context:"standalone"})}},i:function(A,Q,B){let G=A.getDay(),Z=G===0?7:G;switch(Q){case"i":return String(Z);case"ii":return V7(Z,Q.length);case"io":return B.ordinalNumber(Z,{unit:"day"});case"iii":return B.day(G,{width:"abbreviated",context:"formatting"});case"iiiii":return B.day(G,{width:"narrow",context:"formatting"});case"iiiiii":return B.day(G,{width:"short",context:"formatting"});case"iiii":default:return B.day(G,{width:"wide",context:"formatting"})}},a:function(A,Q,B){let Z=A.getHours()/12>=1?"pm":"am";switch(Q){case"a":case"aa":return B.dayPeriod(Z,{width:"abbreviated",context:"formatting"});case"aaa":return B.dayPeriod(Z,{width:"abbreviated",context:"formatting"}).toLowerCase();case"aaaaa":return B.dayPeriod(Z,{width:"narrow",context:"formatting"});case"aaaa":default:return B.dayPeriod(Z,{width:"wide",context:"formatting"})}},b:function(A,Q,B){let G=A.getHours(),Z;if(G===12)Z=aIA.noon;else if(G===0)Z=aIA.midnight;else Z=G/12>=1?"pm":"am";switch(Q){case"b":case"bb":return B.dayPeriod(Z,{width:"abbreviated",context:"formatting"});case"bbb":return B.dayPeriod(Z,{width:"abbreviated",context:"formatting"}).toLowerCase();case"bbbbb":return B.dayPeriod(Z,{width:"narrow",context:"formatting"});case"bbbb":default:return B.dayPeriod(Z,{width:"wide",context:"formatting"})}},B:function(A,Q,B){let G=A.getHours(),Z;if(G>=17)Z=aIA.evening;else if(G>=12)Z=aIA.afternoon;else if(G>=4)Z=aIA.morning;else Z=aIA.night;switch(Q){case"B":case"BB":case"BBB":return B.dayPeriod(Z,{width:"abbreviated",context:"formatting"});case"BBBBB":return B.dayPeriod(Z,{width:"narrow",context:"formatting"});case"BBBB":default:return B.dayPeriod(Z,{width:"wide",context:"formatting"})}},h:function(A,Q,B){if(Q==="ho"){let G=A.getHours()%12;if(G===0)G=12;return B.ordinalNumber(G,{unit:"hour"})}return wg.h(A,Q)},H:function(A,Q,B){if(Q==="Ho")return B.ordinalNumber(A.getHours(),{unit:"hour"});return wg.H(A,Q)},K:function(A,Q,B){let G=A.getHours()%12;if(Q==="Ko")return B.ordinalNumber(G,{unit:"hour"});return V7(G,Q.length)},k:function(A,Q,B){let G=A.getHours();if(G===0)G=24;if(Q==="ko")return B.ordinalNumber(G,{unit:"hour"});return V7(G,Q.length)},m:function(A,Q,B){if(Q==="mo")return B.ordinalNumber(A.getMinutes(),{unit:"minute"});return wg.m(A,Q)},s:function(A,Q,B){if(Q==="so")return B.ordinalNumber(A.getSeconds(),{unit:"second"});return wg.s(A,Q)},S:function(A,Q){return wg.S(A,Q)},X:function(A,Q,B){let G=A.getTimezoneOffset();if(G===0)return"Z";switch(Q){case"X":return UM2(G);case"XXXX":case"XX":return l0A(G);case"XXXXX":case"XXX":default:return l0A(G,":")}},x:function(A,Q,B){let G=A.getTimezoneOffset();switch(Q){case"x":return UM2(G);case"xxxx":case"xx":return l0A(G);case"xxxxx":case"xxx":default:return l0A(G,":")}},O:function(A,Q,B){let G=A.getTimezoneOffset();switch(Q){case"O":case"OO":case"OOO":return"GMT"+zM2(G,":");case"OOOO":default:return"GMT"+l0A(G,":")}},z:function(A,Q,B){let G=A.getTimezoneOffset();switch(Q){case"z":case"zz":case"zzz":return"GMT"+zM2(G,":");case"zzzz":default:return"GMT"+l0A(G,":")}},t:function(A,Q,B){let G=Math.trunc(+A/1000);return V7(G,Q.length)},T:function(A,Q,B){return V7(+A,Q.length)}}});var wM2=(A,Q)=>{switch(A){case"P":return Q.date({width:"short"});case"PP":return Q.date({width:"medium"});case"PPP":return Q.date({width:"long"});case"PPPP":default:return Q.date({width:"full"})}},NM2=(A,Q)=>{switch(A){case"p":return Q.time({width:"short"});case"pp":return Q.time({width:"medium"});case"ppp":return Q.time({width:"long"});case"pppp":default:return Q.time({width:"full"})}},T55=(A,Q)=>{let B=A.match(/(P+)(p+)?/)||[],G=B[1],Z=B[2];if(!Z)return wM2(A,Q);let Y;switch(G){case"P":Y=Q.dateTime({width:"short"});break;case"PP":Y=Q.dateTime({width:"medium"});break;case"PPP":Y=Q.dateTime({width:"long"});break;case"PPPP":default:Y=Q.dateTime({width:"full"});break}return Y.replace("{{date}}",wM2(G,Q)).replace("{{time}}",NM2(Z,Q))},qM2;var LM2=q(()=>{qM2={p:NM2,P:T55}});function MM2(A){return j55.test(A)}function OM2(A){return P55.test(A)}function RM2(A,Q,B){let G=x55(A,Q,B);if(console.warn(G),S55.includes(A))throw RangeError(G)}function x55(A,Q,B){let G=A[0]==="Y"?"years":"days of the month";return`Use \`${A.toLowerCase()}\` instead of \`${A}\` (in \`${Q}\`) for formatting ${G} to the input \`${B}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`}var j55,P55,S55;var _M2=q(()=>{j55=/^D+$/,P55=/^Y+$/,S55=["D","DD","YY","YYYY"]});function TM2(A,Q,B){let G=Mn(),Z=B?.locale??G.locale??z70,Y=B?.firstWeekContainsDate??B?.locale?.options?.firstWeekContainsDate??G.firstWeekContainsDate??G.locale?.options?.firstWeekContainsDate??1,J=B?.weekStartsOn??B?.locale?.options?.weekStartsOn??G.weekStartsOn??G.locale?.options?.weekStartsOn??0,I=$I(A,B?.in);if(!YL2(I))throw RangeError("Invalid time value");let X=Q.match(v55).map((K)=>{let V=K[0];if(V==="p"||V==="P"){let E=qM2[V];return E(K,Z.formatLong)}return K}).join("").match(y55).map((K)=>{if(K==="''")return{isToken:!1,value:"'"};let V=K[0];if(V==="'")return{isToken:!1,value:h55(K)};if(q70[V])return{isToken:!0,value:K};if(V.match(b55))throw RangeError("Format string contains an unescaped latin alphabet character `"+V+"`");return{isToken:!1,value:K}});if(Z.localize.preprocessor)X=Z.localize.preprocessor(I,X);let W={firstWeekContainsDate:Y,weekStartsOn:J,locale:Z};return X.map((K)=>{if(!K.isToken)return K.value;let V=K.value;if(!B?.useAdditionalWeekYearTokens&&OM2(V)||!B?.useAdditionalDayOfYearTokens&&MM2(V))RM2(V,Q,String(A));let E=q70[V[0]];return E(I,V,Z.localize,W)}).join("")}function h55(A){let Q=A.match(k55);if(!Q)return A;return Q[1].replace(f55,"'")}var y55,v55,k55,f55,b55;var jM2=q(()=>{VM2();r_A();$M2();LM2();_M2();F70();yN();y55=/[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,v55=/P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,k55=/^'([^]*?)'?$/,f55=/''/g,b55=/[a-zA-Z]/});var PM2=()=>{};var SM2=()=>{};var xM2=()=>{};var yM2=()=>{};var vM2=()=>{};var kM2=()=>{};var fM2=()=>{};var bM2=()=>{};var hM2=()=>{};var gM2=()=>{};var uM2=()=>{};var mM2=()=>{};var dM2=()=>{};var cM2=()=>{};var pM2=()=>{};var lM2=()=>{};var iM2=()=>{};var nM2=()=>{};var aM2=()=>{};var oM2=()=>{};var rM2=()=>{};var sM2=()=>{};var tM2=()=>{};var eM2=()=>{};var AO2=()=>{};var QO2=()=>{};var BO2=()=>{};var GO2=()=>{};var ZO2=()=>{};var YO2=()=>{};var JO2=()=>{};var IO2=()=>{};var XO2=()=>{};var WO2=()=>{};var KO2=()=>{};var VO2=()=>{};var EO2=()=>{};var DO2=()=>{};var HO2=()=>{};var FO2=()=>{};var CO2=()=>{};var zO2=()=>{};var UO2=()=>{};var $O2=()=>{};var wO2=()=>{};var NO2=()=>{};var qO2=()=>{};var LO2=()=>{};var MO2=()=>{};var OO2=()=>{};var RO2=()=>{};var _O2=()=>{};var TO2=()=>{};var jO2=()=>{};var PO2=()=>{};var SO2=()=>{};var xO2=()=>{};var yO2=()=>{};var vO2=()=>{};var kO2=()=>{};var fO2=()=>{};var bO2=()=>{};var hO2=()=>{};var gO2=()=>{};var uO2=()=>{};var mO2=()=>{};var dO2=()=>{};var cO2=()=>{};var pO2=()=>{};var lO2=()=>{};var iO2=()=>{};var nO2=()=>{};var aO2=()=>{};var oO2=()=>{};var rO2=()=>{};var sO2=()=>{};var tO2=()=>{};var eO2=()=>{};var AR2=()=>{};var QR2=()=>{};var BR2=()=>{};var GR2=()=>{};var ZR2=()=>{};var YR2=()=>{};var JR2=()=>{};var IR2=()=>{};var XR2=()=>{};var WR2=()=>{};var KR2=()=>{};var VR2=()=>{};var ER2=()=>{};var DR2=()=>{};var HR2=()=>{};var FR2=()=>{};var CR2=()=>{};var zR2=()=>{};var UR2=()=>{};var $R2=()=>{};var wR2=()=>{};var NR2=()=>{};var qR2=()=>{};var LR2=()=>{};var MR2=()=>{};var OR2=()=>{};var RR2=()=>{};var _R2=()=>{};var TR2=()=>{};var jR2=()=>{};var PR2=()=>{};var SR2=()=>{};var xR2=()=>{};var yR2=()=>{};var vR2=()=>{};var kR2=()=>{};var fR2=()=>{};var bR2=()=>{};var hR2=()=>{};var gR2=()=>{};var uR2=()=>{};var mR2=()=>{};var dR2=()=>{};var cR2=()=>{};var pR2=()=>{};var lR2=()=>{};var iR2=()=>{};var nR2=()=>{};var aR2=()=>{};var oR2=()=>{};var rR2=()=>{};var sR2=()=>{};var tR2=()=>{};var eR2=()=>{};var A_2=()=>{};var Q_2=()=>{};var B_2=()=>{};var G_2=()=>{};var Z_2=()=>{};var Y_2=()=>{};var J_2=()=>{};var I_2=()=>{};var X_2=()=>{};var W_2=()=>{};var K_2=()=>{};var V_2=()=>{};var E_2=()=>{};var D_2=()=>{};var H_2=()=>{};var F_2=()=>{};var C_2=()=>{};var z_2=()=>{};var U_2=()=>{};var $_2=()=>{};var w_2=()=>{};var N_2=()=>{};var q_2=()=>{};var L_2=q(()=>{Tq2();xq2();Rq2();vq2();mq2();yq2();dq2();_q2();cq2();pq2();lq2();iq2();nq2();rq2();sq2();tq2();eq2();AL2();Ln();QL2();BL2();JL2();E70();IL2();XL2();WL2();VL2();EL2();DL2();HL2();FL2();zL2();UL2();$L2();LL2();ML2();OL2();RL2();_L2();TL2();jL2();PL2();SL2();yL2();vL2();kL2();bL2();uL2();mL2();wL2();dL2();cL2();lL2();iL2();nL2();NL2();aL2();oL2();rL2();sL2();pL2();hL2();tL2();jM2();PM2();SM2();xM2();yM2();vM2();kM2();fM2();bM2();hM2();gM2();uM2();mM2();dM2();cM2();U70();pM2();iM2();nM2();aM2();oM2();rM2();$70();V81();sM2();tM2();eM2();AO2();QO2();KL2();BO2();GO2();ZO2();N70();YO2();H81();IO2();XO2();WO2();KO2();VO2();EO2();DO2();HO2();FO2();CO2();zO2();H70();UO2();$O2();wO2();NO2();qO2();qL2();lM2();jO2();PO2();SO2();GL2();yO2();kO2();fO2();hO2();gO2();uO2();dO2();vO2();cO2();jq2();Pq2();pO2();lO2();iO2();nO2();aO2();oO2();rO2();sO2();tO2();eO2();AR2();QR2();F70();BR2();Sq2();GR2();YR2();JR2();XR2();WR2();JO2();KR2();IR2();VR2();ER2();aq2();DR2();HR2();FR2();CR2();oq2();zR2();UR2();$R2();wR2();NR2();qR2();LR2();MR2();OR2();RR2();_R2();TR2();jR2();TO2();PR2();SR2();xR2();yR2();vR2();kR2();fR2();bR2();hR2();gR2();uR2();mR2();dR2();cR2();pR2();lR2();iR2();aR2();oR2();RO2();rR2();sR2();tR2();_O2();OO2();uq2();eR2();A_2();nR2();Q_2();B_2();MO2();G_2();Z_2();V70();Y_2();xO2();s_A();D70();bO2();fL2();xL2();mO2();J_2();I_2();lIA();w70();C70();X_2();K_2();V_2();ZR2();E_2();CL2();D_2();H_2();W_2();F_2();C_2();z_2();U_2();yN();LO2();$_2();w_2();N_2();q_2()});function M_2(){let[A,Q]=t_A.useState([]),[B,G]=t_A.useState(0);if(t_A.useEffect(()=>{let Z=NB.getSandboxViolationStore();return Z.subscribe((J)=>{Q(J.slice(-10)),G(Z.getTotalCount())})},[]),!NB.isSandboxingEnabled()||pQ()==="linux")return null;if(B===0)return null;return SC.createElement(j,{flexDirection:"column",marginTop:1},SC.createElement(j,{marginLeft:0},SC.createElement(z,{color:"permission"},"‚ßà Sandbox blocked ",B," total"," ",B===1?"operation":"operations")),A.map((Z,Y)=>SC.createElement(j,{key:`${Z.timestamp.getTime()}-${Y}`,paddingLeft:2},SC.createElement(z,{dimColor:!0},TM2(Z.timestamp,"h:mm:ssa"),Z.command?` ${Z.command}:`:""," ",Z.line))),SC.createElement(j,{paddingLeft:2},SC.createElement(z,{dimColor:!0},"‚Ä¶ showing last ",Math.min(10,A.length)," of ",B)))}var SC,t_A;var O_2=q(()=>{hA();BI();L_2();Z8();SC=o(KA(),1),t_A=o(KA(),1)});function F81(){let{addNotification:A}=fG(),[Q,B]=oIA.useState(()=>{let{errors:Z}=Gy();return Z}),G=oIA.useCallback(()=>{let{errors:Z}=Gy();B(Z)},[]);return I8A(G),oIA.useEffect(()=>{if(Q.length>0){let Z=`Found ${Q.length} invalid settings ${Q.length===1?"file":"files"} ¬∑ /doctor for details`,Y=!1,J="inactive",I=8000;A({key:"settings-errors",text:Z,color:"inactive",priority:"high",timeoutMs:8000})}},[Q,A]),Q}var oIA;var L70=q(()=>{gB();icA();TC();oIA=o(KA(),1)});function __2({mcpClients:A=[]}){let{addNotification:Q}=fG();R_2.useEffect(()=>{let B=A.filter((Z)=>Z.type==="failed"&&Z.config.type!=="sse-ide"&&Z.config.type!=="ws-ide"),G=A.filter((Z)=>Z.type==="needs-auth");if(B.length===0&&G.length===0)return;if(B.length>0)Q({key:"mcp-failed",jsx:lV.createElement(lV.Fragment,null,lV.createElement(z,{color:"error"},B.length," MCP"," ",B.length===1?"server":"servers"," failed"),lV.createElement(z,{dimColor:!0}," ¬∑ /mcp for info")),priority:"medium"});if(G.length)Q({key:"mcp-needs-auth",jsx:lV.createElement(lV.Fragment,null,lV.createElement(z,{color:"warning"},G.length," MCP"," ",G.length===1?"server needs":"servers need"," ","auth"),lV.createElement(z,{dimColor:!0}," ¬∑ /mcp for info")),priority:"medium"})},[Q,A])}var lV,R_2;var T_2=q(()=>{hA();TC();lV=o(KA(),1),R_2=o(KA(),1)});function j_2(){let{addNotification:A}=fG(),[Q]=RQ(),{installationStatus:B}=Q.plugins,{totalFailed:G,failedMarketplacesCount:Z,failedPluginsCount:Y}=C81.useMemo(()=>{if(!B)return{totalFailed:0,failedMarketplacesCount:0,failedPluginsCount:0};let J=B.marketplaces.filter((X)=>X.status==="failed"),I=B.plugins.filter((X)=>X.status==="failed");return{totalFailed:J.length+I.length,failedMarketplacesCount:J.length,failedPluginsCount:I.length}},[B]);C81.useEffect(()=>{if(!B){f("No installation status to monitor");return}if(G===0)return;if(f(`Plugin installation status: ${Z} failed marketplaces, ${Y} failed plugins`),G===0)return;f(`Adding notification for ${G} failed installations`),A({key:"plugin-install-failed",jsx:dy.createElement(dy.Fragment,null,dy.createElement(z,{color:"error"},G," plugin",G===1?"":"s"," failed to install"),dy.createElement(z,{dimColor:!0}," ¬∑ /plugin for details")),priority:"medium"})},[A,G,Z,Y])}var dy,C81;var P_2=q(()=>{hA();TC();f2();Q0();dy=o(KA(),1),C81=o(KA(),1)});async function S_2(){let A=CQ(),Q=new Map;if(A.extraKnownMarketplaces)for(let[B,G]of Object.entries(A.extraKnownMarketplaces))Q.set(B,G);return Q}async function x_2(A){try{let Q=await _5(),B=[];for(let[G]of A)if(!Q[G])B.push(G);return B}catch(Q){return r(Q instanceof Error?Q:Error(String(Q))),[]}}function y_2(){(async()=>{if(si())return;try{let A=await _5(),Q=Object.keys(A);if(Q.length===0)return;f(`Auto-updating ${Q.length} installed marketplaces in background`),await Promise.allSettled(Q.map(async(B)=>{try{f(`Auto-updating marketplace "${B}"`),await up(B),f(`Successfully auto-updated marketplace "${B}"`)}catch(G){f(`Failed to auto-update marketplace "${B}": ${G instanceof Error?G.message:String(G)}`,{level:"warn"})}}))}catch(A){f(`Failed to auto-update: ${A instanceof Error?A.message:String(A)}`,{level:"error"})}})()}var M70=q(()=>{gB();aW();g1();Q0();vQ()});import{rename as O70}from"fs/promises";import{existsSync as g55,mkdirSync as v_2,rmSync as u55}from"fs";import{dirname as k_2,sep as f_2,join as m55}from"path";import{tmpdir as d55}from"os";function b_2(){return new Date().toISOString()}async function xC(A,Q,B="user",G,Z){let Y=typeof Q.source==="string"&&Z?Z:Q.source,J=await ie(Y,{manifest:Q}),I=await Y81(J.path),X=b_2(),W=J.manifest.version||Q.version||"unknown",K=typeof Q.source==="string",V=eS(A,W),E=J.path;if(J.path!==V){if(v_2(k_2(V),{recursive:!0}),g55(V))u55(V,{recursive:!0,force:!0});let D=J.path.endsWith(f_2)?J.path:J.path+f_2;if(V.startsWith(D)){let F=m55(d55(),`claude-plugin-temp-${Date.now()}`);await O70(J.path,F),v_2(k_2(V),{recursive:!0}),await O70(F,V)}else await O70(J.path,V);E=V}return G70(A,{version:W,installedAt:X,lastUpdated:X,installPath:E,gitCommitSha:I,isLocal:K},B,G),E}function h_2(A,Q="user",B){let G=b_2();G70(A.pluginId,{version:A.version||"unknown",installedAt:G,lastUpdated:G,installPath:A.installPath,isLocal:!0},Q,B)}var i0A=q(()=>{cT();GW()});import{join as c55}from"path";async function R70(){let A=CQ(),Q=[];if(A.enabledPlugins){for(let[B,G]of Object.entries(A.enabledPlugins))if(B.includes("@")&&G)Q.push(B)}return Q}function g_2(){let A=new Map,Q=[{scope:"managed",source:"policySettings"},{scope:"user",source:"userSettings"},{scope:"project",source:"projectSettings"},{scope:"local",source:"localSettings"},{scope:"flag",source:"flagSettings"}];for(let{scope:B,source:G}of Q){let Z=uB(G);if(!Z?.enabledPlugins)continue;for(let[Y,J]of Object.entries(Z.enabledPlugins)){if(!Y.includes("@"))continue;if(J===!0)A.set(Y,B);else if(J===!1)A.delete(Y)}}return f(`Found ${A.size} enabled plugins with scopes: ${Array.from(A.entries()).map(([B,G])=>`${B}(${G})`).join(", ")}`),A}async function _70(){Z70().catch((B)=>{r(B instanceof Error?B:Error(String(B)))});let A=B70(),Q=Object.keys(A.plugins);return f(`Found ${Q.length} installed plugins (V2 format)`),Q}async function u_2(A){try{let Q=await _70(),B=[];for(let G of A)if(!Q.includes(G))try{if(await VH(G))B.push(G)}catch(Z){f(`Failed to check plugin ${G} in marketplace: ${Z}`)}return B}catch(Q){return r(Q instanceof Error?Q:Error(String(Q))),[]}}async function m_2(A,Q,B="user"){let G=B!=="user"?s1():void 0,Z=uy(B),Y=uB(Z),J={...Y?.enabledPlugins},I=[],X=[];for(let W=0;W<A.length;W++){let K=A[W];if(!K)continue;if(Q)Q(K,W+1,A.length);try{let V=await VH(K);if(!V){X.push({name:K,error:"Plugin not found in any marketplace"});continue}let{entry:E,marketplaceInstallLocation:D}=V;if(!__(E.source))await xC(K,E,B,G);else h_2({pluginId:K,installPath:c55(D,E.source),version:E.version},B,G);J[K]=!0,I.push(K)}catch(V){let E=V instanceof Error?V.message:String(V);X.push({name:K,error:E}),r(V instanceof Error?V:Error(String(V)))}}return X2(Z,{...Y,enabledPlugins:J}),{installed:I,failed:X}}var T70=q(()=>{gB();aW();g1();Q0();GW();gB();YQ();sL();i0A();pIA();pB();cT()});import{join as p55,basename as l55}from"path";function d_2(A,Q){let B=[],G=jA();function Z(Y){try{let J=G.readdirSync(Y);for(let I of J){let X=p55(Y,I.name);if(I.isDirectory())Z(X);else if(I.isFile()&&I.name.endsWith(".md")){let W=c_2(X,Q);if(W)B.push(W)}}}catch(J){f(`Failed to scan output-styles directory ${Y}: ${J}`,{level:"error"})}}return Z(A),B}function c_2(A,Q){let B=jA();try{let G=B.readFileSync(A,{encoding:"utf-8"}),{frontmatter:Z,content:Y}=dW(G),J=l55(A,".md"),I=Z.name||J,X=`${Q}:${I}`,W=Z.description||gy(Y,`Output style from ${Q} plugin`);return{name:X,description:W,prompt:Y.trim(),source:"plugin"}}catch(G){return f(`Failed to load output style from ${A}: ${G}`,{level:"error"}),null}}function P70(){j70.cache?.clear?.()}var j70;var z81=q(()=>{p2();YQ();GW();Q0();Zy();j70=Z0(async()=>{let{enabled:A,errors:Q}=await J7(),B=[];if(Q.length>0)f(`Plugin loading errors: ${Q.map((G)=>WM(G)).join(", ")}`);for(let G of A){if(G.outputStylesPath)try{let Z=d_2(G.outputStylesPath,G.name);if(B.push(...Z),Z.length>0)f(`Loaded ${Z.length} output styles from plugin ${G.name} default directory`)}catch(Z){f(`Failed to load output styles from plugin ${G.name} default directory: ${Z}`,{level:"error"})}if(G.outputStylesPaths)for(let Z of G.outputStylesPaths)try{let J=jA().statSync(Z);if(J.isDirectory()){let I=d_2(Z,G.name);if(B.push(...I),I.length>0)f(`Loaded ${I.length} output styles from plugin ${G.name} custom path: ${Z}`)}else if(J.isFile()&&Z.endsWith(".md")){let I=c_2(Z,G.name);if(I)B.push(I),f(`Loaded output style from plugin ${G.name} custom file: ${Z}`)}}catch(Y){f(`Failed to load output styles from plugin ${G.name} custom path ${Z}: ${Y}`,{level:"error"})}}return f(`Total plugin output styles loaded: ${B.length}`),B})});function i55(){mp(),O61(),F02(),oa1(),P70()}function VZ(){i55(),p_2()}var Ng=q(()=>{GW();R_A();pMA();$qA();z81();VC()});import{join as S70,dirname as n55}from"path";function U81(A){if(!yC.includes(A))throw Error(`Invalid scope "${A}". Must be one of: ${yC.join(", ")}`)}function On(A){return yC.includes(A)}function Lg(A){return A==="project"||A==="local"?cQ():void 0}function a55(A,Q,B){let G="";if(Object.keys(B?.enabledPlugins||{}).forEach((Z)=>{if(Z===A||Z===Q.name||Z.startsWith(`${Q.name}@`))G=Z}),!G)G=A.includes("@")?A:Q.name;return G}function l_2(A,Q){let{name:B,marketplace:G}=Z81(A);return Q.find((Z)=>{if(Z.name===A||Z.name===B)return!0;if(G&&Z.source)return Z.name===B&&Z.source.includes(`@${G}`);return!1})}function qg(A){let B=J$().plugins[A];if(!B||B.length===0)return{scope:"user"};let G=cQ(),Z=B.find((I)=>I.scope==="local"&&I.projectPath===G);if(Z)return{scope:Z.scope,projectPath:Z.projectPath};let Y=B.find((I)=>I.scope==="project"&&I.projectPath===G);if(Y)return{scope:Y.scope,projectPath:Y.projectPath};let J=B.find((I)=>I.scope==="user");if(J)return{scope:J.scope};return{scope:B[0].scope,projectPath:B[0].projectPath}}function o55(A,Q,B,G){let Z=G||qg(A),{scope:Y}=Z,J=uy(Y),X={...uB(J)?.enabledPlugins};if(Object.keys(X).forEach((K)=>{if(K===A||K===B.name||K.startsWith(`${B.name}@`))X[K]=Q}),!(A in X))X[A]=Q;let{error:W}=X2(J,{enabledPlugins:X});if(W)throw W;VZ()}async function i_2(A,Q="user"){U81(Q);let{name:B,marketplace:G}=Z81(A),Z,Y,J;if(G){let C=await VH(A);if(C)Z=C.entry,Y=G,J=C.marketplaceInstallLocation}else{let C=await _5();for(let[$,O]of Object.entries(C))try{let L=(await uw($)).plugins.find((_)=>_.name===B);if(L){Z=L,Y=$,J=O.installLocation;break}}catch(M){r(M instanceof Error?M:Error(`Failed to load marketplace "${$}": ${M}`));continue}}if(!Z||!Y){let C=G?`marketplace "${G}"`:"any configured marketplace";return{success:!1,message:`Plugin "${B}" not found in ${C}`}}let I=Z,X=`${I.name}@${Y}`,W=Lg(Q),K,{source:V}=I;if(__(V)){if(!J)return{success:!1,message:`Cannot install local plugin "${B}" without marketplace install location`};K=S70(J,V)}await xC(X,I,Q,W,K);let E=uy(Q),H={...uB(E)?.enabledPlugins,[X]:!0},{error:F}=X2(E,{enabledPlugins:H});if(F)return{success:!1,message:`Failed to update settings: ${F.message}`};return VZ(),{success:!0,message:`Successfully installed plugin: ${X} (scope: ${Q})`,pluginId:X,pluginName:I.name,scope:Q}}async function ATA(A,Q="user"){U81(Q);let{enabled:B,disabled:G}=await J7(),Z=[...B,...G],Y=l_2(A,Z);if(!Y)return{success:!1,message:`Plugin "${A}" not found in installed plugins`};let J=uy(Q),I=uB(J),X=a55(A,Y,I),W=Lg(Q),V=J$().plugins[X],E=V?.find(($)=>$.scope===Q&&$.projectPath===W);if(!E){let{scope:$}=qg(X);if($!==Q&&V&&V.length>0)return{success:!1,message:`Plugin "${A}" is installed in ${$} scope, not ${Q}. Use --scope ${$} to uninstall.`};return{success:!1,message:`Plugin "${A}" is not installed in ${Q} scope. Use --scope to specify the correct scope.`}}let D=E.installPath,H={...I?.enabledPlugins};H[X]=void 0,X2(J,{enabledPlugins:H}),VZ(),Eq2(X,Q,W);let C=J$().plugins[X];if((!C||C.length===0)&&D);return{success:!0,message:`Successfully uninstalled plugin: ${Y.name} (scope: ${Q})`,pluginId:X,pluginName:Y.name,scope:Q}}async function n_2(A,Q,B){let G=Q?"enable":"disable";if(B)U81(B);let{enabled:Z,disabled:Y}=await J7(),I=l_2(A,Q?Y:Z);if(!I)return{success:!1,message:`Plugin "${A}" not found in ${Q?"disabled":"enabled"} plugins`};let X=A.includes("@")?A:`${I.name}@${I.source?.split("@")[1]||"unknown"}`,W;if(B){let K=Lg(B);W={scope:B,projectPath:K};let V=qg(X);if(V.scope!==B)return{success:!1,message:`Plugin "${A}" is installed at ${V.scope} scope, not ${B}. Use --scope ${V.scope} or omit --scope to auto-detect.`}}else W=qg(X);if(!On(W.scope))return{success:!1,message:`Managed plugins cannot be ${G}d. They can only be updated.`};try{o55(X,Q,I,W)}catch(K){return{success:!1,message:K instanceof Error?K.message:`Failed to ${G} plugin`}}return{success:!0,message:`Successfully ${G}d plugin: ${I.name} (scope: ${W.scope})`,pluginId:X,pluginName:I.name,scope:W.scope}}async function n0A(A,Q){return n_2(A,!0,Q)}async function QTA(A,Q){return n_2(A,!1,Q)}async function BTA(A,Q){let{name:B,marketplace:G}=Z81(A),Z=G?`${B}@${G}`:A,Y=await VH(A);if(!Y)return{success:!1,message:`Plugin "${B}" not found`,pluginId:Z,scope:Q};let{entry:J,marketplaceInstallLocation:I}=Y,W=J81().plugins[Z];if(!W||W.length===0)return{success:!1,message:`Plugin "${B}" is not installed`,pluginId:Z,scope:Q};let K=Lg(Q),V=W.find((E)=>E.scope===Q&&E.projectPath===K);if(!V){let E=K?`${Q} (${K})`:Q;return{success:!1,message:`Plugin "${B}" is not installed at scope ${E}`,pluginId:Z,scope:Q}}return r55({pluginId:Z,pluginName:B,entry:J,marketplaceInstallLocation:I,installation:V,scope:Q,projectPath:K})}async function r55({pluginId:A,pluginName:Q,entry:B,marketplaceInstallLocation:G,installation:Z,scope:Y,projectPath:J}){let I=jA(),X=Z.version,W,K,V=!1;if(typeof B.source!=="string"){let E=await ie(B.source,{manifest:{name:B.name}});W=E.path,V=!0,K=await pe(A,B.source,E.manifest,E.path,B.version)}else{if(!I.existsSync(G))return{success:!1,message:`Marketplace directory not found at ${G}`,pluginId:A,scope:Y};let E=I.statSync(G).isDirectory()?G:n55(G);if(W=S70(E,B.source),!I.existsSync(W))return{success:!1,message:`Plugin source not found at ${W}`,pluginId:A,scope:Y};let D,H=S70(W,".claude-plugin","plugin.json");try{D=$sA(H,B.name,B.source)}catch{}K=await pe(A,B.source,D,W,B.version)}try{let E=eS(A,K);if(Z.version===K||Z.installPath===E)return{success:!0,message:`${Q} is already at the latest version (${K}).`,pluginId:A,newVersion:K,oldVersion:X,alreadyUpToDate:!0,scope:Y};if(!I.existsSync(E))await UsA(W,A,K,B);let H=Z.installPath;if(Dq2(A,Y,J,E,K),H&&H!==E){let $=J81();if(!Object.values($.plugins).some((M)=>M.some((L)=>L.installPath===H))&&I.existsSync(H));}let F=J?`${Y} (${J})`:Y;return{success:!0,message:`Plugin "${Q}" updated from ${X||"unknown"} to ${K} for scope ${F}. Restart to apply changes.`,pluginId:A,newVersion:K,oldVersion:X,scope:Y}}finally{if(V&&W!==eS(A,K))I.rmSync(W,{recursive:!0,force:!0})}}var yC,e_A;var GTA=q(()=>{GW();cT();i0A();aW();sL();gB();Ng();pIA();u0();Lp1();YQ();g1();yC=["user","project","local"],e_A=["user","project","local","managed"]});import{join as s55}from"path";function x70(A,Q,B,G){A((Z)=>({...Z,plugins:{...Z.plugins,installationStatus:{...Z.plugins.installationStatus,marketplaces:Z.plugins.installationStatus.marketplaces.map((Y)=>Y.name===Q?{...Y,status:B,error:G}:Y)}}}))}function y70(A,Q,B,G){A((Z)=>({...Z,plugins:{...Z.plugins,installationStatus:{...Z.plugins.installationStatus,plugins:Z.plugins.installationStatus.plugins.map((Y)=>Y.id===Q?{...Y,status:B,error:G}:Y)}}}))}async function t55(A,Q,B){let G=[],Z=[];for(let Y of A){let J=Q.get(Y);if(!J)continue;x70(B,Y,"installing");try{await T_(J.source),G.push(Y),x70(B,Y,"installed"),CsA(),mp(),await e55(Y,B)}catch(I){let X=I instanceof Error?I.message:String(I);Z.push({name:Y,error:X}),x70(B,Y,"failed",X),r(I instanceof Error?I:Error(String(I)))}}return{installed:G,failed:Z}}async function e55(A,Q){try{let G=(await R70()).filter((Z)=>Z.endsWith(`@${A}`));if(G.length>0){let Z=await u_2(G);if(Z.length>0)f(`Installing ${Z.length} plugins from newly installed marketplace ${A}`),await a_2(Z,Q)}}catch(B){r(B instanceof Error?B:Error(String(B)))}}async function a_2(A,Q){let B=[],G=[],Z=g_2(),Y=new Map;for(let J of A){y70(Q,J,"installing");try{let I=await VH(J);if(!I)throw Error("Plugin not found in any marketplace");let X=Z.get(J),{entry:W,marketplaceInstallLocation:K}=I,V=__(W.source)?s55(K,W.source):void 0;if(X==="flag"){let E=V??W.source;await ie(E,{manifest:W})}else{let E=X||"user",D=Lg(E);if(await xC(J,W,E,D,V),E!=="managed"){if(CQ().enabledPlugins?.[J]!==!0){let C=Y.get(E)??{};C[J]=!0,Y.set(E,C)}}}B.push(J),y70(Q,J,"installed")}catch(I){let X=I instanceof Error?I.message:String(I);G.push({name:J,error:X}),y70(Q,J,"failed",X),r(I instanceof Error?I:Error(String(I)))}}for(let[J,I]of Y)if(Object.keys(I).length>0){let X=uy(J),W=uB(X);X2(X,{...W,enabledPlugins:{...W?.enabledPlugins,...I}})}return{installed:B,failed:G}}async function $81(A){f("performBackgroundPluginInstallations called");try{let Q=[],B=[],G=await _5(),Z=await S_2();if(Z.size>0){f(`Found ${Z.size} extra marketplaces in settings`);let I=await x_2(Z);if(I.length>0){f(`Installing ${I.length} marketplaces automatically`);for(let X of I){let W=Z.get(X);if(W)Q.push({name:X,marketplace:W})}}}let Y=await R70(),J=[];if(Y.length>0){f(`Found ${Y.length} enabled plugins`);let I=await _70(),X=Y.filter((K)=>!I.includes(K));f(`Found ${X.length} missing plugins (not installed): ${X.join(", ")}`);let W=[];for(let K of X){let[,V]=K.split("@");if(!V)W.push(K);else if(V in G||Z.has(V)||Q.some((E)=>E.name===V))W.push(K);else J.push(K)}if(J.length>0){let K=[...new Set(J.map((V)=>V.split("@")[1]))];f(`Cannot install ${J.length} plugins because their marketplaces are not installed or configured: ${K.join(", ")}`),f(`Uninstallable plugins: ${J.join(", ")}`)}if(W.length>0)f(`Installing ${W.length} plugins automatically`),B.push(...W)}if(f(`Setting installation status: ${Q.length} marketplaces, ${B.length} installable plugins, ${J.length} uninstallable plugins`),A((I)=>({...I,plugins:{...I.plugins,installationStatus:{marketplaces:Q.map(({name:X})=>({name:X,status:"pending"})),plugins:[...B.map((X)=>{let[W]=X.split("@");return{id:X,name:W||X,status:"pending"}}),...J.map((X)=>{let[W,K]=X.split("@");return{id:X,name:W||X,status:"failed",error:`Marketplace '${K}' is not installed or configured`}})]}}})),Q.length>0)t55(Q.map((I)=>I.name),Z,A).catch((I)=>{r(I instanceof Error?I:Error(String(I)))});if(B.length>0){let I=B.filter((X)=>{let[,W]=X.split("@");return!Q.some((K)=>K.name===W)});if(I.length>0)a_2(I,A).catch((X)=>{r(X instanceof Error?X:Error(String(X)))})}}catch(Q){r(Q instanceof Error?Q:Error(String(Q)))}}var v70=q(()=>{Q0();g1();M70();T70();pIA();GTA();aW();aW();GW();i0A();sL();gB()});async function o_2(A){if(f("performStartupChecks called"),!tZ(!0)){f("Trust not accepted for current directory - skipping plugin installations");return}try{f("Starting background plugin installations"),await $81(A)}catch(Q){f(`Error initiating background plugin installations: ${Q}`)}}var r_2=q(()=>{Q0();v70();vQ()});function s_2(A){let{addNotification:Q}=fG(),B=PeA(),G=Ea1(B,A),Z=Da1(B),Y=a0A.useRef(null),[J,I]=a0A.useState(!1);a0A.useEffect(()=>{if(B.isUsingOverage&&!J)Q({key:"limit-reached",text:Z,priority:"immediate"}),I(!0);else if(!B.isUsingOverage&&J)I(!1)},[B.isUsingOverage,Z,J,Q]),a0A.useEffect(()=>{if(G&&G!==Y.current)Y.current=G,Q({key:"rate-limit-warning",jsx:ZTA.createElement(z,null,ZTA.createElement(z,{color:"warning"},G)),priority:"high"})},[G,Q])}var ZTA,a0A;var t_2=q(()=>{TC();ql();hA();ZTA=o(KA(),1),a0A=o(KA(),1)});function A75(A){let Q=A.toLowerCase(),B=_3();if(Q.includes("claude-3-opus"))return{isDeprecated:!0,modelName:"Claude 3 Opus",retirementDate:B==="bedrock"?"January 15, 2026":"January 5, 2026"};if(Q.includes("claude-3-7-sonnet")){let G;if(B==="vertex")G="May 11, 2026";else if(B==="bedrock")G="April 28, 2026";else G="February 10, 2026";return{isDeprecated:!0,modelName:"Claude 3.7 Sonnet",retirementDate:G}}return{isDeprecated:!1}}function w81(A){if(!A)return null;let Q=A75(A);if(!Q.isDeprecated)return null;return`‚ö† ${Q.modelName} will be retired on ${Q.retirementDate}. Consider switching to a newer model.`}var k70=q(()=>{hW()});function e_2(A){let{addNotification:Q}=fG(),B=N81.useRef(null);N81.useEffect(()=>{let G=w81(A);if(G&&G!==B.current)B.current=G,Q({key:"model-deprecation-warning",text:G,color:"warning",priority:"high"});if(!G)B.current=null},[A,Q])}var N81;var AT2=q(()=>{TC();k70();N81=o(KA(),1)});function BT2({ideSelection:A,mcpClients:Q,ideInstallationStatus:B}){let{addNotification:G}=fG(),Z=CIA(Q),Y=B?O_(B?.ideType):!1,J=B?.error||Y,I=Z==="connected"&&(A?.filePath||A?.text&&A.lineCount>0),X=Z==="connected"&&!I,W=J&&!Y&&!X&&!I,K=J&&Y&&!X&&!I;QT2.useEffect(()=>{if(BW()||Z!==null)return;kwA(!0).then((V)=>{if(V.length>0){let E=V[0]?.name;if(E&&!K)G({key:"ide-status-hint",jsx:pT.createElement(z,{dimColor:!0},X1.circle," /ide for ",Q75(E)),priority:"low"});else if(!W&&Z==="disconnected")G({key:"ide-status-disconnected",jsx:pT.createElement(z,{color:"error",key:"ide-status"},X1.circle," IDE disconnected"),priority:"medium"});else if(K)G({key:"ide-status-jetbrains-disconnected",jsx:pT.createElement(z,{dimColor:!0},"IDE plugin not connected ¬∑ /status for info"),priority:"medium"});else if(X)G({key:"ide-status-connected",jsx:pT.createElement(z,{color:"ide",key:"ide-status"},X1.circle,"IDE connected"),priority:"low"});else if(W)G({key:"ide-status-install-error",jsx:pT.createElement(z,{color:"error"},"IDE extension install failed (see /status for info)"),priority:"medium"})}})},[G,Z,X,W,K])}function Q75(A){if(A==="Visual Studio Code")return"VS Code";return A}var QT2,pT;var GT2=q(()=>{TC();RJ();q31();hA();v2();QT2=o(KA(),1),pT=o(KA(),1)});function YT2(){let{addNotification:A}=fG();ZT2.useEffect(()=>{let B=c1().sonnet45MigrationTimestamp;if(B){if(Date.now()-B<3000)A({key:"sonnet-4.5-update",text:"Model updated to Sonnet 4.5",color:"suggestion",priority:"high",timeoutMs:3000})}},[A])}var ZT2;var JT2=q(()=>{TC();vQ();ZT2=o(KA(),1)});function XT2(){let{addNotification:A}=fG();IT2.useEffect(()=>{if(c1().subscriptionNoticeCount??0>=B75)return;G75().then((Q)=>{if(Q===null)return;i0((B)=>({...B,subscriptionNoticeCount:(B.subscriptionNoticeCount??0)+1})),s("tengu_switch_to_subscription_notice_shown",{}),A({key:"switch-to-subscription",jsx:YTA.createElement(z,{color:"suggestion"},"Use your existing Claude ",Q," plan with Claude Code",YTA.createElement(z,{color:"text",dimColor:!0}," ","¬∑ /login to activate")),priority:"low"})})},[A])}async function G75(){if(LB())return null;let A=await myA();if(!A)return null;if(A.account.has_claude_max)return"Max";if(A.account.has_claude_pro)return"Pro";return null}var YTA,IT2,B75=3;var WT2=q(()=>{hA();rKA();vQ();_0();V2();TC();YTA=o(KA(),1),IT2=o(KA(),1)});function KT2(){let A=q81.useRef(!1);q81.useEffect(()=>{if(A.current)return;A.current=!0,$w2()},[])}var q81;var VT2=q(()=>{T50();q81=o(KA(),1)});function ET2({onRun:A,onCancel:Q,reason:B}){let G=rIA.useRef(!1);return f1(rIA.useCallback((Z,Y)=>{if(Y.escape)Q()},[Q])),rIA.useEffect(()=>{if(!G.current)G.current=!0,A()},[A]),KD.createElement(j,{flexDirection:"column",marginTop:1},KD.createElement(j,null,KD.createElement(z,{bold:!0},"Running /issue to capture feedback...")),KD.createElement(j,null,KD.createElement(z,{dimColor:!0},"Press ",KD.createElement(L0,{shortcut:"Esc",action:"cancel"})," anytime")),KD.createElement(j,null,KD.createElement(z,{dimColor:!0},"Reason: ",B)))}function f70(A){return!1;switch(A){case"feedback_survey_bad":return!0;case"feedback_survey_good":default:return!1}}function DT2(A){switch(A){case"feedback_survey_bad":return'You responded "Bad" to the feedback survey';case"feedback_survey_good":return'You responded "Good" to the feedback survey';default:return"Unknown reason"}}var KD,rIA;var HT2=q(()=>{hA();t4();KD=o(KA(),1),rIA=o(KA(),1)});import{randomUUID as b70}from"crypto";function FT2({mainThreadAgentDefinition:A,toolUseContext:Q,customSystemPrompt:B,defaultSystemPrompt:G,appendSystemPrompt:Z}){let Y=A?gM(A)?A.getSystemPrompt({toolUseContext:{options:Q.options}}):A.getSystemPrompt():void 0;return[...Y?[Y]:B?[B]:G,...Z?[Z]:[]]}function r0A({commands:A,debug:Q,initialPrompt:B,initialTools:G,initialMessages:Z,initialFileHistorySnapshots:Y,mcpClients:J,dynamicMcpConfig:I,mcpCliEndpoint:X,autoConnectIdeFlag:W,strictMcpConfig:K=!1,systemPrompt:V,appendSystemPrompt:E,onBeforeQuery:D,onTurnComplete:H,disabled:F=!1,mainThreadAgentDefinition:C,disableSlashCommands:$=!1}){let[O,M]=RQ(),{toolPermissionContext:L,verbose:_,mcp:T,plugins:x,agentDefinitions:b}=O,v=En(),m=YB.useMemo(()=>LH(L),[L]);$q2();let[u,e]=YB.useState(I),p=YB.useCallback((v0)=>{e(v0)},[e]),[k,c]=YB.useState("prompt"),[t,AA]=YB.useState(1),[VA,OA]=YB.useState(!1),{addNotification:IA}=fG(),PA=Gw2(J,T.clients),[kA,YA]=YB.useState(void 0),[ZA,zA]=YB.useState(null),[bA,TA]=YB.useState(null),[B1,JA]=YB.useState(!1);YT2(),XT2(),BT2({ideSelection:kA,mcpClients:PA,ideInstallationStatus:bA}),__2({mcpClients:PA}),j_2(),F81(),s_2(v),e_2(v),oN2(),Zq2();let CA=YB.useMemo(()=>{return[...m,...G]},[m,G]);_61(),YB.useEffect(()=>{o_2(M)},[M]),YB.useEffect(()=>{},[M]);let MA=L61(CA,T.tools),NA=YB.useMemo(()=>{if(!C)return MA;let{resolvedTools:v0}=Ri(C,MA,!1);return v0},[C,MA]),UA=N50(A,x.commands),LA=N50(UA,T.commands),nA=YB.useMemo(()=>$?[]:LA,[$,LA]);i02(T.clients),MN2(T.clients,YA);let[gA,I1]=YB.useState("responding"),[q1,_A]=YB.useState([]),[Q1,h1]=YB.useState(null),[_1,V0]=YB.useState(!1),[AQ,n0]=YB.useState(0),[JQ,BQ]=YB.useState(void 0),F1=YB.useCallback((v0)=>{if(V0(v0),v0)n0(0)},[]);X7(()=>{if(_1&&$5!=="tool-permission")n0((v0)=>v0+100)},100);let[eA,K1]=YB.useState(null);YB.useEffect(()=>{if(eA?.notifications)eA.notifications.forEach((v0)=>{IA({key:"auto-updater-notification",text:v0,priority:"low"})})},[eA,IA]);let[O1,G0]=YB.useState(null),[$0,F0]=YB.useState([]),[HA,$A]=YB.useState([]),[A1,N1]=YB.useState(Z??[]);KT2();let[C1,D1]=YB.useState([]),[B0,i1]=YB.useState(""),[P0,IQ]=YB.useState("prompt"),[fB,oQ]=YB.useState(),[H2,d0]=YB.useState({}),[NQ,RB]=YB.useState(0),[z9,JB]=YB.useState(0),[V1,iA]=YB.useState(0),[z1,A0]=YB.useState(null),[E0,xQ]=YB.useState(null),[eB,X9]=YB.useState(null),[Q9,y4]=YB.useState(!1),[B9,$3]=YB.useState(!1),[w3,C4]=YB.useState(b70()),[O9,N3]=YB.useState(c1().hasAcknowledgedCostThreshold),[p9,v5]=YB.useState(new Set),[M6,q3]=YB.useState("INSERT"),[l9,s0]=YB.useState(!1),[mQ,XB]=YB.useState(!1),[e9,x2]=YB.useState(!1),[WG,gG]=YB.useState(!1),[f6,b6]=YB.useState(!1),aA=YB.useRef(!1),WA=YB.useRef(null),[BA]=E2(),xA=YB.useCallback(()=>{Fq2({theme:BA,readFileState:HB.current}).then(async(v0)=>{if(v0){let FB=await v0.content({theme:BA});M((K2)=>({...K2,spinnerTip:FB})),Cq2(v0)}else M((FB)=>({...FB,spinnerTip:void 0}))})},[M,BA]),fA=YB.useCallback(()=>{F1(!1),BQ(void 0),JB(0),_A([]),A0(null),xQ(null),X9(null),xA(),O01()},[F1,xA]),uA=_$2(B0),w1=(!O1||O1.showSpinner===!0)&&$0.length===0&&(_1||JQ)&&!O.pendingWorkerRequest,x1=mN2(A1,_1,NQ),k1=YB.useMemo(()=>({...x1,handleSelect:(v0)=>{if(x1.handleSelect(v0),v0==="bad"&&f70("feedback_survey_bad")||v0==="good"&&f70("feedback_survey_good"))k5(v0==="bad"?"feedback_survey_bad":"feedback_survey_good")}}),[x1]),n1=cN2(A1,_1);vN2({autoConnectIdeFlag:W,ideToInstallExtension:ZA,setDynamicMcpConfig:e,setShowIdeOnboarding:JA,setIDEInstallationState:TA}),Nq2(Y,O.fileHistory,(v0)=>M((FB)=>({...FB,fileHistory:v0})));let p1=YB.useCallback(async(v0,FB,K2)=>{s("tengu_session_resumed",{entrypoint:K2});let J6=wqA(FB.messages),M3=await NU("resume",v0);if(J6.push(...M3),ieA(FB),OoA(FB),FB.fileHistorySnapshots)dGA(FB.fileHistorySnapshots,(g3)=>{M((A4)=>({...A4,fileHistory:g3}))}),QeA(FB);if(j2(J6,FB.projectPath??cQ()),fA(),h1(null),!AH())await JI();C4(v0);let g2=NT1(v0);if(qT1(),wWA(),y$(v0),await DM(),g2)NPA(g2);N1(()=>J6),G0(null),i1(""),D1([])},[fA,M]),z0=W0(),qQ=YB.useMemo(()=>Ml(W0()),[]),HB=YB.useRef((()=>{let v0=tb(L81);return v0.set(qQ,{content:JSON.stringify(O.todos[z0]||[]),timestamp:0,offset:void 0,limit:void 0}),v0})()),j2=YB.useCallback((v0,FB)=>{let K2=i61(v0,FB,L81);HB.current=ceA(HB.current,K2)},[]);YB.useEffect(()=>{if(Z&&Z.length>0)j2(Z,cQ())},[]);let{status:A2,reverify:n2}=D$2(),[L3,k5]=YB.useState(null),[N8,MW]=YB.useState(null),[KG,LI]=YB.useState(!1),MI=!_1&&B9;function OW(){if(KG||N8)return;if(Q9)return"message-selector";if(HA[0])return"sandbox-permission";let v0=!O1||O1.shouldContinueAnimation;if(v0&&$0[0])return"tool-permission";if(v0&&O.workerPermissions.queue[0])return"worker-permission";if(v0&&O.elicitation.queue[0])return"elicitation";if(v0&&MI)return"cost";if(v0&&B1)return"ide-onboarding";return}let $5=OW();function VG(){if($5==="elicitation")return;if(fA(),$5==="tool-permission")$0[0]?.onAbort(),F0([]);else if($5==="worker-permission"){let v0=O.workerPermissions.queue[0];if(v0)SB1(v0.id,{decision:"rejected",resolvedBy:"leader"},O.teamContext?.teamName),M((FB)=>({...FB,workerPermissions:{...FB.workerPermissions,queue:FB.workerPermissions.queue.slice(1)}}))}else Q1?.abort()}let UK=YB.useCallback(async()=>{let v0=await QA1(B0,0,async()=>new Promise((FB)=>M((K2)=>{return FB(K2),K2})),M);if(!v0)return;i1(v0.text),IQ("prompt")},[M,i1,IQ,B0]);U$2(F0,VG,Q9||l9,k,Q1?.signal,UK,M6,O1?.isLocalJSXCommand,f6),YB.useEffect(()=>{if(JE()>=5&&!B9&&!O9){if(s("tengu_cost_threshold_reached",{}),yuA())$3(!0)}},[A1,B9,O9]);let NX=YB.useCallback(async(v0)=>{return new Promise((FB)=>{$A((K2)=>[...K2,{hostPattern:v0,resolvePromise:FB}])})},[]);if(NB.isSandboxingEnabled())NB.initialize(NX).catch((v0)=>{process.stderr.write(`
2674:`)},FB=()=>{CD((K2)=>K2+1)};return NY?.on("suspend",v0),NY?.on("resume",FB),()=>{NY?.off("suspend",v0),NY?.off("resume",FB)}},[NY]);let NK=YB.useMemo(()=>YJ(C1).filter(g_A),[C1]),FO=YB.useMemo(()=>{if(!_1)return null;let v0=A1.filter((W9)=>W9.type==="progress"&&W9.data.type==="hook_progress"&&(W9.data.hookEvent==="Stop"||W9.data.hookEvent==="SubagentStop"));if(v0.length===0)return null;let FB=[...new Set(v0.map((W9)=>W9.toolUseID))],K2=FB[FB.length-1];if(!K2)return null;if(A1.some((W9)=>W9.type==="system"&&W9.subtype==="stop_hook_summary"&&W9.toolUseID===K2))return null;let M3=v0.filter((W9)=>W9.toolUseID===K2),g2=M3.length,g3=A1.filter((W9)=>{if(W9.type!=="attachment")return!1;let t8=W9.attachment;return"hookEvent"in t8&&(t8.hookEvent==="Stop"||t8.hookEvent==="SubagentStop")&&"toolUseID"in t8&&t8.toolUseID===K2}).length,A4=M3.find((W9)=>W9.data.statusMessage)?.data.statusMessage;if(A4)return g2===1?`${A4}‚Ä¶`:`${A4}‚Ä¶ ${g3}/${g2}`;let bB=M3[0]?.data.hookEvent==="SubagentStop"?"subagent stop":"stop";return g2===1?`running ${bB} hook`:`running stop hooks‚Ä¶ ${g3}/${g2}`},[A1,_1]);qN2(k,c,AA,OA,JI);let rH=O.todos[z0];if(C$2(rH),k==="transcript")return i2.createElement(i2.Fragment,null,i2.createElement(d0A,{messages:A1,normalizedMessageHistory:NK,tools:NA,verbose:!0,toolJSX:null,toolUseConfirmQueue:[],inProgressToolUseIDs:p9,isMessageSelectorVisible:!1,conversationId:w3,screen:k,agentDefinitions:b,screenToggleId:t,streamingToolUses:q1,showAllInTranscript:VA,onOpenRateLimitOptions:H$}),O1&&i2.createElement(j,{flexDirection:"column",width:"100%"},O1.jsx),i2.createElement(M_2,null),i2.createElement(j,{alignItems:"center",alignSelf:"center",borderTopDimColor:!0,borderBottom:!1,borderLeft:!1,borderRight:!1,borderStyle:"single",marginTop:1,paddingLeft:2,width:"100%"},i2.createElement(z,{dimColor:!0},"Showing detailed transcript ¬∑ ctrl+o to toggle")));return i2.createElement(v31,{key:EG,dynamicMcpConfig:u,isStrictMcpConfig:K,mcpCliEndpoint:X},i2.createElement(d0A,{messages:A1,normalizedMessageHistory:NK,tools:NA,verbose:_,toolJSX:O1,toolUseConfirmQueue:$0,inProgressToolUseIDs:p9,isMessageSelectorVisible:Q9,conversationId:w3,screen:k,screenToggleId:t,streamingToolUses:q1,showAllInTranscript:VA,agentDefinitions:b,onOpenRateLimitOptions:H$}),i2.createElement(hN2,null),!F&&JQ&&i2.createElement(y0A,{param:{text:JQ,type:"text"},addMargin:!0,verbose:_}),O1&&i2.createElement(j,{flexDirection:"column",width:"100%"},O1.jsx),i2.createElement(j,{flexDirection:"column",width:"100%"},!1,w1&&i2.createElement(aiB,{mode:gA,spinnerTip:O.spinnerTip,currentResponseLength:z9,overrideMessage:z1,spinnerSuffix:FO,verbose:_,elapsedTimeMs:AQ,todos:rH,overrideColor:E0,overrideShimmerColor:eB,hasActiveTools:p9.size>0}),!w1&&O.showExpandedTodos&&i2.createElement(j,{width:"100%",flexDirection:"column"},i2.createElement(Yi,{todos:rH||[],isStandalone:!0})),$5==="sandbox-permission"&&i2.createElement(Lq2,{key:HA[0].hostPattern.host,hostPattern:HA[0].hostPattern,onUserResponse:(v0)=>{let{allow:FB,persistToSettings:K2}=v0,J6=HA[0];if(!J6)return;let M3=J6.hostPattern.host;if(K2){let g2={type:"addRules",rules:[{toolName:mW,ruleContent:`domain:${M3}`}],behavior:FB?"allow":"deny",destination:"localSettings"};M((g3)=>({...g3,toolPermissionContext:aX(g3.toolPermissionContext,g2)})),$f(g2),NB.refreshConfig()}$A((g2)=>{return g2.filter((g3)=>g3.hostPattern.host===M3).forEach((g3)=>g3.resolvePromise(FB)),g2.filter((g3)=>g3.hostPattern.host!==M3)})}}),$5==="tool-permission"&&i2.createElement(B62,{key:$0[0]?.toolUseID,onDone:()=>F0(([v0,...FB])=>FB),onReject:UK,toolUseConfirm:$0[0],toolUseContext:DZ(A1,A1,Q1??v9(),[],void 0,v),verbose:_}),$5==="worker-permission"&&O.workerPermissions.queue[0]&&i2.createElement(v02,{key:O.workerPermissions.queue[0].id,request:O.workerPermissions.queue[0],workerColor:Object.values(O.teamContext?.teammates??{}).find((v0)=>v0.name===O.workerPermissions.queue[0]?.workerName)?.color,onDone:()=>{M((v0)=>({...v0,workerPermissions:{...v0.workerPermissions,queue:v0.workerPermissions.queue.slice(1)}}))},onApprove:(v0)=>{let FB=O.workerPermissions.queue[0];if(FB)SB1(FB.id,{decision:"approved",resolvedBy:"leader",updatedInput:v0},O.teamContext?.teamName)},onDeny:(v0)=>{let FB=O.workerPermissions.queue[0];if(FB)SB1(FB.id,{decision:"rejected",resolvedBy:"leader",feedback:v0},O.teamContext?.teamName)}}),O.pendingWorkerRequest&&i2.createElement(f02,{toolName:O.pendingWorkerRequest.toolName,description:O.pendingWorkerRequest.description}),$5==="elicitation"&&i2.createElement(I62,{serverName:O.elicitation.queue[0].serverName,request:O.elicitation.queue[0].request,onResponse:(v0,FB)=>{let K2=O.elicitation.queue[0];if(K2)M((J6)=>({...J6,elicitation:{queue:J6.elicitation.queue.slice(1)}})),K2.respond({action:v0,content:FB})},signal:O.elicitation.queue[0].signal}),$5==="cost"&&i2.createElement($02,{onDone:()=>{$3(!1),N3(!0),i0((v0)=>({...v0,hasAcknowledgedCostThreshold:!0})),s("tengu_cost_threshold_acknowledged",{})}}),$5==="ide-onboarding"&&i2.createElement(MEB,{onDone:()=>JA(!1),installationStatus:bA}),N8,!O1?.shouldHidePromptInput&&!$5&&!KG&&!F&&i2.createElement(i2.Fragment,null,L3&&i2.createElement(ET2,{onRun:Y6,onCancel:aH,reason:DT2(L3)}),n1.state!=="closed"?i2.createElement(l50,{state:n1.state,handleSelect:n1.handleSelect,inputValue:B0,setInputValue:i1,message:"How did that compaction go? (optional)"}):i2.createElement(l50,{state:k1.state,handleSelect:k1.handleSelect,inputValue:B0,setInputValue:i1}),i2.createElement(X$2,{debug:Q,ideSelection:kA,getToolUseContext:DZ,toolPermissionContext:L,setToolPermissionContext:qX,apiKeyStatus:A2,commands:nA,agents:b.activeAgents,isLoading:_1,onExit:async()=>{LI(!0);let v0=await r61.call(()=>{});MW(v0)},verbose:_,messages:A1,onAutoUpdaterResult:K1,autoUpdaterResult:eA,input:B0,onInputChange:OI,mode:P0,onModeChange:IQ,stashedPrompt:fB,setStashedPrompt:oQ,submitCount:NQ,onShowMessageSelector:()=>y4((v0)=>!v0),mcpClients:PA,pastedContents:H2,setPastedContents:d0,vimMode:M6,setVimMode:q3,showBashesDialog:l9,setShowBashesDialog:s0,showDiffDialog:mQ,setShowDiffDialog:XB,tasksSelected:e9,setTasksSelected:x2,diffSelected:WG,setDiffSelected:gG,onSubmit:h6,isSearchingHistory:f6,setIsSearchingHistory:b6}))),$5==="message-selector"&&i2.createElement(d02,{messages:A1,onPreRestore:VG,onRestoreCode:async(v0)=>{await uNA((FB)=>{M((K2)=>({...K2,fileHistory:FB(K2.fileHistory)}))},v0.uuid)},onRestoreMessage:async(v0)=>{let FB=A1.indexOf(v0),K2=A1.slice(0,FB);setImmediate(async()=>{if(!AH())await JI();N1([...K2]),C4(b70()),M((M3)=>({...M3,todos:{...M3.todos,[z0]:v0.todos??[]},promptSuggestion:{text:null,shownAt:0,acceptedAt:0}})),WZA(v0.todos??[],z0);let J6=CT2(v0);if(J6!==null){let M3=t2(J6,"bash-input"),g2=t2(J6,"command-name");if(M3)i1(M3),IQ("bash");else if(g2){let g3=t2(J6,"command-args")||"";i1(`${g2} ${g3}`),IQ("prompt")}else i1(J6),IQ("prompt")}if(Array.isArray(v0.message.content)&&v0.message.content.some((M3)=>M3.type==="image")){let M3=v0.message.content.filter((g2)=>g2.type==="image");if(M3.length>0){let g2={};M3.forEach((g3,A4)=>{if(g3.source.type==="base64")g2[A4+1]={id:A4+1,type:"image",content:g3.source.data,mediaType:g3.source.media_type}}),d0(g2)}}})},onClose:()=>y4(!1)}))}var i2,YB,L81=100;var M81=q(()=>{hA();w02();jV();TC();YMA();nw();u0();L02();aMA();k02();b02();Gi();u02();oMA();n02();G62();X62();W$2();kG();qi();By();CC();EL();E$2();Xc();H$2();z$2();$$2();O$2();T$2();P$2();GV();vQ();_0();KB();qb();js();bM();pY();s$2();Qw2();L_A();Mi();Zw2();$50();w50();Xw2();L50();c61();dLA();FCA();LN2();uAA();ON2();JN();qT();P1A();rRA();f2();fIA();Ol();tF();x8();zZA();u50();UU();PN2();xN2();B50();RJ();kN2();d50();o_();VAA();ac1();IA0();NZ();Kn();gN2();dN2();pN2();nN2();rN2();Yq2();zq2();wq2();BI();qq2();Mq2();O_2();L70();T_2();P_2();r_2();J61();t_2();AT2();GT2();JT2();WT2();VT2();HT2();i2=o(KA(),1),YB=o(KA(),1)});import{randomUUID as Z75}from"crypto";async function*sIA({agentDefinition:A,promptMessages:Q,toolUseContext:B,canUseTool:G,isAsync:Z,forkContextMessages:Y,querySource:J,override:I,model:X}){let W=await B.getAppState(),K=W.toolPermissionContext.mode,V=E6A(A.model,B.options.mainLoopModel,X,K),E=I?.agentId?I.agentId:HAA(),H=[...Y?wQ0(Y):[],...Q],F=Y!==void 0?PAA(B.readFileState):tb(L81),[C,$]=await Promise.all([I?.userContext??yV(),I?.systemContext??BD()]),O=A.permissionMode,L=O!==void 0||Z?async()=>{let t=await B.getAppState(),AA=t.toolPermissionContext;if(O&&t.toolPermissionContext.mode!=="bypassPermissions")AA={...AA,mode:O};if(Z)AA={...AA,shouldAvoidPermissionPrompts:!0};if(AA===t.toolPermissionContext)return t;return{...t,toolPermissionContext:AA}}:B.getAppState,T=Ri(A,B.options.tools,Z).resolvedTools,x=Array.from(W.toolPermissionContext.additionalWorkingDirectories.keys()),b=I?.systemPrompt?I.systemPrompt:await Y75(A,B,V,x),v=[],m=I?.abortController?I.abortController:Z?new AbortController:B.abortController,u=[];for await(let t of h70(E,A.agentType,m.signal))if(t.additionalContexts&&t.additionalContexts.length>0)u.push(...t.additionalContexts);if(u.length>0){let t=r9({type:"hook_additional_context",content:u,hookName:"SubagentStart",toolUseID:Z75(),hookEvent:"SubagentStart"});H.push(t)}let e=A.skills??[];if(e.length>0){let t=await BJA(s1()),AA=[];for(let VA of e){if(!ch(VA,t)){f(`[Agent: ${A.agentType}] Warning: Skill '${VA}' specified in frontmatter was not found`,{level:"warn"});continue}let OA=FN(VA,t);if(OA.type!=="prompt"){f(`[Agent: ${A.agentType}] Warning: Skill '${VA}' is not a prompt-based skill`,{level:"warn"});continue}AA.push({skillName:VA,skill:OA})}for(let{skillName:VA,skill:OA}of AA){let IA=await OA.getPromptForCommand("",B);f(`[Agent: ${A.agentType}] Preloaded skill '${VA}'`);let PA=G90(VA,OA.progressMessage);H.push(g0({content:[{type:"text",text:PA},...IA]}))}}let p={isNonInteractiveSession:Z?!0:B.options.isNonInteractiveSession??!1,hasAppendSystemPrompt:B.options.hasAppendSystemPrompt,tools:T,commands:[],debug:B.options.debug,verbose:B.options.verbose,mainLoopModel:V,maxThinkingTokens:kh(H),mcpClients:B.options.mcpClients,mcpResources:B.options.mcpResources,agentDefinitions:B.options.agentDefinitions},k=hMA(B,{options:p,agentId:E,messages:H,readFileState:F,abortController:m,getAppState:L,shareSetAppState:!Z,shareSetResponseLength:!0,criticalSystemReminder_EXPERIMENTAL:A.criticalSystemReminder_EXPERIMENTAL});await Wn1(H,E).catch((t)=>f(`Failed to record sidechain transcript: ${t}`));let c=H.length>0?H[H.length-1].uuid:null;for await(let t of kU({messages:H,systemPrompt:b,userContext:C,systemContext:$,canUseTool:G,toolUseContext:k,querySource:J}))if(t.type==="assistant"||t.type==="user"||t.type==="progress"||t.type==="system"&&t.subtype==="compact_boundary")v.push(t),await Wn1([t],E,c).catch((AA)=>f(`Failed to record sidechain transcript: ${AA}`)),c=t.uuid,yield t;if(m.signal.aborted)throw new FJ;if(gM(A)&&A.callback)A.callback()}function wQ0(A){let Q=new Set;for(let B of A)if(B?.type==="user"){let Z=B.message.content;if(Array.isArray(Z)){for(let Y of Z)if(Y.type==="tool_result"&&Y.tool_use_id)Q.add(Y.tool_use_id)}}return A.filter((B)=>{if(B?.type==="assistant"){let Z=B.message.content;if(Array.isArray(Z))return!Z.some((J)=>J.type==="tool_use"&&J.id&&!Q.has(J.id))}return!0})}async function Y75(A,Q,B,G){try{let Z=A.getSystemPrompt({toolUseContext:Q});return await JTA([Z],B,G)}catch(Z){return await JTA([zT2],B,G)}}var HB1=q(()=>{Mi();rZ();Vx();By();qi();d2();bM();P1A();qT();nw();M81();aw();OM();x8();Q0();fMA();N9();VC();pB();KB();SOA();DB1()});function UT2({agentType:A,description:Q,toolUseCount:B,tokens:G,color:Z,isLast:Y,isResolved:J,isError:I,isAsync:X=!1,shouldAnimate:W,lastToolInfo:K,hideType:V=!1}){let E=Y?"‚îî‚îÄ":"‚îú‚îÄ",D=()=>{if(!J)return K||"Initializing‚Ä¶";return X?"Launched":"Done"};return v8.createElement(j,{flexDirection:"column"},v8.createElement(j,{paddingLeft:3},v8.createElement(z,{dimColor:!J},E," ",V?v8.createElement(z,{bold:!0},Q||A):v8.createElement(v8.Fragment,null,v8.createElement(z,{bold:!0,backgroundColor:Z,color:Z?"inverseText":void 0},A),Q&&v8.createElement(z,null," (",Q,")"))," ¬∑ ",X&&J?v8.createElement(z,null,"Running in background"):v8.createElement(v8.Fragment,null,B," tool ",B===1?"use":"uses"),G!==null&&v8.createElement(v8.Fragment,null," ¬∑ ",I8(G)," tokens"))),v8.createElement(j,{paddingLeft:3,flexDirection:"row"},v8.createElement(z,{dimColor:!J},Y?" ":"‚îÇ"),v8.createElement(h0,null,v8.createElement(z,{dimColor:!0},D()))))}var v8;var $T2=q(()=>{hA();g4();v8=o(KA(),1)});function ITA({prompt:A,theme:Q,dim:B=!1}){return e0.createElement(j,{flexDirection:"column"},e0.createElement(z,{color:"success",bold:!0},"Prompt:"),e0.createElement(j,{paddingLeft:2},e0.createElement(z,{dimColor:B},Q?l1A(A,Q):A)))}function u70({content:A,theme:Q}){return e0.createElement(j,{flexDirection:"column"},e0.createElement(z,{color:"success",bold:!0},"Response:"),A.map((B,G)=>e0.createElement(j,{key:G,paddingLeft:2,marginTop:G===0?0:1},e0.createElement(z,null,Q?l1A(B.text,Q):B.text))))}function wT2(A,Q,{tools:B,verbose:G,theme:Z}){if(A.status==="async_launched"){let{prompt:F}=A;return e0.createElement(j,{flexDirection:"column"},e0.createElement(h0,{height:1},e0.createElement(z,null,"Backgrounded agent",!G&&e0.createElement(z,{dimColor:!0}," (",e0.createElement($B,null,e0.createElement(L0,{shortcut:"‚Üì",action:"manage"}),F&&e0.createElement(L0,{shortcut:"ctrl+o",action:"expand"})),")"))),G&&F&&e0.createElement(h0,null,e0.createElement(ITA,{prompt:F,theme:Z})))}if(A.status!=="completed")return null;let{agentId:Y,totalDurationMs:J,totalToolUseCount:I,totalTokens:X,usage:W,content:K,prompt:V}=A,D=`Done (${[I===1?"1 tool use":`${I} tool uses`,I8(X)+" tokens",rK(J)].join(" ¬∑ ")})`,H=aE({content:D,usage:W});return e0.createElement(j,{flexDirection:"column"},!1,G&&V&&e0.createElement(h0,null,e0.createElement(ITA,{prompt:V,theme:Z})),G?e0.createElement($d1,null,Q.map((F)=>e0.createElement(h0,{key:F.uuid},e0.createElement(hT,{message:F.data.message,messages:F.data.normalizedMessages,addMargin:!1,tools:B,verbose:G,erroredToolUseIDs:new Set,inProgressToolUseIDs:new Set,resolvedToolUseIDs:new Set,progressMessagesForMessage:Q,shouldAnimate:!1,shouldShowDot:!1,isTranscriptMode:!1,isStatic:!0})))):null,G&&K&&K.length>0&&e0.createElement(h0,null,e0.createElement(u70,{content:K,theme:Z})),e0.createElement(h0,{height:1},e0.createElement(hT,{message:H,messages:YJ([H]),addMargin:!1,tools:B,verbose:G,erroredToolUseIDs:new Set,inProgressToolUseIDs:new Set,resolvedToolUseIDs:new Set,progressMessagesForMessage:[],shouldAnimate:!1,shouldShowDot:!1,isTranscriptMode:!1,isStatic:!0})))}function NT2({description:A,prompt:Q}){if(!A||!Q)return null;return A}function O81(A,{tools:Q,verbose:B,terminalSize:G,inProgressToolCallCount:Z}){if(!A.length)return e0.createElement(h0,{height:1},e0.createElement(z,{dimColor:!0},X75));let Y=(Z??1)*J75+I75,J=!B&&G&&G.rows&&G.rows<Y,I=()=>{let D=A.filter((C)=>{return C.data.message.message.content.some((O)=>O.type==="tool_use")}).length,H=[...A].reverse().find((C)=>C.data.message.type==="assistant"),F=null;if(H?.data.message.type==="assistant"){let C=H.data.message.message.usage;F=(C.cache_creation_input_tokens??0)+(C.cache_read_input_tokens??0)+C.input_tokens+C.output_tokens}return{toolUseCount:D,tokens:F}};if(J){let{toolUseCount:D,tokens:H}=I();return e0.createElement(h0,{height:1},e0.createElement(z,{dimColor:!0},"In progress‚Ä¶ ¬∑ ",e0.createElement(z,{bold:!0},D)," tool"," ",D===1?"use":"uses",H&&` ¬∑ ${I8(H)} tokens`," ¬∑"," ",e0.createElement(L0,{shortcut:"ctrl+o",action:"expand",parens:!0})))}let X=A.filter((D)=>{return D.data.message.message.content.some((F)=>F.type==="tool_use")}).length,W=B?A:A.slice(-g70),K=W.filter((D)=>{return D.data.message.message.content.some((F)=>F.type==="tool_use")}).length,V=X-K;if(!B&&A.length>g70)W=A.slice(-g70+1);let E=A[0]?.data.prompt;return e0.createElement(h0,null,e0.createElement(j,{flexDirection:"column"},e0.createElement($d1,null,B&&E&&e0.createElement(j,{marginBottom:1},e0.createElement(ITA,{prompt:E})),W.map((D)=>e0.createElement(j,{key:D.uuid,height:1,overflow:"hidden"},e0.createElement(hT,{message:D.data.message,messages:D.data.normalizedMessages,addMargin:!1,tools:Q,verbose:B,erroredToolUseIDs:new Set,inProgressToolUseIDs:new Set,resolvedToolUseIDs:l70(A),progressMessagesForMessage:A,shouldAnimate:!1,shouldShowDot:!1,style:"condensed",isTranscriptMode:!1,isStatic:!0})))),V>0&&e0.createElement(z,{dimColor:!0},"+",V," more tool ",V===1?"use":"uses"," ",e0.createElement(Nb,null))))}function qT2(A,{progressMessagesForMessage:Q,tools:B,verbose:G}){let Z=Q[0]?.data?.agentId;return e0.createElement(e0.Fragment,null,!1,O81(Q,{tools:B,verbose:G}),e0.createElement(l8,null))}function LT2(A,{progressMessagesForMessage:Q,tools:B,verbose:G}){return e0.createElement(e0.Fragment,null,O81(Q,{tools:B,verbose:G}),e0.createElement(D6,{result:A,verbose:G}))}function W75(A){let Q=A.filter((Z)=>{let Y=Z.data.message;return Y.type==="user"&&Y.message.content.some((J)=>J.type==="tool_result")}).length,B=[...A].reverse().find((Z)=>Z.data.message.type==="assistant"),G=null;if(B?.data.message.type==="assistant"){let Z=B.data.message.message.usage;G=(Z.cache_creation_input_tokens??0)+(Z.cache_read_input_tokens??0)+Z.input_tokens+Z.output_tokens}return{toolUseCount:Q,tokens:G}}function MT2(A,Q){let{shouldAnimate:B,tools:G}=Q,Z=A.map(({param:V,isResolved:E,isError:D,progressMessages:H})=>{let F=W75(H),C=K75(H,G),$=p70.safeParse(V.input),O=$.success?m70($.data):"Task",M=$.success?$.data.description:void 0,L=$.success?d70($.data):void 0,_=$.success&&"run_in_background"in $.data&&$.data.run_in_background===!0;return{id:V.id,agentType:O,description:M,toolUseCount:F.toolUseCount,tokens:F.tokens,isResolved:E,isError:D,isAsync:_,color:L,lastToolInfo:C}}),Y=A.some((V)=>!V.isResolved),J=A.some((V)=>V.isError),I=!Y,X=Z.length>0&&Z.every((V)=>V.agentType===Z[0]?.agentType),W=X?Z[0]?.agentType:null,K=Z.every((V)=>V.isAsync);return e0.createElement(j,{flexDirection:"column",marginTop:1},e0.createElement(j,{flexDirection:"row"},e0.createElement(i31,{shouldAnimate:B&&Y,isUnresolved:Y,isError:J}),e0.createElement(z,null,I?e0.createElement(e0.Fragment,null,e0.createElement(z,{bold:!0},A.length)," ",W?`${W} agents`:"agents"," ",K?"launched":"finished"):e0.createElement(e0.Fragment,null,"Running ",e0.createElement(z,{bold:!0},A.length)," ",W?`${W} agents`:"agents","‚Ä¶")," "),e0.createElement(Nb,null)),Z.map((V,E)=>e0.createElement(UT2,{key:V.id,agentType:V.agentType,description:V.description,toolUseCount:V.toolUseCount,tokens:V.tokens,color:V.color,isLast:E===Z.length-1,isResolved:V.isResolved,isError:V.isError,isAsync:V.isAsync,shouldAnimate:B,lastToolInfo:V.lastToolInfo,hideType:X})))}function m70(A){if(A?.subagent_type&&A.subagent_type!==MB1.agentType)return A.subagent_type;return"Task"}function d70(A){if(!A?.subagent_type)return;return BZA(A.subagent_type)}function K75(A,Q){let B=[...A].reverse().find((G)=>{let Z=G.data.message;return Z.type==="user"&&Z.message.content.some((Y)=>Y.type==="tool_result")});if(B?.data.message.type==="user"){let G=B.data.message.message.content.find((Z)=>Z.type==="tool_result");if(G?.type==="tool_result"){let Z=G.tool_use_id,Y=A.find((J)=>{let I=J.data.message;return I.type==="assistant"&&I.message.content.some((X)=>X.type==="tool_use"&&X.id===Z)});if(Y?.data.message.type==="assistant"){let J=Y.data.message.message.content.find((I)=>I.type==="tool_use"&&I.id===Z);if(J?.type==="tool_use"){let I=Q.find((V)=>V.name===J.name);if(!I)return J.name;let X=J.input,W=I.inputSchema.safeParse(X),K=I.userFacingName(W.success?W.data:void 0);if(I.getToolUseSummary){let V=I.getToolUseSummary(W.success?W.data:void 0);if(V)return`${K}: ${V}`}return K}}}}return null}var e0,g70=3,J75=9,I75=7,X75="Initializing‚Ä¶";var c70=q(()=>{hA();lW();II();h21();g4();SIA();KB();KB();kQ0();$M();L7A();t4();i3();V80();$T2();ZqA();fMA();N9();e0=o(KA(),1)});function R81({onBackground:A}){f1((B,G)=>{if(B==="b"&&G.ctrl)A()});let Q=QQ.terminal==="tmux"?"ctrl+b ctrl+b":"ctrl+b";return CY.createElement(j,{paddingLeft:5},CY.createElement(z,{dimColor:!0},CY.createElement(L0,{shortcut:Q,action:"run in background"})))}function RT2(A,{verbose:Q,theme:B}){let{command:G}=A;if(!G)return null;let Z=G;if(G.includes(`"$(cat <<'EOF'`)){let Y=G.match(/^(.*?)"?\$\(cat <<'EOF'\n([\s\S]*?)\n\s*EOF\n\s*\)"(.*)$/);if(Y&&Y[1]&&Y[2]){let J=Y[1],I=Y[2],X=Y[3]||"";Z=`${J.trim()} "${I.trim()}"${X.trim()}`}}if(!Q){let Y=Z.split(`
3770:Other exit codes - show stderr to user only`,matcherMetadata:{fieldToMatch:"notification_type",values:["permission_prompt","idle_prompt","auth_success","elicitation_dialog"]}},UserPromptSubmit:{summary:"When the user submits a prompt",description:`Input to command is JSON with original user prompt text.
4322:`,signal:Q,enablePromptCaching:!1,options:{querySource:"bash_extract_prefix",agents:[],isNonInteractiveSession:B,hasAppendSystemPrompt:!1,mcpTools:[],agentIdOrSessionId:W0()}});clearTimeout(G);let I=Date.now()-Z,X=typeof J.message.content==="string"?J.message.content:Array.isArray(J.message.content)?J.message.content.find((W)=>W.type==="text")?.text??"none":"none";if(X.startsWith(tW))s("tengu_bash_prefix",{success:!1,error:"API error",durationMs:I}),Y=null;else if(X==="command_injection_detected")s("tengu_bash_prefix",{success:!1,error:"command_injection_detected",durationMs:I}),Y={commandPrefix:null};else if(X==="git")s("tengu_bash_prefix",{success:!1,error:'prefix "git"',durationMs:I}),Y={commandPrefix:null};else if(X==="none")s("tengu_bash_prefix",{success:!1,error:'prefix "none"',durationMs:I}),Y={commandPrefix:null};else if(!A.startsWith(X))s("tengu_bash_prefix",{success:!1,error:"command did not start with prefix",durationMs:I}),Y={commandPrefix:null};else s("tengu_bash_prefix",{success:!0,durationMs:I}),Y={commandPrefix:X};return Y}catch(J){throw clearTimeout(G),J}},(A)=>A),kh2=new Set(["&&","||",";",";;","|"]),oX5=new Set([...kh2,">&",">",">>"])});var fh2=q(()=>{g1();S8A()});function LG0(A){return ccA(A)}function NL(A){let Q=A.match(/^([^(]+)\(([^)]+)\)$/);if(!Q)return{toolName:A};let B=Q[1],G=Q[2];if(!B||!G)return{toolName:A};return{toolName:B,ruleContent:G}}function X5(A){return A.ruleContent?`${A.toolName}(${A.ruleContent})`:A.toolName}function GXA(A){return OY0.flatMap((Q)=>(A.alwaysAllowRules[Q]||[]).map((B)=>({source:Q,ruleBehavior:"allow",ruleValue:NL(B)})))}function YK(A,Q){if(Q)switch(Q.type){case"hook":return Q.reason?`Hook '${Q.hookName}' blocked this action: ${Q.reason}`:`Hook '${Q.hookName}' requires approval for this ${A} command`;case"rule":{let G=X5(Q.rule.ruleValue),Z=LG0(Q.rule.source);return`Permission rule '${G}' from ${Z} requires approval for this ${A} command`}case"subcommandResults":{let G=[];for(let[Z,Y]of Q.reasons)if(Y.behavior==="ask"||Y.behavior==="passthrough")if(A==="Bash"){let{commandWithoutRedirections:J,redirections:I}=OT(Z),X=I.length>0?J:Z;G.push(X)}else G.push(Z);if(G.length>0)return`This ${A} command contains multiple operations. The following part${G.length>1?"s":""} require${G.length>1?"":"s"} approval: ${G.join(", ")}`;return`This ${A} command contains multiple operations that require approval`}case"permissionPromptTool":return`Tool '${Q.permissionPromptToolName}' requires approval for this ${A} command`;case"sandboxOverride":return"Run outside of the sandbox";case"classifier":return`Classifier '${Q.classifier}' requires approval for this ${A} command: ${Q.reason}`;case"workingDir":return Q.reason;case"other":return Q.reason;case"mode":return`Current permission mode (${Mf(Q.mode)}) requires approval for this ${A} command`;case"asyncAgent":return Q.reason}return`Claude requested permissions to use ${A}, but you haven't granted it yet.`}function AXA(A){return OY0.flatMap((Q)=>(A.alwaysDenyRules[Q]||[]).map((B)=>({source:Q,ruleBehavior:"deny",ruleValue:NL(B)})))}function l81(A){return OY0.flatMap((Q)=>(A.alwaysAskRules[Q]||[]).map((B)=>({source:Q,ruleBehavior:"ask",ruleValue:NL(B)})))}function RY0(A,Q){if(Q.ruleValue.ruleContent!==void 0)return!1;if(Q.ruleValue.toolName===A.name)return!0;let B=HV(Q.ruleValue.toolName),G=HV(A.name);return B!==null&&G!==null&&B.toolName===void 0&&B.serverName===G.serverName}function qB0(A,Q){return GXA(A).find((B)=>RY0(Q,B))||null}function LB0(A,Q){return AXA(A).find((B)=>RY0(Q,B))||null}function MB0(A,Q){return l81(A).find((B)=>RY0(Q,B))||null}function mU(A,Q,B){return _Y0(A,Q.name,B)}function _Y0(A,Q,B){let G=new Map,Z=[];switch(B){case"allow":Z=GXA(A);break;case"deny":Z=AXA(A);break;case"ask":Z=l81(A);break}for(let Y of Z)if(Y.ruleValue.toolName===Q&&Y.ruleValue.ruleContent!==void 0&&Y.ruleBehavior===B)G.set(Y.ruleValue.ruleContent,Y);return G}async function QW5(A,Q,B,G){if(B.abortController.signal.aborted)throw new FJ;let Z=await B.getAppState(),Y=LB0(Z.toolPermissionContext,A);if(Y)return{behavior:"deny",decisionReason:{type:"rule",rule:Y},message:`Permission to use ${A.name} has been denied.`};let J=MB0(Z.toolPermissionContext,A);if(J){if(!(A.name===n9&&NB.isSandboxingEnabled()&&NB.isAutoAllowBashIfSandboxedEnabled()))return{behavior:"ask",decisionReason:{type:"rule",rule:J},message:YK(A.name)}}let I={behavior:"passthrough",message:YK(A.name)};try{let V=A.inputSchema.parse(Q);I=await A.checkPermissions(V,B)}catch(V){r(V)}if(I?.behavior==="deny")return I;if(A.requiresUserInteraction?.()&&I?.behavior==="ask")return I;if(Z=await B.getAppState(),Z.toolPermissionContext.mode==="bypassPermissions"||Z.toolPermissionContext.mode==="plan"&&Z.toolPermissionContext.isBypassPermissionsModeAvailable)return{behavior:"allow",updatedInput:Q,decisionReason:{type:"mode",mode:Z.toolPermissionContext.mode}};let W=qB0(Z.toolPermissionContext,A);if(W)return{behavior:"allow",updatedInput:Q,decisionReason:{type:"rule",rule:W}};let K=I.behavior==="passthrough"?{...I,behavior:"ask",message:YK(A.name,I.decisionReason)}:I;if(K.behavior==="ask"&&K.suggestions)f(`Permission suggestions for ${A.name}: ${JSON.stringify(K.suggestions,null,2)}`);return K}async function NS2({rule:A,initialContext:Q,setToolPermissionContext:B}){if(A.source==="policySettings"||A.source==="flagSettings"||A.source==="command")throw Error("Cannot delete permission rules from read-only settings");let G=aX(Q,{type:"removeRules",rules:[A.ruleValue],behavior:A.ruleBehavior,destination:A.source});switch(A.source){case"localSettings":case"userSettings":case"projectSettings":{QiQ(A);break}case"cliArg":case"session":break}B(G)}function bh2(A,Q){let B=new Map;for(let Z of A){let Y=`${Z.source}:${Z.ruleBehavior}`;if(!B.has(Y))B.set(Y,[]);B.get(Y).push(Z.ruleValue)}let G=[];for(let[Z,Y]of B){let[J,I]=Z.split(":");G.push({type:Q,rules:Y,behavior:I,destination:J})}return G}function xP2(A,Q){let B=bh2(Q,"addRules");return Uf(A,B)}function hh2(A,Q){let B=bh2(Q,"replaceRules");return Uf(A,B)}var OY0,Z$=async(A,Q,B,G,Z)=>{let Y=await QW5(A,Q,B,G);if(Y.behavior==="ask"){let J=await B.getAppState();if(J.toolPermissionContext.mode==="dontAsk")return{behavior:"deny",decisionReason:{type:"mode",mode:"dontAsk"},message:`Permission to use ${A.name} has been auto-denied in dontAsk mode.`};if(J.toolPermissionContext.shouldAvoidPermissionPrompts)return{behavior:"deny",decisionReason:{type:"asyncAgent",reason:"Permission prompts are not available in this context"},message:`Permission to use ${A.name} has been auto-denied (prompts unavailable).`}}return Y};var rG=q(()=>{GV();rZ();g1();Q0();ds();iI();_J();BI();Mw();hU();fh2();w4();OY0=[...wL,"cliArg","command","session"]});function gh2(){}function p51(){let A=CQ()||{},Q=c1().env||{},B=A.env||{};for(let[G,Z]of Object.entries(Q))if(bLA.has(G.toUpperCase()))process.env[G]=Z;for(let[G,Z]of Object.entries(B))if(bLA.has(G.toUpperCase()))process.env[G]=Z;gh2()}function nTA(){let A=CQ()||{};Object.assign(process.env,c1().env),Object.assign(process.env,A.env),gh2()}var aTA=q(()=>{vQ();gB();le1()});function BW5({filePath:A,errorDescription:Q,onExit:B,onReset:G}){f1((J,I)=>{if(I.escape)B()});let Z=jQ();return pH.default.createElement(pH.default.Fragment,null,pH.default.createElement(j,{flexDirection:"column",borderColor:"error",borderStyle:"round",padding:1,width:70,gap:1},pH.default.createElement(z,{bold:!0},"Configuration Error"),pH.default.createElement(j,{flexDirection:"column",gap:1},pH.default.createElement(z,null,"The configuration file at ",pH.default.createElement(z,{bold:!0},A)," contains invalid JSON."),pH.default.createElement(z,null,Q)),pH.default.createElement(j,{flexDirection:"column"},pH.default.createElement(z,{bold:!0},"Choose an option:"),pH.default.createElement(S0,{options:[{label:"Exit and fix manually",value:"exit"},{label:"Reset with default configuration",value:"reset"}],onChange:(J)=>{if(J==="exit")B();else G()},onCancel:B}))),Z.pending?pH.default.createElement(z,{dimColor:!0},"Press ",Z.keyName," again to exit"):pH.default.createElement(AV,null))}async function uh2({error:A}){let Q={exitOnCtrlC:!1,theme:GW5};await new Promise(async(B)=>{let{unmount:G}=await O5(pH.default.createElement(n5,null,pH.default.createElement(BW5,{filePath:A.filePath,errorDescription:A.message,onExit:()=>{G(),B(),process.exit(1)},onReset:()=>{jA().writeFileSync(A.filePath,JSON.stringify(A.defaultConfig,null,2),{flush:!1,encoding:"utf8"}),G(),B(),process.exit(0)}})),Q)})}var pH,GW5="dark";var mh2=q(()=>{hA();G6();hA();YQ();o9();f2();pH=o(KA(),1)});import{realpathSync as ZW5,existsSync as YW5}from"fs";async function dh2(){try{let A=await EM();if(!A){f("Not in a GitHub repository, skipping path mapping update");return}let Q;try{Q=ZW5(cQ())}catch{Q=cQ()}let B=A.toLowerCase(),Z=c1().githubRepoPaths?.[B]??[];if(Z.includes(Q)){f(`Path ${Q} already tracked for repo ${B}`);return}let Y=[Q,...Z];i0((J)=>({...J,githubRepoPaths:{...J.githubRepoPaths,[B]:Y}})),f(`Added ${Q} to tracked paths for repo ${B}`)}catch(A){f(`Error updating repo path mapping: ${A}`)}}function ch2(A){let Q=c1(),B=A.toLowerCase();return Q.githubRepoPaths?.[B]??[]}function ph2(A){return A.filter((Q)=>YW5(Q))}async function lh2(A,Q){try{let{stdout:B,code:G}=await j6("git",["remote","get-url","origin"],{cwd:A,preserveOutputOnError:!1});if(G!==0||!B)return!1;let Z=ub(B.trim());if(!Z)return!1;return Z.toLowerCase()===Q.toLowerCase()}catch{return!1}}function ih2(A,Q){let B=c1(),G=A.toLowerCase(),Z=B.githubRepoPaths?.[G]??[],Y=Z.filter((I)=>I!==Q);if(Y.length===Z.length)return;let J={...B.githubRepoPaths};if(Y.length===0)delete J[G];else J[G]=Y;i0((I)=>({...I,githubRepoPaths:J})),f(`Removed ${Q} from tracked paths for repo ${G}`)}var l51=q(()=>{FAA();vQ();u0();Q0();Q3()});function i5(A){return A.replace(/[^a-zA-Z0-9_-]/g,"_")}import{join as ah2}from"path";import{tmpdir as JW5}from"os";import{writeFile as IW5,mkdir as XW5,rm as nh2,readdir as WW5}from"fs/promises";function hg(){return process.env.USE_MCP_CLI_DIR||ah2(JW5(),"claude-code-mcp-cli")}function NXA(){if(hZ()){let A=process.env.CLAUDE_CODE_SESSION_ID;if(A)return A}return W0()}function oh2(){if(!hZ())return;O8(async()=>{try{let A=i51();await nh2(A,{force:!0});let Q=hg();if((await WW5(Q)).length===0)await nh2(Q,{recursive:!0,force:!0})}catch{}})}function i51(){let A=NXA();return ah2(hg(),`${A}.json`)}function KW5(A){let Q={name:A.name,type:A.type};if(A.type==="connected")return{...Q,capabilities:A.capabilities};return Q}async function VW5(A){let Q="";try{Q=await A.description({},{isNonInteractiveSession:!1,toolPermissionContext:{mode:"default",additionalWorkingDirectories:new Map,alwaysAllowRules:{},alwaysDenyRules:{},alwaysAskRules:{},isBypassPermissionsModeAvailable:!1},tools:[]})}catch{}return{name:A.name,description:Q,inputJSONSchema:A.inputJSONSchema,isMcp:A.isMcp,originalToolName:A.originalMcpToolName}}async function rh2(A,Q,B){if(!hZ())return;try{await XW5(hg(),{recursive:!0});let G=await Promise.all(Q.filter((X)=>X.isMcp).map(VW5)),Z={},Y={};for(let X of A){Z[X.name]=X.config;let W=i5(X.name);if(Y[W]&&Y[W]!==X.name)console.warn(`Warning: MCP server name collision detected. Both "${Y[W]}" and "${X.name}" normalize to "${W}". Only "${X.name}" will be accessible via normalized lookup.`);Y[W]=X.name}let J={clients:A.map(KW5),configs:Z,tools:G,resources:B,normalizedNames:Y},I=i51();await IW5(I,JSON.stringify(J,null,2))}catch{}}var qXA=q(()=>{u0();fW();pE()});function n51(){if(TY0)return;th2(),TY0=!0}function th2(){let A=KiB();if(A)lW0(A,(B,G)=>{let Z=A?.createCounter(B,G);return{add(Y,J={}){let X={...FYA(),...J};Z?.add(Y,X)}}})}var TY0=!1,sh2;var jY0=q(()=>{da();u0();vQ();vQ();aTA();rZ();mh2();pY();fW();p2();u0();ce1();QFA();L01();Md();v3A();v8A();ms();V2();MYA();vQ();u0();qq();D10();l51();qXA();pE();fNA();mY();sh2=Z0(()=>{w9("init_function_start");try{oTA(),w9("init_configs_enabled"),p51(),w9("init_safe_env_vars_applied"),SF.initialize(),w9("init_settings_detector_initialized"),eh2(),w9("init_after_graceful_shutdown"),ofQ(),w9("init_after_1p_event_logging"),Hu0(),w9("init_after_oauth_populate");let A=CHA()&&!tZ(!0)&&!I4(),Q=MiB(),B=A||Q;if(Q)LiB();if(w9("init_after_defer_check"),!B)th2(),TY0=!0;if(w9("init_telemetry_setup"),Ag2(),gFQ(),pFQ(),w9("init_network_configured"),MaQ(),vrB(),dh2(),jqB(),O8(PqB),hZ())process.env.CLAUDE_CODE_SESSION_ID=W0(),oh2();if(wXA())Qg2();w9("init_function_end")}catch(A){if(A instanceof Ez)return uh2({error:A});else throw A}})});function bn(){return{settings:dV(),tasks:{},verbose:!1,mainLoopModel:null,mainLoopModelForSession:null,statusLineText:void 0,showExpandedTodos:!1,toolPermissionContext:Uw(),agent:void 0,agentDefinitions:{activeAgents:[],allAgents:[]},fileHistory:{snapshots:[],trackedFiles:new Set},mcp:{clients:[],tools:[],commands:[],resources:{}},plugins:{enabled:[],disabled:[],commands:[],agents:[],errors:[],installationStatus:{marketplaces:[],plugins:[]}},todos:{},notifications:{current:null,queue:[]},elicitation:{queue:[]},thinkingEnabled:LB1(),feedbackSurvey:{timeLastShown:null,submitCountAtLastAppearance:null},sessionHooks:{},inbox:{messages:[]},workerPermissions:{queue:[],selectedIndex:0},pendingWorkerRequest:null,promptSuggestion:{text:null,shownAt:0,acceptedAt:0},queuedCommands:[],gitDiff:{stats:null,perFileStats:new Map,hunks:new Map,lastUpdated:0}}}function n5({children:A,initialState:Q,onChangeAppState:B}){if(rV.useContext(Bg2))throw Error("AppStateProvider can not be nested within another AppStateProvider");let[Z,Y]=rV.useState({currentState:Q??bn(),previousState:null}),J=rV.useCallback((X)=>{Y(({currentState:W})=>{let K={currentState:X(W),previousState:W};return B?.({newState:K.currentState,oldState:K.previousState}),K})},[B]),I=rV.useMemo(()=>{let X=[Z.currentState,J];return X.__IS_INITIALIZED__=!0,X},[Z.currentState,J]);return rV.useEffect(()=>{let{toolPermissionContext:X}=Z.currentState;if(X.isBypassPermissionsModeAvailable&&KTA())f("Disabling bypass permissions mode on mount (remote settings loaded before mount)"),J((W)=>({...W,toolPermissionContext:a_A(W.toolPermissionContext)}))},[]),I8A(rV.useCallback((X,W)=>{f(`Settings changed from ${X}, updating AppState`);let K=ncA();p51(),n51(),J((V)=>{let E=hh2(V.toolPermissionContext,K);if(E.isBypassPermissionsModeAvailable&&KTA())E=a_A(E);return{...V,settings:W,toolPermissionContext:E}})},[J])),rV.default.createElement(Bg2.Provider,{value:!0},rV.default.createElement(PY0.Provider,{value:I},A))}function RQ(){let A=rV.useContext(PY0);if(!A.__IS_INITIALIZED__)throw ReferenceError("useAppState cannot be called outside of an <AppStateProvider />");return A}function lH2(){let A=rV.useContext(PY0);if(!A.__IS_INITIALIZED__)return null;return A}var rV,PY0,Bg2;var f2=q(()=>{icA();rG();ds();a1A();bM();gB();Q0();jY0();aTA();rV=o(KA(),1);PY0=rV.default.createContext([{},(A)=>A]),Bg2=rV.default.createContext(!1)});function fG(){let[A,Q]=RQ(),B=rTA.useCallback(()=>{Q((Z)=>{let Y=EW5(Z.notifications.queue);if(Z.notifications.current!==null||!Y)return Z;return HQA=setTimeout(()=>{HQA=null,Q((J)=>{if(J.notifications.current?.key!==Y.key)return J;return{...J,notifications:{queue:J.notifications.queue,current:null}}}),B()},Y.timeoutMs??Gg2),{...Z,notifications:{queue:Z.notifications.queue.filter((J)=>J!==Y),current:Y}}})},[Q]),G=rTA.useCallback((Z)=>{if(Z.priority==="immediate"){if(HQA)clearTimeout(HQA),HQA=null;HQA=setTimeout(()=>{HQA=null,Q((Y)=>{if(Y.notifications.current?.key!==Z.key)return Y;return{...Y,notifications:{queue:Y.notifications.queue.filter((J)=>!Z.invalidates?.includes(J.key)),current:null}}}),B()},Z.timeoutMs??Gg2),Q((Y)=>({...Y,notifications:{current:Z,queue:[...Y.notifications.current?[Y.notifications.current]:[],...Y.notifications.queue].filter((J)=>J.priority!=="immediate"&&!Z.invalidates?.includes(J.key))}}));return}Q((Y)=>{if(Z.priority==="immediate")return Y;let I=!new Set(Y.notifications.queue.map((X)=>X.key)).has(Z.key)&&Y.notifications.current?.key!==Z.key;return{...Y,notifications:{current:Y.notifications.current,queue:I?[...Y.notifications.queue.filter((X)=>X.priority!=="immediate"&&!Z.invalidates?.includes(X.key)),Z]:Y.notifications.queue}}}),B()},[Q,B]);return rTA.useEffect(()=>{if(A.notifications.queue.length>0)B()},[]),{addNotification:G}}function EW5(A){return A.sort((Q,B)=>{let G=Zg2[Q.priority]??999,Z=Zg2[B.priority]??999;return G-Z})[0]}var rTA,Gg2=8000,HQA=null,Zg2;var TC=q(()=>{f2();rTA=o(KA(),1);Zg2={immediate:0,high:1,medium:2,low:3}});function Yg2(A){return function(Q){return(new Map(A).get(Q)??(()=>{}))(Q)}}function f31({value:A,onChange:Q,onSubmit:B,onExit:G,onExitMessage:Z,onHistoryUp:Y,onHistoryDown:J,onHistoryReset:I,mask:X="",multiline:W=!1,cursorChar:K,invert:V,columns:E,onImagePaste:D,disableCursorMovementForUpDownKeys:H=!1,externalOffset:F,onOffsetChange:C,inputFilter:$}){let O=F,M=C,L=G7.fromText(A,E,O),{addNotification:_}=fG(),T=Ef((ZA)=>{Z?.(ZA,"Ctrl-C")},()=>G?.(),()=>{if(A)Q(""),M(0),I?.()}),x=Ef((ZA)=>{if(!A||!ZA)return;_({key:"escape-again-to-clear",text:"Press Escape again to clear",priority:"immediate",timeoutMs:1000})},()=>{if(A){if(A.trim()!=="")ks(A);Q(""),M(0),I?.()}});function b(){if(A.trim()!=="")ks(A),I?.();return G7.fromText("",E,0)}let v=Ef((ZA)=>{if(A!=="")return;Z?.(ZA,"Ctrl-D")},()=>{if(A!=="")return;G?.()});function m(){if(L.text==="")return v(),L;return L.del()}function u(){if(!D)return;RcA().then((ZA)=>{if(ZA)D(ZA.base64,ZA.mediaType);else _({key:"no-image-in-clipboard",text:`No image found in clipboard. Use ${bs.displayText} to paste images.`,priority:"immediate",timeoutMs:1000})})}function e(){let{cursor:ZA,killed:zA}=L.deleteToLineEnd();return tdA(zA,!0),ZA}function p(){let{cursor:ZA,killed:zA}=L.deleteToLineStart();return tdA(zA,!0),ZA}function k(){let{cursor:ZA,killed:zA}=L.deleteWordBefore();return tdA(zA,!0),ZA}function c(){let ZA=JdQ();if(ZA.length>0)return L.insert(ZA);return L}let t=Yg2([["a",()=>L.startOfLine()],["b",()=>L.left()],["c",T],["d",m],["e",()=>L.endOfLine()],["f",()=>L.right()],["h",()=>L.backspace()],["k",e],["l",()=>b()],["n",()=>IA()],["p",()=>OA()],["u",p],["w",k],["y",c]]),AA=Yg2([["b",()=>L.prevWord()],["f",()=>L.nextWord()],["d",()=>L.deleteWordAfter()]]);function VA(ZA){if(W&&L.offset>0&&L.text[L.offset-1]==="\\")return XlQ(),L.backspace().insert(`
4709:${z9}`)}if(Object.keys(NQ).length>0){let z9=Bs(NQ,(JB)=>({...JB,scope:"dynamic"}));JA={...JA,...z9}}}let CA=I.strictMcpConfig||!1;if(Ni1()){if(CA)process.stderr.write(pA.red("You cannot use --strict-mcp-config when an enterprise MCP config is present")),process.exit(1);if(JA&&!JwB(JA))process.stderr.write(pA.red("You cannot dynamically configure MCP servers when an enterprise MCP config is present")),process.exit(1)}let MA,NA,{toolPermissionContext:UA,warnings:LA}=PP2({allowedToolsCli:D,disallowedToolsCli:H,baseToolsCli:E,permissionMode:TA,allowDangerouslySkipPermissions:V,addDirs:$});LA.forEach((d0)=>{console.error(d0)}),Ng2();let{servers:nA}=CA?{servers:{}}:await k_(),gA={...nA,...JA},I1={},q1={};for(let[d0,NQ]of Object.entries(gA)){let RB=NQ;if(RB.type==="sdk")I1[d0]=RB;else q1[d0]=RB}if(w9("action_mcp_configs_loaded"),u&&u!=="text"&&u!=="stream-json")console.error(`Error: Invalid input format "${u}".`),process.exit(1);if(u==="stream-json"&&m!=="stream-json")console.error("Error: --input-format=stream-json requires output-format=stream-json."),process.exit(1);if(PA){if(u!=="stream-json"||m!=="stream-json")console.error("Error: --sdk-url requires both --input-format=stream-json and --output-format=stream-json."),process.exit(1)}if(I.replayUserMessages){if(u!=="stream-json"||m!=="stream-json")console.error("Error: --replay-user-messages requires both --input-format=stream-json and --output-format=stream-json."),process.exit(1)}if(T){if(!ZA||m!=="stream-json")bv("Error: --include-partial-messages requires --print and --output-format=stream-json."),process.exit(1)}if(E.length>0&&!ZA)bv("Error: --tools can only be used with --print mode."),process.exit(1);if(I.sessionPersistence===!1&&!ZA)bv("Error: --no-session-persistence can only be used with --print mode."),process.exit(1);let _A=await hD5(J||"",u??"text");w9("action_after_input_prompt");let Q1=LH(UA);w9("action_tools_loaded");let h1;if(_N2({isNonInteractiveSession:ZA})&&I.jsonSchema)h1=JSON.parse(I.jsonSchema);if(h1){let d0=l61(h1);if(d0)Q1=[...Q1,d0],s("tengu_structured_output_enabled",{schema_property_count:Object.keys(h1.properties||{}).length,has_required_fields:Boolean(h1.required)});else s("tengu_structured_output_failure",{error:"Invalid JSON schema"})}w9("action_before_setup"),await v71(mJ0(),TA,V,c,_?KC(_):void 0),w9("action_after_setup");let _1=I.model==="default"?ek():I.model,V0=O==="default"?ek():O,AQ=s1(),[n0,JQ]=await Promise.all([OC(AQ),U02(AQ)]);w9("action_commands_loaded");let BQ=[];if(b)try{let d0=d8(b);if(d0)BQ=_B1(d0,"flagSettings")}catch(d0){r(d0 instanceof Error?d0:Error(String(d0)))}let F1=[...JQ.allAgents,...BQ],eA={...JQ,allAgents:F1,activeAgents:Yy(F1)},K1=v??dV().agent,O1;if(K1){if(O1=eA.activeAgents.find((d0)=>d0.agentType===K1),!O1)f(`Warning: agent "${K1}" not found. Available agents: ${eA.activeAgents.map((d0)=>d0.agentType).join(", ")}. Using default behavior.`)}if(!ZA){if(await Kc2(TA,V,n0)&&J?.trim().toLowerCase()==="/login")J=""}if(process.exitCode!==void 0){f("Graceful shutdown initiated, skipping further initialization");return}KRB().catch((d0)=>r(d0)),syQ(),GN2(),Zc2(),am2(I4());let G0=xtA(q1),$0=NA===void 0&&(_A||ZA)?await G0:{clients:[],tools:[],commands:[]},F0=MA?MA:$0.clients,HA=NA?NA:$0.tools,$A=NA?[]:$0.commands,A1;if(NA!==void 0)A1=new DjA(F0,HA);else if(_XA())A1=new DjA(F0,HA),A1.start().then(({url:d0})=>{let NQ=A1.getSecret();XjA({url:d0,key:NQ}),f(`[MCP CLI Endpoint] Started at ${d0}`)}).catch((d0)=>{r(d0 instanceof Error?d0:Error(String(d0)))}),O8(async()=>{await A1?.stop()});n6("info","started"),O8(async()=>{n6("info","exited")}),uD5({hasInitialPrompt:Boolean(J),hasStdin:Boolean(_A),verbose:e,debug:X,debugToStderr:W,print:p??!1,outputFormat:m??"text",inputFormat:u??"text",numAllowedTools:D.length,numDisallowedTools:H.length,mcpClientCount:Object.keys(gA).length,worktree:c,skipWebFetchPreflight:dV().skipWebFetchPreflight,githubActionInputs:process.env.GITHUB_ACTION_INPUTS,dangerouslySkipPermissionsPassed:K??!1,modeIsBypass:TA==="bypassPermissions",allowDangerouslySkipPermissionsPassed:V,systemPromptFlag:zA?I.systemPromptFile?"file":"flag":void 0,appendSystemPromptFlag:bA?I.appendSystemPromptFile?"file":"flag":void 0}),P12(q1,UA),peA(null,"initialization"),OD5(),RD5(),await Hq2(),w9("action_after_plugins_init");let N1=_1;if(!N1&&O1?.model&&O1.model!=="inherit")N1=uI(O1.model);if(ga(N1),ZA){if(m==="stream-json"||m==="json")LK0(!0);nTA();let d0=k?[]:n0.filter((RB)=>RB.type==="prompt"&&!RB.disableNonInteractive||RB.type==="local"&&RB.supportsNonInteractive),NQ=bn();if(NQ={...NQ,mcp:{...NQ.mcp,clients:F0,commands:$A,tools:HA},toolPermissionContext:UA},UA.mode==="bypassPermissions"||V)SP2(UA);if(I.sessionPersistence===!1)CK0(!0);gd2(_A,async()=>NQ,(RB)=>{let z9=NQ;NQ=RB(NQ),ty({newState:NQ,oldState:z9})},d0,Q1,I1,eA.activeAgents,{continue:I.continue,resume:I.resume,verbose:e,outputFormat:m,jsonSchema:h1,permissionPromptToolName:I.permissionPromptTool,allowedTools:D,maxThinkingTokens:I.maxThinkingTokens,maxTurns:I.maxTurns,maxBudgetUsd:I.maxBudgetUsd,systemPrompt:zA,appendSystemPrompt:bA,userSpecifiedModel:_1,fallbackModel:V0,sdkBetas:M.length>0?M:void 0,teleport:kA,sdkUrl:PA,replayUserMessages:I.replayUserMessages,includePartialMessages:T,forkSession:I.forkSession||!1,resumeSessionAt:I.resumeSessionAt||void 0,rewindFiles:I.rewindFiles,enableAuthStatus:I.enableAuthStatus});return}let C1=bD5(!1);zLB(),s("tengu_startup_manual_model_config",{cli_flag:I.model,env_var:process.env.ANTHROPIC_MODEL,settings_file:(dV()||{}).model,subscriptionType:c3(),agent:K1});let D1=I.model||process.env.ANTHROPIC_MODEL||dV().model;if(LB()&&!YL()&&D1!==void 0&&FmA(D1))console.error(pA.yellow("Your plan doesn't include Opus in Claude Code. You can turn on /extra-usage or /upgrade to Max to access it. The current model is now Sonnet."));pW0(CmA()||null);let B0=wPA(),i1=uI(B0??ek()),P0=w81(i1),IQ=[];if(B1)IQ.push({key:"permission-mode-notification",text:B1,priority:"high"});if(P0)IQ.push({key:"model-deprecation-warning",text:P0,color:"warning",priority:"high"});let fB=W0(),oQ={settings:dV(),tasks:{},verbose:e??c1().verbose??!1,mainLoopModel:B0,mainLoopModelForSession:null,showExpandedTodos:c1().showExpandedTodos??!1,toolPermissionContext:UA,agent:O1?.agentType,agentDefinitions:eA,mcp:{clients:[],tools:[],commands:[],resources:{}},plugins:{enabled:[],disabled:[],commands:[],agents:[],errors:[],installationStatus:{marketplaces:[],plugins:[]}},statusLineText:void 0,notifications:{current:null,queue:IQ},elicitation:{queue:[]},todos:{[fB]:eb(fB)},fileHistory:{snapshots:[],trackedFiles:new Set},thinkingEnabled:LB1(),feedbackSurvey:{timeLastShown:null,submitCountAtLastAppearance:null},sessionHooks:{},inbox:{messages:[]},promptSuggestion:{text:null,shownAt:0,acceptedAt:0},queuedCommands:[],workerPermissions:{queue:[],selectedIndex:0},pendingWorkerRequest:null,gitDiff:{stats:null,perFileStats:new Map,hunks:new Map,lastUpdated:0}},H2=NA?[]:HA;if(TD5(),I.continue)try{s("tengu_continue",{});let d0=await Tl(void 0,void 0);if(!d0)console.error("No conversation found to continue"),process.exit(1);if(!I.forkSession){if(d0.sessionId)y$(d0.sessionId),await DM(),cHA(d0.sessionId)}await O5(s8.default.createElement(n5,{initialState:oQ,onChangeAppState:ty},s8.default.createElement(r0A,{debug:X||W,initialPrompt:_A,commands:[...n0,...$A],initialTools:H2,initialMessages:d0.messages,initialFileHistorySnapshots:d0.fileHistorySnapshots,mcpClients:F0,dynamicMcpConfig:JA,mcpCliEndpoint:A1,autoConnectIdeFlag:L,strictMcpConfig:CA,systemPrompt:zA,appendSystemPrompt:bA,mainThreadAgentDefinition:O1,disableSlashCommands:k})),C1)}catch(d0){r(d0 instanceof Error?d0:Error(String(d0))),process.exit(1)}else if(I.resume||kA||YA){let d0=null,NQ=void 0,RB=KC(I.resume),z9=void 0;if(I.resume&&typeof I.resume==="string"&&!RB){let JB=I.resume.trim();if(JB){let V1=await bGA(JB,{exact:!0});if(V1.length===1)RB=g_(V1[0])??null;else z9=JB}}if(YA){s("tengu_remote_create_session",{description_length:String(YA.length)});let JB=await hoB(YA,new AbortController().signal);if(!JB)s("tengu_remote_create_session_error",{error:"unable_to_create_session"}),process.stderr.write(pA.red(`Error: Unable to create remote session[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "message-selector|sandbox-permission|tool-permission|worker-permission|elicitation|ide-onboarding" bundles/ClaudeCodeCode/cli.js | head -n 40'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 36ms:[0m
[2m975:`))Q=Q.slice(0,-1)}return H_.prototype.equals.call(this,A,Q,B)};UM3=new H_;UM3.tokenize=function(A){return A.split(/(\S.+?[.!?])(?=\s+|$)/)};$M3=new H_;$M3.tokenize=function(A){return A.split(/([{}:;,]|\s+)/)};IwA=new H_;IwA.useLongestToken=!0;IwA.tokenize=voA.tokenize;IwA.castInput=function(A,Q){var{undefinedReplacement:B,stringifyReplacer:G}=Q,Z=G===void 0?function(Y,J){return typeof J>"u"?B:J}:G;return typeof A==="string"?A:JSON.stringify(ed1(A,null,null,Z),Z,"  ")};IwA.equals=function(A,Q,B){return H_.prototype.equals.call(IwA,A.replace(/,([\r\n])/g,"$1"),Q.replace(/,([\r\n])/g,"$1"),B)};Ac1=new H_;Ac1.tokenize=function(A){return A.slice()};Ac1.join=Ac1.removeEmpty=function(A){return A}});function KwA(A){return A.replaceAll("&",IKB).replaceAll("$",XKB)}function WKB(A){return A.replaceAll(IKB,"&").replaceAll(XKB,"$")}function VwA(A,Q){let B=0,G=0;if(A.length===0&&Q)B=Q.split(/\r?\n/).length;else B=A.reduce((Z,Y)=>Z+Y.lines.filter((J)=>J.startsWith("+")).length,0),G=A.reduce((Z,Y)=>Z+Y.lines.filter((J)=>J.startsWith("-")).length,0);kG1(B,G),gG1()?.add(B,{type:"added"}),gG1()?.add(G,{type:"removed"}),r("tengu_file_changed",{lines_added:B,lines_removed:G})}function KKB({filePath:A,oldContent:Q,newContent:B,ignoreWhitespace:G=!1,singleHunk:Z=!1}){return XwA(A,A,KwA(Q),KwA(B),void 0,void 0,{ignoreWhitespace:G,context:Z?1e5:JKB}).hunks.map((Y)=>({...Y,lines:Y.lines.map(WKB)}))}function zw({filePath:A,fileContents:Q,edits:B,ignoreWhitespace:G=!1}){let Z=KwA(O7A(Q));return XwA(A,A,Z,B.reduce((Y,J)=>{let{old_string:I,new_string:X}=J,W="replace_all"in J?J.replace_all:!1,K=KwA(O7A(I)),V=KwA(O7A(X));if(W)return Y.replaceAll(K,()=>V);else return Y.replace(K,()=>V)},Z),void 0,void 0,{context:JKB,ignoreWhitespace:G}).hunks.map((Y)=>({...Y,lines:Y.lines.map(WKB)}))}var JKB=3,IKB="<<:AMPERSAND_TOKEN:>>",XKB="<<:DOLLAR_TOKEN:>>";var ef=L(()=>{WwA();tq();M9();T0();g0()});var Dp="2025-06-18",koA,foA="2.0",VKB,EKB,TM3,vL,sz,EwA,fS,kL,boA,DKB,hoA=(A)=>DKB.safeParse(A).success,HKB,FKB=(A)=>HKB.safeParse(A).success,CKB,DwA=(A)=>CKB.safeParse(A).success,pF,zKB,UKB=(A)=>zKB.safeParse(A).success,bS,Ab,goA,HwA,$KB,jM3,Qc1,PM3,Bc1,uoA,wKB=(A)=>uoA.safeParse(A).success,moA,SM3,doA,coA,poA,NKB,qKB,Gc1,LKB,MKB,xM3,yM3,$e,vM3,Zc1,kM3,Hp,fM3,bM3,hM3,gM3,uM3,mM3,dM3,FwA,cM3,Yc1,Jc1,Ic1,pM3,lM3,OKB,iM3,Xc1,nM3,aM3,oM3,loA,CwA,F_,gi7,ioA,rM3,RKB,sM3,tM3,eM3,AO3,QO3,BO3,Wc1,GO3,ZO3,YO3,JO3,IO3,_KB,Kc1,XO3,WO3,KO3,Vc1,VO3,Ec1,Dc1,EO3,ui7,mi7,di7,ci7,pi7,li7,lF;var JV=L(()=>{z2();koA=[Dp,"2025-03-26","2024-11-05","2024-10-07"],VKB=P.union([P.string(),P.number().int()]),EKB=P.string(),TM3=P.object({progressToken:P.optional(VKB)}).passthrough(),vL=P.object({_meta:P.optional(TM3)}).passthrough(),sz=P.object({method:P.string(),params:P.optional(vL)}),EwA=P.object({_meta:P.optional(P.object({}).passthrough())}).passthrough(),fS=P.object({method:P.string(),params:P.optional(EwA)}),kL=P.object({_meta:P.optional(P.object({}).passthrough())}).passthrough(),boA=P.union([P.string(),P.number().int()]),DKB=P.object({jsonrpc:P.literal(foA),id:boA}).merge(sz).strict(),HKB=P.object({jsonrpc:P.literal(foA)}).merge(fS).strict(),CKB=P.object({jsonrpc:P.literal(foA),id:boA,result:kL}).strict();(function(A){A[A.ConnectionClosed=-32000]="ConnectionClosed",A[A.RequestTimeout=-32001]="RequestTimeout",A[A.ParseError=-32700]="ParseError",A[A.InvalidRequest=-32600]="InvalidRequest",A[A.MethodNotFound=-32601]="MethodNotFound",A[A.InvalidParams=-32602]="InvalidParams",A[A.InternalError=-32603]="InternalError"})(pF||(pF={}));zKB=P.object({jsonrpc:P.literal(foA),id:boA,error:P.object({code:P.number().int(),message:P.string(),data:P.optional(P.unknown())})}).strict(),bS=P.union([DKB,HKB,CKB,zKB]),Ab=kL.strict(),goA=fS.extend({method:P.literal("notifications/cancelled"),params:EwA.extend({requestId:boA,reason:P.string().optional()})}),HwA=P.object({name:P.string(),title:P.optional(P.string())}).passthrough(),$KB=HwA.extend({version:P.string()}),jM3=P.object({experimental:P.optional(P.object({}).passthrough()),sampling:P.optional(P.object({}).passthrough()),elicitation:P.optional(P.object({}).passthrough()),roots:P.optional(P.object({listChanged:P.optional(P.boolean())}).passthrough())}).passthrough(),Qc1=sz.extend({method:P.literal("initialize"),params:vL.extend({protocolVersion:P.string(),capabilities:jM3,clientInfo:$KB})}),PM3=P.object({experimental:P.optional(P.object({}).passthrough()),logging:P.optional(P.object({}).passthrough()),completions:P.optional(P.object({}).passthrough()),prompts:P.optional(P.object({listChanged:P.optional(P.boolean())}).passthrough()),resources:P.optional(P.object({subscribe:P.optional(P.boolean()),listChanged:P.optional(P.boolean())}).passthrough()),tools:P.optional(P.object({listChanged:P.optional(P.boolean())}).passthrough())}).passthrough(),Bc1=kL.extend({protocolVersion:P.string(),capabilities:PM3,serverInfo:$KB,instructions:P.optional(P.string())}),uoA=fS.extend({method:P.literal("notifications/initialized")}),moA=sz.extend({method:P.literal("ping")}),SM3=P.object({progress:P.number(),total:P.optional(P.number()),message:P.optional(P.string())}).passthrough(),doA=fS.extend({method:P.literal("notifications/progress"),params:EwA.merge(SM3).extend({progressToken:VKB})}),coA=sz.extend({params:vL.extend({cursor:P.optional(EKB)}).optional()}),poA=kL.extend({nextCursor:P.optional(EKB)}),NKB=P.object({uri:P.string(),mimeType:P.optional(P.string()),_meta:P.optional(P.object({}).passthrough())}).passthrough(),qKB=NKB.extend({text:P.string()}),Gc1=P.string().refine((A)=>{try{return atob(A),!0}catch(Q){return!1}},{message:"Invalid Base64 string"}),LKB=NKB.extend({blob:Gc1}),MKB=HwA.extend({uri:P.string(),description:P.optional(P.string()),mimeType:P.optional(P.string()),_meta:P.optional(P.object({}).passthrough())}),xM3=HwA.extend({uriTemplate:P.string(),description:P.optional(P.string()),mimeType:P.optional(P.string()),_meta:P.optional(P.object({}).passthrough())}),yM3=coA.extend({method:P.literal("resources/list")}),$e=poA.extend({resources:P.array(MKB)}),vM3=coA.extend({method:P.literal("resources/templates/list")}),Zc1=poA.extend({resourceTemplates:P.array(xM3)}),kM3=sz.extend({method:P.literal("resources/read"),params:vL.extend({uri:P.string()})}),Hp=kL.extend({contents:P.array(P.union([qKB,LKB]))}),fM3=fS.extend({method:P.literal("notifications/resources/list_changed")}),bM3=sz.extend({method:P.literal("resources/subscribe"),params:vL.extend({uri:P.string()})}),hM3=sz.extend({method:P.literal("resources/unsubscribe"),params:vL.extend({uri:P.string()})}),gM3=fS.extend({method:P.literal("notifications/resources/updated"),params:EwA.extend({uri:P.string()})}),uM3=P.object({name:P.string(),description:P.optional(P.string()),required:P.optional(P.boolean())}).passthrough(),mM3=HwA.extend({description:P.optional(P.string()),arguments:P.optional(P.array(uM3)),_meta:P.optional(P.object({}).passthrough())}),dM3=coA.extend({method:P.literal("prompts/list")}),FwA=poA.extend({prompts:P.array(mM3)}),cM3=sz.extend({method:P.literal("prompts/get"),params:vL.extend({name:P.string(),arguments:P.optional(P.record(P.string()))})}),Yc1=P.object({type:P.literal("text"),text:P.string(),_meta:P.optional(P.object({}).passthrough())}).passthrough(),Jc1=P.object({type:P.literal("image"),data:Gc1,mimeType:P.string(),_meta:P.optional(P.object({}).passthrough())}).passthrough(),Ic1=P.object({type:P.literal("audio"),data:Gc1,mimeType:P.string(),_meta:P.optional(P.object({}).passthrough())}).passthrough(),pM3=P.object({type:P.literal("resource"),resource:P.union([qKB,LKB]),_meta:P.optional(P.object({}).passthrough())}).passthrough(),lM3=MKB.extend({type:P.literal("resource_link")}),OKB=P.union([Yc1,Jc1,Ic1,lM3,pM3]),iM3=P.object({role:P.enum(["user","assistant"]),content:OKB}).passthrough(),Xc1=kL.extend({description:P.optional(P.string()),messages:P.array(iM3)}),nM3=fS.extend({method:P.literal("notifications/prompts/list_changed")}),aM3=P.object({title:P.optional(P.string()),readOnlyHint:P.optional(P.boolean()),destructiveHint:P.optional(P.boolean()),idempotentHint:P.optional(P.boolean()),openWorldHint:P.optional(P.boolean())}).passthrough(),oM3=HwA.extend({description:P.optional(P.string()),inputSchema:P.object({type:P.literal("object"),properties:P.optional(P.object({}).passthrough()),required:P.optional(P.array(P.string()))}).passthrough(),outputSchema:P.optional(P.object({type:P.literal("object"),properties:P.optional(P.object({}).passthrough()),required:P.optional(P.array(P.string()))}).passthrough()),annotations:P.optional(aM3),_meta:P.optional(P.object({}).passthrough())}),loA=coA.extend({method:P.literal("tools/list")}),CwA=poA.extend({tools:P.array(oM3)}),F_=kL.extend({content:P.array(OKB).default([]),structuredContent:P.object({}).passthrough().optional(),isError:P.optional(P.boolean())}),gi7=F_.or(kL.extend({toolResult:P.unknown()})),ioA=sz.extend({method:P.literal("tools/call"),params:vL.extend({name:P.string(),arguments:P.optional(P.record(P.unknown()))})}),rM3=fS.extend({method:P.literal("notifications/tools/list_changed")}),RKB=P.enum(["debug","info","notice","warning","error","critical","alert","emergency"]),sM3=sz.extend({method:P.literal("logging/setLevel"),params:vL.extend({level:RKB})}),tM3=fS.extend({method:P.literal("notifications/message"),params:EwA.extend({level:RKB,logger:P.optional(P.string()),data:P.unknown()})}),eM3=P.object({name:P.string().optional()}).passthrough(),AO3=P.object({hints:P.optional(P.array(eM3)),costPriority:P.optional(P.number().min(0).max(1)),speedPriority:P.optional(P.number().min(0).max(1)),intelligencePriority:P.optional(P.number().min(0).max(1))}).passthrough(),QO3=P.object({role:P.enum(["user","assistant"]),content:P.union([Yc1,Jc1,Ic1])}).passthrough(),BO3=sz.extend({method:P.literal("sampling/createMessage"),params:vL.extend({messages:P.array(QO3),systemPrompt:P.optional(P.string()),includeContext:P.optional(P.enum(["none","thisServer","allServers"])),temperature:P.optional(P.number()),maxTokens:P.number().int(),stopSequences:P.optional(P.array(P.string())),metadata:P.optional(P.object({}).passthrough()),modelPreferences:P.optional(AO3)})}),Wc1=kL.extend({model:P.string(),stopReason:P.optional(P.enum(["endTurn","stopSequence","maxTokens"]).or(P.string())),role:P.enum(["user","assistant"]),content:P.discriminatedUnion("type",[Yc1,Jc1,Ic1])}),GO3=P.object({type:P.literal("boolean"),title:P.optional(P.string()),description:P.optional(P.string()),default:P.optional(P.boolean())}).passthrough(),ZO3=P.object({type:P.literal("string"),title:P.optional(P.string()),description:P.optional(P.string()),minLength:P.optional(P.number()),maxLength:P.optional(P.number()),format:P.optional(P.enum(["email","uri","date","date-time"]))}).passthrough(),YO3=P.object({type:P.enum(["number","integer"]),title:P.optional(P.string()),description:P.optional(P.string()),minimum:P.optional(P.number()),maximum:P.optional(P.number())}).passthrough(),JO3=P.object({type:P.literal("string"),title:P.optional(P.string()),description:P.optional(P.string()),enum:P.array(P.string()),enumNames:P.optional(P.array(P.string()))}).passthrough(),IO3=P.union([GO3,ZO3,YO3,JO3]),_KB=sz.extend({method:P.literal("elicitation/create"),params:vL.extend({message:P.string(),requestedSchema:P.object({type:P.literal("object"),properties:P.record(P.string(),IO3),required:P.optional(P.array(P.string()))}).passthrough()})}),Kc1=kL.extend({action:P.enum(["accept","decline","cancel"]),content:P.optional(P.record(P.string(),P.unknown()))}),XO3=P.object({type:P.literal("ref/resource"),uri:P.string()}).passthrough(),WO3=P.object({type:P.literal("ref/prompt"),name:P.string()}).passthrough(),KO3=sz.extend({method:P.literal("completion/complete"),params:vL.extend({ref:P.union([WO3,XO3]),argument:P.object({name:P.string(),value:P.string()}).passthrough(),context:P.optional(P.object({arguments:P.optional(P.record(P.string(),P.string()))}))})}),Vc1=kL.extend({completion:P.object({values:P.array(P.string()).max(100),total:P.optional(P.number().int()),hasMore:P.optional(P.boolean())}).passthrough()}),VO3=P.object({uri:P.string().startsWith("file://"),name:P.optional(P.string()),_meta:P.optional(P.object({}).passthrough())}).passthrough(),Ec1=sz.extend({method:P.literal("roots/list")}),Dc1=kL.extend({roots:P.array(VO3)}),EO3=fS.extend({method:P.literal("notifications/roots/list_changed")}),ui7=P.union([moA,Qc1,KO3,sM3,cM3,dM3,yM3,vM3,kM3,bM3,hM3,ioA,loA]),mi7=P.union([goA,doA,uoA,EO3]),di7=P.union([Ab,Wc1,Kc1,Dc1]),ci7=P.union([moA,BO3,_KB,Ec1]),pi7=P.union([goA,doA,tM3,gM3,fM3,rM3,nM3]),li7=P.union([Ab,Bc1,Vc1,Xc1,FwA,$e,Zc1,Hp,F_,CwA]);lF=class lF extends Error{constructor(A,Q,B){super(`MCP error ${A}: ${Q}`);this.code=A,this.data=B,this.name="McpError"}}});class zwA{constructor(A){this._options=A,this._requestMessageId=0,this._requestHandlers=new Map,this._requestHandlerAbortControllers=new Map,this._notificationHandlers=new Map,this._responseHandlers=new Map,this._progressHandlers=new Map,this._timeoutInfo=new Map,this._pendingDebouncedNotifications=new Set,this.setNotificationHandler(goA,(Q)=>{let B=this._requestHandlerAbortControllers.get(Q.params.requestId);B===null||B===void 0||B.abort(Q.params.reason)}),this.setNotificationHandler(doA,(Q)=>{this._onprogress(Q)}),this.setRequestHandler(moA,(Q)=>({}))}_setupTimeout(A,Q,B,G,Z=!1){this._timeoutInfo.set(A,{timeoutId:setTimeout(G,Q),startTime:Date.now(),timeout:Q,maxTotalTimeout:B,resetTimeoutOnProgress:Z,onTimeout:G})}_resetTimeout(A){let Q=this._timeoutInfo.get(A);if(!Q)return!1;let B=Date.now()-Q.startTime;if(Q.maxTotalTimeout&&B>=Q.maxTotalTimeout)throw this._timeoutInfo.delete(A),new lF(pF.RequestTimeout,"Maximum total timeout exceeded",{maxTotalTimeout:Q.maxTotalTimeout,totalElapsed:B});return clearTimeout(Q.timeoutId),Q.timeoutId=setTimeout(Q.onTimeout,Q.timeout),!0}_cleanupTimeout(A){let Q=this._timeoutInfo.get(A);if(Q)clearTimeout(Q.timeoutId),this._timeoutInfo.delete(A)}async connect(A){var Q,B,G;this._transport=A;let Z=(Q=this.transport)===null||Q===void 0?void 0:Q.onclose;this._transport.onclose=()=>{Z===null||Z===void 0||Z(),this._onclose()};let Y=(B=this.transport)===null||B===void 0?void 0:B.onerror;this._transport.onerror=(I)=>{Y===null||Y===void 0||Y(I),this._onerror(I)};let J=(G=this._transport)===null||G===void 0?void 0:G.onmessage;this._transport.onmessage=(I,X)=>{if(J===null||J===void 0||J(I,X),DwA(I)||UKB(I))this._onresponse(I);else if(hoA(I))this._onrequest(I,X);else if(FKB(I))this._onnotification(I);else this._onerror(Error(`Unknown message type: ${JSON.stringify(I)}`))},await this._transport.start()}_onclose(){var A;let Q=this._responseHandlers;this._responseHandlers=new Map,this._progressHandlers.clear(),this._pendingDebouncedNotifications.clear(),this._transport=void 0,(A=this.onclose)===null||A===void 0||A.call(this);let B=new lF(pF.ConnectionClosed,"Connection closed");for(let G of Q.values())G(B)}_onerror(A){var Q;(Q=this.onerror)===null||Q===void 0||Q.call(this,A)}_onnotification(A){var Q;let B=(Q=this._notificationHandlers.get(A.method))!==null&&Q!==void 0?Q:this.fallbackNotificationHandler;if(B===void 0)return;Promise.resolve().then(()=>B(A)).catch((G)=>this._onerror(Error(`Uncaught error in notification handler: ${G}`)))}_onrequest(A,Q){var B,G;let Z=(B=this._requestHandlers.get(A.method))!==null&&B!==void 0?B:this.fallbackRequestHandler,Y=this._transport;if(Z===void 0){Y===null||Y===void 0||Y.send({jsonrpc:"2.0",id:A.id,error:{code:pF.MethodNotFound,message:"Method not found"}}).catch((X)=>this._onerror(Error(`Failed to send an error response: ${X}`)));return}let J=new AbortController;this._requestHandlerAbortControllers.set(A.id,J);let I={signal:J.signal,sessionId:Y===null||Y===void 0?void 0:Y.sessionId,_meta:(G=A.params)===null||G===void 0?void 0:G._meta,sendNotification:(X)=>this.notification(X,{relatedRequestId:A.id}),sendRequest:(X,W,K)=>this.request(X,W,{...K,relatedRequestId:A.id}),authInfo:Q===null||Q===void 0?void 0:Q.authInfo,requestId:A.id,requestInfo:Q===null||Q===void 0?void 0:Q.requestInfo};Promise.resolve().then(()=>Z(A,I)).then((X)=>{if(J.signal.aborted)return;return Y===null||Y===void 0?void 0:Y.send({result:X,jsonrpc:"2.0",id:A.id})},(X)=>{var W;if(J.signal.aborted)return;return Y===null||Y===void 0?void 0:Y.send({jsonrpc:"2.0",id:A.id,error:{code:Number.isSafeInteger(X.code)?X.code:pF.InternalError,message:(W=X.message)!==null&&W!==void 0?W:"Internal error"}})}).catch((X)=>this._onerror(Error(`Failed to send response: ${X}`))).finally(()=>{this._requestHandlerAbortControllers.delete(A.id)})}_onprogress(A){let{progressToken:Q,...B}=A.params,G=Number(Q),Z=this._progressHandlers.get(G);if(!Z){this._onerror(Error(`Received a progress notification for an unknown token: ${JSON.stringify(A)}`));return}let Y=this._responseHandlers.get(G),J=this._timeoutInfo.get(G);if(J&&Y&&J.resetTimeoutOnProgress)try{this._resetTimeout(G)}catch(I){Y(I);return}Z(B)}_onresponse(A){let Q=Number(A.id),B=this._responseHandlers.get(Q);if(B===void 0){this._onerror(Error(`Received a response for an unknown message ID: ${JSON.stringify(A)}`));return}if(this._responseHandlers.delete(Q),this._progressHandlers.delete(Q),this._cleanupTimeout(Q),DwA(A))B(A);else{let G=new lF(A.error.code,A.error.message,A.error.data);B(G)}}get transport(){return this._transport}async close(){var A;await((A=this._transport)===null||A===void 0?void 0:A.close())}request(A,Q,B){let{relatedRequestId:G,resumptionToken:Z,onresumptiontoken:Y}=B!==null&&B!==void 0?B:{};return new Promise((J,I)=>{var X,W,K,V,E,D;if(!this._transport){I(Error("Not connected"));return}if(((X=this._options)===null||X===void 0?void 0:X.enforceStrictCapabilities)===!0)this.assertCapabilityForMethod(A.method);(W=B===null||B===void 0?void 0:B.signal)===null||W===void 0||W.throwIfAborted();let H=this._requestMessageId++,F={...A,jsonrpc:"2.0",id:H};if(B===null||B===void 0?void 0:B.onprogress)this._progressHandlers.set(H,B.onprogress),F.params={...A.params,_meta:{...((K=A.params)===null||K===void 0?void 0:K._meta)||{},progressToken:H}};let C=(q)=>{var M;this._responseHandlers.delete(H),this._progressHandlers.delete(H),this._cleanupTimeout(H),(M=this._transport)===null||M===void 0||M.send({jsonrpc:"2.0",method:"notifications/cancelled",params:{requestId:H,reason:String(q)}},{relatedRequestId:G,resumptionToken:Z,onresumptiontoken:Y}).catch((_)=>this._onerror(Error(`Failed to send cancellation: ${_}`))),I(q)};this._responseHandlers.set(H,(q)=>{var M;if((M=B===null||B===void 0?void 0:B.signal)===null||M===void 0?void 0:M.aborted)return;if(q instanceof Error)return I(q);try{let _=Q.parse(q.result);J(_)}catch(_){I(_)}}),(V=B===null||B===void 0?void 0:B.signal)===null||V===void 0||V.addEventListener("abort",()=>{var q;C((q=B===null||B===void 0?void 0:B.signal)===null||q===void 0?void 0:q.reason)});let U=(E=B===null||B===void 0?void 0:B.timeout)!==null&&E!==void 0?E:DO3,O=()=>C(new lF(pF.RequestTimeout,"Request timed out",{timeout:U}));this._setupTimeout(H,U,B===null||B===void 0?void 0:B.maxTotalTimeout,O,(D=B===null||B===void 0?void 0:B.resetTimeoutOnProgress)!==null&&D!==void 0?D:!1),this._transport.send(F,{relatedRequestId:G,resumptionToken:Z,onresumptiontoken:Y}).catch((q)=>{this._cleanupTimeout(H),I(q)})})}async notification(A,Q){var B,G;if(!this._transport)throw Error("Not connected");if(this.assertNotificationCapability(A.method),((G=(B=this._options)===null||B===void 0?void 0:B.debouncedNotificationMethods)!==null&&G!==void 0?G:[]).includes(A.method)&&!A.params&&!(Q===null||Q===void 0?void 0:Q.relatedRequestId)){if(this._pendingDebouncedNotifications.has(A.method))return;this._pendingDebouncedNotifications.add(A.method),Promise.resolve().then(()=>{var I;if(this._pendingDebouncedNotifications.delete(A.method),!this._transport)return;let X={...A,jsonrpc:"2.0"};(I=this._transport)===null||I===void 0||I.send(X,Q).catch((W)=>this._onerror(W))});return}let J={...A,jsonrpc:"2.0"};await this._transport.send(J,Q)}setRequestHandler(A,Q){let B=A.shape.method.value;this.assertRequestHandlerCapability(B),this._requestHandlers.set(B,(G,Z)=>{return Promise.resolve(Q(A.parse(G),Z))})}removeRequestHandler(A){this._requestHandlers.delete(A)}assertCanSetRequestHandler(A){if(this._requestHandlers.has(A))throw Error(`A request handler for ${A} already exists, which would be overridden`)}setNotificationHandler(A,Q){this._notificationHandlers.set(A.shape.method.value,(B)=>Promise.resolve(Q(A.parse(B))))}removeNotificationHandler(A){this._notificationHandlers.delete(A)}}function noA(A,Q){return Object.entries(Q).reduce((B,[G,Z])=>{if(Z&&typeof Z==="object")B[G]=B[G]?{...B[G],...Z}:Z;else B[G]=Z;return B},{...A})}var DO3=60000;var Hc1=L(()=>{JV()});var jKB=w((aoA,TKB)=>{(function(A,Q){typeof aoA==="object"&&typeof TKB<"u"?Q(aoA):typeof define==="function"&&define.amd?define(["exports"],Q):Q(A.URI=A.URI||{})})(aoA,function(A){function Q(){for(var K1=arguments.length,iA=Array(K1),F1=0;F1<K1;F1++)iA[F1]=arguments[F1];if(iA.length>1){iA[0]=iA[0].slice(0,-1);var A0=iA.length-1;for(var D0=1;D0<A0;++D0)iA[D0]=iA[D0].slice(1,-1);return iA[A0]=iA[A0].slice(1),iA.join("")}else return iA[0]}function B(K1){return"(?:"+K1+")"}function G(K1){return K1===void 0?"undefined":K1===null?"null":Object.prototype.toString.call(K1).split(" ").pop().split("]").shift().toLowerCase()}function Z(K1){return K1.toUpperCase()}function Y(K1){return K1!==void 0&&K1!==null?K1 instanceof Array?K1:typeof K1.length!=="number"||K1.split||K1.setInterval||K1.call?[K1]:Array.prototype.slice.call(K1):[]}function J(K1,iA){var F1=K1;if(iA)for(var A0 in iA)F1[A0]=iA[A0];return F1}function I(K1){var iA="[A-Za-z]",F1="[\\x0D]",A0="[0-9]",D0="[\\x22]",YQ=Q(A0,"[A-Fa-f]"),Q2="[\\x0A]",K9="[\\x20]",b9=B(B("%[EFef]"+YQ+"%"+YQ+YQ+"%"+YQ+YQ)+"|"+B("%[89A-Fa-f]"+YQ+"%"+YQ+YQ)+"|"+B("%"+YQ+YQ)),g6="[\\:\\/\\?\\#\\[\\]\\@]",T9="[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",M6=Q(g6,T9),n6=K1?"[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]":"[]",k4=K1?"[\\uE000-\\uF8FF]":"[]",$2=Q(iA,A0,"[\\-\\.\\_\\~]",n6),s2=B(iA+Q(iA,A0,"[\\+\\-\\.]")+"*"),H9=B(B(b9+"|"+Q($2,T9,"[\\:]"))+"*"),E5=B(B("25[0-5]")+"|"+B("2[0-4]"+A0)+"|"+B("1"+A0+A0)+"|"+B("[1-9]"+A0)+"|"+A0),w3=B(B("25[0-5]")+"|"+B("2[0-4]"+A0)+"|"+B("1"+A0+A0)+"|"+B("0?[1-9]"+A0)+"|0?0?"+A0),U6=B(w3+"\\."+w3+"\\."+w3+"\\."+w3),h9=B(YQ+"{1,4}"),t0=B(B(h9+"\\:"+h9)+"|"+U6),nQ=B(B(h9+"\\:")+"{6}"+t0),xB=B("\\:\\:"+B(h9+"\\:")+"{5}"+t0),Y4=B(B(h9)+"?\\:\\:"+B(h9+"\\:")+"{4}"+t0),e4=B(B(B(h9+"\\:")+"{0,1}"+h9)+"?\\:\\:"+B(h9+"\\:")+"{3}"+t0),kG=B(B(B(h9+"\\:")+"{0,2}"+h9)+"?\\:\\:"+B(h9+"\\:")+"{2}"+t0),DZ=B(B(B(h9+"\\:")+"{0,3}"+h9)+"?\\:\\:"+h9+"\\:"+t0),S3=B(B(B(h9+"\\:")+"{0,4}"+h9)+"?\\:\\:"+t0),N3=B(B(B(h9+"\\:")+"{0,5}"+h9)+"?\\:\\:"+h9),nA=B(B(B(h9+"\\:")+"{0,6}"+h9)+"?\\:\\:"),IA=B([nQ,xB,Y4,e4,kG,DZ,S3,N3,nA].join("|")),BA=B(B($2+"|"+b9)+"+"),xA=B(IA+"\\%25"+BA),hA=B(IA+B("\\%25|\\%(?!"+YQ+"{2})")+BA),dA=B("[vV]"+YQ+"+\\."+Q($2,T9,"[\\:]")+"+"),q1=B("\\["+B(hA+"|"+IA+"|"+dA)+"\\]"),v1=B(B(b9+"|"+Q($2,T9))+"*"),f1=B(q1+"|"+U6+"(?!"+v1+")|"+v1),a1=B(A0+"*"),e1=B(B(H9+"@")+"?"+f1+B("\\:"+a1)+"?"),L0=B(b9+"|"+Q($2,T9,"[\\:\\@]")),LQ=B(L0+"*"),XB=B(L0+"+"),S2=B(B(b9+"|"+Q($2,T9,"[\\@]"))+"+"),iB=B(B("\\/"+LQ)+"*"),c2=B("\\/"+B(XB+iB)+"?"),O6=B(S2+iB),D5=B(XB+iB),F8="(?!"+L0+")",wK=B(iB+"|"+c2+"|"+O6+"|"+D5+"|"+F8),JG=B(B(L0+"|"+Q("[\\/\\?]",k4))+"*"),gJ=B(B(L0+"|[\\/\\?]")+"*"),uJ=B(B("\\/\\/"+e1+iB)+"|"+c2+"|"+D5+"|"+F8),_W=B(s2+"\\:"+uJ+B("\\?"+JG)+"?"+B("\\#"+gJ)+"?"),H5=B(B("\\/\\/"+e1+iB)+"|"+c2+"|"+O6+"|"+F8),IG=B(H5+B("\\?"+JG)+"?"+B("\\#"+gJ)+"?"),NK=B(_W+"|"+IG),RX=B(s2+"\\:"+uJ+B("\\?"+JG)+"?"),_X="^("+s2+")\\:"+B(B("\\/\\/("+B("("+H9+")@")+"?("+f1+")"+B("\\:("+a1+")")+"?)")+"?("+iB+"|"+c2+"|"+D5+"|"+F8+")")+B("\\?("+JG+")")+"?"+B("\\#("+gJ+")")+"?$",TW="^(){0}"+B(B("\\/\\/("+B("("+H9+")@")+"?("+f1+")"+B("\\:("+a1+")")+"?)")+"?("+iB+"|"+c2+"|"+O6+"|"+F8+")")+B("\\?("+JG+")")+"?"+B("\\#("+gJ+")")+"?$",HZ="^("+s2+")\\:"+B(B("\\/\\/("+B("("+H9+")@")+"?("+f1+")"+B("\\:("+a1+")")+"?)")+"?("+iB+"|"+c2+"|"+D5+"|"+F8+")")+B("\\?("+JG+")")+"?$",mJ="^"+B("\\#("+gJ+")")+"?$",eM="^"+B("("+H9+")@")+"?("+f1+")"+B("\\:("+a1+")")+"?$";return{NOT_SCHEME:new RegExp(Q("[^]",iA,A0,"[\\+\\-\\.]"),"g"),NOT_USERINFO:new RegExp(Q("[^\\%\\:]",$2,T9),"g"),NOT_HOST:new RegExp(Q("[^\\%\\[\\]\\:]",$2,T9),"g"),NOT_PATH:new RegExp(Q("[^\\%\\/\\:\\@]",$2,T9),"g"),NOT_PATH_NOSCHEME:new RegExp(Q("[^\\%\\/\\@]",$2,T9),"g"),NOT_QUERY:new RegExp(Q("[^\\%]",$2,T9,"[\\:\\@\\/\\?]",k4),"g"),NOT_FRAGMENT:new RegExp(Q("[^\\%]",$2,T9,"[\\:\\@\\/\\?]"),"g"),ESCAPE:new RegExp(Q("[^]",$2,T9),"g"),UNRESERVED:new RegExp($2,"g"),OTHER_CHARS:new RegExp(Q("[^\\%]",$2,M6),"g"),PCT_ENCODED:new RegExp(b9,"g"),IPV4ADDRESS:new RegExp("^("+U6+")$"),IPV6ADDRESS:new RegExp("^\\[?("+IA+")"+B(B("\\%25|\\%(?!"+YQ+"{2})")+"("+BA+")")+"?\\]?$")}}var X=I(!1),W=I(!0),K=function(){function K1(iA,F1){var A0=[],D0=!0,YQ=!1,Q2=void 0;try{for(var K9=iA[Symbol.iterator](),b9;!(D0=(b9=K9.next()).done);D0=!0)if(A0.push(b9.value),F1&&A0.length===F1)break}catch(g6){YQ=!0,Q2=g6}finally{try{if(!D0&&K9.return)K9.return()}finally{if(YQ)throw Q2}}return A0}return function(iA,F1){if(Array.isArray(iA))return iA;else if(Symbol.iterator in Object(iA))return K1(iA,F1);else throw TypeError("Invalid attempt to destructure non-iterable instance")}}(),V=function(K1){if(Array.isArray(K1)){for(var iA=0,F1=Array(K1.length);iA<K1.length;iA++)F1[iA]=K1[iA];return F1}else return Array.from(K1)},E=2147483647,D=36,H=1,F=26,C=38,U=700,O=72,q=128,M="-",_=/^xn--/,T=/[^\0-\x7E]/,y=/[\x2E\u3002\uFF0E\uFF61]/g,h={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},x=D-H,m=Math.floor,g=String.fromCharCode;function t(K1){throw RangeError(h[K1])}function p(K1,iA){var F1=[],A0=K1.length;while(A0--)F1[A0]=iA(K1[A0]);return F1}function k(K1,iA){var F1=K1.split("@"),A0="";if(F1.length>1)A0=F1[0]+"@",K1=F1[1];K1=K1.replace(y,".");var D0=K1.split("."),YQ=p(D0,iA).join(".");return A0+YQ}function c(K1){var iA=[],F1=0,A0=K1.length;while(F1<A0){var D0=K1.charCodeAt(F1++);if(D0>=55296&&D0<=56319&&F1<A0){var YQ=K1.charCodeAt(F1++);if((YQ&64512)==56320)iA.push(((D0&1023)<<10)+(YQ&1023)+65536);else iA.push(D0),F1--}else iA.push(D0)}return iA}var e=function(iA){return String.fromCodePoint.apply(String,V(iA))},AA=function(iA){if(iA-48<10)return iA-22;if(iA-65<26)return iA-65;if(iA-97<26)return iA-97;return D},VA=function(iA,F1){return iA+22+75*(iA<26)-((F1!=0)<<5)},OA=function(iA,F1,A0){var D0=0;iA=A0?m(iA/U):iA>>1,iA+=m(iA/F1);for(;iA>x*F>>1;D0+=D)iA=m(iA/x);return m(D0+(x+1)*iA/(iA+C))},EA=function(iA){var F1=[],A0=iA.length,D0=0,YQ=q,Q2=O,K9=iA.lastIndexOf(M);if(K9<0)K9=0;for(var b9=0;b9<K9;++b9){if(iA.charCodeAt(b9)>=128)t("not-basic");F1.push(iA.charCodeAt(b9))}for(var g6=K9>0?K9+1:0;g6<A0;){var T9=D0;for(var M6=1,n6=D;;n6+=D){if(g6>=A0)t("invalid-input");var k4=AA(iA.charCodeAt(g6++));if(k4>=D||k4>m((E-D0)/M6))t("overflow");D0+=k4*M6;var $2=n6<=Q2?H:n6>=Q2+F?F:n6-Q2;if(k4<$2)break;var s2=D-$2;if(M6>m(E/s2))t("overflow");M6*=s2}var H9=F1.length+1;if(Q2=OA(D0-T9,H9,T9==0),m(D0/H9)>E-YQ)t("overflow");YQ+=m(D0/H9),D0%=H9,F1.splice(D0++,0,YQ)}return String.fromCodePoint.apply(String,F1)},SA=function(iA){var F1=[];iA=c(iA);var A0=iA.length,D0=q,YQ=0,Q2=O,K9=!0,b9=!1,g6=void 0;try{for(var T9=iA[Symbol.iterator](),M6;!(K9=(M6=T9.next()).done);K9=!0){var n6=M6.value;if(n6<128)F1.push(g(n6))}}catch(hA){b9=!0,g6=hA}finally{try{if(!K9&&T9.return)T9.return()}finally{if(b9)throw g6}}var k4=F1.length,$2=k4;if(k4)F1.push(M);while($2<A0){var s2=E,H9=!0,E5=!1,w3=void 0;try{for(var U6=iA[Symbol.iterator](),h9;!(H9=(h9=U6.next()).done);H9=!0){var t0=h9.value;if(t0>=D0&&t0<s2)s2=t0}}catch(hA){E5=!0,w3=hA}finally{try{if(!H9&&U6.return)U6.return()}finally{if(E5)throw w3}}var nQ=$2+1;if(s2-D0>m((E-YQ)/nQ))t("overflow");YQ+=(s2-D0)*nQ,D0=s2;var xB=!0,Y4=!1,e4=void 0;try{for(var kG=iA[Symbol.iterator](),DZ;!(xB=(DZ=kG.next()).done);xB=!0){var S3=DZ.value;if(S3<D0&&++YQ>E)t("overflow");if(S3==D0){var N3=YQ;for(var nA=D;;nA+=D){var IA=nA<=Q2?H:nA>=Q2+F?F:nA-Q2;if(N3<IA)break;var BA=N3-IA,xA=D-IA;F1.push(g(VA(IA+BA%xA,0))),N3=m(BA/xA)}F1.push(g(VA(N3,0))),Q2=OA(YQ,nQ,$2==k4),YQ=0,++$2}}}catch(hA){Y4=!0,e4=hA}finally{try{if(!xB&&kG.return)kG.return()}finally{if(Y4)throw e4}}++YQ,++D0}return F1.join("")},yA=function(iA){return k(iA,function(F1){return _.test(F1)?EA(F1.slice(4).toLowerCase()):F1})},ZA=function(iA){return k(iA,function(F1){return T.test(F1)?"xn--"+SA(F1):F1})},GA={version:"2.1.0",ucs2:{decode:c,encode:e},decode:EA,encode:SA,toASCII:ZA,toUnicode:yA},zA={};function bA(K1){var iA=K1.charCodeAt(0),F1=void 0;if(iA<16)F1="%0"+iA.toString(16).toUpperCase();else if(iA<128)F1="%"+iA.toString(16).toUpperCase();else if(iA<2048)F1="%"+(iA>>6|192).toString(16).toUpperCase()+"%"+(iA&63|128).toString(16).toUpperCase();else F1="%"+(iA>>12|224).toString(16).toUpperCase()+"%"+(iA>>6&63|128).toString(16).toUpperCase()+"%"+(iA&63|128).toString(16).toUpperCase();return F1}function TA(K1){var iA="",F1=0,A0=K1.length;while(F1<A0){var D0=parseInt(K1.substr(F1+1,2),16);if(D0<128)iA+=String.fromCharCode(D0),F1+=3;else if(D0>=194&&D0<224){if(A0-F1>=6){var YQ=parseInt(K1.substr(F1+4,2),16);iA+=String.fromCharCode((D0&31)<<6|YQ&63)}else iA+=K1.substr(F1,6);F1+=6}else if(D0>=224){if(A0-F1>=9){var Q2=parseInt(K1.substr(F1+4,2),16),K9=parseInt(K1.substr(F1+7,2),16);iA+=String.fromCharCode((D0&15)<<12|(Q2&63)<<6|K9&63)}else iA+=K1.substr(F1,9);F1+=9}else iA+=K1.substr(F1,3),F1+=3}return iA}function G1(K1,iA){function F1(A0){var D0=TA(A0);return!D0.match(iA.UNRESERVED)?A0:D0}if(K1.scheme)K1.scheme=String(K1.scheme).replace(iA.PCT_ENCODED,F1).toLowerCase().replace(iA.NOT_SCHEME,"");if(K1.userinfo!==void 0)K1.userinfo=String(K1.userinfo).replace(iA.PCT_ENCODED,F1).replace(iA.NOT_USERINFO,bA).replace(iA.PCT_ENCODED,Z);if(K1.host!==void 0)K1.host=String(K1.host).replace(iA.PCT_ENCODED,F1).toLowerCase().replace(iA.NOT_HOST,bA).replace(iA.PCT_ENCODED,Z);if(K1.path!==void 0)K1.path=String(K1.path).replace(iA.PCT_ENCODED,F1).replace(K1.scheme?iA.NOT_PATH:iA.NOT_PATH_NOSCHEME,bA).replace(iA.PCT_ENCODED,Z);if(K1.query!==void 0)K1.query=String(K1.query).replace(iA.PCT_ENCODED,F1).replace(iA.NOT_QUERY,bA).replace(iA.PCT_ENCODED,Z);if(K1.fragment!==void 0)K1.fragment=String(K1.fragment).replace(iA.PCT_ENCODED,F1).replace(iA.NOT_FRAGMENT,bA).replace(iA.PCT_ENCODED,Z);return K1}function YA(K1){return K1.replace(/^0*(.*)/,"$1")||"0"}function CA(K1,iA){var F1=K1.match(iA.IPV4ADDRESS)||[],A0=K(F1,2),D0=A0[1];if(D0)return D0.split(".").map(YA).join(".");else return K1}function MA(K1,iA){var F1=K1.match(iA.IPV6ADDRESS)||[],A0=K(F1,3),D0=A0[1],YQ=A0[2];if(D0){var Q2=D0.toLowerCase().split("::").reverse(),K9=K(Q2,2),b9=K9[0],g6=K9[1],T9=g6?g6.split(":").map(YA):[],M6=b9.split(":").map(YA),n6=iA.IPV4ADDRESS.test(M6[M6.length-1]),k4=n6?7:8,$2=M6.length-k4,s2=Array(k4);for(var H9=0;H9<k4;++H9)s2[H9]=T9[H9]||M6[$2+H9]||"";if(n6)s2[k4-1]=CA(s2[k4-1],iA);var E5=s2.reduce(function(nQ,xB,Y4){if(!xB||xB==="0"){var e4=nQ[nQ.length-1];if(e4&&e4.index+e4.length===Y4)e4.length++;else nQ.push({index:Y4,length:1})}return nQ},[]),w3=E5.sort(function(nQ,xB){return xB.length-nQ.length})[0],U6=void 0;if(w3&&w3.length>1){var h9=s2.slice(0,w3.index),t0=s2.slice(w3.index+w3.length);U6=h9.join(":")+"::"+t0.join(":")}else U6=s2.join(":");if(YQ)U6+="%"+YQ;return U6}else return K1}var NA=/^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i,UA="".match(/(){0}/)[1]===void 0;function LA(K1){var iA=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},F1={},A0=iA.iri!==!1?W:X;if(iA.reference==="suffix")K1=(iA.scheme?iA.scheme+":":"")+"//"+K1;var D0=K1.match(NA);if(D0){if(UA){if(F1.scheme=D0[1],F1.userinfo=D0[3],F1.host=D0[4],F1.port=parseInt(D0[5],10),F1.path=D0[6]||"",F1.query=D0[7],F1.fragment=D0[8],isNaN(F1.port))F1.port=D0[5]}else if(F1.scheme=D0[1]||void 0,F1.userinfo=K1.indexOf("@")!==-1?D0[3]:void 0,F1.host=K1.indexOf("//")!==-1?D0[4]:void 0,F1.port=parseInt(D0[5],10),F1.path=D0[6]||"",F1.query=K1.indexOf("?")!==-1?D0[7]:void 0,F1.fragment=K1.indexOf("#")!==-1?D0[8]:void 0,isNaN(F1.port))F1.port=K1.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/)?D0[4]:void 0;if(F1.host)F1.host=MA(CA(F1.host,A0),A0);if(F1.scheme===void 0&&F1.userinfo===void 0&&F1.host===void 0&&F1.port===void 0&&!F1.path&&F1.query===void 0)F1.reference="same-document";else if(F1.scheme===void 0)F1.reference="relative";else if(F1.fragment===void 0)F1.reference="absolute";else F1.reference="uri";if(iA.reference&&iA.reference!=="suffix"&&iA.reference!==F1.reference)F1.error=F1.error||"URI is not a "+iA.reference+" reference.";var YQ=zA[(iA.scheme||F1.scheme||"").toLowerCase()];if(!iA.unicodeSupport&&(!YQ||!YQ.unicodeSupport)){if(F1.host&&(iA.domainHost||YQ&&YQ.domainHost))try{F1.host=GA.toASCII(F1.host.replace(A0.PCT_ENCODED,TA).toLowerCase())}catch(Q2){F1.error=F1.error||"Host's domain name can not be converted to ASCII via punycode: "+Q2}G1(F1,X)}else G1(F1,A0);if(YQ&&YQ.parse)YQ.parse(F1,iA)}else F1.error=F1.error||"URI can not be parsed.";return F1}function lA(K1,iA){var F1=iA.iri!==!1?W:X,A0=[];if(K1.userinfo!==void 0)A0.push(K1.userinfo),A0.push("@");if(K1.host!==void 0)A0.push(MA(CA(String(K1.host),F1),F1).replace(F1.IPV6ADDRESS,function(D0,YQ,Q2){return"["+YQ+(Q2?"%25"+Q2:"")+"]"}));if(typeof K1.port==="number"||typeof K1.port==="string")A0.push(":"),A0.push(String(K1.port));return A0.length?A0.join(""):void 0}var gA=/^\.\.?\//,I1=/^\/\.(\/|$)/,$1=/^\/\.\.(\/|$)/,RA=/^\/?(?:.|\n)*?(?=\/|$)/;function B1(K1){var iA=[];while(K1.length)if(K1.match(gA))K1=K1.replace(gA,"");else if(K1.match(I1))K1=K1.replace(I1,"/");else if(K1.match($1))K1=K1.replace($1,"/"),iA.pop();else if(K1==="."||K1==="..")K1="";else{var F1=K1.match(RA);if(F1){var A0=F1[0];K1=K1.slice(A0.length),iA.push(A0)}else throw Error("Unexpected dot segment condition")}return iA.join("")}function m1(K1){var iA=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},F1=iA.iri?W:X,A0=[],D0=zA[(iA.scheme||K1.scheme||"").toLowerCase()];if(D0&&D0.serialize)D0.serialize(K1,iA);if(K1.host){if(F1.IPV6ADDRESS.test(K1.host));else if(iA.domainHost||D0&&D0.domainHost)try{K1.host=!iA.iri?GA.toASCII(K1.host.replace(F1.PCT_ENCODED,TA).toLowerCase()):GA.toUnicode(K1.host)}catch(K9){K1.error=K1.error||"Host's domain name can not be converted to "+(!iA.iri?"ASCII":"Unicode")+" via punycode: "+K9}}if(G1(K1,F1),iA.reference!=="suffix"&&K1.scheme)A0.push(K1.scheme),A0.push(":");var YQ=lA(K1,iA);if(YQ!==void 0){if(iA.reference!=="suffix")A0.push("//");if(A0.push(YQ),K1.path&&K1.path.charAt(0)!=="/")A0.push("/")}if(K1.path!==void 0){var Q2=K1.path;if(!iA.absolutePath&&(!D0||!D0.absolutePath))Q2=B1(Q2);if(YQ===void 0)Q2=Q2.replace(/^\/\//,"/%2F");A0.push(Q2)}if(K1.query!==void 0)A0.push("?"),A0.push(K1.query);if(K1.fragment!==void 0)A0.push("#"),A0.push(K1.fragment);return A0.join("")}function S1(K1,iA){var F1=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},A0=arguments[3],D0={};if(!A0)K1=LA(m1(K1,F1),F1),iA=LA(m1(iA,F1),F1);if(F1=F1||{},!F1.tolerant&&iA.scheme)D0.scheme=iA.scheme,D0.userinfo=iA.userinfo,D0.host=iA.host,D0.port=iA.port,D0.path=B1(iA.path||""),D0.query=iA.query;else{if(iA.userinfo!==void 0||iA.host!==void 0||iA.port!==void 0)D0.userinfo=iA.userinfo,D0.host=iA.host,D0.port=iA.port,D0.path=B1(iA.path||""),D0.query=iA.query;else{if(!iA.path)if(D0.path=K1.path,iA.query!==void 0)D0.query=iA.query;else D0.query=K1.query;else{if(iA.path.charAt(0)==="/")D0.path=B1(iA.path);else{if((K1.userinfo!==void 0||K1.host!==void 0||K1.port!==void 0)&&!K1.path)D0.path="/"+iA.path;else if(!K1.path)D0.path=iA.path;else D0.path=K1.path.slice(0,K1.path.lastIndexOf("/")+1)+iA.path;D0.path=B1(D0.path)}D0.query=iA.query}D0.userinfo=K1.userinfo,D0.host=K1.host,D0.port=K1.port}D0.scheme=K1.scheme}return D0.fragment=iA.fragment,D0}function H0(K1,iA,F1){var A0=J({scheme:"null"},F1);return m1(S1(LA(K1,A0),LA(iA,A0),A0,!0),A0)}function ZQ(K1,iA){if(typeof K1==="string")K1=m1(LA(K1,iA),iA);else if(G(K1)==="object")K1=LA(m1(K1,iA),iA);return K1}function o0(K1,iA,F1){if(typeof K1==="string")K1=m1(LA(K1,F1),F1);else if(G(K1)==="object")K1=m1(K1,F1);if(typeof iA==="string")iA=m1(LA(iA,F1),F1);else if(G(iA)==="object")iA=m1(iA,F1);return K1===iA}function EQ(K1,iA){return K1&&K1.toString().replace(!iA||!iA.iri?X.ESCAPE:W.ESCAPE,bA)}function WQ(K1,iA){return K1&&K1.toString().replace(!iA||!iA.iri?X.PCT_ENCODED:W.PCT_ENCODED,TA)}var w1={scheme:"http",domainHost:!0,parse:function(iA,F1){if(!iA.host)iA.error=iA.error||"HTTP URIs must have a host.";return iA},serialize:function(iA,F1){var A0=String(iA.scheme).toLowerCase()==="https";if(iA.port===(A0?443:80)||iA.port==="")iA.port=void 0;if(!iA.path)iA.path="/";return iA}},eA={scheme:"https",domainHost:w1.domainHost,parse:w1.parse,serialize:w1.serialize};function V1(K1){return typeof K1.secure==="boolean"?K1.secure:String(K1.scheme).toLowerCase()==="wss"}var R1={scheme:"ws",domainHost:!0,parse:function(iA,F1){var A0=iA;return A0.secure=V1(A0),A0.resourceName=(A0.path||"/")+(A0.query?"?"+A0.query:""),A0.path=void 0,A0.query=void 0,A0},serialize:function(iA,F1){if(iA.port===(V1(iA)?443:80)||iA.port==="")iA.port=void 0;if(typeof iA.secure==="boolean")iA.scheme=iA.secure?"wss":"ws",iA.secure=void 0;if(iA.resourceName){var A0=iA.resourceName.split("?"),D0=K(A0,2),YQ=D0[0],Q2=D0[1];iA.path=YQ&&YQ!=="/"?YQ:void 0,iA.query=Q2,iA.resourceName=void 0}return iA.fragment=void 0,iA}},G0={scheme:"wss",domainHost:R1.domainHost,parse:R1.parse,serialize:R1.serialize},U0={},C0=!0,HA="[A-Za-z0-9\\-\\.\\_\\~"+(C0?"\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF":"")+"]",wA="[0-9A-Fa-f]",tA=B(B("%[EFef]"+wA+"%"+wA+wA+"%"+wA+wA)+"|"+B("%[89A-Fa-f]"+wA+"%"+wA+wA)+"|"+B("%"+wA+wA)),N1="[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]",C1="[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]",D1=Q(C1,"[\\\"\\\\]"),X0="[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]",p1=new RegExp(HA,"g"),k0=new RegExp(tA,"g"),KQ=new RegExp(Q("[^]",N1,"[\\.]","[\\\"]",D1),"g"),bB=new RegExp(Q("[^]",HA,X0),"g"),IB=bB;function W2(K1){var iA=TA(K1);return!iA.match(p1)?K1:iA}var d0={scheme:"mailto",parse:function(iA,F1){var A0=iA,D0=A0.to=A0.path?A0.path.split(","):[];if(A0.path=void 0,A0.query){var YQ=!1,Q2={},K9=A0.query.split("&");for(var b9=0,g6=K9.length;b9<g6;++b9){var T9=K9[b9].split("=");switch(T9[0]){case"to":var M6=T9[1].split(",");for(var n6=0,k4=M6.length;n6<k4;++n6)D0.push(M6[n6]);break;case"subject":A0.subject=WQ(T9[1],F1);break;case"body":A0.body=WQ(T9[1],F1);break;default:YQ=!0,Q2[WQ(T9[0],F1)]=WQ(T9[1],F1);break}}if(YQ)A0.headers=Q2}A0.query=void 0;for(var $2=0,s2=D0.length;$2<s2;++$2){var H9=D0[$2].split("@");if(H9[0]=WQ(H9[0]),!F1.unicodeSupport)try{H9[1]=GA.toASCII(WQ(H9[1],F1).toLowerCase())}catch(E5){A0.error=A0.error||"Email address's domain name can not be converted to ASCII via punycode: "+E5}else H9[1]=WQ(H9[1],F1).toLowerCase();D0[$2]=H9.join("@")}return A0},serialize:function(iA,F1){var A0=iA,D0=Y(iA.to);if(D0){for(var YQ=0,Q2=D0.length;YQ<Q2;++YQ){var K9=String(D0[YQ]),b9=K9.lastIndexOf("@"),g6=K9.slice(0,b9).replace(k0,W2).replace(k0,Z).replace(KQ,bA),T9=K9.slice(b9+1);try{T9=!F1.iri?GA.toASCII(WQ(T9,F1).toLowerCase()):GA.toUnicode(T9)}catch($2){A0.error=A0.error||"Email address's domain name can not be converted to "+(!F1.iri?"ASCII":"Unicode")+" via punycode: "+$2}D0[YQ]=g6+"@"+T9}A0.path=D0.join(",")}var M6=iA.headers=iA.headers||{};if(iA.subject)M6.subject=iA.subject;if(iA.body)M6.body=iA.body;var n6=[];for(var k4 in M6)if(M6[k4]!==U0[k4])n6.push(k4.replace(k0,W2).replace(k0,Z).replace(bB,bA)+"="+M6[k4].replace(k0,W2).replace(k0,Z).replace(IB,bA));if(n6.length)A0.query=n6.join("&");return A0}},OQ=/^([^\:]+)\:(.*)/,fB={scheme:"urn",parse:function(iA,F1){var A0=iA.path&&iA.path.match(OQ),D0=iA;if(A0){var YQ=F1.scheme||D0.scheme||"urn",Q2=A0[1].toLowerCase(),K9=A0[2],b9=YQ+":"+(F1.nid||Q2),g6=zA[b9];if(D0.nid=Q2,D0.nss=K9,D0.path=void 0,g6)D0=g6.parse(D0,F1)}else D0.error=D0.error||"URN can not be parsed.";return D0},serialize:function(iA,F1){var A0=F1.scheme||iA.scheme||"urn",D0=iA.nid,YQ=A0+":"+(F1.nid||D0),Q2=zA[YQ];if(Q2)iA=Q2.serialize(iA,F1);var K9=iA,b9=iA.nss;return K9.path=(D0||F1.nid)+":"+b9,K9}},_9=/^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/,GB={scheme:"urn:uuid",parse:function(iA,F1){var A0=iA;if(A0.uuid=A0.nss,A0.nss=void 0,!F1.tolerant&&(!A0.uuid||!A0.uuid.match(_9)))A0.error=A0.error||"UUID is not valid.";return A0},serialize:function(iA,F1){var A0=iA;return A0.nss=(iA.uuid||"").toLowerCase(),A0}};zA[w1.scheme]=w1,zA[eA.scheme]=eA,zA[R1.scheme]=R1,zA[G0.scheme]=G0,zA[d0.scheme]=d0,zA[fB.scheme]=fB,zA[GB.scheme]=GB,A.SCHEMES=zA,A.pctEncChar=bA,A.pctDecChars=TA,A.parse=LA,A.removeDotSegments=B1,A.serialize=m1,A.resolveComponents=S1,A.resolve=H0,A.normalize=ZQ,A.equal=o0,A.escapeComponent=EQ,A.unescapeComponent=WQ,Object.defineProperty(A,"__esModule",{value:!0})})});var ooA=w((oi7,PKB)=>{PKB.exports=function A(Q,B){if(Q===B)return!0;if(Q&&B&&typeof Q=="object"&&typeof B=="object"){if(Q.constructor!==B.constructor)return!1;var G,Z,Y;if(Array.isArray(Q)){if(G=Q.length,G!=B.length)return!1;for(Z=G;Z--!==0;)if(!A(Q[Z],B[Z]))return!1;return!0}if(Q.constructor===RegExp)return Q.source===B.source&&Q.flags===B.flags;if(Q.valueOf!==Object.prototype.valueOf)return Q.valueOf()===B.valueOf();if(Q.toString!==Object.prototype.toString)return Q.toString()===B.toString();if(Y=Object.keys(Q),G=Y.length,G!==Object.keys(B).length)return!1;for(Z=G;Z--!==0;)if(!Object.prototype.hasOwnProperty.call(B,Y[Z]))return!1;for(Z=G;Z--!==0;){var J=Y[Z];if(!A(Q[J],B[J]))return!1}return!0}return Q!==Q&&B!==B}});var xKB=w((ri7,SKB)=>{SKB.exports=function(Q){var B=0,G=Q.length,Z=0,Y;while(Z<G)if(B++,Y=Q.charCodeAt(Z++),Y>=55296&&Y<=56319&&Z<G){if(Y=Q.charCodeAt(Z),(Y&64512)==56320)Z++}return B}});var we=w((si7,kKB)=>{kKB.exports={copy:HO3,checkDataType:Fc1,checkDataTypes:FO3,coerceToTypes:CO3,toHash:zc1,getProperty:Uc1,escapeQuotes:$c1,equal:ooA(),ucs2length:xKB(),varOccurences:$O3,varReplace:wO3,schemaHasRules:NO3,schemaHasRulesExcept:qO3,schemaUnknownRules:LO3,toQuotedString:Cc1,getPathExpr:MO3,getPath:OO3,getData:TO3,unescapeFragment:jO3,unescapeJsonPointer:Nc1,escapeFragment:PO3,escapeJsonPointer:wc1};function HO3(A,Q){Q=Q||{};for(var B in A)Q[B]=A[B];return Q}function Fc1(A,Q,B,G){var Z=G?" !== ":" === ",Y=G?" || ":" && ",J=G?"!":"",I=G?"":"!";switch(A){case"null":return Q+Z+"null";case"array":return J+"Array.isArray("+Q+")";case"object":return"("+J+Q+Y+"typeof "+Q+Z+'"object"'+Y+I+"Array.isArray("+Q+"))";case"integer":return"(typeof "+Q+Z+'"number"'+Y+I+"("+Q+" % 1)"+Y+Q+Z+Q+(B?Y+J+"isFinite("+Q+")":"")+")";case"number":return"(typeof "+Q+Z+'"'+A+'"'+(B?Y+J+"isFinite("+Q+")":"")+")";default:return"typeof "+Q+Z+'"'+A+'"'}}function FO3(A,Q,B){switch(A.length){case 1:return Fc1(A[0],Q,B,!0);default:var G="",Z=zc1(A);if(Z.array&&Z.object)G=Z.null?"(":"(!"+Q+" || ",G+="typeof "+Q+' !== "object")',delete Z.null,delete Z.array,delete Z.object;if(Z.number)delete Z.integer;for(var Y in Z)G+=(G?" && ":"")+Fc1(Y,Q,B,!0);return G}}var yKB=zc1(["string","number","integer","boolean","null"]);function CO3(A,Q){if(Array.isArray(Q)){var B=[];for(var G=0;G<Q.length;G++){var Z=Q[G];if(yKB[Z])B[B.length]=Z;else if(A==="array"&&Z==="array")B[B.length]=Z}if(B.length)return B}else if(yKB[Q])return[Q];else if(A==="array"&&Q==="array")return["array"]}function zc1(A){var Q={};for(var B=0;B<A.length;B++)Q[A[B]]=!0;return Q}var zO3=/^[a-z$_][a-z$_0-9]*$/i,UO3=/'|\\/g;function Uc1(A){return typeof A=="number"?"["+A+"]":zO3.test(A)?"."+A:"['"+$c1(A)+"']"}function $c1(A){return A.replace(UO3,"\\$&").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/\f/g,"\\f").replace(/\t/g,"\\t")}function $O3(A,Q){Q+="[^0-9]";var B=A.match(new RegExp(Q,"g"));return B?B.length:0}function wO3(A,Q,B){return Q+="([^0-9])",B=B.replace(/\$/g,"$$$$"),A.replace(new RegExp(Q,"g"),B+"$1")}function NO3(A,Q){if(typeof A=="boolean")return!A;for(var B in A)if(Q[B])return!0}function qO3(A,Q,B){if(typeof A=="boolean")return!A&&B!="not";for(var G in A)if(G!=B&&Q[G])return!0}function LO3(A,Q){if(typeof A=="boolean")return;for(var B in A)if(!Q[B])return B}function Cc1(A){return"'"+$c1(A)+"'"}function MO3(A,Q,B,G){var Z=B?"'/' + "+Q+(G?"":".replace(/~/g, '~0').replace(/\\//g, '~1')"):G?"'[' + "+Q+" + ']'":"'[\\'' + "+Q+" + '\\']'";return vKB(A,Z)}function OO3(A,Q,B){var G=B?Cc1("/"+wc1(Q)):Cc1(Uc1(Q));return vKB(A,G)}var RO3=/^\/(?:[^~]|~0|~1)*$/,_O3=/^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;function TO3(A,Q,B){var G,Z,Y,J;if(A==="")return"rootData";if(A[0]=="/"){if(!RO3.test(A))throw Error("Invalid JSON-pointer: "+A);Z=A,Y="rootData"}else{if(J=A.match(_O3),!J)throw Error("Invalid JSON-pointer: "+A);if(G=+J[1],Z=J[2],Z=="#"){if(G>=Q)throw Error("Cannot access property/index "+G+" levels up, current level is "+Q);return B[Q-G]}if(G>Q)throw Error("Cannot access data "+G+" levels up, current level is "+Q);if(Y="data"+(Q-G||""),!Z)return Y}var I=Y,X=Z.split("/");for(var W=0;W<X.length;W++){var K=X[W];if(K)Y+=Uc1(Nc1(K)),I+=" && "+Y}return I}function vKB(A,Q){if(A=='""')return Q;return(A+" + "+Q).replace(/([^\\])' \+ '/g,"$1")}function jO3(A){return Nc1(decodeURIComponent(A))}function PO3(A){return encodeURIComponent(wc1(A))}function wc1(A){return A.replace(/~/g,"~0").replace(/\//g,"~1")}function Nc1(A){return A.replace(/~1/g,"/").replace(/~0/g,"~")}});var qc1=w((ti7,fKB)=>{var SO3=we();fKB.exports=xO3;function xO3(A){SO3.copy(A,this)}});var hKB=w((ei7,bKB)=>{var Fp=bKB.exports=function(A,Q,B){if(typeof Q=="function")B=Q,Q={};B=Q.cb||B;var G=typeof B=="function"?B:B.pre||function(){},Z=B.post||function(){};roA(Q,G,Z,A,"",A)};Fp.keywords={additionalItems:!0,items:!0,contains:!0,additionalProperties:!0,propertyNames:!0,not:!0};Fp.arrayKeywords={items:!0,allOf:!0,anyOf:!0,oneOf:!0};Fp.propsKeywords={definitions:!0,properties:!0,patternProperties:!0,dependencies:!0};Fp.skipKeywords={default:!0,enum:!0,const:!0,required:!0,maximum:!0,minimum:!0,exclusiveMaximum:!0,exclusiveMinimum:!0,multipleOf:!0,maxLength:!0,minLength:!0,pattern:!0,format:!0,maxItems:!0,minItems:!0,uniqueItems:!0,maxProperties:!0,minProperties:!0};function roA(A,Q,B,G,Z,Y,J,I,X,W){if(G&&typeof G=="object"&&!Array.isArray(G)){Q(G,Z,Y,J,I,X,W);for(var K in G){var V=G[K];if(Array.isArray(V)){if(K in Fp.arrayKeywords)for(var E=0;E<V.length;E++)roA(A,Q,B,V[E],Z+"/"+K+"/"+E,Y,Z,K,G,E)}else if(K in Fp.propsKeywords){if(V&&typeof V=="object")for(var D in V)roA(A,Q,B,V[D],Z+"/"+K+"/"+yO3(D),Y,Z,K,G,D)}else if(K in Fp.keywords||A.allKeys&&!(K in Fp.skipKeywords))roA(A,Q,B,V,Z+"/"+K,Y,Z,K,G)}B(G,Z,Y,J,I,X,W)}}function yO3(A){return A.replace(/~/g,"~0").replace(/\//g,"~1")}});var BrA=w((An7,dKB)=>{var UwA=jKB(),gKB=ooA(),ArA=we(),soA=qc1(),vO3=hKB();dKB.exports=zp;zp.normalizeId=Cp;zp.fullPath=toA;zp.url=eoA;zp.ids=gO3;zp.inlineRef=Lc1;zp.schema=QrA;function zp(A,Q,B){var G=this._refs[B];if(typeof G=="string")if(this._refs[G])G=this._refs[G];else return zp.call(this,A,Q,G);if(G=G||this._schemas[B],G instanceof soA)return Lc1(G.schema,this._opts.inlineRefs)?G.schema:G.validate||this._compile(G);var Z=QrA.call(this,Q,B),Y,J,I;if(Z)Y=Z.schema,Q=Z.root,I=Z.baseId;if(Y instanceof soA)J=Y.validate||A.call(this,Y.schema,Q,void 0,I);else if(Y!==void 0)J=Lc1(Y,this._opts.inlineRefs)?Y:A.call(this,Y,Q,void 0,I);return J}function QrA(A,Q){var B=UwA.parse(Q),G=mKB(B),Z=toA(this._getId(A.schema));if(Object.keys(A.schema).length===0||G!==Z){var Y=Cp(G),J=this._refs[Y];if(typeof J=="string")return kO3.call(this,A,J,B);else if(J instanceof soA){if(!J.validate)this._compile(J);A=J}else if(J=this._schemas[Y],J instanceof soA){if(!J.validate)this._compile(J);if(Y==Cp(Q))return{schema:J,root:A,baseId:Z};A=J}else return;if(!A.schema)return;Z=toA(this._getId(A.schema))}return uKB.call(this,B,Z,A.schema,A)}function kO3(A,Q,B){var G=QrA.call(this,A,Q);if(G){var{schema:Z,baseId:Y}=G;A=G.root;var J=this._getId(Z);if(J)Y=eoA(Y,J);return uKB.call(this,B,Y,Z,A)}}var fO3=ArA.toHash(["properties","patternProperties","enum","dependencies","definitions"]);function uKB(A,Q,B,G){if(A.fragment=A.fragment||"",A.fragment.slice(0,1)!="/")return;var Z=A.fragment.split("/");for(var Y=1;Y<Z.length;Y++){var J=Z[Y];if(J){if(J=ArA.unescapeFragment(J),B=B[J],B===void 0)break;var I;if(!fO3[J]){if(I=this._getId(B),I)Q=eoA(Q,I);if(B.$ref){var X=eoA(Q,B.$ref),W=QrA.call(this,G,X);if(W)B=W.schema,G=W.root,Q=W.baseId}}}}if(B!==void 0&&B!==G.schema)return{schema:B,root:G,baseId:Q}}var bO3=ArA.toHash(["type","format","pattern","maxLength","minLength","maxProperties","minProperties","maxItems","minItems","maximum","minimum","uniqueItems","multipleOf","required","enum"]);function Lc1(A,Q){if(Q===!1)return!1;if(Q===void 0||Q===!0)return Mc1(A);else if(Q)return Oc1(A)<=Q}function Mc1(A){var Q;if(Array.isArray(A)){for(var B=0;B<A.length;B++)if(Q=A[B],typeof Q=="object"&&!Mc1(Q))return!1}else for(var G in A){if(G=="$ref")return!1;if(Q=A[G],typeof Q=="object"&&!Mc1(Q))return!1}return!0}function Oc1(A){var Q=0,B;if(Array.isArray(A))for(var G=0;G<A.length;G++){if(B=A[G],typeof B=="object")Q+=Oc1(B);if(Q==1/0)return 1/0}else for(var Z in A){if(Z=="$ref")return 1/0;if(bO3[Z])Q++;else{if(B=A[Z],typeof B=="object")Q+=Oc1(B)+1;if(Q==1/0)return 1/0}}return Q}function toA(A,Q){if(Q!==!1)A=Cp(A);var B=UwA.parse(A);return mKB(B)}function mKB(A){return UwA.serialize(A).split("#")[0]+"#"}var hO3=/#\/?$/;function Cp(A){return A?A.replace(hO3,""):""}function eoA(A,Q){return Q=Cp(Q),UwA.resolve(A,Q)}function gO3(A){var Q=Cp(this._getId(A)),B={"":Q},G={"":toA(Q,!1)},Z={},Y=this;return vO3(A,{allKeys:!0},function(J,I,X,W,K,V,E){if(I==="")return;var D=Y._getId(J),H=B[W],F=G[W]+"/"+K;if(E!==void 0)F+="/"+(typeof E=="number"?E:ArA.escapeFragment(E));if(typeof D=="string"){D=H=Cp(H?UwA.resolve(H,D):D);var C=Y._refs[D];if(typeof C=="string")C=Y._refs[C];if(C&&C.schema){if(!gKB(J,C.schema))throw Error('id "'+D+'" resolves to more than one schema')}else if(D!=Cp(F))if(D[0]=="#"){if(Z[D]&&!gKB(J,Z[D]))throw Error('id "'+D+'" resolves to more than one schema');Z[D]=J}else Y._refs[D]=F}B[I]=H,G[I]=F}),Z}});var GrA=w((Qn7,pKB)=>{var Rc1=BrA();pKB.exports={Validation:cKB(uO3),MissingRef:cKB(_c1)};function uO3(A){this.message="validation failed",this.errors=A,this.ajv=this.validation=!0}_c1.message=function(A,Q){return"can't resolve reference "+Q+" from id "+A};function _c1(A,Q,B){this.message=B||_c1.message(A,Q),this.missingRef=Rc1.url(A,Q),this.missingSchema=Rc1.normalizeId(Rc1.fullPath(this.missingRef))}function cKB(A){return A.prototype=Object.create(Error.prototype),A.prototype.constructor=A,A}});var Tc1=w((Bn7,lKB)=>{lKB.exports=function(A,Q){if(!Q)Q={};if(typeof Q==="function")Q={cmp:Q};var B=typeof Q.cycles==="boolean"?Q.cycles:!1,G=Q.cmp&&function(Y){return function(J){return function(I,X){var W={key:I,value:J[I]},K={key:X,value:J[X]};return Y(W,K)}}}(Q.cmp),Z=[];return function Y(J){if(J&&J.toJSON&&typeof J.toJSON==="function")J=J.toJSON();if(J===void 0)return;if(typeof J=="number")return isFinite(J)?""+J:"null";if(typeof J!=="object")return JSON.stringify(J);var I,X;if(Array.isArray(J)){X="[";for(I=0;I<J.length;I++){if(I)X+=",";X+=Y(J[I])||"null"}return X+"]"}if(J===null)return"null";if(Z.indexOf(J)!==-1){if(B)return JSON.stringify("__cycle__");throw TypeError("Converting circular structure to JSON")}var W=Z.push(J)-1,K=Object.keys(J).sort(G&&G(J));X="";for(I=0;I<K.length;I++){var V=K[I],E=Y(J[V]);if(!E)continue;if(X)X+=",";X+=JSON.stringify(V)+":"+E}return Z.splice(W,1),"{"+X+"}"}(A)}});var jc1=w((Gn7,iKB)=>{iKB.exports=function(Q,B,G){var Z="",Y=Q.schema.$async===!0,J=Q.util.schemaHasRulesExcept(Q.schema,Q.RULES.all,"$ref"),I=Q.self._getId(Q.schema);if(Q.opts.strictKeywords){var X=Q.util.schemaUnknownRules(Q.schema,Q.RULES.keywords);if(X){var W="unknown keyword: "+X;if(Q.opts.strictKeywords==="log")Q.logger.warn(W);else throw Error(W)}}if(Q.isTop){if(Z+=" var validate = ",Y)Q.async=!0,Z+="async ";if(Z+="function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ",I&&(Q.opts.sourceCode||Q.opts.processCode))Z+=" "+("/*# sourceURL="+I+" */")+" "}if(typeof Q.schema=="boolean"||!(J||Q.schema.$ref)){var B="false schema",K=Q.level,V=Q.dataLevel,E=Q.schema[B],D=Q.schemaPath+Q.util.getProperty(B),H=Q.errSchemaPath+"/"+B,_=!Q.opts.allErrors,h,F="data"+(V||""),M="valid"+K;if(Q.schema===!1){if(Q.isTop)_=!0;else Z+=" var "+M+" = false; ";var C=C||[];if(C.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(h||"false schema")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(H)+" , params: {} ",Q.opts.messages!==!1)Z+=" , message: 'boolean schema is false' ";if(Q.opts.verbose)Z+=" , schema: false , parentSchema: validate.schema"+Q.schemaPath+" , data: "+F+" ";Z+=" } "}else Z+=" {} ";var U=Z;if(Z=C.pop(),!Q.compositeRule&&_)if(Q.async)Z+=" throw new ValidationError(["+U+"]); ";else Z+=" validate.errors = ["+U+"]; return false; ";else Z+=" var err = "+U+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "}else if(Q.isTop)if(Y)Z+=" return data; ";else Z+=" validate.errors = null; return true; ";else Z+=" var "+M+" = true; ";if(Q.isTop)Z+=" }; return validate; ";return Z}if(Q.isTop){var O=Q.isTop,K=Q.level=0,V=Q.dataLevel=0,F="data";if(Q.rootId=Q.resolve.fullPath(Q.self._getId(Q.root.schema)),Q.baseId=Q.baseId||Q.rootId,delete Q.isTop,Q.dataPathArr=[""],Q.schema.default!==void 0&&Q.opts.useDefaults&&Q.opts.strictDefaults){var q="default is ignored in the schema root";if(Q.opts.strictDefaults==="log")Q.logger.warn(q);else throw Error(q)}Z+=" var vErrors = null; ",Z+=" var errors = 0;     ",Z+=" if (rootData === undefined) rootData = data; "}else{var{level:K,dataLevel:V}=Q,F="data"+(V||"");if(I)Q.baseId=Q.resolve.url(Q.baseId,I);if(Y&&!Q.async)throw Error("async schema in sync schema");Z+=" var errs_"+K+" = errors;"}var M="valid"+K,_=!Q.opts.allErrors,T="",y="",h,x=Q.schema.type,m=Array.isArray(x);if(x&&Q.opts.nullable&&Q.schema.nullable===!0){if(m){if(x.indexOf("null")==-1)x=x.concat("null")}else if(x!="null")x=[x,"null"],m=!0}if(m&&x.length==1)x=x[0],m=!1;if(Q.schema.$ref&&J){if(Q.opts.extendRefs=="fail")throw Error('$ref: validation keywords used in schema at path "'+Q.errSchemaPath+'" (see option extendRefs)');else if(Q.opts.extendRefs!==!0)J=!1,Q.logger.warn('$ref: keywords ignored in schema at path "'+Q.errSchemaPath+'"')}if(Q.schema.$comment&&Q.opts.$comment)Z+=" "+Q.RULES.all.$comment.code(Q,"$comment");if(x){if(Q.opts.coerceTypes)var g=Q.util.coerceToTypes(Q.opts.coerceTypes,x);var t=Q.RULES.types[x];if(g||m||t===!0||t&&!RA(t)){var D=Q.schemaPath+".type",H=Q.errSchemaPath+"/type",D=Q.schemaPath+".type",H=Q.errSchemaPath+"/type",p=m?"checkDataTypes":"checkDataType";if(Z+=" if ("+Q.util[p](x,F,Q.opts.strictNumbers,!0)+") { ",g){var k="dataType"+K,c="coerced"+K;if(Z+=" var "+k+" = typeof "+F+"; var "+c+" = undefined; ",Q.opts.coerceTypes=="array")Z+=" if ("+k+" == 'object' && Array.isArray("+F+") && "+F+".length == 1) { "+F+" = "+F+"[0]; "+k+" = typeof "+F+"; if ("+Q.util.checkDataType(Q.schema.type,F,Q.opts.strictNumbers)+") "+c+" = "+F+"; } ";Z+=" if ("+c+" !== undefined) ; ";var e=g;if(e){var AA,VA=-1,OA=e.length-1;while(VA<OA)if(AA=e[VA+=1],AA=="string")Z+=" else if ("+k+" == 'number' || "+k+" == 'boolean') "+c+" = '' + "+F+"; else if ("+F+" === null) "+c+" = ''; ";else if(AA=="number"||AA=="integer"){if(Z+=" else if ("+k+" == 'boolean' || "+F+" === null || ("+k+" == 'string' && "+F+" && "+F+" == +"+F+" ",AA=="integer")Z+=" && !("+F+" % 1)";Z+=")) "+c+" = +"+F+"; "}else if(AA=="boolean")Z+=" else if ("+F+" === 'false' || "+F+" === 0 || "+F+" === null) "+c+" = false; else if ("+F+" === 'true' || "+F+" === 1) "+c+" = true; ";else if(AA=="null")Z+=" else if ("+F+" === '' || "+F+" === 0 || "+F+" === false) "+c+" = null; ";else if(Q.opts.coerceTypes=="array"&&AA=="array")Z+=" else if ("+k+" == 'string' || "+k+" == 'number' || "+k+" == 'boolean' || "+F+" == null) "+c+" = ["+F+"]; "}Z+=" else {   ";var C=C||[];if(C.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(h||"type")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(H)+" , params: { type: '",m)Z+=""+x.join(",");else Z+=""+x;if(Z+="' } ",Q.opts.messages!==!1){if(Z+=" , message: 'should be ",m)Z+=""+x.join(",");else Z+=""+x;Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+D+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+F+" ";Z+=" } "}else Z+=" {} ";var U=Z;if(Z=C.pop(),!Q.compositeRule&&_)if(Q.async)Z+=" throw new ValidationError(["+U+"]); ";else Z+=" validate.errors = ["+U+"]; return false; ";else Z+=" var err = "+U+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";Z+=" } if ("+c+" !== undefined) {  ";var EA=V?"data"+(V-1||""):"parentData",SA=V?Q.dataPathArr[V]:"parentDataProperty";if(Z+=" "+F+" = "+c+"; ",!V)Z+="if ("+EA+" !== undefined)";Z+=" "+EA+"["+SA+"] = "+c+"; } "}else{var C=C||[];if(C.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(h||"type")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(H)+" , params: { type: '",m)Z+=""+x.join(",");else Z+=""+x;if(Z+="' } ",Q.opts.messages!==!1){if(Z+=" , message: 'should be ",m)Z+=""+x.join(",");else Z+=""+x;Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+D+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+F+" ";Z+=" } "}else Z+=" {} ";var U=Z;if(Z=C.pop(),!Q.compositeRule&&_)if(Q.async)Z+=" throw new ValidationError(["+U+"]); ";else Z+=" validate.errors = ["+U+"]; return false; ";else Z+=" var err = "+U+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "}Z+=" } "}}if(Q.schema.$ref&&!J){if(Z+=" "+Q.RULES.all.$ref.code(Q,"$ref")+" ",_){if(Z+=" } if (errors === ",O)Z+="0";else Z+="errs_"+K;Z+=") { ",y+="}"}}else{var yA=Q.RULES;if(yA){var t,ZA=-1,GA=yA.length-1;while(ZA<GA)if(t=yA[ZA+=1],RA(t)){if(t.type)Z+=" if ("+Q.util.checkDataType(t.type,F,Q.opts.strictNumbers)+") { ";if(Q.opts.useDefaults){if(t.type=="object"&&Q.schema.properties){var E=Q.schema.properties,zA=Object.keys(E),bA=zA;if(bA){var TA,G1=-1,YA=bA.length-1;while(G1<YA){TA=bA[G1+=1];var CA=E[TA];if(CA.default!==void 0){var MA=F+Q.util.getProperty(TA);if(Q.compositeRule){if(Q.opts.strictDefaults){var q="default is ignored for: "+MA;if(Q.opts.strictDefaults==="log")Q.logger.warn(q);else throw Error(q)}}else{if(Z+=" if ("+MA+" === undefined ",Q.opts.useDefaults=="empty")Z+=" || "+MA+" === null || "+MA+" === '' ";if(Z+=" ) "+MA+" = ",Q.opts.useDefaults=="shared")Z+=" "+Q.useDefault(CA.default)+" ";else Z+=" "+JSON.stringify(CA.default)+" ";Z+="; "}}}}}else if(t.type=="array"&&Array.isArray(Q.schema.items)){var NA=Q.schema.items;if(NA){var CA,VA=-1,UA=NA.length-1;while(VA<UA)if(CA=NA[VA+=1],CA.default!==void 0){var MA=F+"["+VA+"]";if(Q.compositeRule){if(Q.opts.strictDefaults){var q="default is ignored for: "+MA;if(Q.opts.strictDefaults==="log")Q.logger.warn(q);else throw Error(q)}}else{if(Z+=" if ("+MA+" === undefined ",Q.opts.useDefaults=="empty")Z+=" || "+MA+" === null || "+MA+" === '' ";if(Z+=" ) "+MA+" = ",Q.opts.useDefaults=="shared")Z+=" "+Q.useDefault(CA.default)+" ";else Z+=" "+JSON.stringify(CA.default)+" ";Z+="; "}}}}}var LA=t.rules;if(LA){var lA,gA=-1,I1=LA.length-1;while(gA<I1)if(lA=LA[gA+=1],B1(lA)){var $1=lA.code(Q,lA.keyword,t.type);if($1){if(Z+=" "+$1+" ",_)T+="}"}}}if(_)Z+=" "+T+" ",T="";if(t.type){if(Z+=" } ",x&&x===t.type&&!g){Z+=" else { ";var D=Q.schemaPath+".type",H=Q.errSchemaPath+"/type",C=C||[];if(C.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(h||"type")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(H)+" , params: { type: '",m)Z+=""+x.join(",");else Z+=""+x;if(Z+="' } ",Q.opts.messages!==!1){if(Z+=" , message: 'should be ",m)Z+=""+x.join(",");else Z+=""+x;Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+D+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+F+" ";Z+=" } "}else Z+=" {} ";var U=Z;if(Z=C.pop(),!Q.compositeRule&&_)if(Q.async)Z+=" throw new ValidationError(["+U+"]); ";else Z+=" validate.errors = ["+U+"]; return false; ";else Z+=" var err = "+U+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";Z+=" } "}}if(_){if(Z+=" if (errors === ",O)Z+="0";else Z+="errs_"+K;Z+=") { ",y+="}"}}}}if(_)Z+=" "+y+" ";if(O){if(Y)Z+=" if (errors === 0) return data;           ",Z+=" else throw new ValidationError(vErrors); ";else Z+=" validate.errors = vErrors; ",Z+=" return errors === 0;       ";Z+=" }; return validate;"}else Z+=" var "+M+" = errors === errs_"+K+";";function RA(S1){var H0=S1.rules;for(var ZQ=0;ZQ<H0.length;ZQ++)if(B1(H0[ZQ]))return!0}function B1(S1){return Q.schema[S1.keyword]!==void 0||S1.implements&&m1(S1)}function m1(S1){var H0=S1.implements;for(var ZQ=0;ZQ<H0.length;ZQ++)if(Q.schema[H0[ZQ]]!==void 0)return!0}return Z}});var sKB=w((Zn7,rKB)=>{var ZrA=BrA(),JrA=we(),aKB=GrA(),mO3=Tc1(),nKB=jc1(),dO3=JrA.ucs2length,cO3=ooA(),pO3=aKB.Validation;rKB.exports=Pc1;function Pc1(A,Q,B,G){var Z=this,Y=this._opts,J=[void 0],I={},X=[],W={},K=[],V={},E=[];Q=Q||{schema:A,refVal:J,refs:I};var D=lO3.call(this,A,Q,G),H=this._compilations[D.index];if(D.compiling)return H.callValidate=q;var F=this._formats,C=this.RULES;try{var U=M(A,Q,B,G);H.validate=U;var O=H.callValidate;if(O){if(O.schema=U.schema,O.errors=null,O.refs=U.refs,O.refVal=U.refVal,O.root=U.root,O.$async=U.$async,Y.sourceCode)O.source=U.source}return U}finally{iO3.call(this,A,Q,G)}function q(){var p=H.validate,k=p.apply(this,arguments);return q.errors=p.errors,k}function M(p,k,c,e){var AA=!k||k&&k.schema==p;if(k.schema!=Q.schema)return Pc1.call(Z,p,k,c,e);var VA=p.$async===!0,OA=nKB({isTop:!0,schema:p,isRoot:AA,baseId:e,root:k,schemaPath:"",errSchemaPath:"#",errorPath:'""',MissingRefError:aKB.MissingRef,RULES:C,validate:nKB,util:JrA,resolve:ZrA,resolveRef:_,usePattern:m,useDefault:g,useCustomRule:t,opts:Y,formats:F,logger:Z.logger,self:Z});if(OA=YrA(J,oO3)+YrA(X,nO3)+YrA(K,aO3)+YrA(E,rO3)+OA,Y.processCode)OA=Y.processCode(OA,p);var EA;try{var SA=Function("self","RULES","formats","root","refVal","defaults","customRules","equal","ucs2length","ValidationError",OA);EA=SA(Z,C,F,Q,J,K,E,cO3,dO3,pO3),J[0]=EA}catch(yA){throw Z.logger.error("Error compiling schema, function code:",OA),yA}if(EA.schema=p,EA.errors=null,EA.refs=I,EA.refVal=J,EA.root=AA?EA:k,VA)EA.$async=!0;if(Y.sourceCode===!0)EA.source={code:OA,patterns:X,defaults:K};return EA}function _(p,k,c){k=ZrA.url(p,k);var e=I[k],AA,VA;if(e!==void 0)return AA=J[e],VA="refVal["+e+"]",x(AA,VA);if(!c&&Q.refs){var OA=Q.refs[k];if(OA!==void 0)return AA=Q.refVal[OA],VA=T(k,AA),x(AA,VA)}VA=T(k);var EA=ZrA.call(Z,M,Q,k);if(EA===void 0){var SA=B&&B[k];if(SA)EA=ZrA.inlineRef(SA,Y.inlineRefs)?SA:Pc1.call(Z,SA,Q,B,p)}if(EA===void 0)y(k);else return h(k,EA),x(EA,VA)}function T(p,k){var c=J.length;return J[c]=k,I[p]=c,"refVal"+c}function y(p){delete I[p]}function h(p,k){var c=I[p];J[c]=k}function x(p,k){return typeof p=="object"||typeof p=="boolean"?{code:k,schema:p,inline:!0}:{code:k,$async:p&&!!p.$async}}function m(p){var k=W[p];if(k===void 0)k=W[p]=X.length,X[k]=p;return"pattern"+k}function g(p){switch(typeof p){case"boolean":case"number":return""+p;case"string":return JrA.toQuotedString(p);case"object":if(p===null)return"null";var k=mO3(p),c=V[k];if(c===void 0)c=V[k]=K.length,K[c]=p;return"default"+c}}function t(p,k,c,e){if(Z._opts.validateSchema!==!1){var AA=p.definition.dependencies;if(AA&&!AA.every(function(bA){return Object.prototype.hasOwnProperty.call(c,bA)}))throw Error("parent schema must have all required keywords: "+AA.join(","));var VA=p.definition.validateSchema;if(VA){var OA=VA(k);if(!OA){var EA="keyword schema is invalid: "+Z.errorsText(VA.errors);if(Z._opts.validateSchema=="log")Z.logger.error(EA);else throw Error(EA)}}}var SA=p.definition.compile,yA=p.definition.inline,ZA=p.definition.macro,GA;if(SA)GA=SA.call(Z,k,c,e);else if(ZA){if(GA=ZA.call(Z,k,c,e),Y.validateSchema!==!1)Z.validateSchema(GA,!0)}else if(yA)GA=yA.call(Z,e,p.keyword,k,c);else if(GA=p.definition.validate,!GA)return;if(GA===void 0)throw Error('custom keyword "'+p.keyword+'"failed to compile');var zA=E.length;return E[zA]=GA,{code:"customRule"+zA,validate:GA}}}function lO3(A,Q,B){var G=oKB.call(this,A,Q,B);if(G>=0)return{index:G,compiling:!0};return G=this._compilations.length,this._compilations[G]={schema:A,root:Q,baseId:B},{index:G,compiling:!1}}function iO3(A,Q,B){var G=oKB.call(this,A,Q,B);if(G>=0)this._compilations.splice(G,1)}function oKB(A,Q,B){for(var G=0;G<this._compilations.length;G++){var Z=this._compilations[G];if(Z.schema==A&&Z.root==Q&&Z.baseId==B)return G}return-1}function nO3(A,Q){return"var pattern"+A+" = new RegExp("+JrA.toQuotedString(Q[A])+");"}function aO3(A){return"var default"+A+" = defaults["+A+"];"}function oO3(A,Q){return Q[A]===void 0?"":"var refVal"+A+" = refVal["+A+"];"}function rO3(A){return"var customRule"+A+" = customRules["+A+"];"}function YrA(A,Q){if(!A.length)return"";var B="";for(var G=0;G<A.length;G++)B+=Q(G,A);return B}});var eKB=w((Yn7,tKB)=>{var IrA=tKB.exports=function(){this._cache={}};IrA.prototype.put=function(Q,B){this._cache[Q]=B};IrA.prototype.get=function(Q){return this._cache[Q]};IrA.prototype.del=function(Q){delete this._cache[Q]};IrA.prototype.clear=function(){this._cache={}}});var VVB=w((Jn7,KVB)=>{var sO3=we(),tO3=/^(\d\d\d\d)-(\d\d)-(\d\d)$/,eO3=[0,31,28,31,30,31,30,31,31,30,31,30,31],AR3=/^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i,AVB=/^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,QR3=/^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,BR3=/^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,QVB=/^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,BVB=/^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i,GVB=/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,ZVB=/^(?:\/(?:[^~/]|~0|~1)*)*$/,YVB=/^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,JVB=/^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;KVB.exports=XrA;function XrA(A){return A=A=="full"?"full":"fast",sO3.copy(XrA[A])}XrA.fast={date:/^\d\d\d\d-[0-1]\d-[0-3]\d$/,time:/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,"date-time":/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,uri:/^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,"uri-reference":/^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,"uri-template":QVB,url:BVB,email:/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,hostname:AVB,ipv4:/^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,ipv6:/^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,regex:WVB,uuid:GVB,"json-pointer":ZVB,"json-pointer-uri-fragment":YVB,"relative-json-pointer":JVB};XrA.full={date:IVB,time:XVB,"date-time":YR3,uri:IR3,"uri-reference":BR3,"uri-template":QVB,url:BVB,email:/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,hostname:AVB,ipv4:/^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,ipv6:/^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,regex:WVB,uuid:GVB,"json-pointer":ZVB,"json-pointer-uri-fragment":YVB,"relative-json-pointer":JVB};function GR3(A){return A%4===0&&(A%100!==0||A%400===0)}function IVB(A){var Q=A.match(tO3);if(!Q)return!1;var B=+Q[1],G=+Q[2],Z=+Q[3];return G>=1&&G<=12&&Z>=1&&Z<=(G==2&&GR3(B)?29:eO3[G])}function XVB(A,Q){var B=A.match(AR3);if(!B)return!1;var G=B[1],Z=B[2],Y=B[3],J=B[5];return(G<=23&&Z<=59&&Y<=59||G==23&&Z==59&&Y==60)&&(!Q||J)}var ZR3=/t|\s/i;function YR3(A){var Q=A.split(ZR3);return Q.length==2&&IVB(Q[0])&&XVB(Q[1],!0)}var JR3=/\/|:/;function IR3(A){return JR3.test(A)&&QR3.test(A)}var XR3=/[^\\]\\Z/;function WVB(A){if(XR3.test(A))return!1;try{return new RegExp(A),!0}catch(Q){return!1}}});var DVB=w((In7,EVB)=>{EVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.errSchemaPath+"/"+B,W=!Q.opts.allErrors,K="data"+(J||""),V="valid"+Y,E,D;if(I=="#"||I=="#/")if(Q.isRoot)E=Q.async,D="validate";else E=Q.root.schema.$async===!0,D="root.refVal[0]";else{var H=Q.resolveRef(Q.baseId,I,Q.isRoot);if(H===void 0){var F=Q.MissingRefError.message(Q.baseId,I);if(Q.opts.missingRefs=="fail"){Q.logger.error(F);var C=C||[];if(C.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '$ref' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(X)+" , params: { ref: '"+Q.util.escapeQuotes(I)+"' } ",Q.opts.messages!==!1)Z+=" , message: 'can\\'t resolve reference "+Q.util.escapeQuotes(I)+"' ";if(Q.opts.verbose)Z+=" , schema: "+Q.util.toQuotedString(I)+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+K+" ";Z+=" } "}else Z+=" {} ";var U=Z;if(Z=C.pop(),!Q.compositeRule&&W)if(Q.async)Z+=" throw new ValidationError(["+U+"]); ";else Z+=" validate.errors = ["+U+"]; return false; ";else Z+=" var err = "+U+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(W)Z+=" if (false) { "}else if(Q.opts.missingRefs=="ignore"){if(Q.logger.warn(F),W)Z+=" if (true) { "}else throw new Q.MissingRefError(Q.baseId,I,F)}else if(H.inline){var O=Q.util.copy(Q);O.level++;var q="valid"+O.level;O.schema=H.schema,O.schemaPath="",O.errSchemaPath=I;var M=Q.validate(O).replace(/validate\.schema/g,H.code);if(Z+=" "+M+" ",W)Z+=" if ("+q+") { "}else E=H.$async===!0||Q.async&&H.$async!==!1,D=H.code}if(D){var C=C||[];if(C.push(Z),Z="",Q.opts.passContext)Z+=" "+D+".call(this, ";else Z+=" "+D+"( ";if(Z+=" "+K+", (dataPath || '')",Q.errorPath!='""')Z+=" + "+Q.errorPath;var _=J?"data"+(J-1||""):"parentData",T=J?Q.dataPathArr[J]:"parentDataProperty";Z+=" , "+_+" , "+T+", rootData)  ";var y=Z;if(Z=C.pop(),E){if(!Q.async)throw Error("async schema referenced by sync schema");if(W)Z+=" var "+V+"; ";if(Z+=" try { await "+y+"; ",W)Z+=" "+V+" = true; ";if(Z+=" } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ",W)Z+=" "+V+" = false; ";if(Z+=" } ",W)Z+=" if ("+V+") { "}else if(Z+=" if (!"+y+") { if (vErrors === null) vErrors = "+D+".errors; else vErrors = vErrors.concat("+D+".errors); errors = vErrors.length; } ",W)Z+=" else { "}return Z}});var FVB=w((Xn7,HVB)=>{HVB.exports=function(Q,B,G){var Z=" ",Y=Q.schema[B],J=Q.schemaPath+Q.util.getProperty(B),I=Q.errSchemaPath+"/"+B,X=!Q.opts.allErrors,W=Q.util.copy(Q),K="";W.level++;var V="valid"+W.level,E=W.baseId,D=!0,H=Y;if(H){var F,C=-1,U=H.length-1;while(C<U)if(F=H[C+=1],Q.opts.strictKeywords?typeof F=="object"&&Object.keys(F).length>0||F===!1:Q.util.schemaHasRules(F,Q.RULES.all)){if(D=!1,W.schema=F,W.schemaPath=J+"["+C+"]",W.errSchemaPath=I+"/"+C,Z+="  "+Q.validate(W)+" ",W.baseId=E,X)Z+=" if ("+V+") { ",K+="}"}}if(X)if(D)Z+=" if (true) { ";else Z+=" "+K.slice(0,-1)+" ";return Z}});var zVB=w((Wn7,CVB)=>{CVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D="errs__"+Y,H=Q.util.copy(Q),F="";H.level++;var C="valid"+H.level,U=I.every(function(h){return Q.opts.strictKeywords?typeof h=="object"&&Object.keys(h).length>0||h===!1:Q.util.schemaHasRules(h,Q.RULES.all)});if(U){var O=H.baseId;Z+=" var "+D+" = errors; var "+E+" = false;  ";var q=Q.compositeRule;Q.compositeRule=H.compositeRule=!0;var M=I;if(M){var _,T=-1,y=M.length-1;while(T<y)_=M[T+=1],H.schema=_,H.schemaPath=X+"["+T+"]",H.errSchemaPath=W+"/"+T,Z+="  "+Q.validate(H)+" ",H.baseId=O,Z+=" "+E+" = "+E+" || "+C+"; if (!"+E+") { ",F+="}"}if(Q.compositeRule=H.compositeRule=q,Z+=" "+F+" if (!"+E+") {   var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'anyOf' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: {} ",Q.opts.messages!==!1)Z+=" , message: 'should match some schema in anyOf' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";if(Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(vErrors); ";else Z+=" validate.errors = vErrors; return false; ";if(Z+=" } else {  errors = "+D+"; if (vErrors !== null) { if ("+D+") vErrors.length = "+D+"; else vErrors = null; } ",Q.opts.allErrors)Z+=" } "}else if(K)Z+=" if (true) { ";return Z}});var $VB=w((Kn7,UVB)=>{UVB.exports=function(Q,B,G){var Z=" ",Y=Q.schema[B],J=Q.errSchemaPath+"/"+B,I=!Q.opts.allErrors,X=Q.util.toQuotedString(Y);if(Q.opts.$comment===!0)Z+=" console.log("+X+");";else if(typeof Q.opts.$comment=="function")Z+=" self._opts.$comment("+X+", "+Q.util.toQuotedString(J)+", validate.root.schema);";return Z}});var NVB=w((Vn7,wVB)=>{wVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D=Q.opts.$data&&I&&I.$data,H;if(D)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",H="schema"+Y;else H=I;if(!D)Z+=" var schema"+Y+" = validate.schema"+X+";";Z+="var "+E+" = equal("+V+", schema"+Y+"); if (!"+E+") {   ";var F=F||[];if(F.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'const' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { allowedValue: schema"+Y+" } ",Q.opts.messages!==!1)Z+=" , message: 'should be equal to constant' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var C=Z;if(Z=F.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+C+"]); ";else Z+=" validate.errors = ["+C+"]; return false; ";else Z+=" var err = "+C+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" }",K)Z+=" else { ";return Z}});var LVB=w((En7,qVB)=>{qVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D="errs__"+Y,H=Q.util.copy(Q),F="";H.level++;var C="valid"+H.level,U="i"+Y,O=H.dataLevel=Q.dataLevel+1,q="data"+O,M=Q.baseId,_=Q.opts.strictKeywords?typeof I=="object"&&Object.keys(I).length>0||I===!1:Q.util.schemaHasRules(I,Q.RULES.all);if(Z+="var "+D+" = errors;var "+E+";",_){var T=Q.compositeRule;Q.compositeRule=H.compositeRule=!0,H.schema=I,H.schemaPath=X,H.errSchemaPath=W,Z+=" var "+C+" = false; for (var "+U+" = 0; "+U+" < "+V+".length; "+U+"++) { ",H.errorPath=Q.util.getPathExpr(Q.errorPath,U,Q.opts.jsonPointers,!0);var y=V+"["+U+"]";H.dataPathArr[O]=U;var h=Q.validate(H);if(H.baseId=M,Q.util.varOccurences(h,q)<2)Z+=" "+Q.util.varReplace(h,q,y)+" ";else Z+=" var "+q+" = "+y+"; "+h+" ";Z+=" if ("+C+") break; }  ",Q.compositeRule=H.compositeRule=T,Z+=" "+F+" if (!"+C+") {"}else Z+=" if ("+V+".length == 0) {";var x=x||[];if(x.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'contains' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: {} ",Q.opts.messages!==!1)Z+=" , message: 'should contain a valid item' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var m=Z;if(Z=x.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+m+"]); ";else Z+=" validate.errors = ["+m+"]; return false; ";else Z+=" var err = "+m+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" } else { ",_)Z+="  errors = "+D+"; if (vErrors !== null) { if ("+D+") vErrors.length = "+D+"; else vErrors = null; } ";if(Q.opts.allErrors)Z+=" } ";return Z}});var OVB=w((Dn7,MVB)=>{MVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="errs__"+Y,D=Q.util.copy(Q),H="";D.level++;var F="valid"+D.level,C={},U={},O=Q.opts.ownProperties;for(T in I){if(T=="__proto__")continue;var q=I[T],M=Array.isArray(q)?U:C;M[T]=q}Z+="var "+E+" = errors;";var _=Q.errorPath;Z+="var missing"+Y+";";for(var T in U)if(M=U[T],M.length){if(Z+=" if ( "+V+Q.util.getProperty(T)+" !== undefined ",O)Z+=" && Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(T)+"') ";if(K){Z+=" && ( ";var y=M;if(y){var h,x=-1,m=y.length-1;while(x<m){if(h=y[x+=1],x)Z+=" || ";var g=Q.util.getProperty(h),t=V+g;if(Z+=" ( ( "+t+" === undefined ",O)Z+=" || ! Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(h)+"') ";Z+=") && (missing"+Y+" = "+Q.util.toQuotedString(Q.opts.jsonPointers?h:g)+") ) "}}Z+=")) {  ";var p="missing"+Y,k="' + "+p+" + '";if(Q.opts._errorDataPathProperty)Q.errorPath=Q.opts.jsonPointers?Q.util.getPathExpr(_,p,!0):_+" + "+p;var c=c||[];if(c.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'dependencies' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { property: '"+Q.util.escapeQuotes(T)+"', missingProperty: '"+k+"', depsCount: "+M.length+", deps: '"+Q.util.escapeQuotes(M.length==1?M[0]:M.join(", "))+"' } ",Q.opts.messages!==!1){if(Z+=" , message: 'should have ",M.length==1)Z+="property "+Q.util.escapeQuotes(M[0]);else Z+="properties "+Q.util.escapeQuotes(M.join(", "));Z+=" when property "+Q.util.escapeQuotes(T)+" is present' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var e=Z;if(Z=c.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+e+"]); ";else Z+=" validate.errors = ["+e+"]; return false; ";else Z+=" var err = "+e+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "}else{Z+=" ) { ";var AA=M;if(AA){var h,VA=-1,OA=AA.length-1;while(VA<OA){h=AA[VA+=1];var g=Q.util.getProperty(h),k=Q.util.escapeQuotes(h),t=V+g;if(Q.opts._errorDataPathProperty)Q.errorPath=Q.util.getPath(_,h,Q.opts.jsonPointers);if(Z+=" if ( "+t+" === undefined ",O)Z+=" || ! Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(h)+"') ";if(Z+=") {  var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'dependencies' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { property: '"+Q.util.escapeQuotes(T)+"', missingProperty: '"+k+"', depsCount: "+M.length+", deps: '"+Q.util.escapeQuotes(M.length==1?M[0]:M.join(", "))+"' } ",Q.opts.messages!==!1){if(Z+=" , message: 'should have ",M.length==1)Z+="property "+Q.util.escapeQuotes(M[0]);else Z+="properties "+Q.util.escapeQuotes(M.join(", "));Z+=" when property "+Q.util.escapeQuotes(T)+" is present' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "}}}if(Z+=" }   ",K)H+="}",Z+=" else { "}Q.errorPath=_;var EA=D.baseId;for(var T in C){var q=C[T];if(Q.opts.strictKeywords?typeof q=="object"&&Object.keys(q).length>0||q===!1:Q.util.schemaHasRules(q,Q.RULES.all)){if(Z+=" "+F+" = true; if ( "+V+Q.util.getProperty(T)+" !== undefined ",O)Z+=" && Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(T)+"') ";if(Z+=") { ",D.schema=q,D.schemaPath=X+Q.util.getProperty(T),D.errSchemaPath=W+"/"+Q.util.escapeFragment(T),Z+="  "+Q.validate(D)+" ",D.baseId=EA,Z+=" }  ",K)Z+=" if ("+F+") { ",H+="}"}}if(K)Z+="   "+H+" if ("+E+" == errors) {";return Z}});var _VB=w((Hn7,RVB)=>{RVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D=Q.opts.$data&&I&&I.$data,H;if(D)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",H="schema"+Y;else H=I;var F="i"+Y,C="schema"+Y;if(!D)Z+=" var "+C+" = validate.schema"+X+";";if(Z+="var "+E+";",D)Z+=" if (schema"+Y+" === undefined) "+E+" = true; else if (!Array.isArray(schema"+Y+")) "+E+" = false; else {";if(Z+=""+E+" = false;for (var "+F+"=0; "+F+"<"+C+".length; "+F+"++) if (equal("+V+", "+C+"["+F+"])) { "+E+" = true; break; }",D)Z+="  }  ";Z+=" if (!"+E+") {   ";var U=U||[];if(U.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'enum' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { allowedValues: schema"+Y+" } ",Q.opts.messages!==!1)Z+=" , message: 'should be equal to one of the allowed values' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var O=Z;if(Z=U.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+O+"]); ";else Z+=" validate.errors = ["+O+"]; return false; ";else Z+=" var err = "+O+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" }",K)Z+=" else { ";return Z}});var jVB=w((Fn7,TVB)=>{TVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||"");if(Q.opts.format===!1){if(K)Z+=" if (true) { ";return Z}var E=Q.opts.$data&&I&&I.$data,D;if(E)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",D="schema"+Y;else D=I;var H=Q.opts.unknownFormats,F=Array.isArray(H);if(E){var C="format"+Y,U="isObject"+Y,O="formatType"+Y;if(Z+=" var "+C+" = formats["+D+"]; var "+U+" = typeof "+C+" == 'object' && !("+C+" instanceof RegExp) && "+C+".validate; var "+O+" = "+U+" && "+C+".type || 'string'; if ("+U+") { ",Q.async)Z+=" var async"+Y+" = "+C+".async; ";if(Z+=" "+C+" = "+C+".validate; } if (  ",E)Z+=" ("+D+" !== undefined && typeof "+D+" != 'string') || ";if(Z+=" (",H!="ignore"){if(Z+=" ("+D+" && !"+C+" ",F)Z+=" && self._opts.unknownFormats.indexOf("+D+") == -1 ";Z+=") || "}if(Z+=" ("+C+" && "+O+" == '"+G+"' && !(typeof "+C+" == 'function' ? ",Q.async)Z+=" (async"+Y+" ? await "+C+"("+V+") : "+C+"("+V+")) ";else Z+=" "+C+"("+V+") ";Z+=" : "+C+".test("+V+"))))) {"}else{var C=Q.formats[I];if(!C)if(H=="ignore"){if(Q.logger.warn('unknown format "'+I+'" ignored in schema at path "'+Q.errSchemaPath+'"'),K)Z+=" if (true) { ";return Z}else if(F&&H.indexOf(I)>=0){if(K)Z+=" if (true) { ";return Z}else throw Error('unknown format "'+I+'" is used in schema at path "'+Q.errSchemaPath+'"');var U=typeof C=="object"&&!(C instanceof RegExp)&&C.validate,O=U&&C.type||"string";if(U){var q=C.async===!0;C=C.validate}if(O!=G){if(K)Z+=" if (true) { ";return Z}if(q){if(!Q.async)throw Error("async format in sync schema");var M="formats"+Q.util.getProperty(I)+".validate";Z+=" if (!(await "+M+"("+V+"))) { "}else{Z+=" if (! ";var M="formats"+Q.util.getProperty(I);if(U)M+=".validate";if(typeof C=="function")Z+=" "+M+"("+V+") ";else Z+=" "+M+".test("+V+") ";Z+=") { "}}var _=_||[];if(_.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'format' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { format:  ",E)Z+=""+D;else Z+=""+Q.util.toQuotedString(I);if(Z+="  } ",Q.opts.messages!==!1){if(Z+=` , message: 'should match format "`,E)Z+="' + "+D+" + '";else Z+=""+Q.util.escapeQuotes(I);Z+=`"' `}if(Q.opts.verbose){if(Z+=" , schema:  ",E)Z+="validate.schema"+X;else Z+=""+Q.util.toQuotedString(I);Z+="         , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" "}Z+=" } "}else Z+=" {} ";var T=Z;if(Z=_.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+T+"]); ";else Z+=" validate.errors = ["+T+"]; return false; ";else Z+=" var err = "+T+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" } ",K)Z+=" else { ";return Z}});var SVB=w((Cn7,PVB)=>{PVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D="errs__"+Y,H=Q.util.copy(Q);H.level++;var F="valid"+H.level,C=Q.schema.then,U=Q.schema.else,O=C!==void 0&&(Q.opts.strictKeywords?typeof C=="object"&&Object.keys(C).length>0||C===!1:Q.util.schemaHasRules(C,Q.RULES.all)),q=U!==void 0&&(Q.opts.strictKeywords?typeof U=="object"&&Object.keys(U).length>0||U===!1:Q.util.schemaHasRules(U,Q.RULES.all)),M=H.baseId;if(O||q){var _;H.createErrors=!1,H.schema=I,H.schemaPath=X,H.errSchemaPath=W,Z+=" var "+D+" = errors; var "+E+" = true;  ";var T=Q.compositeRule;if(Q.compositeRule=H.compositeRule=!0,Z+="  "+Q.validate(H)+" ",H.baseId=M,H.createErrors=!0,Z+="  errors = "+D+"; if (vErrors !== null) { if ("+D+") vErrors.length = "+D+"; else vErrors = null; }  ",Q.compositeRule=H.compositeRule=T,O){if(Z+=" if ("+F+") {  ",H.schema=Q.schema.then,H.schemaPath=Q.schemaPath+".then",H.errSchemaPath=Q.errSchemaPath+"/then",Z+="  "+Q.validate(H)+" ",H.baseId=M,Z+=" "+E+" = "+F+"; ",O&&q)_="ifClause"+Y,Z+=" var "+_+" = 'then'; ";else _="'then'";if(Z+=" } ",q)Z+=" else { "}else Z+=" if (!"+F+") { ";if(q){if(H.schema=Q.schema.else,H.schemaPath=Q.schemaPath+".else",H.errSchemaPath=Q.errSchemaPath+"/else",Z+="  "+Q.validate(H)+" ",H.baseId=M,Z+=" "+E+" = "+F+"; ",O&&q)_="ifClause"+Y,Z+=" var "+_+" = 'else'; ";else _="'else'";Z+=" } "}if(Z+=" if (!"+E+") {   var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'if' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { failingKeyword: "+_+" } ",Q.opts.messages!==!1)Z+=` , message: 'should match "' + `+_+` + '" schema' `;if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";if(Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(vErrors); ";else Z+=" validate.errors = vErrors; return false; ";if(Z+=" }   ",K)Z+=" else { "}else if(K)Z+=" if (true) { ";return Z}});var yVB=w((zn7,xVB)=>{xVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D="errs__"+Y,H=Q.util.copy(Q),F="";H.level++;var C="valid"+H.level,U="i"+Y,O=H.dataLevel=Q.dataLevel+1,q="data"+O,M=Q.baseId;if(Z+="var "+D+" = errors;var "+E+";",Array.isArray(I)){var _=Q.schema.additionalItems;if(_===!1){Z+=" "+E+" = "+V+".length <= "+I.length+"; ";var T=W;W=Q.errSchemaPath+"/additionalItems",Z+="  if (!"+E+") {   ";var y=y||[];if(y.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'additionalItems' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { limit: "+I.length+" } ",Q.opts.messages!==!1)Z+=" , message: 'should NOT have more than "+I.length+" items' ";if(Q.opts.verbose)Z+=" , schema: false , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var h=Z;if(Z=y.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+h+"]); ";else Z+=" validate.errors = ["+h+"]; return false; ";else Z+=" var err = "+h+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" } ",W=T,K)F+="}",Z+=" else { "}var x=I;if(x){var m,g=-1,t=x.length-1;while(g<t)if(m=x[g+=1],Q.opts.strictKeywords?typeof m=="object"&&Object.keys(m).length>0||m===!1:Q.util.schemaHasRules(m,Q.RULES.all)){Z+=" "+C+" = true; if ("+V+".length > "+g+") { ";var p=V+"["+g+"]";H.schema=m,H.schemaPath=X+"["+g+"]",H.errSchemaPath=W+"/"+g,H.errorPath=Q.util.getPathExpr(Q.errorPath,g,Q.opts.jsonPointers,!0),H.dataPathArr[O]=g;var k=Q.validate(H);if(H.baseId=M,Q.util.varOccurences(k,q)<2)Z+=" "+Q.util.varReplace(k,q,p)+" ";else Z+=" var "+q+" = "+p+"; "+k+" ";if(Z+=" }  ",K)Z+=" if ("+C+") { ",F+="}"}}if(typeof _=="object"&&(Q.opts.strictKeywords?typeof _=="object"&&Object.keys(_).length>0||_===!1:Q.util.schemaHasRules(_,Q.RULES.all))){H.schema=_,H.schemaPath=Q.schemaPath+".additionalItems",H.errSchemaPath=Q.errSchemaPath+"/additionalItems",Z+=" "+C+" = true; if ("+V+".length > "+I.length+") {  for (var "+U+" = "+I.length+"; "+U+" < "+V+".length; "+U+"++) { ",H.errorPath=Q.util.getPathExpr(Q.errorPath,U,Q.opts.jsonPointers,!0);var p=V+"["+U+"]";H.dataPathArr[O]=U;var k=Q.validate(H);if(H.baseId=M,Q.util.varOccurences(k,q)<2)Z+=" "+Q.util.varReplace(k,q,p)+" ";else Z+=" var "+q+" = "+p+"; "+k+" ";if(K)Z+=" if (!"+C+") break; ";if(Z+=" } }  ",K)Z+=" if ("+C+") { ",F+="}"}}else if(Q.opts.strictKeywords?typeof I=="object"&&Object.keys(I).length>0||I===!1:Q.util.schemaHasRules(I,Q.RULES.all)){H.schema=I,H.schemaPath=X,H.errSchemaPath=W,Z+="  for (var "+U+" = 0; "+U+" < "+V+".length; "+U+"++) { ",H.errorPath=Q.util.getPathExpr(Q.errorPath,U,Q.opts.jsonPointers,!0);var p=V+"["+U+"]";H.dataPathArr[O]=U;var k=Q.validate(H);if(H.baseId=M,Q.util.varOccurences(k,q)<2)Z+=" "+Q.util.varReplace(k,q,p)+" ";else Z+=" var "+q+" = "+p+"; "+k+" ";if(K)Z+=" if (!"+C+") break; ";Z+=" }"}if(K)Z+=" "+F+" if ("+D+" == errors) {";return Z}});var Sc1=w((Un7,vVB)=>{vVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,M,V="data"+(J||""),E=Q.opts.$data&&I&&I.$data,D;if(E)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",D="schema"+Y;else D=I;var H=B=="maximum",F=H?"exclusiveMaximum":"exclusiveMinimum",C=Q.schema[F],U=Q.opts.$data&&C&&C.$data,O=H?"<":">",q=H?">":"<",M=void 0;if(!(E||typeof I=="number"||I===void 0))throw Error(B+" must be number");if(!(U||C===void 0||typeof C=="number"||typeof C=="boolean"))throw Error(F+" must be number or boolean");if(U){var _=Q.util.getData(C.$data,J,Q.dataPathArr),T="exclusive"+Y,y="exclType"+Y,h="exclIsNumber"+Y,x="op"+Y,m="' + "+x+" + '";Z+=" var schemaExcl"+Y+" = "+_+"; ",_="schemaExcl"+Y,Z+=" var "+T+"; var "+y+" = typeof "+_+"; if ("+y+" != 'boolean' && "+y+" != 'undefined' && "+y+" != 'number') { ";var M=F,g=g||[];if(g.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(M||"_exclusiveLimit")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: {} ",Q.opts.messages!==!1)Z+=" , message: '"+F+" should be boolean' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var t=Z;if(Z=g.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+t+"]); ";else Z+=" validate.errors = ["+t+"]; return false; ";else Z+=" var err = "+t+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" } else if ( ",E)Z+=" ("+D+" !== undefined && typeof "+D+" != 'number') || ";if(Z+=" "+y+" == 'number' ? ( ("+T+" = "+D+" === undefined || "+_+" "+O+"= "+D+") ? "+V+" "+q+"= "+_+" : "+V+" "+q+" "+D+" ) : ( ("+T+" = "+_+" === true) ? "+V+" "+q+"= "+D+" : "+V+" "+q+" "+D+" ) || "+V+" !== "+V+") { var op"+Y+" = "+T+" ? '"+O+"' : '"+O+"='; ",I===void 0)M=F,W=Q.errSchemaPath+"/"+F,D=_,E=U}else{var h=typeof C=="number",m=O;if(h&&E){var x="'"+m+"'";if(Z+=" if ( ",E)Z+=" ("+D+" !== undefined && typeof "+D+" != 'number') || ";Z+=" ( "+D+" === undefined || "+C+" "+O+"= "+D+" ? "+V+" "+q+"= "+C+" : "+V+" "+q+" "+D+" ) || "+V+" !== "+V+") { "}else{if(h&&I===void 0)T=!0,M=F,W=Q.errSchemaPath+"/"+F,D=C,q+="=";else{if(h)D=Math[H?"min":"max"](C,I);if(C===(h?D:!0))T=!0,M=F,W=Q.errSchemaPath+"/"+F,q+="=";else T=!1,m+="="}var x="'"+m+"'";if(Z+=" if ( ",E)Z+=" ("+D+" !== undefined && typeof "+D+" != 'number') || ";Z+=" "+V+" "+q+" "+D+" || "+V+" !== "+V+") { "}}M=M||B;var g=g||[];if(g.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(M||"_limit")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { comparison: "+x+", limit: "+D+", exclusive: "+T+" } ",Q.opts.messages!==!1)if(Z+=" , message: 'should be "+m+" ",E)Z+="' + "+D;else Z+=""+D+"'";if(Q.opts.verbose){if(Z+=" , schema:  ",E)Z+="validate.schema"+X;else Z+=""+I;Z+="         , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" "}Z+=" } "}else Z+=" {} ";var t=Z;if(Z=g.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+t+"]); ";else Z+=" validate.errors = ["+t+"]; return false; ";else Z+=" var err = "+t+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" } ",K)Z+=" else { ";return Z}});var xc1=w(($n7,kVB)=>{kVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,F,V="data"+(J||""),E=Q.opts.$data&&I&&I.$data,D;if(E)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",D="schema"+Y;else D=I;if(!(E||typeof I=="number"))throw Error(B+" must be number");var H=B=="maxItems"?">":"<";if(Z+="if ( ",E)Z+=" ("+D+" !== undefined && typeof "+D+" != 'number') || ";Z+=" "+V+".length "+H+" "+D+") { ";var F=B,C=C||[];if(C.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(F||"_limitItems")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { limit: "+D+" } ",Q.opts.messages!==!1){if(Z+=" , message: 'should NOT have ",B=="maxItems")Z+="more";else Z+="fewer";if(Z+=" than ",E)Z+="' + "+D+" + '";else Z+=""+I;Z+=" items' "}if(Q.opts.verbose){if(Z+=" , schema:  ",E)Z+="validate.schema"+X;else Z+=""+I;Z+="         , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" "}Z+=" } "}else Z+=" {} ";var U=Z;if(Z=C.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+U+"]); ";else Z+=" validate.errors = ["+U+"]; return false; ";else Z+=" var err = "+U+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+="} ",K)Z+=" else { ";return Z}});var yc1=w((wn7,fVB)=>{fVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,F,V="data"+(J||""),E=Q.opts.$data&&I&&I.$data,D;if(E)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",D="schema"+Y;else D=I;if(!(E||typeof I=="number"))throw Error(B+" must be number");var H=B=="maxLength"?">":"<";if(Z+="if ( ",E)Z+=" ("+D+" !== undefined && typeof "+D+" != 'number') || ";if(Q.opts.unicode===!1)Z+=" "+V+".length ";else Z+=" ucs2length("+V+") ";Z+=" "+H+" "+D+") { ";var F=B,C=C||[];if(C.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(F||"_limitLength")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { limit: "+D+" } ",Q.opts.messages!==!1){if(Z+=" , message: 'should NOT be ",B=="maxLength")Z+="longer";else Z+="shorter";if(Z+=" than ",E)Z+="' + "+D+" + '";else Z+=""+I;Z+=" characters' "}if(Q.opts.verbose){if(Z+=" , schema:  ",E)Z+="validate.schema"+X;else Z+=""+I;Z+="         , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" "}Z+=" } "}else Z+=" {} ";var U=Z;if(Z=C.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+U+"]); ";else Z+=" validate.errors = ["+U+"]; return false; ";else Z+=" var err = "+U+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+="} ",K)Z+=" else { ";return Z}});var vc1=w((Nn7,bVB)=>{bVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,F,V="data"+(J||""),E=Q.opts.$data&&I&&I.$data,D;if(E)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",D="schema"+Y;else D=I;if(!(E||typeof I=="number"))throw Error(B+" must be number");var H=B=="maxProperties"?">":"<";if(Z+="if ( ",E)Z+=" ("+D+" !== undefined && typeof "+D+" != 'number') || ";Z+=" Object.keys("+V+").length "+H+" "+D+") { ";var F=B,C=C||[];if(C.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(F||"_limitProperties")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { limit: "+D+" } ",Q.opts.messages!==!1){if(Z+=" , message: 'should NOT have ",B=="maxProperties")Z+="more";else Z+="fewer";if(Z+=" than ",E)Z+="' + "+D+" + '";else Z+=""+I;Z+=" properties' "}if(Q.opts.verbose){if(Z+=" , schema:  ",E)Z+="validate.schema"+X;else Z+=""+I;Z+="         , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" "}Z+=" } "}else Z+=" {} ";var U=Z;if(Z=C.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+U+"]); ";else Z+=" validate.errors = ["+U+"]; return false; ";else Z+=" var err = "+U+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+="} ",K)Z+=" else { ";return Z}});var gVB=w((qn7,hVB)=>{hVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E=Q.opts.$data&&I&&I.$data,D;if(E)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",D="schema"+Y;else D=I;if(!(E||typeof I=="number"))throw Error(B+" must be number");if(Z+="var division"+Y+";if (",E)Z+=" "+D+" !== undefined && ( typeof "+D+" != 'number' || ";if(Z+=" (division"+Y+" = "+V+" / "+D+", ",Q.opts.multipleOfPrecision)Z+=" Math.abs(Math.round(division"+Y+") - division"+Y+") > 1e-"+Q.opts.multipleOfPrecision+" ";else Z+=" division"+Y+" !== parseInt(division"+Y+") ";if(Z+=" ) ",E)Z+="  )  ";Z+=" ) {   ";var H=H||[];if(H.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'multipleOf' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { multipleOf: "+D+" } ",Q.opts.messages!==!1)if(Z+=" , message: 'should be multiple of ",E)Z+="' + "+D;else Z+=""+D+"'";if(Q.opts.verbose){if(Z+=" , schema:  ",E)Z+="validate.schema"+X;else Z+=""+I;Z+="         , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" "}Z+=" } "}else Z+=" {} ";var F=Z;if(Z=H.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+F+"]); ";else Z+=" validate.errors = ["+F+"]; return false; ";else Z+=" var err = "+F+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+="} ",K)Z+=" else { ";return Z}});var mVB=w((Ln7,uVB)=>{uVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="errs__"+Y,D=Q.util.copy(Q);D.level++;var H="valid"+D.level;if(Q.opts.strictKeywords?typeof I=="object"&&Object.keys(I).length>0||I===!1:Q.util.schemaHasRules(I,Q.RULES.all)){D.schema=I,D.schemaPath=X,D.errSchemaPath=W,Z+=" var "+E+" = errors;  ";var F=Q.compositeRule;Q.compositeRule=D.compositeRule=!0,D.createErrors=!1;var C;if(D.opts.allErrors)C=D.opts.allErrors,D.opts.allErrors=!1;if(Z+=" "+Q.validate(D)+" ",D.createErrors=!0,C)D.opts.allErrors=C;Q.compositeRule=D.compositeRule=F,Z+=" if ("+H+") {   ";var U=U||[];if(U.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'not' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: {} ",Q.opts.messages!==!1)Z+=" , message: 'should NOT be valid' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var O=Z;if(Z=U.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+O+"]); ";else Z+=" validate.errors = ["+O+"]; return false; ";else Z+=" var err = "+O+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" } else {  errors = "+E+"; if (vErrors !== null) { if ("+E+") vErrors.length = "+E+"; else vErrors = null; } ",Q.opts.allErrors)Z+=" } "}else{if(Z+="  var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'not' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: {} ",Q.opts.messages!==!1)Z+=" , message: 'should NOT be valid' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";if(Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",K)Z+=" if (false) { "}return Z}});var cVB=w((Mn7,dVB)=>{dVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D="errs__"+Y,H=Q.util.copy(Q),F="";H.level++;var C="valid"+H.level,U=H.baseId,O="prevValid"+Y,q="passingSchemas"+Y;Z+="var "+D+" = errors , "+O+" = false , "+E+" = false , "+q+" = null; ";var M=Q.compositeRule;Q.compositeRule=H.compositeRule=!0;var _=I;if(_){var T,y=-1,h=_.length-1;while(y<h){if(T=_[y+=1],Q.opts.strictKeywords?typeof T=="object"&&Object.keys(T).length>0||T===!1:Q.util.schemaHasRules(T,Q.RULES.all))H.schema=T,H.schemaPath=X+"["+y+"]",H.errSchemaPath=W+"/"+y,Z+="  "+Q.validate(H)+" ",H.baseId=U;else Z+=" var "+C+" = true; ";if(y)Z+=" if ("+C+" && "+O+") { "+E+" = false; "+q+" = ["+q+", "+y+"]; } else { ",F+="}";Z+=" if ("+C+") { "+E+" = "+O+" = true; "+q+" = "+y+"; }"}}if(Q.compositeRule=H.compositeRule=M,Z+=""+F+"if (!"+E+") {   var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'oneOf' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { passingSchemas: "+q+" } ",Q.opts.messages!==!1)Z+=" , message: 'should match exactly one schema in oneOf' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";if(Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(vErrors); ";else Z+=" validate.errors = vErrors; return false; ";if(Z+="} else {  errors = "+D+"; if (vErrors !== null) { if ("+D+") vErrors.length = "+D+"; else vErrors = null; }",Q.opts.allErrors)Z+=" } ";return Z}});var lVB=w((On7,pVB)=>{pVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E=Q.opts.$data&&I&&I.$data,D;if(E)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",D="schema"+Y;else D=I;var H=E?"(new RegExp("+D+"))":Q.usePattern(I);if(Z+="if ( ",E)Z+=" ("+D+" !== undefined && typeof "+D+" != 'string') || ";Z+=" !"+H+".test("+V+") ) {   ";var F=F||[];if(F.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'pattern' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { pattern:  ",E)Z+=""+D;else Z+=""+Q.util.toQuotedString(I);if(Z+="  } ",Q.opts.messages!==!1){if(Z+=` , message: 'should match pattern "`,E)Z+="' + "+D+" + '";else Z+=""+Q.util.escapeQuotes(I);Z+=`"' `}if(Q.opts.verbose){if(Z+=" , schema:  ",E)Z+="validate.schema"+X;else Z+=""+Q.util.toQuotedString(I);Z+="         , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" "}Z+=" } "}else Z+=" {} ";var C=Z;if(Z=F.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+C+"]); ";else Z+=" validate.errors = ["+C+"]; return false; ";else Z+=" var err = "+C+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+="} ",K)Z+=" else { ";return Z}});var nVB=w((Rn7,iVB)=>{iVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="errs__"+Y,D=Q.util.copy(Q),H="";D.level++;var F="valid"+D.level,C="key"+Y,U="idx"+Y,O=D.dataLevel=Q.dataLevel+1,q="data"+O,M="dataProperties"+Y,_=Object.keys(I||{}).filter(VA),T=Q.schema.patternProperties||{},y=Object.keys(T).filter(VA),h=Q.schema.additionalProperties,x=_.length||y.length,m=h===!1,g=typeof h=="object"&&Object.keys(h).length,t=Q.opts.removeAdditional,p=m||g||t,k=Q.opts.ownProperties,c=Q.baseId,e=Q.schema.required;if(e&&!(Q.opts.$data&&e.$data)&&e.length<Q.opts.loopRequired)var AA=Q.util.toHash(e);function VA(WQ){return WQ!=="__proto__"}if(Z+="var "+E+" = errors;var "+F+" = true;",k)Z+=" var "+M+" = undefined;";if(p){if(k)Z+=" "+M+" = "+M+" || Object.keys("+V+"); for (var "+U+"=0; "+U+"<"+M+".length; "+U+"++) { var "+C+" = "+M+"["+U+"]; ";else Z+=" for (var "+C+" in "+V+") { ";if(x){if(Z+=" var isAdditional"+Y+" = !(false ",_.length)if(_.length>8)Z+=" || validate.schema"+X+".hasOwnProperty("+C+") ";else{var OA=_;if(OA){var EA,SA=-1,yA=OA.length-1;while(SA<yA)EA=OA[SA+=1],Z+=" || "+C+" == "+Q.util.toQuotedString(EA)+" "}}if(y.length){var ZA=y;if(ZA){var GA,zA=-1,bA=ZA.length-1;while(zA<bA)GA=ZA[zA+=1],Z+=" || "+Q.usePattern(GA)+".test("+C+") "}}Z+=" ); if (isAdditional"+Y+") { "}if(t=="all")Z+=" delete "+V+"["+C+"]; ";else{var TA=Q.errorPath,G1="' + "+C+" + '";if(Q.opts._errorDataPathProperty)Q.errorPath=Q.util.getPathExpr(Q.errorPath,C,Q.opts.jsonPointers);if(m)if(t)Z+=" delete "+V+"["+C+"]; ";else{Z+=" "+F+" = false; ";var YA=W;W=Q.errSchemaPath+"/additionalProperties";var CA=CA||[];if(CA.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'additionalProperties' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { additionalProperty: '"+G1+"' } ",Q.opts.messages!==!1){if(Z+=" , message: '",Q.opts._errorDataPathProperty)Z+="is an invalid additional property";else Z+="should NOT have additional properties";Z+="' "}if(Q.opts.verbose)Z+=" , schema: false , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var MA=Z;if(Z=CA.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+MA+"]); ";else Z+=" validate.errors = ["+MA+"]; return false; ";else Z+=" var err = "+MA+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(W=YA,K)Z+=" break; "}else if(g)if(t=="failing"){Z+=" var "+E+" = errors;  ";var NA=Q.compositeRule;Q.compositeRule=D.compositeRule=!0,D.schema=h,D.schemaPath=Q.schemaPath+".additionalProperties",D.errSchemaPath=Q.errSchemaPath+"/additionalProperties",D.errorPath=Q.opts._errorDataPathProperty?Q.errorPath:Q.util.getPathExpr(Q.errorPath,C,Q.opts.jsonPointers);var UA=V+"["+C+"]";D.dataPathArr[O]=C;var LA=Q.validate(D);if(D.baseId=c,Q.util.varOccurences(LA,q)<2)Z+=" "+Q.util.varReplace(LA,q,UA)+" ";else Z+=" var "+q+" = "+UA+"; "+LA+" ";Z+=" if (!"+F+") { errors = "+E+"; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete "+V+"["+C+"]; }  ",Q.compositeRule=D.compositeRule=NA}else{D.schema=h,D.schemaPath=Q.schemaPath+".additionalProperties",D.errSchemaPath=Q.errSchemaPath+"/additionalProperties",D.errorPath=Q.opts._errorDataPathProperty?Q.errorPath:Q.util.getPathExpr(Q.errorPath,C,Q.opts.jsonPointers);var UA=V+"["+C+"]";D.dataPathArr[O]=C;var LA=Q.validate(D);if(D.baseId=c,Q.util.varOccurences(LA,q)<2)Z+=" "+Q.util.varReplace(LA,q,UA)+" ";else Z+=" var "+q+" = "+UA+"; "+LA+" ";if(K)Z+=" if (!"+F+") break; "}Q.errorPath=TA}if(x)Z+=" } ";if(Z+=" }  ",K)Z+=" if ("+F+") { ",H+="}"}var lA=Q.opts.useDefaults&&!Q.compositeRule;if(_.length){var gA=_;if(gA){var EA,I1=-1,$1=gA.length-1;while(I1<$1){EA=gA[I1+=1];var RA=I[EA];if(Q.opts.strictKeywords?typeof RA=="object"&&Object.keys(RA).length>0||RA===!1:Q.util.schemaHasRules(RA,Q.RULES.all)){var B1=Q.util.getProperty(EA),UA=V+B1,m1=lA&&RA.default!==void 0;D.schema=RA,D.schemaPath=X+B1,D.errSchemaPath=W+"/"+Q.util.escapeFragment(EA),D.errorPath=Q.util.getPath(Q.errorPath,EA,Q.opts.jsonPointers),D.dataPathArr[O]=Q.util.toQuotedString(EA);var LA=Q.validate(D);if(D.baseId=c,Q.util.varOccurences(LA,q)<2){LA=Q.util.varReplace(LA,q,UA);var S1=UA}else{var S1=q;Z+=" var "+q+" = "+UA+"; "}if(m1)Z+=" "+LA+" ";else{if(AA&&AA[EA]){if(Z+=" if ( "+S1+" === undefined ",k)Z+=" || ! Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(EA)+"') ";Z+=") { "+F+" = false; ";var TA=Q.errorPath,YA=W,H0=Q.util.escapeQuotes(EA);if(Q.opts._errorDataPathProperty)Q.errorPath=Q.util.getPath(TA,EA,Q.opts.jsonPointers);W=Q.errSchemaPath+"/required";var CA=CA||[];if(CA.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'required' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { missingProperty: '"+H0+"' } ",Q.opts.messages!==!1){if(Z+=" , message: '",Q.opts._errorDataPathProperty)Z+="is a required property";else Z+="should have required property \\'"+H0+"\\'";Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var MA=Z;if(Z=CA.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+MA+"]); ";else Z+=" validate.errors = ["+MA+"]; return false; ";else Z+=" var err = "+MA+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";W=YA,Q.errorPath=TA,Z+=" } else { "}else if(K){if(Z+=" if ( "+S1+" === undefined ",k)Z+=" || ! Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(EA)+"') ";Z+=") { "+F+" = true; } else { "}else{if(Z+=" if ("+S1+" !== undefined ",k)Z+=" &&   Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(EA)+"') ";Z+=" ) { "}Z+=" "+LA+" } "}}if(K)Z+=" if ("+F+") { ",H+="}"}}}if(y.length){var ZQ=y;if(ZQ){var GA,o0=-1,EQ=ZQ.length-1;while(o0<EQ){GA=ZQ[o0+=1];var RA=T[GA];if(Q.opts.strictKeywords?typeof RA=="object"&&Object.keys(RA).length>0||RA===!1:Q.util.schemaHasRules(RA,Q.RULES.all)){if(D.schema=RA,D.schemaPath=Q.schemaPath+".patternProperties"+Q.util.getProperty(GA),D.errSchemaPath=Q.errSchemaPath+"/patternProperties/"+Q.util.escapeFragment(GA),k)Z+=" "+M+" = "+M+" || Object.keys("+V+"); for (var "+U+"=0; "+U+"<"+M+".length; "+U+"++) { var "+C+" = "+M+"["+U+"]; ";else Z+=" for (var "+C+" in "+V+") { ";Z+=" if ("+Q.usePattern(GA)+".test("+C+")) { ",D.errorPath=Q.util.getPathExpr(Q.errorPath,C,Q.opts.jsonPointers);var UA=V+"["+C+"]";D.dataPathArr[O]=C;var LA=Q.validate(D);if(D.baseId=c,Q.util.varOccurences(LA,q)<2)Z+=" "+Q.util.varReplace(LA,q,UA)+" ";else Z+=" var "+q+" = "+UA+"; "+LA+" ";if(K)Z+=" if (!"+F+") break; ";if(Z+=" } ",K)Z+=" else "+F+" = true; ";if(Z+=" }  ",K)Z+=" if ("+F+") { ",H+="}"}}}}if(K)Z+=" "+H+" if ("+E+" == errors) {";return Z}});var oVB=w((_n7,aVB)=>{aVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="errs__"+Y,D=Q.util.copy(Q),H="";D.level++;var F="valid"+D.level;if(Z+="var "+E+" = errors;",Q.opts.strictKeywords?typeof I=="object"&&Object.keys(I).length>0||I===!1:Q.util.schemaHasRules(I,Q.RULES.all)){D.schema=I,D.schemaPath=X,D.errSchemaPath=W;var C="key"+Y,U="idx"+Y,O="i"+Y,q="' + "+C+" + '",M=D.dataLevel=Q.dataLevel+1,_="data"+M,T="dataProperties"+Y,y=Q.opts.ownProperties,h=Q.baseId;if(y)Z+=" var "+T+" = undefined; ";if(y)Z+=" "+T+" = "+T+" || Object.keys("+V+"); for (var "+U+"=0; "+U+"<"+T+".length; "+U+"++) { var "+C+" = "+T+"["+U+"]; ";else Z+=" for (var "+C+" in "+V+") { ";Z+=" var startErrs"+Y+" = errors; ";var x=C,m=Q.compositeRule;Q.compositeRule=D.compositeRule=!0;var g=Q.validate(D);if(D.baseId=h,Q.util.varOccurences(g,_)<2)Z+=" "+Q.util.varReplace(g,_,x)+" ";else Z+=" var "+_+" = "+x+"; "+g+" ";if(Q.compositeRule=D.compositeRule=m,Z+=" if (!"+F+") { for (var "+O+"=startErrs"+Y+"; "+O+"<errors; "+O+"++) { vErrors["+O+"].propertyName = "+C+"; }   var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'propertyNames' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { propertyName: '"+q+"' } ",Q.opts.messages!==!1)Z+=" , message: 'property name \\'"+q+"\\' is invalid' ";if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";if(Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(vErrors); ";else Z+=" validate.errors = vErrors; return false; ";if(K)Z+=" break; ";Z+=" } }"}if(K)Z+=" "+H+" if ("+E+" == errors) {";return Z}});var sVB=w((Tn7,rVB)=>{rVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D=Q.opts.$data&&I&&I.$data,H;if(D)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",H="schema"+Y;else H=I;var F="schema"+Y;if(!D)if(I.length<Q.opts.loopRequired&&Q.schema.properties&&Object.keys(Q.schema.properties).length){var C=[],U=I;if(U){var O,q=-1,M=U.length-1;while(q<M){O=U[q+=1];var _=Q.schema.properties[O];if(!(_&&(Q.opts.strictKeywords?typeof _=="object"&&Object.keys(_).length>0||_===!1:Q.util.schemaHasRules(_,Q.RULES.all))))C[C.length]=O}}}else var C=I;if(D||C.length){var T=Q.errorPath,y=D||C.length>=Q.opts.loopRequired,h=Q.opts.ownProperties;if(K)if(Z+=" var missing"+Y+"; ",y){if(!D)Z+=" var "+F+" = validate.schema"+X+"; ";var x="i"+Y,m="schema"+Y+"["+x+"]",g="' + "+m+" + '";if(Q.opts._errorDataPathProperty)Q.errorPath=Q.util.getPathExpr(T,m,Q.opts.jsonPointers);if(Z+=" var "+E+" = true; ",D)Z+=" if (schema"+Y+" === undefined) "+E+" = true; else if (!Array.isArray(schema"+Y+")) "+E+" = false; else {";if(Z+=" for (var "+x+" = 0; "+x+" < "+F+".length; "+x+"++) { "+E+" = "+V+"["+F+"["+x+"]] !== undefined ",h)Z+=" &&   Object.prototype.hasOwnProperty.call("+V+", "+F+"["+x+"]) ";if(Z+="; if (!"+E+") break; } ",D)Z+="  }  ";Z+="  if (!"+E+") {   ";var t=t||[];if(t.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'required' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { missingProperty: '"+g+"' } ",Q.opts.messages!==!1){if(Z+=" , message: '",Q.opts._errorDataPathProperty)Z+="is a required property";else Z+="should have required property \\'"+g+"\\'";Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var p=Z;if(Z=t.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+p+"]); ";else Z+=" validate.errors = ["+p+"]; return false; ";else Z+=" var err = "+p+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";Z+=" } else { "}else{Z+=" if ( ";var k=C;if(k){var c,x=-1,e=k.length-1;while(x<e){if(c=k[x+=1],x)Z+=" || ";var AA=Q.util.getProperty(c),VA=V+AA;if(Z+=" ( ( "+VA+" === undefined ",h)Z+=" || ! Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(c)+"') ";Z+=") && (missing"+Y+" = "+Q.util.toQuotedString(Q.opts.jsonPointers?c:AA)+") ) "}}Z+=") {  ";var m="missing"+Y,g="' + "+m+" + '";if(Q.opts._errorDataPathProperty)Q.errorPath=Q.opts.jsonPointers?Q.util.getPathExpr(T,m,!0):T+" + "+m;var t=t||[];if(t.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'required' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { missingProperty: '"+g+"' } ",Q.opts.messages!==!1){if(Z+=" , message: '",Q.opts._errorDataPathProperty)Z+="is a required property";else Z+="should have required property \\'"+g+"\\'";Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";var p=Z;if(Z=t.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+p+"]); ";else Z+=" validate.errors = ["+p+"]; return false; ";else Z+=" var err = "+p+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";Z+=" } else { "}else if(y){if(!D)Z+=" var "+F+" = validate.schema"+X+"; ";var x="i"+Y,m="schema"+Y+"["+x+"]",g="' + "+m+" + '";if(Q.opts._errorDataPathProperty)Q.errorPath=Q.util.getPathExpr(T,m,Q.opts.jsonPointers);if(D){if(Z+=" if ("+F+" && !Array.isArray("+F+")) {  var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'required' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { missingProperty: '"+g+"' } ",Q.opts.messages!==!1){if(Z+=" , message: '",Q.opts._errorDataPathProperty)Z+="is a required property";else Z+="should have required property \\'"+g+"\\'";Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if ("+F+" !== undefined) { "}if(Z+=" for (var "+x+" = 0; "+x+" < "+F+".length; "+x+"++) { if ("+V+"["+F+"["+x+"]] === undefined ",h)Z+=" || ! Object.prototype.hasOwnProperty.call("+V+", "+F+"["+x+"]) ";if(Z+=") {  var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'required' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { missingProperty: '"+g+"' } ",Q.opts.messages!==!1){if(Z+=" , message: '",Q.opts._errorDataPathProperty)Z+="is a required property";else Z+="should have required property \\'"+g+"\\'";Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";if(Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ",D)Z+="  }  "}else{var OA=C;if(OA){var c,EA=-1,SA=OA.length-1;while(EA<SA){c=OA[EA+=1];var AA=Q.util.getProperty(c),g=Q.util.escapeQuotes(c),VA=V+AA;if(Q.opts._errorDataPathProperty)Q.errorPath=Q.util.getPath(T,c,Q.opts.jsonPointers);if(Z+=" if ( "+VA+" === undefined ",h)Z+=" || ! Object.prototype.hasOwnProperty.call("+V+", '"+Q.util.escapeQuotes(c)+"') ";if(Z+=") {  var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: 'required' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { missingProperty: '"+g+"' } ",Q.opts.messages!==!1){if(Z+=" , message: '",Q.opts._errorDataPathProperty)Z+="is a required property";else Z+="should have required property \\'"+g+"\\'";Z+="' "}if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" ";Z+=" } "}else Z+=" {} ";Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "}}}Q.errorPath=T}else if(K)Z+=" if (true) {";return Z}});var eVB=w((jn7,tVB)=>{tVB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V="data"+(J||""),E="valid"+Y,D=Q.opts.$data&&I&&I.$data,H;if(D)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",H="schema"+Y;else H=I;if((I||D)&&Q.opts.uniqueItems!==!1){if(D)Z+=" var "+E+"; if ("+H+" === false || "+H+" === undefined) "+E+" = true; else if (typeof "+H+" != 'boolean') "+E+" = false; else { ";Z+=" var i = "+V+".length , "+E+" = true , j; if (i > 1) { ";var F=Q.schema.items&&Q.schema.items.type,C=Array.isArray(F);if(!F||F=="object"||F=="array"||C&&(F.indexOf("object")>=0||F.indexOf("array")>=0))Z+=" outer: for (;i--;) { for (j = i; j--;) { if (equal("+V+"[i], "+V+"[j])) { "+E+" = false; break outer; } } } ";else{Z+=" var itemIndices = {}, item; for (;i--;) { var item = "+V+"[i]; ";var U="checkDataType"+(C?"s":"");if(Z+=" if ("+Q.util[U](F,"item",Q.opts.strictNumbers,!0)+") continue; ",C)Z+=` if (typeof item == 'string') item = '"' + item; `;Z+=" if (typeof itemIndices[item] == 'number') { "+E+" = false; j = itemIndices[item]; break; } itemIndices[item] = i; } "}if(Z+=" } ",D)Z+="  }  ";Z+=" if (!"+E+") {   ";var O=O||[];if(O.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: 'uniqueItems' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { i: i, j: j } ",Q.opts.messages!==!1)Z+=" , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";if(Q.opts.verbose){if(Z+=" , schema:  ",D)Z+="validate.schema"+X;else Z+=""+I;Z+="         , parentSchema: validate.schema"+Q.schemaPath+" , data: "+V+" "}Z+=" } "}else Z+=" {} ";var q=Z;if(Z=O.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+q+"]); ";else Z+=" validate.errors = ["+q+"]; return false; ";else Z+=" var err = "+q+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";if(Z+=" } ",K)Z+=" else { "}else if(K)Z+=" if (true) { ";return Z}});var QEB=w((Pn7,AEB)=>{AEB.exports={$ref:DVB(),allOf:FVB(),anyOf:zVB(),$comment:$VB(),const:NVB(),contains:LVB(),dependencies:OVB(),enum:_VB(),format:jVB(),if:SVB(),items:yVB(),maximum:Sc1(),minimum:Sc1(),maxItems:xc1(),minItems:xc1(),maxLength:yc1(),minLength:yc1(),maxProperties:vc1(),minProperties:vc1(),multipleOf:gVB(),not:mVB(),oneOf:cVB(),pattern:lVB(),properties:nVB(),propertyNames:oVB(),required:sVB(),uniqueItems:eVB(),validate:jc1()}});var ZEB=w((Sn7,GEB)=>{var BEB=QEB(),kc1=we().toHash;GEB.exports=function(){var Q=[{type:"number",rules:[{maximum:["exclusiveMaximum"]},{minimum:["exclusiveMinimum"]},"multipleOf","format"]},{type:"string",rules:["maxLength","minLength","pattern","format"]},{type:"array",rules:["maxItems","minItems","items","contains","uniqueItems"]},{type:"object",rules:["maxProperties","minProperties","required","dependencies","propertyNames",{properties:["additionalProperties","patternProperties"]}]},{rules:["$ref","const","enum","not","anyOf","oneOf","allOf","if"]}],B=["type","$comment"],G=["$schema","$id","id","$data","$async","title","description","default","definitions","examples","readOnly","writeOnly","contentMediaType","contentEncoding","additionalItems","then","else"],Z=["number","integer","string","array","object","boolean","null"];return Q.all=kc1(B),Q.types=kc1(Z),Q.forEach(function(Y){if(Y.rules=Y.rules.map(function(J){var I;if(typeof J=="object"){var X=Object.keys(J)[0];I=J[X],J=X,I.forEach(function(K){B.push(K),Q.all[K]=!0})}B.push(J);var W=Q.all[J]={keyword:J,code:BEB[J],implements:I};return W}),Q.all.$comment={keyword:"$comment",code:BEB.$comment},Y.type)Q.types[Y.type]=Y}),Q.keywords=kc1(B.concat(G)),Q.custom={},Q}});var IEB=w((xn7,JEB)=>{var YEB=["multipleOf","maximum","exclusiveMaximum","minimum","exclusiveMinimum","maxLength","minLength","pattern","additionalItems","maxItems","minItems","uniqueItems","maxProperties","minProperties","required","additionalProperties","enum","format","const"];JEB.exports=function(A,Q){for(var B=0;B<Q.length;B++){A=JSON.parse(JSON.stringify(A));var G=Q[B].split("/"),Z=A,Y;for(Y=1;Y<G.length;Y++)Z=Z[G[Y]];for(Y=0;Y<YEB.length;Y++){var J=YEB[Y],I=Z[J];if(I)Z[J]={anyOf:[I,{$ref:"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"}]}}}return A}});var KEB=w((yn7,WEB)=>{var WR3=GrA().MissingRef;WEB.exports=XEB;function XEB(A,Q,B){var G=this;if(typeof this._opts.loadSchema!="function")throw Error("options.loadSchema should be a function");if(typeof Q=="function")B=Q,Q=void 0;var Z=Y(A).then(function(){var I=G._addSchema(A,void 0,Q);return I.validate||J(I)});if(B)Z.then(function(I){B(null,I)},B);return Z;function Y(I){var X=I.$schema;return X&&!G.getSchema(X)?XEB.call(G,{$ref:X},!0):Promise.resolve()}function J(I){try{return G._compile(I)}catch(W){if(W instanceof WR3)return X(W);throw W}function X(W){var K=W.missingSchema;if(D(K))throw Error("Schema "+K+" is loaded but "+W.missingRef+" cannot be resolved");var V=G._loadingSchemas[K];if(!V)V=G._loadingSchemas[K]=G._opts.loadSchema(K),V.then(E,E);return V.then(function(H){if(!D(K))return Y(H).then(function(){if(!D(K))G.addSchema(H,K,void 0,Q)})}).then(function(){return J(I)});function E(){delete G._loadingSchemas[K]}function D(H){return G._refs[H]||G._schemas[H]}}}}});var EEB=w((vn7,VEB)=>{VEB.exports=function(Q,B,G){var Z=" ",Y=Q.level,J=Q.dataLevel,I=Q.schema[B],X=Q.schemaPath+Q.util.getProperty(B),W=Q.errSchemaPath+"/"+B,K=!Q.opts.allErrors,V,E="data"+(J||""),D="valid"+Y,H="errs__"+Y,F=Q.opts.$data&&I&&I.$data,C;if(F)Z+=" var schema"+Y+" = "+Q.util.getData(I.$data,J,Q.dataPathArr)+"; ",C="schema"+Y;else C=I;var U=this,O="definition"+Y,q=U.definition,M="",_,T,y,h,x;if(F&&q.$data){x="keywordValidate"+Y;var m=q.validateSchema;Z+=" var "+O+" = RULES.custom['"+B+"'].definition; var "+x+" = "+O+".validate;"}else{if(h=Q.useCustomRule(U,I,Q.schema,Q),!h)return;C="validate.schema"+X,x=h.code,_=q.compile,T=q.inline,y=q.macro}var g=x+".errors",t="i"+Y,p="ruleErr"+Y,k=q.async;if(k&&!Q.async)throw Error("async keyword in sync schema");if(!(T||y))Z+=""+g+" = null;";if(Z+="var "+H+" = errors;var "+D+";",F&&q.$data){if(M+="}",Z+=" if ("+C+" === undefined) { "+D+" = true; } else { ",m)M+="}",Z+=" "+D+" = "+O+".validateSchema("+C+"); if ("+D+") { "}if(T)if(q.statements)Z+=" "+h.validate+" ";else Z+=" "+D+" = "+h.validate+"; ";else if(y){var c=Q.util.copy(Q),M="";c.level++;var e="valid"+c.level;c.schema=h.validate,c.schemaPath="";var AA=Q.compositeRule;Q.compositeRule=c.compositeRule=!0;var VA=Q.validate(c).replace(/validate\.schema/g,x);Q.compositeRule=c.compositeRule=AA,Z+=" "+VA}else{var OA=OA||[];if(OA.push(Z),Z="",Z+="  "+x+".call( ",Q.opts.passContext)Z+="this";else Z+="self";if(_||q.schema===!1)Z+=" , "+E+" ";else Z+=" , "+C+" , "+E+" , validate.schema"+Q.schemaPath+" ";if(Z+=" , (dataPath || '')",Q.errorPath!='""')Z+=" + "+Q.errorPath;var EA=J?"data"+(J-1||""):"parentData",SA=J?Q.dataPathArr[J]:"parentDataProperty";Z+=" , "+EA+" , "+SA+" , rootData )  ";var yA=Z;if(Z=OA.pop(),q.errors===!1){if(Z+=" "+D+" = ",k)Z+="await ";Z+=""+yA+"; "}else if(k)g="customErrors"+Y,Z+=" var "+g+" = null; try { "+D+" = await "+yA+"; } catch (e) { "+D+" = false; if (e instanceof ValidationError) "+g+" = e.errors; else throw e; } ";else Z+=" "+g+" = null; "+D+" = "+yA+"; "}if(q.modifying)Z+=" if ("+EA+") "+E+" = "+EA+"["+SA+"];";if(Z+=""+M,q.valid){if(K)Z+=" if (true) { "}else{if(Z+=" if ( ",q.valid===void 0)if(Z+=" !",y)Z+=""+e;else Z+=""+D;else Z+=" "+!q.valid+" ";Z+=") { ",V=U.keyword;var OA=OA||[];OA.push(Z),Z="";var OA=OA||[];if(OA.push(Z),Z="",Q.createErrors!==!1){if(Z+=" { keyword: '"+(V||"custom")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { keyword: '"+U.keyword+"' } ",Q.opts.messages!==!1)Z+=` , message: 'should pass "`+U.keyword+`" keyword validation' `;if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+E+" ";Z+=" } "}else Z+=" {} ";var ZA=Z;if(Z=OA.pop(),!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(["+ZA+"]); ";else Z+=" validate.errors = ["+ZA+"]; return false; ";else Z+=" var err = "+ZA+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";var GA=Z;if(Z=OA.pop(),T)if(q.errors){if(q.errors!="full"){if(Z+="  for (var "+t+"="+H+"; "+t+"<errors; "+t+"++) { var "+p+" = vErrors["+t+"]; if ("+p+".dataPath === undefined) "+p+".dataPath = (dataPath || '') + "+Q.errorPath+"; if ("+p+".schemaPath === undefined) { "+p+'.schemaPath = "'+W+'"; } ',Q.opts.verbose)Z+=" "+p+".schema = "+C+"; "+p+".data = "+E+"; ";Z+=" } "}}else if(q.errors===!1)Z+=" "+GA+" ";else{if(Z+=" if ("+H+" == errors) { "+GA+" } else {  for (var "+t+"="+H+"; "+t+"<errors; "+t+"++) { var "+p+" = vErrors["+t+"]; if ("+p+".dataPath === undefined) "+p+".dataPath = (dataPath || '') + "+Q.errorPath+"; if ("+p+".schemaPath === undefined) { "+p+'.schemaPath = "'+W+'"; } ',Q.opts.verbose)Z+=" "+p+".schema = "+C+"; "+p+".data = "+E+"; ";Z+=" } } "}else if(y){if(Z+="   var err =   ",Q.createErrors!==!1){if(Z+=" { keyword: '"+(V||"custom")+"' , dataPath: (dataPath || '') + "+Q.errorPath+" , schemaPath: "+Q.util.toQuotedString(W)+" , params: { keyword: '"+U.keyword+"' } ",Q.opts.messages!==!1)Z+=` , message: 'should pass "`+U.keyword+`" keyword validation' `;if(Q.opts.verbose)Z+=" , schema: validate.schema"+X+" , parentSchema: validate.schema"+Q.schemaPath+" , data: "+E+" ";Z+=" } "}else Z+=" {} ";if(Z+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!Q.compositeRule&&K)if(Q.async)Z+=" throw new ValidationError(vErrors); ";else Z+=" validate.errors = vErrors; return false; "}else if(q.errors===!1)Z+=" "+GA+" ";else{if(Z+=" if (Array.isArray("+g+")) { if (vErrors === null) vErrors = "+g+"; else vErrors = vErrors.concat("+g+"); errors = vErrors.length;  for (var "+t+"="+H+"; "+t+"<errors; "+t+"++) { var "+p+" = vErrors["+t+"]; if ("+p+".dataPath === undefined) "+p+".dataPath = (dataPath || '') + "+Q.errorPath+";  "+p+'.schemaPath = "'+W+'";  ',Q.opts.verbose)Z+=" "+p+".schema = "+C+"; "+p+".data = "+E+"; ";Z+=" } } else { "+GA+" } "}if(Z+=" } ",K)Z+=" else { "}return Z}});var fc1=w((kn7,KR3)=>{KR3.exports={$schema:"http://json-schema.org/draft-07/schema#",$id:"http://json-schema.org/draft-07/schema#",title:"Core schema meta-schema",definitions:{schemaArray:{type:"array",minItems:1,items:{$ref:"#"}},nonNegativeInteger:{type:"integer",minimum:0},nonNegativeIntegerDefault0:{allOf:[{$ref:"#/definitions/nonNegativeInteger"},{default:0}]},simpleTypes:{enum:["array","boolean","integer","null","number","object","string"]},stringArray:{type:"array",items:{type:"string"},uniqueItems:!0,default:[]}},type:["object","boolean"],properties:{$id:{type:"string",format:"uri-reference"},$schema:{type:"string",format:"uri"},$ref:{type:"string",format:"uri-reference"},$comment:{type:"string"},title:{type:"string"},description:{type:"string"},default:!0,readOnly:{type:"boolean",default:!1},examples:{type:"array",items:!0},multipleOf:{type:"number",exclusiveMinimum:0},maximum:{type:"number"},exclusiveMaximum:{type:"number"},minimum:{type:"number"},exclusiveMinimum:{type:"number"},maxLength:{$ref:"#/definitions/nonNegativeInteger"},minLength:{$ref:"#/definitions/nonNegativeIntegerDefault0"},pattern:{type:"string",format:"regex"},additionalItems:{$ref:"#"},items:{anyOf:[{$ref:"#"},{$ref:"#/definitions/schemaArray"}],default:!0},maxItems:{$ref:"#/definitions/nonNegativeInteger"},minItems:{$ref:"#/definitions/nonNegativeIntegerDefault0"},uniqueItems:{type:"boolean",default:!1},contains:{$ref:"#"},maxProperties:{$ref:"#/definitions/nonNegativeInteger"},minProperties:{$ref:"#/definitions/nonNegativeIntegerDefault0"},required:{$ref:"#/definitions/stringArray"},additionalProperties:{$ref:"#"},definitions:{type:"object",additionalProperties:{$ref:"#"},default:{}},properties:{type:"object",additionalProperties:{$ref:"#"},default:{}},patternProperties:{type:"object",additionalProperties:{$ref:"#"},propertyNames:{format:"regex"},default:{}},dependencies:{type:"object",additionalProperties:{anyOf:[{$ref:"#"},{$ref:"#/definitions/stringArray"}]}},propertyNames:{$ref:"#"},const:!0,enum:{type:"array",items:!0,minItems:1,uniqueItems:!0},type:{anyOf:[{$ref:"#/definitions/simpleTypes"},{type:"array",items:{$ref:"#/definitions/simpleTypes"},minItems:1,uniqueItems:!0}]},format:{type:"string"},contentMediaType:{type:"string"},contentEncoding:{type:"string"},if:{$ref:"#"},then:{$ref:"#"},else:{$ref:"#"},allOf:{$ref:"#/definitions/schemaArray"},anyOf:{$ref:"#/definitions/schemaArray"},oneOf:{$ref:"#/definitions/schemaArray"},not:{$ref:"#"}},default:!0}});var FEB=w((fn7,HEB)=>{var DEB=fc1();HEB.exports={$id:"https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",definitions:{simpleTypes:DEB.definitions.simpleTypes},type:"object",dependencies:{schema:["validate"],$data:["validate"],statements:["inline"],valid:{not:{required:["macro"]}}},properties:{type:DEB.properties.type,schema:{type:"boolean"},statements:{type:"boolean"},dependencies:{type:"array",items:{type:"string"}},metaSchema:{type:"object"},modifying:{type:"boolean"},valid:{type:"boolean"},$data:{type:"boolean"},async:{type:"boolean"},errors:{anyOf:[{type:"boolean"},{const:"full"}]}}}});var zEB=w((bn7,CEB)=>{var VR3=/^[a-z_$][a-z0-9_$-]*$/i,ER3=EEB(),DR3=FEB();CEB.exports={add:HR3,get:FR3,remove:CR3,validate:bc1};function HR3(A,Q){var B=this.RULES;if(B.keywords[A])throw Error("Keyword "+A+" is already defined");if(!VR3.test(A))throw Error("Keyword "+A+" is not a valid identifier");if(Q){this.validateKeyword(Q,!0);var G=Q.type;if(Array.isArray(G))for(var Z=0;Z<G.length;Z++)J(A,G[Z],Q);else J(A,G,Q);var Y=Q.metaSchema;if(Y){if(Q.$data&&this._opts.$data)Y={anyOf:[Y,{$ref:"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"}]};Q.validateSchema=this.compile(Y,!0)}}B.keywords[A]=B.all[A]=!0;function J(I,X,W){var K;for(var V=0;V<B.length;V++){var E=B[V];if(E.type==X){K=E;break}}if(!K)K={type:X,rules:[]},B.push(K);var D={keyword:I,definition:W,custom:!0,code:ER3,implements:W.implements};K.rules.push(D),B.custom[I]=D}return this}function FR3(A){var Q=this.RULES.custom[A];return Q?Q.definition:this.RULES.keywords[A]||!1}function CR3(A){var Q=this.RULES;delete Q.keywords[A],delete Q.all[A],delete Q.custom[A];for(var B=0;B<Q.length;B++){var G=Q[B].rules;for(var Z=0;Z<G.length;Z++)if(G[Z].keyword==A){G.splice(Z,1);break}}return this}function bc1(A,Q){bc1.errors=null;var B=this._validateKeyword=this._validateKeyword||this.compile(DR3,!0);if(B(A))return!0;if(bc1.errors=B.errors,Q)throw Error("custom keyword definition is invalid: "+this.errorsText(B.errors));else return!1}});var UEB=w((hn7,zR3)=>{zR3.exports={$schema:"http://json-schema.org/draft-07/schema#",$id:"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",description:"Meta-schema for $data reference (JSON Schema extension proposal)",type:"object",required:["$data"],properties:{$data:{type:"string",anyOf:[{format:"relative-json-pointer"},{format:"json-pointer"}]}},additionalProperties:!1}});var ErA=w((gn7,_EB)=>{var wEB=sKB(),Ne=BrA(),UR3=eKB(),NEB=qc1(),$R3=Tc1(),wR3=VVB(),NR3=ZEB(),qEB=IEB(),LEB=we();_EB.exports=HI;HI.prototype.validate=LR3;HI.prototype.compile=MR3;HI.prototype.addSchema=OR3;HI.prototype.addMetaSchema=RR3;HI.prototype.validateSchema=_R3;HI.prototype.getSchema=jR3;HI.prototype.removeSchema=SR3;HI.prototype.addFormat=gR3;HI.prototype.errorsText=hR3;HI.prototype._addSchema=xR3;HI.prototype._compile=yR3;HI.prototype.compileAsync=KEB();var VrA=zEB();HI.prototype.addKeyword=VrA.add;HI.prototype.getKeyword=VrA.get;HI.prototype.removeKeyword=VrA.remove;HI.prototype.validateKeyword=VrA.validate;var MEB=GrA();HI.ValidationError=MEB.Validation;HI.MissingRefError=MEB.MissingRef;HI.$dataMetaSchema=qEB;var KrA="http://json-schema.org/draft-07/schema",$EB=["removeAdditional","useDefaults","coerceTypes","strictDefaults"],qR3=["/properties"];function HI(A){if(!(this instanceof HI))return new HI(A);if(A=this._opts=LEB.copy(A)||{},lR3(this),this._schemas={},this._refs={},this._fragments={},this._formats=wR3(A.format),this._cache=A.cache||new UR3,this._loadingSchemas={},this._compilations=[],this.RULES=NR3(),this._getId=vR3(A),A.loopRequired=A.loopRequired||1/0,A.errorDataPath=="property")A._errorDataPathProperty=!0;if(A.serialize===void 0)A.serialize=$R3;if(this._metaOpts=pR3(this),A.formats)dR3(this);if(A.keywords)cR3(this);if(uR3(this),typeof A.meta=="object")this.addMetaSchema(A.meta);if(A.nullable)this.addKeyword("nullable",{metaSchema:{type:"boolean"}});mR3(this)}function LR3(A,Q){var B;if(typeof A=="string"){if(B=this.getSchema(A),!B)throw Error('no schema with key or ref "'+A+'"')}else{var G=this._addSchema(A);B=G.validate||this._compile(G)}var Z=B(Q);if(B.$async!==!0)this.errors=B.errors;return Z}function MR3(A,Q){var B=this._addSchema(A,void 0,Q);return B.validate||this._compile(B)}function OR3(A,Q,B,G){if(Array.isArray(A)){for(var Z=0;Z<A.length;Z++)this.addSchema(A[Z],void 0,B,G);return this}var Y=this._getId(A);if(Y!==void 0&&typeof Y!="string")throw Error("schema id must be string");return Q=Ne.normalizeId(Q||Y),REB(this,Q),this._schemas[Q]=this._addSchema(A,B,G,!0),this}function RR3(A,Q,B){return this.addSchema(A,Q,B,!0),this}function _R3(A,Q){var B=A.$schema;if(B!==void 0&&typeof B!="string")throw Error("$schema must be a string");if(B=B||this._opts.defaultMeta||TR3(this),!B)return this.logger.warn("meta-schema not available"),this.errors=null,!0;var G=this.validate(B,A);if(!G&&Q){var Z="schema is invalid: "+this.errorsText();if(this._opts.validateSchema=="log")this.logger.error(Z);else throw Error(Z)}return G}function TR3(A){var Q=A._opts.meta;return A._opts.defaultMeta=typeof Q=="object"?A._getId(Q)||Q:A.getSchema(KrA)?KrA:void 0,A._opts.defaultMeta}function jR3(A){var Q=OEB(this,A);switch(typeof Q){case"object":return Q.validate||this._compile(Q);case"string":return this.getSchema(Q);case"undefined":return PR3(this,A)}}function PR3(A,Q){var B=Ne.schema.call(A,{schema:{}},Q);if(B){var{schema:G,root:Z,baseId:Y}=B,J=wEB.call(A,G,Z,void 0,Y);return A._fragments[Q]=new NEB({ref:Q,fragment:!0,schema:G,root:Z,baseId:Y,validate:J}),J}}function OEB(A,Q){return Q=Ne.normalizeId(Q),A._schemas[Q]||A._refs[Q]||A._fragments[Q]}function SR3(A){if(A instanceof RegExp)return WrA(this,this._schemas,A),WrA(this,this._refs,A),this;switch(typeof A){case"undefined":return WrA(this,this._schemas),WrA(this,this._refs),this._cache.clear(),this;case"string":var Q=OEB(this,A);if(Q)this._cache.del(Q.cacheKey);return delete this._schemas[A],delete this._refs[A],this;case"object":var B=this._opts.serialize,G=B?B(A):A;this._cache.del(G);var Z=this._getId(A);if(Z)Z=Ne.normalizeId(Z),delete this._schemas[Z],delete this._refs[Z]}return this}function WrA(A,Q,B){for(var G in Q){var Z=Q[G];if(!Z.meta&&(!B||B.test(G)))A._cache.del(Z.cacheKey),delete Q[G]}}function xR3(A,Q,B,G){if(typeof A!="object"&&typeof A!="boolean")throw Error("schema should be object or boolean");var Z=this._opts.serialize,Y=Z?Z(A):A,J=this._cache.get(Y);if(J)return J;G=G||this._opts.addUsedSchema!==!1;var I=Ne.normalizeId(this._getId(A));if(I&&G)REB(this,I);var X=this._opts.validateSchema!==!1&&!Q,W;if(X&&!(W=I&&I==Ne.normalizeId(A.$schema)))this.validateSchema(A,!0);var K=Ne.ids.call(this,A),V=new NEB({id:I,schema:A,localRefs:K,cacheKey:Y,meta:B});if(I[0]!="#"&&G)this._refs[I]=V;if(this._cache.put(Y,V),X&&W)this.validateSchema(A,!0);return V}function yR3(A,Q){if(A.compiling){if(A.validate=Z,Z.schema=A.schema,Z.errors=null,Z.root=Q?Q:Z,A.schema.$async===!0)Z.$async=!0;return Z}A.compiling=!0;var B;if(A.meta)B=this._opts,this._opts=this._metaOpts;var G;try{G=wEB.call(this,A.schema,Q,A.localRefs)}catch(Y){throw delete A.validate,Y}finally{if(A.compiling=!1,A.meta)this._opts=B}return A.validate=G,A.refs=G.refs,A.refVal=G.refVal,A.root=G.root,G;function Z(){var Y=A.validate,J=Y.apply(this,arguments);return Z.errors=Y.errors,J}}function vR3(A){switch(A.schemaId){case"auto":return bR3;case"id":return kR3;default:return fR3}}function kR3(A){if(A.$id)this.logger.warn("schema $id ignored",A.$id);return A.id}function fR3(A){if(A.id)this.logger.warn("schema id ignored",A.id);return A.$id}function bR3(A){if(A.$id&&A.id&&A.$id!=A.id)throw Error("schema $id is different from id");return A.$id||A.id}function hR3(A,Q){if(A=A||this.errors,!A)return"No errors";Q=Q||{};var B=Q.separator===void 0?", ":Q.separator,G=Q.dataVar===void 0?"data":Q.dataVar,Z="";for(var Y=0;Y<A.length;Y++){var J=A[Y];if(J)Z+=G+J.dataPath+" "+J.message+B}return Z.slice(0,-B.length)}function gR3(A,Q){if(typeof Q=="string")Q=new RegExp(Q);return this._formats[A]=Q,this}function uR3(A){var Q;if(A._opts.$data)Q=UEB(),A.addMetaSchema(Q,Q.$id,!0);if(A._opts.meta===!1)return;var B=fc1();if(A._opts.$data)B=qEB(B,qR3);A.addMetaSchema(B,KrA,!0),A._refs["http://json-schema.org/schema"]=KrA}function mR3(A){var Q=A._opts.schemas;if(!Q)return;if(Array.isArray(Q))A.addSchema(Q);else for(var B in Q)A.addSchema(Q[B],B)}function dR3(A){for(var Q in A._opts.formats){var B=A._opts.formats[Q];A.addFormat(Q,B)}}function cR3(A){for(var Q in A._opts.keywords){var B=A._opts.keywords[Q];A.addKeyword(Q,B)}}function REB(A,Q){if(A._schemas[Q]||A._refs[Q])throw Error('schema with key or id "'+Q+'" already exists')}function pR3(A){var Q=LEB.copy(A._opts);for(var B=0;B<$EB.length;B++)delete Q[$EB[B]];return Q}function lR3(A){var Q=A._opts.logger;if(Q===!1)A.logger={log:hc1,warn:hc1,error:hc1};else{if(Q===void 0)Q=console;if(!(typeof Q=="object"&&Q.log&&Q.warn&&Q.error))throw Error("logger must implement log, warn and error methods");A.logger=Q}}function hc1(){}});var TEB,DrA;var jEB=L(()=>{Hc1();JV();TEB=o(ErA(),1);DrA=class DrA extends zwA{constructor(A,Q){var B;super(Q);this._clientInfo=A,this._cachedToolOutputValidators=new Map,this._capabilities=(B=Q===null||Q===void 0?void 0:Q.capabilities)!==null&&B!==void 0?B:{},this._ajv=new TEB.default}registerCapabilities(A){if(this.transport)throw Error("Cannot register capabilities after connecting to transport");this._capabilities=noA(this._capabilities,A)}assertCapability(A,Q){var B;if(!((B=this._serverCapabilities)===null||B===void 0?void 0:B[A]))throw Error(`Server does not support ${A} (required for ${Q})`)}async connect(A,Q){if(await super.connect(A),A.sessionId!==void 0)return;try{let B=await this.request({method:"initialize",params:{protocolVersion:Dp,capabilities:this._capabilities,clientInfo:this._clientInfo}},Bc1,Q);if(B===void 0)throw Error(`Server sent invalid initialize result: ${B}`);if(!koA.includes(B.protocolVersion))throw Error(`Server's protocol version is not supported: ${B.protocolVersion}`);if(this._serverCapabilities=B.capabilities,this._serverVersion=B.serverInfo,A.setProtocolVersion)A.setProtocolVersion(B.protocolVersion);this._instructions=B.instructions,await this.notification({method:"notifications/initialized"})}catch(B){throw this.close(),B}}getServerCapabilities(){return this._serverCapabilities}getServerVersion(){return this._serverVersion}getInstructions(){return this._instructions}assertCapabilityForMethod(A){var Q,B,G,Z,Y;switch(A){case"logging/setLevel":if(!((Q=this._serverCapabilities)===null||Q===void 0?void 0:Q.logging))throw Error(`Server does not support logging (required for ${A})`);break;case"prompts/get":case"prompts/list":if(!((B=this._serverCapabilities)===null||B===void 0?void 0:B.prompts))throw Error(`Server does not support prompts (required for ${A})`);break;case"resources/list":case"resources/templates/list":case"resources/read":case"resources/subscribe":case"resources/unsubscribe":if(!((G=this._serverCapabilities)===null||G===void 0?void 0:G.resources))throw Error(`Server does not support resources (required for ${A})`);if(A==="resources/subscribe"&&!this._serverCapabilities.resources.subscribe)throw Error(`Server does not support resource subscriptions (required for ${A})`);break;case"tools/call":case"tools/list":if(!((Z=this._serverCapabilities)===null||Z===void 0?void 0:Z.tools))throw Error(`Server does not support tools (required for ${A})`);break;case"completion/complete":if(!((Y=this._serverCapabilities)===null||Y===void 0?void 0:Y.completions))throw Error(`Server does not support completions (required for ${A})`);break;case"initialize":break;case"ping":break}}assertNotificationCapability(A){var Q;switch(A){case"notifications/roots/list_changed":if(!((Q=this._capabilities.roots)===null||Q===void 0?void 0:Q.listChanged))throw Error(`Client does not support roots list changed notifications (required for ${A})`);break;case"notifications/initialized":break;case"notifications/cancelled":break;case"notifications/progress":break}}assertRequestHandlerCapability(A){switch(A){case"sampling/createMessage":if(!this._capabilities.sampling)throw Error(`Client does not support sampling capability (required for ${A})`);break;case"elicitation/create":if(!this._capabilities.elicitation)throw Error(`Client does not support elicitation capability (required for ${A})`);break;case"roots/list":if(!this._capabilities.roots)throw Error(`Client does not support roots capability (required for ${A})`);break;case"ping":break}}async ping(A){return this.request({method:"ping"},Ab,A)}async complete(A,Q){return this.request({method:"completion/complete",params:A},Vc1,Q)}async setLoggingLevel(A,Q){return this.request({method:"logging/setLevel",params:{level:A}},Ab,Q)}async getPrompt(A,Q){return this.request({method:"prompts/get",params:A},Xc1,Q)}async listPrompts(A,Q){return this.request({method:"prompts/list",params:A},FwA,Q)}async listResources(A,Q){return this.request({method:"resources/list",params:A},$e,Q)}async listResourceTemplates(A,Q){return this.request({method:"resources/templates/list",params:A},Zc1,Q)}async readResource(A,Q){return this.request({method:"resources/read",params:A},Hp,Q)}async subscribeResource(A,Q){return this.request({method:"resources/subscribe",params:A},Ab,Q)}async unsubscribeResource(A,Q){return this.request({method:"resources/unsubscribe",params:A},Ab,Q)}async callTool(A,Q=F_,B){let G=await this.request({method:"tools/call",params:A},Q,B),Z=this.getToolOutputValidator(A.name);if(Z){if(!G.structuredContent&&!G.isError)throw new lF(pF.InvalidRequest,`Tool ${A.name} has an output schema but did not return structured content`);if(G.structuredContent)try{if(!Z(G.structuredContent))throw new lF(pF.InvalidParams,`Structured content does not match the tool's output schema: ${this._ajv.errorsText(Z.errors)}`)}catch(Y){if(Y instanceof lF)throw Y;throw new lF(pF.InvalidParams,`Failed to validate structured content: ${Y instanceof Error?Y.message:String(Y)}`)}}return G}cacheToolOutputSchemas(A){this._cachedToolOutputValidators.clear();for(let Q of A)if(Q.outputSchema)try{let B=this._ajv.compile(Q.outputSchema);this._cachedToolOutputValidators.set(Q.name,B)}catch(B){}}getToolOutputValidator(A){return this._cachedToolOutputValidators.get(A)}async listTools(A,Q){let B=await this.request({method:"tools/list",params:A},CwA,Q);return this.cacheToolOutputSchemas(B.tools),B}async sendRootsListChanged(){return this.notification({method:"notifications/roots/list_changed"})}}});class $wA{append(A){this._buffer=this._buffer?Buffer.concat([this._buffer,A]):A}readMessage(){if(!this._buffer)return null;let A=this._buffer.indexOf(`
2293:`})});function T32(){return null}function j32(){return null}function P32(){return null}function S32(){return _OA.createElement(m8,null)}function x32(A,{verbose:Q}){return _OA.createElement(K3,{result:A,verbose:Q})}var _OA;var y32=L(()=>{DI();lW();_OA=o(WA(),1)});var zq8,Uq8,Ti;var t21=L(()=>{z2();BC();pB();oG();ROA();_32();y32();T0();zq8=P.object({command:P.string().describe('The slash command to execute with its arguments, e.g., "/review-pr 123"')}),Uq8=P.object({success:P.boolean().describe("Whether the slash command is valid"),commandName:P.string().describe("The name of the slash command")}),Ti={name:LT,inputSchema:zq8,outputSchema:Uq8,description:async({command:A})=>`Execute slash command: ${A}`,prompt:async()=>R32(r1()),userFacingName:()=>LT,isConcurrencySafe:()=>!1,isEnabled:()=>!0,isReadOnly:()=>!1,async validateInput({command:A},Q){let B=SJA(A);if(!B)return{result:!1,message:`Invalid slash command format: ${A}`,errorCode:1};let{commandName:G}=B,Z=await FC(r1());if(!Uh(G,Z))return{result:!1,message:`Unknown slash command: ${G}`,errorCode:2};let Y=aw(G,Z);if(!Y)return{result:!1,message:`Could not load slash command: ${G}`,errorCode:3};if(Y.disableModelInvocation)return{result:!1,message:`Slash command ${G} cannot be used with ${LT} tool due to disable-model-invocation`,errorCode:4};if(Y.type!=="prompt")return{result:!1,message:`Slash command ${G} is not a prompt-based command`,errorCode:5};return{result:!0}},async checkPermissions({command:A},Q){let{commandName:B}=SJA(A)||{commandName:"unknown"},Z=(await Q.getAppState()).toolPermissionContext,Y=await FC(r1()),J=aw(B,Y),I=(E)=>{if(E===A)return!0;if(E.endsWith(":*")){let D=E.slice(0,-2);return A.startsWith(D)}return!1},X=jU(Z,Ti,"deny");for(let[E,D]of X.entries())if(I(E))return{behavior:"deny",message:"Slash command execution blocked by permission rules",decisionReason:{type:"rule",rule:D}};let W=jU(Z,Ti,"allow");for(let[E,D]of W.entries())if(I(E))return{behavior:"allow",updatedInput:{command:A},decisionReason:{type:"rule",rule:D}};let K=[{type:"addRules",rules:[{toolName:LT,ruleContent:A}],behavior:"allow",destination:"localSettings"}],V=A.indexOf(" ");if(V>0){let E=A.substring(0,V);K.push({type:"addRules",rules:[{toolName:LT,ruleContent:`${E}:*`}],behavior:"allow",destination:"localSettings"})}return{behavior:"ask",message:`Execute slash command: /${B}`,decisionReason:void 0,suggestions:K,metadata:{command:J}}},async call({command:A},Q,B,G){let{commandName:Z,args:Y}=SJA(A),J=await FC(r1()),I=await n21(Z,Y,J,Q);if(!I.shouldQuery)throw Error("Command processing failed");let X=I.allowedTools||[],W=I.model,K=I.maxThinkingTokens,V=eS().has(Z)?Z:"custom";r("tengu_slash_command_tool_invocation",{command_name:V});let E=o21(G,LT),D=a21(I.messages.filter((H)=>H.type!=="progress"),E);return{data:{success:!0,commandName:Z},newMessages:D,contextModifier(H){let F=H;if(X.length>0)F={...F,async getAppState(){let C=await Q.getAppState();return{...C,toolPermissionContext:{...C.toolPermissionContext,alwaysAllowRules:{...C.toolPermissionContext.alwaysAllowRules,command:[...new Set([...C.toolPermissionContext.alwaysAllowRules.command||[],...X])]}}}}};if(W)F={...F,options:{...F.options,mainLoopModel:W}};if(K!==void 0)F={...F,options:{...F.options,maxThinkingTokens:K}};return F}}},mapToolResultToToolResultBlockParam(A,Q){return{type:"tool_result",tool_use_id:Q,content:`Launching command: /${A.commandName}`}},renderToolResultMessage:T32,renderToolUseMessage:j32,renderToolUseProgressMessage:P32,renderToolUseRejectedMessage:S32,renderToolUseErrorMessage:x32}});function v32(A){let{toolUseConfirm:Q,onDone:B,onReject:G,verbose:Z}=A,J=((E)=>{let D=_i.inputSchema.safeParse(E);if(!D.success)return s(Error(`Failed to parse skill tool input: ${D.error.message}`)),"";return D.data.skill})(Q.input),I=Q.permissionResult.behavior==="ask"&&Q.permissionResult.metadata&&"command"in Q.permissionResult.metadata?Q.permissionResult.metadata.command:void 0,X=PM.useMemo(()=>({completion_type:"tool_use_single",language_name:"none"}),[]);OU(Q,X);let W=pQ(),K=PM.useMemo(()=>{let E=[{label:"Yes",value:"yes"}],D={label:`Yes, and don't ask again for ${cA.bold(J)} in ${cA.bold(W)}`,value:"yes-exact"},H=J.indexOf(" "),F=[];if(H>0){let U=J.substring(0,H);F.push({label:`Yes, and don't ask again for ${cA.bold(U+":*")} commands in ${cA.bold(W)}`,value:"yes-prefix"})}let C={label:`No, and tell Claude what to do differently ${cA.bold("(esc)")}`,value:"no"};return[...E,D,...F,C]},[J,W]),V=(E)=>{switch(E){case"yes":GJ({completion_type:"tool_use_single",event:"accept",metadata:{language_name:"none",message_id:Q.assistantMessage.message.id,platform:JQ.platform}}),Q.onAllow(Q.input,[]),B();break;case"yes-exact":{GJ({completion_type:"tool_use_single",event:"accept",metadata:{language_name:"none",message_id:Q.assistantMessage.message.id,platform:JQ.platform}}),Q.onAllow(Q.input,[{type:"addRules",rules:[{toolName:gw,ruleContent:J}],behavior:"allow",destination:"localSettings"}]),B();break}case"yes-prefix":{GJ({completion_type:"tool_use_single",event:"accept",metadata:{language_name:"none",message_id:Q.assistantMessage.message.id,platform:JQ.platform}});let D=J.indexOf(" "),H=D>0?J.substring(0,D):J;Q.onAllow(Q.input,[{type:"addRules",rules:[{toolName:gw,ruleContent:`${H}:*`}],behavior:"allow",destination:"localSettings"}]),B();break}case"no":GJ({completion_type:"tool_use_single",event:"reject",metadata:{language_name:"none",message_id:Q.assistantMessage.message.id,platform:JQ.platform}}),Q.onReject(),G(),B();break}};return PM.default.createElement(YZ,{title:`Use skill "${J}"?`},PM.default.createElement(z,null,"Claude may use instructions, code, or files from this Skill."),PM.default.createElement(j,{flexDirection:"column",paddingX:2,paddingY:1},PM.default.createElement(z,{dimColor:!0},I?.description)),PM.default.createElement(j,{flexDirection:"column"},PM.default.createElement(wH,{permissionResult:Q.permissionResult,toolType:"tool"}),PM.default.createElement(z,null,"Do you want to proceed?"),PM.default.createElement(S0,{options:K,onChange:V,onCancel:()=>V("no")})))}var PM;var k32=L(()=>{fA();Y3();UU();Hi();$8();g0();t2();Fi();Dh();r21();h1();PM=o(WA(),1)});function f32(A){let{toolUseConfirm:Q,onDone:B,onReject:G,verbose:Z}=A,J=((E)=>{let D=Ti.inputSchema.safeParse(E);if(!D.success)return s(Error(`Failed to parse slash command tool input: ${D.error.message}`)),"";return D.data.command})(Q.input),I=Q.permissionResult.behavior==="ask"&&Q.permissionResult.metadata&&"command"in Q.permissionResult.metadata?Q.permissionResult.metadata.command:void 0,X=SM.useMemo(()=>({completion_type:"tool_use_single",language_name:"none"}),[]);OU(Q,X);let W=pQ(),K=SM.useMemo(()=>{let E=[{label:"Yes",value:"yes"}],D={label:`Yes, and don't ask again for ${cA.bold(J)} in ${cA.bold(W)}`,value:"yes-exact"},H=J.indexOf(" "),F=[];if(H>0){let U=J.substring(0,H);F.push({label:`Yes, and don't ask again for ${cA.bold(U+":*")} commands in ${cA.bold(W)}`,value:"yes-prefix"})}let C={label:`No, and tell Claude what to do differently ${cA.bold("(esc)")}`,value:"no"};return[...E,D,...F,C]},[J,W]),V=(E)=>{switch(E){case"yes":GJ({completion_type:"tool_use_single",event:"accept",metadata:{language_name:"none",message_id:Q.assistantMessage.message.id,platform:JQ.platform}}),Q.onAllow(Q.input,[]),B();break;case"yes-exact":{GJ({completion_type:"tool_use_single",event:"accept",metadata:{language_name:"none",message_id:Q.assistantMessage.message.id,platform:JQ.platform}}),Q.onAllow(Q.input,[{type:"addRules",rules:[{toolName:LT,ruleContent:J}],behavior:"allow",destination:"localSettings"}]),B();break}case"yes-prefix":{GJ({completion_type:"tool_use_single",event:"accept",metadata:{language_name:"none",message_id:Q.assistantMessage.message.id,platform:JQ.platform}});let D=J.indexOf(" "),H=D>0?J.substring(0,D):J;Q.onAllow(Q.input,[{type:"addRules",rules:[{toolName:LT,ruleContent:`${H}:*`}],behavior:"allow",destination:"localSettings"}]),B();break}case"no":GJ({completion_type:"tool_use_single",event:"reject",metadata:{language_name:"none",message_id:Q.assistantMessage.message.id,platform:JQ.platform}}),Q.onReject(),G(),B();break}};return SM.default.createElement(YZ,{title:LT},SM.default.createElement(j,{flexDirection:"column",paddingX:2,paddingY:1},SM.default.createElement(z,null,J),SM.default.createElement(z,{dimColor:!0},I?.description)),SM.default.createElement(j,{flexDirection:"column"},SM.default.createElement(wH,{permissionResult:Q.permissionResult,toolType:"tool"}),SM.default.createElement(z,null,"Do you want to proceed?"),SM.default.createElement(S0,{options:K,onChange:V,onCancel:()=>V("no")})))}var SM;var b32=L(()=>{fA();Y3();UU();Hi();$8();g0();t2();Fi();Dh();t21();h1();SM=o(WA(),1)});function wq8({answers:A}){return fJ.createElement(j,{flexDirection:"column",marginTop:1},fJ.createElement(j,{flexDirection:"row"},fJ.createElement(z,{color:gR("default")},UI,"¬†"),fJ.createElement(z,null,"User answered Claude's questions:")),fJ.createElement(h0,null,fJ.createElement(j,{flexDirection:"column"},Object.entries(A).map(([Q,B])=>fJ.createElement(z,{key:Q,color:"inactive"},"¬∑ ",Q," ‚Üí ",B)))))}var fJ,$q8,h32,L90,bgG,e21;var A91=L(()=>{z2();fA();h4();xx();Gw();g0();rQ();fJ=o(WA(),1),$q8=P.object({label:P.string().describe("The display text for this option that the user will see and select. Should be concise (1-5 words) and clearly describe the choice."),description:P.string().describe("Explanation of what this option means or what will happen if chosen. Useful for providing context about trade-offs or implications.")}),h32=P.object({question:P.string().describe('The complete question to ask the user. Should be clear, specific, and end with a question mark. Example: "Which library should we use for date formatting?" If multiSelect is true, phrase it accordingly, e.g. "Which features do you want to enable?"'),header:P.string().describe(`Very short label displayed as a chip/tag (max ${m62} chars). Examples: "Auth method", "Library", "Approach".`),options:P.array($q8).min(2).max(4).describe("The available choices for this question. Must have 2-4 options. Each option should be a distinct, mutually exclusive choice (unless multiSelect is enabled). There should be no 'Other' option, that will be provided automatically."),multiSelect:P.boolean().describe("Set to true to allow the user to select multiple options instead of just one. Use when choices are not mutually exclusive.")}),L90=P.strictObject({questions:P.array(h32).min(1).max(4).describe("Questions to ask the user (1-4 questions)"),answers:P.record(P.string(),P.string()).optional().describe("User answers collected by the permission component")}).refine((A)=>{let Q=A.questions.map((B)=>B.question);if(Q.length!==new Set(Q).size)return!1;for(let B of A.questions){let G=B.options.map((Z)=>Z.label);if(G.length!==new Set(G).size)return!1}return!0},{message:"Question texts must be unique, option labels must be unique within each question"}),bgG=P.object({questions:P.array(h32).describe("The questions that were asked"),answers:P.record(P.string(),P.string()).describe("The answers provided by the user (question text -> answer string; multi-select answers are comma-separated)")});e21={name:LI,async description(){return d62},async prompt(){return c62},inputSchema:L90,userFacingName(){return""},isEnabled(){return SBA()||z0(process.env.CLAUDE_CODE_ENABLE_ASK_USER_QUESTION_TOOL)},isConcurrencySafe(){return!0},isReadOnly(){return!0},requiresUserInteraction(){return!0},async checkPermissions(A){return{behavior:"ask",message:"Answer questions?",updatedInput:A}},renderToolUseMessage(){return null},renderToolUseProgressMessage(){return null},renderToolResultMessage({answers:A},Q){return fJ.createElement(wq8,{answers:A})},renderToolUseRejectedMessage(){return fJ.createElement(j,{flexDirection:"row",marginTop:1},fJ.createElement(z,{color:gR("default")},UI,"¬†"),fJ.createElement(z,null,"User declined to answer questions"))},renderToolUseErrorMessage(){return null},async call({questions:A,answers:Q={}},B){return{data:{questions:A,answers:Q}}},mapToolResultToToolResultBlockParam({answers:A},Q){return{type:"tool_result",content:`User has answered your questions: ${Object.entries(A).map(([G,Z])=>`"${G}"="${Z}"`).join(", ")}. You can now continue with the user's answers in mind.`,tool_use_id:Q}}}});function Nq8(A,Q){switch(Q.type){case"next-question":return{...A,currentQuestionIndex:A.currentQuestionIndex+1,isInTextInput:!1};case"prev-question":return{...A,currentQuestionIndex:Math.max(0,A.currentQuestionIndex-1),isInTextInput:!1};case"update-question-state":{let B=A.questionStates[Q.questionText],G={selectedValue:Q.updates.selectedValue??B?.selectedValue??(Q.isMultiSelect?[]:void 0),textInputValue:Q.updates.textInputValue??B?.textInputValue??""};return{...A,questionStates:{...A.questionStates,[Q.questionText]:G}}}case"set-answer":{let B={...A,answers:{...A.answers,[Q.questionText]:Q.answer}};if(Q.shouldAdvance)return{...B,currentQuestionIndex:B.currentQuestionIndex+1,isInTextInput:!1};return B}case"set-text-input-mode":return{...A,isInTextInput:Q.isInInput}}}function g32(){let[A,Q]=ji.useReducer(Nq8,qq8),B=ji.useCallback(()=>{Q({type:"next-question"})},[]),G=ji.useCallback(()=>{Q({type:"prev-question"})},[]),Z=ji.useCallback((I,X,W)=>{Q({type:"update-question-state",questionText:I,updates:X,isMultiSelect:W})},[]),Y=ji.useCallback((I,X,W=!0)=>{Q({type:"set-answer",questionText:I,answer:X,shouldAdvance:W})},[]),J=ji.useCallback((I)=>{Q({type:"set-text-input-mode",isInInput:I})},[]);return{currentQuestionIndex:A.currentQuestionIndex,answers:A.answers,questionStates:A.questionStates,isInTextInput:A.isInTextInput,nextQuestion:B,prevQuestion:G,updateQuestionState:Z,setAnswer:Y,setTextInputMode:J}}var ji,qq8;var u32=L(()=>{ji=o(WA(),1);qq8={currentQuestionIndex:0,answers:{},questionStates:{},isInTextInput:!1}});function Q91({questions:A,currentQuestionIndex:Q,answers:B,hideSubmitTab:G=!1}){let{columns:Z}=kB(),Y=xM.useMemo(()=>{let W=G?"":` ${X1.tick} Submit `,K=2,V=2,E=UG("‚Üê ")+UG(" ‚Üí")+UG(W),D=Z-E;if(D<=0)return A.map((h,x)=>{let m=h?.header||`Q${x+1}`;return x===Q?m.slice(0,3):""});let H=A.map((h,x)=>h?.header||`Q${x+1}`);if(H.map((h)=>4+UG(h)).reduce((h,x)=>h+x,0)<=D)return H;let U=H[Q]||"",O=4+UG(U),q=6,M=Math.min(O,D/2),_=D-M,T=A.length-1,y=Math.max(q,Math.floor(_/Math.max(T,1)));return H.map((h,x)=>{if(x===Q){let m=M-2-2;if(UG(h)<=m)return h;let g=h;while(UG(g+"‚Ä¶")>m&&g.length>1)g=g.slice(0,-1);return g+"‚Ä¶"}else{let m=y-2-2;if(UG(h)<=m)return h;let g=h;while(UG(g+"‚Ä¶")>m&&g.length>1)g=g.slice(0,-1);return g.length>0?g+"‚Ä¶":h[0]+"‚Ä¶"}})},[A,Q,Z,G]),J=A.length===1&&G;return xM.default.createElement(j,{flexDirection:"row",marginBottom:1},!J&&xM.default.createElement(z,{color:Q===0?"inactive":void 0},"‚Üê"," "),A.map((I,X)=>{let W=X===Q,V=I?.question&&!!B[I.question]?X1.checkboxOn:X1.checkboxOff,E=Y[X]||I?.header||`Q${X+1}`;return xM.default.createElement(j,{key:I?.question||`question-${X}`},W?xM.default.createElement(z,{backgroundColor:"permission",color:"inverseText"}," ",V," ",E," "):xM.default.createElement(z,null," ",V," ",E," "))}),!G&&xM.default.createElement(j,{key:"submit"},Q===A.length?xM.default.createElement(z,{backgroundColor:"permission",color:"inverseText"}," ",X1.tick," Submit"," "):xM.default.createElement(z,null," ",X1.tick," Submit ")),!J&&xM.default.createElement(z,{color:Q===A.length?"inactive":void 0}," ","‚Üí"))}var xM;var M90=L(()=>{g2();fA();y6();Ys();xM=o(WA(),1)});function m32({question:A,questions:Q,currentQuestionIndex:B,answers:G,questionStates:Z,hideSubmitTab:Y=!1,onUpdateQuestionState:J,onAnswer:I,onTextInputFocus:X,onCancel:W,onSubmit:K}){let V=ow.useCallback((U)=>{X(U==="__other__")},[X]),E=A.options.map((U)=>({type:"text",value:U.label,label:U.label,description:U.description})),D=A.question,H=Z[D],F={type:"input",value:"__other__",label:"Other",placeholder:A.multiSelect?"Type something":"Type something.",initialValue:H?.textInputValue??"",onChange:(U)=>{J(D,{textInputValue:U},A.multiSelect??!1)}},C=[...E,F];return ow.default.createElement(j,{flexDirection:"column",marginTop:1},ow.default.createElement(p8,{dividerColor:"inactive"}),ow.default.createElement(j,{flexDirection:"column",paddingTop:0},ow.default.createElement(Q91,{questions:Q,currentQuestionIndex:B,answers:G,hideSubmitTab:Y}),ow.default.createElement(NYA,{title:A.question,color:"text"}),ow.default.createElement(j,{marginTop:1},A.multiSelect?ow.default.createElement(Fo1,{key:A.question,options:C,defaultValue:Z[A.question]?.selectedValue,onChange:(U)=>{J(D,{selectedValue:U},!0);let O=U.includes("__other__")?Z[D]?.textInputValue:void 0,q=U.filter((M)=>M!=="__other__").concat(O?[O]:[]);I(D,q,void 0,!1)},onFocus:V,onCancel:W,submitButtonText:B===Q.length-1?"Submit":"Next",onSubmit:K}):ow.default.createElement(S0,{key:A.question,options:C,defaultValue:Z[A.question]?.selectedValue,onChange:(U)=>{J(D,{selectedValue:U},!1);let O=U==="__other__"?Z[D]?.textInputValue:void 0;I(D,U,O)},onFocus:V,onCancel:W,layout:"compact-vertical"})),ow.default.createElement(j,{marginTop:1},ow.default.createElement(z,{color:"inactive",dimColor:!0},"Enter to select ¬∑ Tab/Arrow keys to navigate ¬∑ Esc to cancel"))))}var ow;var d32=L(()=>{fA();Y3();R01();M90();AK();ow=o(WA(),1)});function c32({questions:A,currentQuestionIndex:Q,answers:B,allQuestionsAnswered:G,permissionResult:Z,onFinalResponse:Y}){return SV.default.createElement(j,{flexDirection:"column",marginTop:1},SV.default.createElement(p8,{dividerColor:"inactive"}),SV.default.createElement(j,{flexDirection:"column",borderTop:!0,borderColor:"inactive",paddingTop:0},SV.default.createElement(Q91,{questions:A,currentQuestionIndex:Q,answers:B}),SV.default.createElement(NYA,{title:"Review your answers",color:"text"}),SV.default.createElement(j,{flexDirection:"column",marginTop:1},!G&&SV.default.createElement(j,{marginBottom:1},SV.default.createElement(z,{color:"warning"},X1.warning," You have not answered all questions")),Object.keys(B).length>0&&SV.default.createElement(j,{flexDirection:"column",marginBottom:1},A.filter((J)=>J?.question&&B[J.question]).map((J)=>{let I=B[J?.question];return SV.default.createElement(j,{key:J?.question||"answer",flexDirection:"column",marginLeft:1},SV.default.createElement(z,null,X1.bullet," ",J?.question||"Question"),SV.default.createElement(j,{marginLeft:2},SV.default.createElement(z,{color:"success"},X1.arrowRight," ",I)))})),SV.default.createElement(wH,{permissionResult:Z,toolType:"tool"}),SV.default.createElement(z,{color:"inactive"},"Ready to submit your answers?"),SV.default.createElement(j,{marginTop:1},SV.default.createElement(S0,{options:[{type:"text",label:"Submit answers",value:"submit"},{type:"text",label:"Cancel",value:"cancel"}],onChange:(J)=>Y(J),onCancel:()=>Y("cancel")})))))}var SV;var p32=L(()=>{g2();fA();Y3();R01();Dh();M90();AK();SV=o(WA(),1)});function l32({toolUseConfirm:A,onDone:Q,onReject:B}){let G=L90.safeParse(A.input),Z=G.success?G.data.questions||[]:[],Y=g32(),{currentQuestionIndex:J,answers:I,questionStates:X,isInTextInput:W,nextQuestion:K,prevQuestion:V,updateQuestionState:E,setAnswer:D,setTextInputMode:H}=Y,F=J<(Z?.length||0)?Z?.[J]:null,C=J===(Z?.length||0),U=Z?.every((y)=>y?.question&&!!I[y.question])??!1,O=Z.length===1&&!Z[0]?.multiSelect,q=b1A.useCallback(()=>{Q(),B(),A.onReject()},[Q,B,A]),M=b1A.useCallback((y)=>{let h={...A.input,answers:y};Q(),A.onAllow(h,[])},[A,Q]),_=b1A.useCallback((y,h,x,m=!0)=>{let g,t=Array.isArray(h);if(t)g=h.join(", ");else g=x||h;let p=Z.length===1;if(!t&&p&&m){let k={...I,[y]:g};M(k);return}D(y,g,m)},[D,Z.length,I,M]);function T(y){if(y==="cancel"){q();return}if(y==="submit")M(I)}if(k1((y,h)=>{if(W&&!C)return;if(h.return)return;if((h.leftArrow||h.shift&&h.tab)&&J>0)V();let x=O?(Z?.length||1)-1:Z?.length||0;if((h.rightArrow||h.tab&&!h.shift)&&J<x)K()}),F)return b1A.default.createElement(m32,{question:F,questions:Z,currentQuestionIndex:J,answers:I,questionStates:X,hideSubmitTab:O,onUpdateQuestionState:E,onAnswer:_,onTextInputFocus:H,onCancel:q,onSubmit:K});if(C)return b1A.default.createElement(c32,{questions:Z,currentQuestionIndex:J,answers:I,allQuestionsAnswered:U,permissionResult:A.permissionResult,onFinalResponse:T});return null}var b1A;var i32=L(()=>{fA();A91();u32();d32();p32();b1A=o(WA(),1)});function Lq8(A){switch(A){case lE:return rQ2;case XW:return sB2;case Q4:return nB2;case IK:return k62;case KT:return g62;case nw:return Z32;case OOA:return H32;case _i:return v32;case Ti:return f32;case e21:return l32;case ZM:case Gx:case V3:return eB2;default:return Q21}}function Mq8(A){let Q=A.tool.userFacingName(A.input);if(A.tool===nw)return"Claude Code needs your approval for the plan";if(A.tool===OOA)return"Claude Code wants to enter plan mode";if(!Q||Q.trim()==="")return"Claude Code needs your attention";return`Claude needs your permission to use ${Q}`}function n32({toolUseConfirm:A,toolUseContext:Q,onDone:B,onReject:G,verbose:Z,workerBadge:Y}){k1((X,W)=>{if(W.ctrl&&X==="c")B(),G(),A.onReject()});let J=Mq8(A);XJA(J,"permission_prompt");let I=Lq8(A.tool);return O90.createElement(I,{toolUseContext:Q,toolUseConfirm:A,onDone:B,onReject:G,verbose:Z,workerBadge:Y})}var O90;var a32=L(()=>{fA();rl();Rb();pE();sQ2();aB2();pB0();kB1();tB2();A22();pYA();tNA();rNA();Cw();PJA();f62();u62();MOA();Y32();w90();F32();r21();t21();k32();b32();A91();i32();O90=o(WA(),1)});function Rq8(A){if(TOA(A))return P.enum(A.enum);if(A.type==="string"){let Q=P.string();if(A.minLength!==void 0)Q=Q.min(A.minLength,{message:`Must be at least ${A.minLength} character${A.minLength===1?"":"s"}`});if(A.maxLength!==void 0)Q=Q.max(A.maxLength,{message:`Must be at most ${A.maxLength} character${A.maxLength===1?"":"s"}`});switch(A.format){case"email":Q=Q.email({message:"Please enter a valid email address"});break;case"uri":Q=Q.url({message:"Please enter a valid URI"});break;case"date":Q=Q.date("Please enter a valid date (YYYY-MM-DD)");break;case"date-time":Q=Q.datetime({offset:!0,message:"Please enter a valid date-time (YYYY-MM-DDTHH:MM:SSZ)"});break;default:break}return Q}if(A.type==="number"||A.type==="integer"){let Q=P.coerce.number();if(A.type==="integer")Q=Q.int();if(A.minimum!==void 0)Q=Q.min(A.minimum,{message:`Must be at least ${A.minimum}`});if(A.maximum!==void 0)Q=Q.max(A.maximum,{message:`Must be at most ${A.maximum}`});return Q}if(A.type==="boolean")return P.coerce.boolean();throw Error(`Unsupported schema: ${JSON.stringify(A)}`)}function R90(A,Q){let G=Rq8(Q).safeParse(A);if(G.success)return{value:G.data,isValid:!0};return{isValid:!1,error:G.error.errors.map((Z)=>Z.message).join("; ")}}function o32(A){if(A.type==="string"){if(!_q8(A))return;let{description:Q,example:B}=Oq8[A.format]||{};return`${Q}, e.g. ${B}`}if(A.type==="number"||A.type==="integer"){let Q=A.type==="integer",B=(G)=>Number.isInteger(G)&&!Q?`${G}.0`:String(G);if(A.minimum!==void 0&&A.maximum!==void 0)return`(${A.type} between ${B(A.minimum)} and ${B(A.maximum)})`;else if(A.minimum!==void 0)return`(${A.type} >= ${B(A.minimum)})`;else if(A.maximum!==void 0)return`(${A.type} <= ${B(A.maximum)})`;else{let G=A.type==="integer"?"42":"3.14";return`(${A.type}, e.g. ${G})`}}return}var Oq8,TOA=(A)=>{return A.type==="string"&&"enum"in A},_q8=(A)=>{return A.type==="string"&&"format"in A&&typeof A.format==="string"};var r32=L(()=>{z2();Oq8={email:{description:"email address",example:"user@example.com"},uri:{description:"URI",example:"https://example.com"},date:{description:"date",example:"2024-03-15"},"date-time":{description:"date-time",example:"2024-03-15T14:30:00Z"}}});function B91(){return N9.default.createElement(z,{italic:!0,dimColor:!0},"<unset>")}function t32({serverName:A,request:Q,onResponse:B,signal:G}){let{message:Z,requestedSchema:Y}=Q,[J,I]=N9.useState(null),[X,W]=N9.useState(()=>{let OA={};if(Y.properties){for(let[EA,SA]of Object.entries(Y.properties))if(typeof SA==="object"&&SA!==null){if(SA.default!==void 0)OA[EA]=SA.default}}return OA}),[K,V]=N9.useState(()=>{let OA={};for(let[EA,SA]of Object.entries(Y.properties))if(s32(SA)&&SA?.default!==void 0){let yA=R90(String(SA.default),SA);if(!yA.isValid&&yA.error)OA[EA]=yA.error}return OA});N9.useEffect(()=>{if(!G)return;let OA=()=>{B("cancel")};if(G.aborted){OA();return}return G.addEventListener("abort",OA),()=>{G.removeEventListener("abort",OA)}},[G,B]);let E=N9.useMemo(()=>{let OA=Y.required??[];return Object.entries(Y.properties).map(([EA,SA])=>({name:EA,schema:SA,isRequired:OA.includes(EA)}))},[Y]),[D,H]=N9.useState(0),[F,C]=N9.useState(),[U,O]=N9.useState(""),[q,M]=N9.useState(0),{columns:_}=kB(),T=D!==void 0?E[D]:void 0,y=T&&s32(T.schema);_Q(),XJA("Claude Code needs your input","elicitation_dialog");function h(OA){let EA=E.length+2,SA=D??(J==="accept"?E.length:J==="decline"?E.length+1:void 0),yA=SA!==void 0?(SA+(OA==="up"?EA-1:1))%EA:0;if(yA<E.length)H(yA),I(null);else H(void 0),I(yA===E.length?"accept":"decline")}function x(OA,EA){W((SA)=>{let yA={...SA};if(EA===void 0)delete yA[OA];else yA[OA]=EA;return yA})}function m(OA,EA){V((SA)=>{let yA={...SA};if(EA)yA[OA]=EA;else delete yA[OA];return yA})}function g(OA){if(!OA)return;x(OA,void 0),m(OA),C(void 0),O(""),M(0)}function t(OA){if(!T)return;if(OA.trim()===""&&(T.schema.type!=="string"||("format"in T.schema)&&T.schema.format!==void 0)){g(T.name),h("down");return}let SA=R90(OA,T.schema);x(T.name,SA.isValid?SA.value:OA),m(T.name,SA.isValid?void 0:SA.error),C(void 0),O(""),M(0),h("down")}function p(){if(!T)return;C(void 0),O(""),M(0)}k1((OA,EA)=>{if(T&&F===T.name){if(TOA(T?.schema))return;if(y){if(EA.escape&&U===""){p();return}}}else{if(EA.escape){B("cancel");return}if(EA.return&&J==="accept"){if(k()&&Object.keys(K).length===0)B("accept",X);return}if(EA.return&&J==="decline"){B("decline");return}if(EA.upArrow||EA.downArrow){h(EA.upArrow?"up":"down");return}if(T){let{schema:SA,name:yA,isRequired:ZA}=T,GA=X[yA];if(EA.backspace&&!ZA){g(T.name);return}if(EA.return){if(SA.type==="boolean"){x(yA,!(GA??!1)),h("down");return}if(C(yA),y){let zA=GA!==void 0?String(GA):"";O(zA),M(zA.length)}}}}},{isActive:!0});let k=()=>{let OA=Y.required||[];for(let EA of OA){let SA=X[EA];if(SA===void 0||SA===null||SA==="")return!1}return!0},c=()=>{if(!E.length)return null;return N9.default.createElement(j,{flexDirection:"column",gap:1},E.map((OA,EA)=>{let{name:SA,schema:yA,isRequired:ZA}=OA,GA=EA===D&&!J,zA=X[SA],bA=(()=>{if(!GA||F!==void 0)return null;let G1=yA.type==="boolean"?"toggle":TOA(yA)?"select":"edit",YA=zA===void 0||ZA?`(Press Enter to ${G1})`:`(Press Enter to ${G1}, Backspace to unset)`;return N9.default.createElement(z,{dimColor:!0}," ",YA)})(),TA=(G1,YA)=>{return N9.default.createElement(j,{key:SA,flexDirection:"column"},N9.default.createElement(j,{gap:1,paddingLeft:GA?0:2},GA&&N9.default.createElement(z,{color:"success"},X1.pointer),N9.default.createElement(j,{flexGrow:1,flexDirection:"column"},G1,yA.description&&N9.default.createElement(j,{marginLeft:2},N9.default.createElement(z,{dimColor:!0},yA.description)),YA&&N9.default.createElement(j,{marginLeft:2},N9.default.createElement(z,{color:"error",bold:!0},X1.warning," ",YA)))))};if(TOA(yA)){let G1=yA.enum.map((YA,CA)=>({label:yA.enumNames?.[CA]??YA,value:YA}));if(GA&&F===SA)return N9.default.createElement(j,{key:SA,flexDirection:"column"},N9.default.createElement(z,{color:"success"},yA.title||SA,ZA&&N9.default.createElement(z,{color:"error"},"*"),yA.description&&N9.default.createElement(z,{dimColor:!0}," - ",yA.description)),N9.default.createElement(S0,{options:G1,defaultValue:zA!==void 0?zA:yA.default??yA.enum[0],onChange:(YA)=>{x(SA,YA),C(void 0),h("down")},onCancel:()=>{C(void 0)}}));else{let YA=yA.enum.findIndex((MA)=>MA===zA),CA=zA!==void 0?YA>=0&&yA.enumNames?.[YA]?yA.enumNames[YA]:zA:N9.default.createElement(B91,null);return TA(N9.default.createElement(z,{color:GA?"success":void 0},yA.title||SA,ZA&&N9.default.createElement(z,{color:"error"},"*"),": ",CA,bA))}}else if(yA.type==="boolean")return TA(N9.default.createElement(z,{color:GA?"success":void 0},yA.title||SA,ZA&&N9.default.createElement(z,{color:"error"},"*"),":"," ",zA!==void 0?zA?`${X1.tick} Yes`:`${X1.cross} No`:N9.default.createElement(B91,null),bA));else if(y){let G1=K[SA],YA=o32(yA);if(GA&&F===SA)return TA(N9.default.createElement(j,{flexDirection:"column"},N9.default.createElement(z,{color:"success"},yA.title||SA,ZA&&N9.default.createElement(z,{color:"error"},"*"),":",YA&&N9.default.createElement(z,{dimColor:!0},` ${YA}`)),N9.default.createElement(j,{marginLeft:2},N9.default.createElement(K6,{value:U,onChange:O,onSubmit:t,onExit:p,placeholder:`Enter ${yA.type}‚Ä¶`,columns:Math.min(_-6,80),cursorOffset:q,onChangeCursorOffset:M,focus:!0,showCursor:!0,multiline:yA.type==="string"}))));return TA(N9.default.createElement(z,{color:GA?"success":void 0},yA.title||SA,ZA&&N9.default.createElement(z,{color:"error"},"*"),":"," ",zA===void 0?N9.default.createElement(B91,null):String(zA),bA),G1)}else return TA(N9.default.createElement(z,{color:GA?"success":void 0},yA.title||SA,ZA&&N9.default.createElement(z,{color:"error"},"*"),":"," ",zA===void 0?N9.default.createElement(B91,null):String(zA),bA))}))},e=(OA)=>{return Y.properties[OA]?.title??OA},AA=Object.keys(K),VA=(Y.required||[]).filter((OA)=>X[OA]===void 0);return N9.default.createElement(j,{flexDirection:"column",gap:1,padding:1,borderStyle:"round",borderColor:"permission"},N9.default.createElement(z,{bold:!0},X1.info," MCP Server ‚Äú",A,"‚Äù requests your input"),N9.default.createElement(j,{padding:1},N9.default.createElement(z,null,Z)),c(),E.length>0&&N9.default.createElement(N9.default.Fragment,null,VA.length>0&&N9.default.createElement(z,{color:"error"},X1.warning," Missing required fields:"," ",VA.map(e).join(", ")),AA.length>0&&N9.default.createElement(z,{color:"error"},X1.warning," Validation errors in:"," ",AA.map(e).join(", ")),N9.default.createElement(z,{bold:!0,color:J==="accept"?"success":void 0,inverse:J==="accept"},"Accept"),N9.default.createElement(z,{bold:!0,color:J==="decline"?"error":void 0,inverse:J==="decline"},"Decline"),N9.default.createElement(z,{dimColor:!0},"Press ‚Üë‚Üì to navigate ¬∑ Enter to edit ¬∑ Esc to cancel / go back")))}var N9,s32=(A)=>["string","number","integer"].includes(A.type);var e32=L(()=>{fA();g2();c9();kB1();Z8();r32();nY();y6();N9=o(WA(),1)});function xJA(A){let[Q,B]=G91.useState(!1);return G91.useEffect(()=>{B(!1);let G=setTimeout(()=>{B(!0)},A);return()=>clearTimeout(G)},[A]),Q}var G91;var Z91=L(()=>{G91=o(WA(),1)});import{homedir as Y91}from"os";import{join as J91}from"path";function I91(){return process.env.XDG_STATE_HOME??J91(Y91(),".local","state")}function A82(){return process.env.XDG_CACHE_HOME??J91(Y91(),".cache")}function Q82(){return process.env.XDG_DATA_HOME??J91(Y91(),".local","share")}function B82(){return J91(Y91(),".local","bin")}var _90=()=>{};import{homedir as X91}from"os";import{join as T90}from"path";function Pi(){let A=process.env.ZDOTDIR||X91();return{zsh:T90(A,".zshrc"),bash:T90(X91(),".bashrc"),fish:T90(X91(),".config/fish/config.fish")}}function W91(A){let Q=!1;return{filtered:A.filter((G)=>{if(G82.test(G)){let Z=G.match(/alias\s+claude\s*=\s*["']([^"']+)["']/);if(!Z)Z=G.match(/alias\s+claude\s*=\s*([^#\n]+)/);if(Z&&Z[1]){if(Z[1].trim()===nCQ)return Q=!0,!1}}return!0}),hadAlias:Q}}function jOA(A){let Q=jA();try{if(!Q.existsSync(A))return null;return Q.readFileSync(A,{encoding:"utf8"}).split(`
2666:`);if(B(F)){let U=new Set(V.map((O)=>O.id));Z((O)=>({...O,inbox:{messages:O.inbox.messages.filter((q)=>!U.has(q.id))}}))}else f("[InboxPoller] Submission rejected, keeping messages queued")},[A,Q,B,Z,G,I]);let X=!!A81(G);aG(J,X?x55:null),P0A.useEffect(()=>{if(A81(G))J()},[J,G])}var P0A,x55=1000;var Pq2=L(()=>{UE();Zh();Y0();u2();AMA();vB1();P0A=o(WA(),1)});function xq2({autoConnectIdeFlag:A,ideToInstallExtension:Q,setDynamicMcpConfig:B,setShowIdeOnboarding:G,setIDEInstallationState:Z}){Sq2.useEffect(()=>{function Y(J){if(!J)return;if(!((d1().autoConnectIde||A||ZW()||Q||z0(process.env.CLAUDE_CODE_AUTO_CONNECT_IDE))&&!rC(process.env.CLAUDE_CODE_AUTO_CONNECT_IDE)))return;B((W)=>{if(W?.ide)return W;return{...W,ide:{type:J.url.startsWith("ws:")?"ws-ide":"sse-ide",url:J.url,ideName:J.name,authToken:J.authToken,ideRunningInWindows:J.ideRunningInWindows,scope:"dynamic"}}})}CDB(Y,Q,()=>G(!0),(J)=>Z(J))},[A,Q,B,G,Z])}var Sq2;var yq2=L(()=>{xQ();PJ();rQ();Sq2=o(WA(),1)});var h_A=L(()=>{I6();pB();XQ();AX();Y0();xQ()});var I70;var vq2=L(()=>{fA();Z8();h_A();SG();wy();I6();T0();Kx();I70=o(WA(),1)});var AYZ;var kq2=L(()=>{vq2();iY();AYZ=o(WA(),1)});function k55(){return pr(v55)??"Goodbye!"}var y55,v55,f55,Q81;var X70=L(()=>{luA();iY();h_A();kq2();y55=o(WA(),1),v55=["Goodbye!","See ya!","Bye!","Catch you later!"];f55={type:"local-jsx",name:"exit",aliases:["quit"],description:"Exit the REPL",isEnabled:()=>!0,isHidden:!1,async call(A){return A(k55()),await W3(0,"prompt_input_exit"),null},userFacingName(){return"exit"}},Q81=f55});function fq2(){let[A,Q]=kT.useState(dD.getInstance().getStatus());if(kT.useEffect(()=>{return dD.getInstance().subscribe(Q)},[]),!A.isAuthenticating&&!A.error&&A.output.length===0)return null;if(!A.isAuthenticating&&!A.error)return null;return kT.default.createElement(j,{flexDirection:"column",borderStyle:"round",borderColor:"permission",paddingX:1,marginY:1},kT.default.createElement(z,{bold:!0,color:"permission"},"AWS Authentication"),A.output.length>0&&kT.default.createElement(j,{flexDirection:"column",marginTop:1},A.output.slice(-5).map((B,G)=>kT.default.createElement(z,{key:G,dimColor:!0},B))),A.error&&kT.default.createElement(j,{marginTop:1},kT.default.createElement(z,{color:"error"},A.error)))}var kT;var bq2=L(()=>{fA();kT=o(WA(),1)});import{randomUUID as hq2}from"crypto";function B81({hideThanksAfterMs:A,onOpen:Q,onSelect:B}){let[G,Z]=Yn.useState("closed"),Y=Yn.useRef(hq2()),J=Yn.useCallback(()=>{Z("thanks"),setTimeout(()=>Z("closed"),A)},[A]),I=Yn.useCallback(()=>{if(G!=="closed")return;Z("open"),Y.current=hq2(),Q(Y.current)},[G,Q]),X=Yn.useCallback((W)=>{if(W==="dismissed")Z("closed");else J();B(Y.current,W)},[J,B]);return{state:G,open:I,handleSelect:X}}var Yn;var W70=L(()=>{Yn=o(WA(),1)});function gq2(A,Q,B,G="session"){let Z=nU.useRef("unknown");Z.current=cIA(A)?.message?.id||"unknown";let[Y,J]=yQ(),I=y01("tengu_feedback_survey_config",b55),X=nU.useRef(Date.now()),W=nU.useRef(B),K=nU.useRef(B);K.current=B;let V=nU.useCallback((M,_)=>{J((T)=>({...T,feedbackSurvey:{timeLastShown:M,submitCountAtLastAppearance:_}}))},[J]),E=nU.useCallback((M)=>{V(Date.now(),K.current),r("tengu_feedback_survey_event",{event_type:"appeared",appearance_id:M,last_assistant_message_id:Z.current,survey_type:G})},[V,G]),D=nU.useCallback((M,_)=>{V(Date.now(),K.current),r("tengu_feedback_survey_event",{event_type:"responded",appearance_id:M,response:_,last_assistant_message_id:Z.current,survey_type:G})},[V,G]),{state:H,open:F,handleSelect:C}=B81({hideThanksAfterMs:I.hideThanksAfterMs,onOpen:E,onSelect:D}),U=g8(),O=nU.useMemo(()=>{if(I.onForModels.length===0)return!1;if(I.onForModels.includes("*"))return!0;return I.onForModels.includes(U)},[I.onForModels,U]),q=nU.useMemo(()=>{if(H!=="closed")return!1;if(Q)return!1;if(process.env.CLAUDE_FORCE_DISPLAY_SURVEY&&!Y.feedbackSurvey.timeLastShown)return!0;if(!O)return!1;if(z0(process.env.CLAUDE_CODE_DISABLE_FEEDBACK_SURVEY))return!1;if(aX())return!1;if(Y.feedbackSurvey.timeLastShown){if(Y.feedbackSurvey.submitCountAtLastAppearance!==null&&B<Y.feedbackSurvey.submitCountAtLastAppearance+I.minUserTurnsBetweenFeedback)return!1}else{if(Date.now()-X.current<I.minTimeBeforeFeedbackMs)return!1;if(B<W.current+I.minUserTurnsBeforeFeedback)return!1}if(Math.random()>I.probability)return!1;let M=d1().feedbackSurveyState;if(M?.lastShownTime){if(Date.now()-M.lastShownTime<I.minTimeBetweenGlobalFeedbackMs)return!1}return!0},[H,Q,O,Y.feedbackSurvey.timeLastShown,Y.feedbackSurvey.submitCountAtLastAppearance,B,I.minTimeBetweenGlobalFeedbackMs,I.minUserTurnsBetweenFeedback,I.minTimeBeforeFeedbackMs,I.minUserTurnsBeforeFeedback,I.probability]);return nU.useEffect(()=>{if(q)F()},[q,F]),{state:H,handleSelect:C}}var nU,b55;var uq2=L(()=>{J4();T0();Mr();xQ();l2();rQ();u2();HB();W70();nU=o(WA(),1),b55={minTimeBeforeFeedbackMs:600000,minTimeBetweenGlobalFeedbackMs:1e8,minUserTurnsBeforeFeedback:5,minUserTurnsBetweenFeedback:10,hideThanksAfterMs:3000,onForModels:["*"],probability:0.005}});function m55(A,Q){let B=A.findIndex((G)=>G.uuid===Q);if(B===-1)return!1;for(let G=B+1;G<A.length;G++){let Z=A[G];if(Z&&(Z.type==="user"||Z.type==="assistant"))return!0}return!1}function mq2(A,Q){let[B,G]=VN.useState(null),Z=VN.useRef(new Set),Y=VN.useRef(null),J=VN.useCallback(async(E)=>{let D=await LQ1();r("tengu_post_compact_survey_event",{event_type:"appeared",appearance_id:E,session_memory_compaction_enabled:D})},[]),I=VN.useCallback(async(E,D)=>{let H=await LQ1();r("tengu_post_compact_survey_event",{event_type:"responded",appearance_id:E,response:D,session_memory_compaction_enabled:H})},[]),{state:X,open:W,handleSelect:K}=B81({hideThanksAfterMs:h55,onOpen:J,onSelect:I});VN.useEffect(()=>{JZ(g55).then(G)},[]);let V=VN.useMemo(()=>new Set(A.filter((E)=>Nb(E)).map((E)=>E.uuid)),[A]);return VN.useEffect(()=>{if(X!=="closed"||Q)return;if(B!==!0)return;if(aX())return;if(z0(process.env.CLAUDE_CODE_DISABLE_FEEDBACK_SURVEY))return;if(Y.current!==null){if(m55(A,Y.current)){if(Y.current=null,Math.random()<u55)W();return}}let E=Array.from(V).filter((D)=>!Z.current.has(D));if(E.length>0)Z.current=new Set(V),Y.current=E[E.length-1]},[V,X,Q,B,A,W]),{state:X,handleSelect:K}}var VN,h55=3000,g55="tengu_post_compact_survey",u55=0.2;var dq2=L(()=>{J4();T0();Mr();rQ();HB();W70();OQ1();VN=o(WA(),1)});function cq2({onSelect:A,inputValue:Q,setInputValue:B,message:G=p55}){let Z=fV.useRef(Q);return fV.useEffect(()=>{if(Q!==Z.current){let Y=Q.slice(-1);if(K70(Y))B(Q.slice(0,-1)),A(c55[Y])}},[Q,A,B]),fV.default.createElement(j,{flexDirection:"column",marginTop:1},fV.default.createElement(j,null,fV.default.createElement(z,null,cA.cyan("‚óè ")),fV.default.createElement(z,{bold:!0},G)),fV.default.createElement(j,{marginLeft:2},fV.default.createElement(j,{width:10},fV.default.createElement(z,null,cA.cyan("1"),": Bad")),fV.default.createElement(j,{width:10},fV.default.createElement(z,null,cA.cyan("2"),": Fine")),fV.default.createElement(j,{width:10},fV.default.createElement(z,null,cA.cyan("3"),": Good")),fV.default.createElement(j,null,fV.default.createElement(z,null,cA.cyan("0"),": Dismiss"))))}var fV,d55,c55,K70=(A)=>d55.includes(A),p55="How is Claude doing this session? (optional)";var pq2=L(()=>{t2();fA();fV=o(WA(),1),d55=["0","1","2","3"],c55={"0":"dismissed","1":"bad","2":"fine","3":"good"}});function V70({state:A,handleSelect:Q,inputValue:B,setInputValue:G,message:Z}){if(A==="closed")return null;if(A==="thanks")return g_A.default.createElement(j,{marginTop:1,flexDirection:"column"},g_A.default.createElement(z,{color:"success"},"‚úì Thanks for helping make Claude better!"),g_A.default.createElement(z,{dimColor:!0},"Use ","/feedback"," to share detailed feedback or file a bug."));if(B&&!K70(B))return null;return g_A.default.createElement(cq2,{onSelect:Q,inputValue:B,setInputValue:G,message:Z})}var g_A;var lq2=L(()=>{fA();pq2();g_A=o(WA(),1)});function nq2(){let{addNotification:A}=xG();iq2.useEffect(()=>{Qy().then((Q)=>{Q.forEach((B,G)=>{let Z="low";if(B.type==="error"||B.userActionRequired)Z="high";else if(B.type==="path"||B.type==="alias")Z="medium";A({key:`install-message-${G}-${B.type}`,text:B.message,priority:Z,color:B.type==="error"?"error":"warning"})})})},[A])}var iq2;var aq2=L(()=>{UC();By();iq2=o(WA(),1)});var E70=()=>{};var oq2,G81;var D70=L(()=>{Hc1();JV();oq2=o(ErA(),1);G81=class G81 extends zwA{constructor(A,Q){var B;super(Q);this._serverInfo=A,this._capabilities=(B=Q===null||Q===void 0?void 0:Q.capabilities)!==null&&B!==void 0?B:{},this._instructions=Q===null||Q===void 0?void 0:Q.instructions,this.setRequestHandler(Qc1,(G)=>this._oninitialize(G)),this.setNotificationHandler(uoA,()=>{var G;return(G=this.oninitialized)===null||G===void 0?void 0:G.call(this)})}registerCapabilities(A){if(this.transport)throw Error("Cannot register capabilities after connecting to transport");this._capabilities=noA(this._capabilities,A)}assertCapabilityForMethod(A){var Q,B,G;switch(A){case"sampling/createMessage":if(!((Q=this._clientCapabilities)===null||Q===void 0?void 0:Q.sampling))throw Error(`Client does not support sampling (required for ${A})`);break;case"elicitation/create":if(!((B=this._clientCapabilities)===null||B===void 0?void 0:B.elicitation))throw Error(`Client does not support elicitation (required for ${A})`);break;case"roots/list":if(!((G=this._clientCapabilities)===null||G===void 0?void 0:G.roots))throw Error(`Client does not support listing roots (required for ${A})`);break;case"ping":break}}assertNotificationCapability(A){switch(A){case"notifications/message":if(!this._capabilities.logging)throw Error(`Server does not support logging (required for ${A})`);break;case"notifications/resources/updated":case"notifications/resources/list_changed":if(!this._capabilities.resources)throw Error(`Server does not support notifying about resources (required for ${A})`);break;case"notifications/tools/list_changed":if(!this._capabilities.tools)throw Error(`Server does not support notifying of tool list changes (required for ${A})`);break;case"notifications/prompts/list_changed":if(!this._capabilities.prompts)throw Error(`Server does not support notifying of prompt list changes (required for ${A})`);break;case"notifications/cancelled":break;case"notifications/progress":break}}assertRequestHandlerCapability(A){switch(A){case"sampling/createMessage":if(!this._capabilities.sampling)throw Error(`Server does not support sampling (required for ${A})`);break;case"logging/setLevel":if(!this._capabilities.logging)throw Error(`Server does not support logging (required for ${A})`);break;case"prompts/get":case"prompts/list":if(!this._capabilities.prompts)throw Error(`Server does not support prompts (required for ${A})`);break;case"resources/list":case"resources/templates/list":case"resources/read":if(!this._capabilities.resources)throw Error(`Server does not support resources (required for ${A})`);break;case"tools/call":case"tools/list":if(!this._capabilities.tools)throw Error(`Server does not support tools (required for ${A})`);break;case"ping":case"initialize":break}}async _oninitialize(A){let Q=A.params.protocolVersion;return this._clientCapabilities=A.params.capabilities,this._clientVersion=A.params.clientInfo,{protocolVersion:koA.includes(Q)?Q:Dp,capabilities:this.getCapabilities(),serverInfo:this._serverInfo,...this._instructions&&{instructions:this._instructions}}}getClientCapabilities(){return this._clientCapabilities}getClientVersion(){return this._clientVersion}getCapabilities(){return this._capabilities}async ping(){return this.request({method:"ping"},Ab)}async createMessage(A,Q){return this.request({method:"sampling/createMessage",params:A},Wc1,Q)}async elicitInput(A,Q){let B=await this.request({method:"elicitation/create",params:A},Kc1,Q);if(B.action==="accept"&&B.content)try{let G=new oq2.default,Z=G.compile(A.requestedSchema);if(!Z(B.content))throw new lF(pF.InvalidParams,`Elicitation response content does not match requested schema: ${G.errorsText(Z.errors)}`)}catch(G){if(G instanceof lF)throw G;throw new lF(pF.InternalError,`Error validating elicitation response: ${G}`)}return B}async listRoots(A,Q){return this.request({method:"roots/list",params:A},Dc1,Q)}async sendLoggingMessage(A){return this.notification({method:"notifications/message",params:A})}async sendResourceUpdated(A){return this.notification({method:"notifications/resources/updated",params:A})}async sendResourceListChanged(){return this.notification({method:"notifications/resources/list_changed"})}async sendToolListChanged(){return this.notification({method:"notifications/tools/list_changed"})}async sendPromptListChanged(){return this.notification({method:"notifications/prompts/list_changed"})}}});import{promises as l55}from"fs";import{platform as rq2,tmpdir as i55,userInfo as n55}from"os";import{join as a55}from"path";import{createConnection as o55}from"net";class r55{socket=null;connected=!1;connecting=!1;responseCallback=null;responseBuffer=Buffer.alloc(0);reconnectAttempts=0;maxReconnectAttempts=10;reconnectDelay=1000;reconnectTimer=null;context;constructor(A){this.context=A}async connect(){let{serverName:A,logger:Q}=this.context;if(this.connecting){Q.info(`[${A}] Already connecting, skipping duplicate attempt`);return}this.closeSocket(),this.connecting=!0;let B=this.getSecureSocketPath();Q.info(`[${A}] Attempting to connect to: ${B}`);try{await this.validateSocketSecurity(B)}catch(G){this.connecting=!1,Q.info(`[${A}] Security validation failed:`,G);return}this.socket=o55(B),this.socket.on("connect",()=>{this.connected=!0,this.connecting=!1,this.reconnectAttempts=0,Q.info(`[${A}] Successfully connected to bridge server`)}),this.socket.on("data",(G)=>{this.responseBuffer=Buffer.concat([this.responseBuffer,G]);while(this.responseBuffer.length>=4){let Z=this.responseBuffer.readUInt32LE(0);if(this.responseBuffer.length<4+Z)break;let Y=this.responseBuffer.slice(4,4+Z);this.responseBuffer=this.responseBuffer.slice(4+Z);try{let J=JSON.parse(Y.toString("utf-8"));this.handleResponse(J)}catch(J){Q.info(`[${A}] Failed to parse response:`,J)}}}),this.socket.on("error",(G)=>{if(Q.info(`[${A}] Socket error:`,G),this.connected=!1,this.connecting=!1,G.code&&["ECONNREFUSED","ECONNRESET","EPIPE"].includes(G.code))this.scheduleReconnect()}),this.socket.on("close",()=>{this.connected=!1,this.connecting=!1,this.scheduleReconnect()})}scheduleReconnect(){let{serverName:A,logger:Q}=this.context;if(this.reconnectTimer){Q.info(`[${A}] Reconnect already scheduled, skipping`);return}if(this.reconnectAttempts>=this.maxReconnectAttempts){Q.info(`[${A}] Max reconnection attempts reached`),this.cleanup();return}this.reconnectAttempts++;let B=Math.min(this.reconnectDelay*Math.pow(1.5,this.reconnectAttempts-1),30000);Q.info(`[${A}] Reconnecting in ${Math.round(B)}ms (attempt ${this.reconnectAttempts})`),this.reconnectTimer=setTimeout(()=>{this.reconnectTimer=null,this.connect()},B)}handleResponse(A){if(this.responseCallback){let Q=this.responseCallback;this.responseCallback=null,Q(A)}}async ensureConnected(){let{serverName:A}=this.context;if(this.connected&&this.socket)return!0;if(!this.socket&&!this.connecting)await this.connect();return new Promise((Q,B)=>{let G=setTimeout(()=>{B(new Z81(`[${A}] Connection attempt timed out after 5000ms`))},5000),Z=()=>{if(this.connected)clearTimeout(G),Q(!0);else setTimeout(Z,100)};Z()})}async sendRequest(A,Q=30000){let{serverName:B}=this.context;if(!this.socket)throw new Z81(`[${B}] Cannot send request: not connected`);let G=this.socket;return new Promise((Z,Y)=>{let J=setTimeout(()=>{this.responseCallback=null,Y(Error(`[${B}] Tool request timed out after ${Q}ms`))},Q);this.responseCallback=(V)=>{clearTimeout(J),Z(V)};let I=JSON.stringify(A),X=Buffer.from(I,"utf-8"),W=Buffer.allocUnsafe(4);W.writeUInt32LE(X.length,0);let K=Buffer.concat([W,X]);G.write(K)})}async callTool(A,Q){let B={method:"execute_tool",params:{client_id:"desktop",tool:A,args:Q}};return await this.sendRequest(B)}isConnected(){return this.connected}closeSocket(){if(this.socket)this.socket.removeAllListeners(),this.socket.end(),this.socket.destroy(),this.socket=null;this.connected=!1,this.connecting=!1}cleanup(){if(this.reconnectTimer)clearTimeout(this.reconnectTimer),this.reconnectTimer=null;this.closeSocket(),this.reconnectAttempts=0,this.responseBuffer=Buffer.alloc(0),this.responseCallback=null}disconnect(){this.cleanup()}getSecureSocketPath(){let A=n55().username||"default";if(rq2()==="win32")return`\\\\.\\pipe\\claude-mcp-browser-bridge-${A}`;else return a55(i55(),`claude-mcp-browser-bridge-${A}`)}async validateSocketSecurity(A){let{serverName:Q,logger:B}=this.context;if(rq2()==="win32")return;try{let G=await l55.stat(A);if(!G.isSocket())throw Error(`[${Q}] Path exists but it's not a socket: ${A}`);let Z=G.mode&511;if(Z!==384)throw Error(`[${Q}] Insecure socket permissions: ${Z.toString(8)} (expected 0600). Socket may have been tampered with. `);let Y=process.getuid?.();if(Y!==void 0&&G.uid!==Y)throw Error(`Socket not owned by current user (uid: ${Y}, socket uid: ${G.uid}). Potential security risk.`);B.info(`[${Q}] Socket security validation passed`)}catch(G){if(G.code==="ENOENT"){B.info(`[${Q}] Socket not found, will be created by server`);return}throw G}}}var Z81;var H70=L(()=>{Z81=class Z81 extends Error{constructor(A){super(A);this.name="SocketConnectionError"}}});var sq2=L(()=>{H70()});var tq2=L(()=>{D70();JV();E70();H70();sq2()});var Y81=L(()=>{E70();tq2()});import{chmod as FJZ,mkdir as CJZ,readFile as zJZ,writeFile as UJZ,readdir as t55,access as eq2}from"fs/promises";import{homedir as e55}from"os";import{join as u_A}from"path";function J81(A){return!1}async function QL2(){return!1}function A75(){let A=dQ(),Q=e55();switch(A){case"macos":return u_A(Q,"Library","Application Support","Google","Chrome");case"windows":{let B=u_A(Q,"AppData","Local");return u_A(B,"Google","Chrome","User Data")}case"linux":return u_A(Q,".config","google-chrome");default:return null}}var AL2="com.anthropic.claude_code_browser_extension",TJZ,jJZ;var I81=L(()=>{k3();Y0();I6();rQ();Y81();r7A();TJZ=`${AL2}.json`,jJZ=`HKCU\\Software\\Google\\Chrome\\NativeMessagingHosts\\${AL2}`});function Q75(){if(process.argv.includes("--chrome"))return!0;if(process.argv.includes("--no-chrome"))return!1;return}function BL2(){let{addNotification:A}=xG();cM.useEffect(()=>{return},[A])}var cM;var GL2=L(()=>{fA();I81();UC();h1();F2();cM=o(WA(),1)});function ZL2(){return d1().tipsHistory||{}}function B75(A){i0((Q)=>{if(Q.tipsHistory===A)return Q;return{...Q,tipsHistory:A}})}function YL2(A){let Q=ZL2(),B=d1().numStartups;Q[A]=B,B75(Q)}function G75(A){return ZL2()[A]||0}function X81(A){let Q=G75(A);if(Q===0)return 1/0;return d1().numStartups-Q}var C70=L(()=>{xQ()});function W81(A){if(A.includes("@")){let Q=A.split("@");return{name:Q[0]||"",marketplace:Q[1]}}return{name:A}}function Ty(A){if(A==="managed")throw Error("Cannot install plugins to managed scope");return Y75[A]}function IL2(A){return JL2[A]}var JL2,Y75;var pIA=L(()=>{JL2={policySettings:"managed",userSettings:"user",projectSettings:"project",localSettings:"local",flagSettings:"flag"};Y75={user:"userSettings",project:"projectSettings",local:"localSettings"}});import{dirname as uJZ,join as Jn}from"path";function m_A(){return Jn(mQ(),"plugins","installed_plugins.json")}function J75(){return Jn(mQ(),"plugins","installed_plugins_v2.json")}function I75(){if(z70)return;let A=jA(),Q=m_A(),B=J75();try{let G=A.existsSync(B),Z=A.existsSync(Q);if(G){A.renameSync(B,Q),f("Renamed installed_plugins_v2.json to installed_plugins.json");let Y=pM();XL2(Y)}else if(Z){let Y=A.readFileSync(Q,{encoding:"utf-8"}),J=JSON.parse(Y);if((typeof J?.version==="number"?J.version:1)===1){let X=fwA.parse(J),W=w70(X);A.writeFileSync(Q,JSON.stringify(W,null,2),{encoding:"utf-8",flush:!0}),f(`Converted installed_plugins.json from V1 to V2 format (${Object.keys(X.plugins).length} plugins)`),XL2(W)}}z70=!0}catch(G){let Z=G instanceof Error?G.message:String(G);f(`Failed to migrate plugin files: ${Z}`,{level:"error"}),s(G instanceof Error?G:Error(`Failed to migrate plugin files: ${Z}`)),z70=!0}}function XL2(A){let Q=jA(),B=o7A();if(!Q.existsSync(B))return;try{let G=new Set;for(let Y of Object.values(A.plugins))for(let J of Y)G.add(J.installPath);let Z=Q.readdirSync(B);for(let Y of Z){if(!Y.isDirectory())continue;let J=Y.name,I=Jn(B,J);if(Q.readdirSync(I).some((K)=>{if(!K.isDirectory())return!1;let V=Jn(I,K.name);return Q.readdirSync(V).some((D)=>D.isDirectory())}))continue;if(!G.has(I))Q.rmSync(I,{recursive:!0,force:!0}),f(`Cleaned up legacy cache directory: ${J}`)}}catch(G){let Z=G instanceof Error?G.message:String(G);f(`Failed to clean up legacy cache: ${Z}`,{level:"warn"})}}function $70(){let A=jA(),Q=m_A();if(!A.existsSync(Q))return null;let B=A.readFileSync(Q,{encoding:"utf-8"}),G=JSON.parse(B);return{version:typeof G?.version==="number"?G.version:1,data:G}}function w70(A){let Q={};for(let[B,G]of Object.entries(A.plugins)){let Z=hS(B,G.version);Q[B]=[{scope:"user",installPath:Z,version:G.version,installedAt:G.installedAt,lastUpdated:G.lastUpdated,gitCommitSha:G.gitCommitSha,isLocal:G.isLocal}]}return{version:2,plugins:Q}}function pM(){if(jy!==null)return jy;let A=m_A();try{let Q=$70();if(Q){if(Q.version===2){let Z=bwA.parse(Q.data);return jy=Z,f(`Loaded ${Object.keys(Z.plugins).length} installed plugins from ${A}`),Z}let B=fwA.parse(Q.data),G=w70(B);return jy=G,f(`Loaded and converted ${Object.keys(B.plugins).length} plugins from V1 format`),G}return f("installed_plugins.json doesn't exist, returning empty V2 object"),jy={version:2,plugins:{}},jy}catch(Q){let B=Q instanceof Error?Q.message:String(Q);return f(`Failed to load installed_plugins.json: ${B}. Starting with empty state.`,{level:"error"}),s(Q instanceof Error?Q:Error(`Failed to load installed_plugins.json: ${B}`)),jy={version:2,plugins:{}},jy}}function N70(A){let Q=jA(),B=m_A();try{let G=Jn(mQ(),"plugins");if(!Q.existsSync(G))Q.mkdirSync(G);let Z=JSON.stringify(A,null,2);Q.writeFileSync(B,Z,{encoding:"utf-8",flush:!0}),jy=A,f(`Saved ${Object.keys(A.plugins).length} installed plugins to ${B}`)}catch(G){let Z=G instanceof Error?G.message:String(G);throw s(G instanceof Error?G:Error(`Failed to save installed_plugins.json: ${Z}`)),G}}function KL2(A,Q,B){let G=pM(),Z=G.plugins[A];if(!Z)return;if(G.plugins[A]=Z.filter((Y)=>!(Y.scope===Q&&Y.projectPath===B)),G.plugins[A].length===0)delete G.plugins[A];N70(G),f(`Removed installation for ${A} at scope ${Q}`)}function q70(){if(U70===null)U70=pM();return U70}function V81(){try{let A=$70();if(A){if(A.version===2)return bwA.parse(A.data);let Q=fwA.parse(A.data);return w70(Q)}return{version:2,plugins:{}}}catch(A){let Q=A instanceof Error?A.message:String(A);return f(`Failed to load installed plugins from disk: ${Q}`,{level:"error"}),{version:2,plugins:{}}}}function VL2(A,Q,B,G,Z){let Y=V81(),J=Y.plugins[A];if(!J){f(`Cannot update ${A} on disk: plugin not found in installed plugins`);return}let I=J.find((X)=>X.scope===Q&&X.projectPath===B);if(I){I.installPath=G,I.version=Z,I.lastUpdated=new Date().toISOString();let X=jA(),W=m_A();X.writeFileSync(W,JSON.stringify(Y,null,2),{encoding:"utf-8",flush:!0}),jy=null,f(`Updated ${A} on disk to version ${Z} at ${G}`)}else f(`Cannot update ${A} on disk: no installation for scope ${Q}`)}async function EL2(){I75();try{await M70()}catch(Q){s(Q instanceof Error?Q:Error(String(Q)))}let A=q70();f(`Initialized versioned plugins system with ${Object.keys(A.plugins).length} plugins`)}function X75(A){let B=pM().plugins[A];if(!B||B.length===0)return;let G=B[0];if(!G)return;return{version:G.version||"unknown",installedAt:G.installedAt||new Date().toISOString(),lastUpdated:G.lastUpdated,installPath:G.installPath,gitCommitSha:G.gitCommitSha,isLocal:G.isLocal}}function aU(A){return X75(A)!==void 0}function L70(A,Q,B="user",G){let Z=pM(),Y={scope:B,installPath:Q.installPath,version:Q.version,installedAt:Q.installedAt,lastUpdated:Q.lastUpdated,gitCommitSha:Q.gitCommitSha,isLocal:Q.isLocal,...G&&{projectPath:G}},J=Z.plugins[A]||[],I=J.findIndex((W)=>W.scope===B&&W.projectPath===G),X=I>=0;if(X)J[I]=Y;else J.push(Y);Z.plugins[A]=J,N70(Z),f(`${X?"Updated":"Added"} installed plugin: ${A} (scope: ${B})`)}async function K81(A){try{let Q=await CQ("git",["-C",A,"rev-parse","HEAD"]);if(Q.code===0&&Q.stdout)return Q.stdout.trim();return}catch(Q){f(`Failed to get git commit SHA from ${A}: ${Q}`);return}}function WL2(A,Q){let B=jA(),G=Jn(A,".claude-plugin","plugin.json");if(!B.existsSync(G))return"unknown";try{let Z=B.readFileSync(G,{encoding:"utf-8"});return JSON.parse(Z).version||"unknown"}catch{return f(`Could not read version from manifest for ${Q}`),"unknown"}}async function M70(){let Q=NQ().enabledPlugins||{};if(Object.keys(Q).length===0)return;let B=$70(),G=B!==null;if(G&&B?.version===2&&B){let D=bwA.safeParse(B.data);if(D?.success){let H=D.data.plugins;if(Object.keys(Q).filter((C)=>C.includes("@")).every((C)=>{let U=H[C];return U&&U.length>0})){f("All plugins already exist, skipping migration");return}}}f(G?"Syncing installed_plugins.json with enabledPlugins from all settings.json files":"Creating installed_plugins.json from settings.json files");let Y=jA(),J=new Date().toISOString(),I=r1(),X=new Map,W=["userSettings","projectSettings","localSettings"];for(let D of W){let F=uB(D)?.enabledPlugins||{};for(let C of Object.keys(F)){if(!C.includes("@"))continue;let U=IL2(D);X.set(C,{scope:U,projectPath:U==="user"?void 0:I})}}let K={};if(G)K={...pM().plugins};let V=0,E=0;for(let[D,H]of X){let F=K[D];if(F&&F.length>0){let C=F[0];if(C&&(C.scope!==H.scope||C.projectPath!==H.projectPath)){if(C.scope=H.scope,H.projectPath)C.projectPath=H.projectPath;else delete C.projectPath;C.lastUpdated=J,V++,f(`Updated ${D} scope to ${H.scope} (settings.json is source of truth)`)}}else{let C=D.split("@"),U=C[0];if(!U||C.length!==2)continue;try{let O=await JH(D);if(!O){f(`Plugin ${D} not found in any marketplace, skipping`);continue}let{entry:q,marketplaceInstallLocation:M}=O,_,T="unknown",y=void 0,h=!1;if(typeof q.source==="string")h=!0,_=Jn(M,q.source),T=WL2(_,D),y=await K81(_);else{let x=o7A(),m=U.replace(/[^a-zA-Z0-9-_]/g,"-"),g=Jn(x,m);if(!Y.existsSync(g)){f(`External plugin ${D} not in cache, skipping`);continue}_=g,T=WL2(g,D),y=await K81(g)}if(T==="unknown"&&q.version)T=q.version;if(T==="unknown"&&y)T=y.substring(0,12);K[D]=[{scope:H.scope,installPath:hS(D,T),version:T,installedAt:J,lastUpdated:J,gitCommitSha:y,isLocal:h,...H.projectPath&&{projectPath:H.projectPath}}],E++,f(`Added ${D} with scope ${H.scope}`)}catch(O){f(`Failed to add plugin ${D}: ${O}`)}}}if(!G||V>0||E>0)N70({version:2,plugins:K}),f(`Sync completed: ${E} added, ${V} updated in installed_plugins.json`)}var z70=!1,jy=null,U70=null;var fT=L(()=>{XQ();Y0();h1();rQ();bL();jB();pIA();pB();YW();I6();aW()});async function W75(){return"claude-code-plugins"in await N5()}async function E81(A){let Q=[...K75,...V75],B=await Promise.all(Q.map((G)=>G.isRelevant(A)));return Q.filter((G,Z)=>B[Z]).filter((G)=>X81(G.id)>=G.cooldownSessions)}var K75,V75;var O70=L(()=>{t2();xQ();J4();AX();fT();aW();l2();I8A();$8();PJ();k3();ad();jB();C70();R8();JU();Y0();PFA();_w();yIA();K75=[{id:"new-user-warmup",content:async()=>"Start with small features or bug fixes, tell Claude to propose a plan, and verify its suggested edits",cooldownSessions:3,async isRelevant(){return d1().numStartups<10}},{id:"plan-mode-for-complex-tasks",content:async()=>`Use Plan Mode to prepare for a complex request before making changes. Press ${yz.displayText} twice to enable.`,cooldownSessions:5,isRelevant:async()=>{let A=d1();return(A.lastPlanModeUse?(Date.now()-A.lastPlanModeUse)/86400000:1/0)>7}},{id:"default-permission-mode-config",content:async()=>"Use /config to change your default permission mode (including Plan Mode)",cooldownSessions:10,isRelevant:async()=>{try{let A=d1(),Q=NQ(),B=Boolean(A.lastPlanModeUse),G=Boolean(Q?.permissions?.defaultMode);return B&&!G}catch(A){return f(`Failed to check default-permission-mode-config tip relevance: ${A}`,{level:"warn"}),!1}}},{id:"git-worktrees",content:async()=>"Use git worktrees to run multiple Claude sessions in parallel.",cooldownSessions:10,isRelevant:async()=>{try{let A=d1();return await iCA()<=1&&A.numStartups>50}catch(A){return!1}}},{id:"terminal-setup",content:async()=>JQ.terminal==="Apple_Terminal"?"Run /terminal-setup to enable convenient terminal integration like Option + Enter for new line and more":"Run /terminal-setup to enable convenient terminal integration like Shift + Enter for new line and more",cooldownSessions:10,async isRelevant(){let A=d1();if(JQ.terminal==="Apple_Terminal")return id.isEnabled()&&!A.optionAsMetaKeyInstalled;return id.isEnabled()&&!A.shiftEnterKeyBindingInstalled}},{id:"shift-enter",content:async()=>JQ.terminal==="Apple_Terminal"?"Press Option+Enter to send a multi-line message":"Press Shift+Enter to send a multi-line message",cooldownSessions:10,async isRelevant(){let A=d1();return Boolean((JQ.terminal==="Apple_Terminal"?A.optionAsMetaKeyInstalled:A.shiftEnterKeyBindingInstalled)&&A.numStartups>3)}},{id:"shift-enter-setup",content:async()=>JQ.terminal==="Apple_Terminal"?"Run /terminal-setup to enable Option+Enter for new lines":"Run /terminal-setup to enable Shift+Enter for new lines",cooldownSessions:10,async isRelevant(){if(!ECA())return!1;let A=d1();return!(JQ.terminal==="Apple_Terminal"?A.optionAsMetaKeyInstalled:A.shiftEnterKeyBindingInstalled)}},{id:"memory-command",content:async()=>"Use /memory to view and manage Claude memory",cooldownSessions:15,async isRelevant(){return d1().memoryUsageCount<=0}},{id:"theme-command",content:async()=>"Use /theme to change the color theme",cooldownSessions:20,isRelevant:async()=>!0},{id:"colorterm-truecolor",content:async()=>"Try setting environment variable COLORTERM=truecolor for richer colors",cooldownSessions:30,isRelevant:async()=>!process.env.COLORTERM&&cA.level<3},{id:"status-line",content:async()=>"Use /statusline to set up a custom status line that will display beneath the input box",cooldownSessions:25,isRelevant:async()=>NQ().statusLine===void 0},{id:"stickers-command",content:async()=>"Use /stickers to order Claude Code swag",cooldownSessions:20,isRelevant:async()=>!0},{id:"prompt-queue",content:async()=>"Hit Enter to queue up additional messages while Claude is working.",cooldownSessions:5,async isRelevant(){return d1().promptQueueUseCount<=3}},{id:"enter-to-steer-in-relatime",content:async()=>"Send messages to Claude while it works to steer Claude in real-time",cooldownSessions:20,isRelevant:async()=>!0},{id:"todo-list",content:async()=>"Ask Claude to create a todo list when working on complex tasks to track progress and remain on track",cooldownSessions:20,isRelevant:async()=>!0},{id:"vscode-command-install",content:async()=>`Open the Command Palette (Cmd+Shift+P) and run "Shell Command: Install '${JQ.terminal==="vscode"?"code":JQ.terminal}' command in PATH" to enable IDE integration`,cooldownSessions:0,async isRelevant(){if(!TwA())return!1;if(dQ()!=="macos")return!1;switch(JQ.terminal){case"vscode":return!HDB();case"cursor":return!EDB();case"windsurf":return!DDB();default:return!1}}},{id:"ide-upsell-external-terminal",content:async()=>"Connect Claude to your IDE ¬∑ /ide",cooldownSessions:4,async isRelevant(){if(ZW())return!1;if(urA().length!==0)return!1;return drA().length>0}},{id:"# for memory",content:async()=>"Want Claude to remember something? Hit # to add preferences, tools, and instructions to Claude's memory",cooldownSessions:10,isRelevant:async()=>d1().memoryUsageCount<=10},{id:"install-github-app",content:async()=>"Run /install-github-app to tag @claude right from your Github issues and PRs",cooldownSessions:10,isRelevant:async()=>!d1().githubActionSetupCount},{id:"install-slack-app",content:async()=>"Run /install-slack-app to use Claude in Slack",cooldownSessions:10,isRelevant:async()=>await JZ("code_slack_app_install_banner")&&!d1().slackAppInstallCount},{id:"permissions",content:async()=>"Use /permissions to pre-approve and pre-deny bash, edit, and MCP tools",cooldownSessions:10,async isRelevant(){return d1().numStartups>10}},{id:"drag-and-drop-images",content:async()=>"Did you know you can drag and drop image files into your terminal?",cooldownSessions:10,isRelevant:async()=>!0},{id:"paste-images-mac",content:async()=>"Paste images into Claude Code using control+v (not cmd+v!)",cooldownSessions:10,isRelevant:async()=>dQ()==="macos"},{id:"double-esc",content:async()=>"Double-tap esc to rewind the conversation to a previous point in time",cooldownSessions:10,isRelevant:async()=>!o7()},{id:"double-esc-code-restore",content:async()=>"Double-tap esc to rewind the code and/or conversation to a previous point in time",cooldownSessions:10,isRelevant:async()=>o7()},{id:"continue",content:async()=>"Run claude --continue or claude --resume to resume a conversation",cooldownSessions:10,isRelevant:async()=>!0},{id:"rename-conversation",content:async()=>"Name your conversations with /rename to find them easily in /resume later",cooldownSessions:15,isRelevant:async()=>$b()&&d1().numStartups>10},{id:"custom-commands",content:async()=>"Create custom slash commands by adding .md files to .claude/commands/ in your project or ~/.claude/commands/ for commands that work in any project",cooldownSessions:15,async isRelevant(){return d1().numStartups>10}},{id:"shift-tab",content:async()=>`Hit ${yz.displayText} to cycle between default mode, auto-accept edit mode, and plan mode`,cooldownSessions:10,isRelevant:async()=>!0},{id:"image-paste",content:async()=>`Use ${qs.displayText} to paste images from your clipboard`,cooldownSessions:20,isRelevant:async()=>!0},{id:"config-thinking-mode",content:async()=>"Use /config to set your default thinking mode preference",cooldownSessions:10,isRelevant:async()=>!0},{id:"ultrathink-keyword",content:async()=>"Type 'ultrathink' in your message to enable thinking for just that turn",cooldownSessions:10,isRelevant:async()=>!0},{id:"custom-agents",content:async()=>"Use /agents to optimize specific tasks. Eg. Software Architect, Code Writer, Code Reviewer",cooldownSessions:15,async isRelevant(){return d1().numStartups>5}},{id:"opusplan-mode-reminder",content:async()=>`Your default model setting is Opus Plan Mode. Press ${yz.displayText} twice to activate Plan Mode and plan with Claude Opus.`,cooldownSessions:2,async isRelevant(){let A=d1(),B=rr()==="opusplan",G=A.lastPlanModeUse?(Date.now()-A.lastPlanModeUse)/86400000:1/0;return B&&G>3}},{id:"frontend-design-plugin",content:async(A)=>{let Q=await W75(),B=vB("suggestion",A.theme);if(!Q)return`Working with HTML/CSS? Add the frontend-design plugin:
2671:     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ${Q("/passes")} to share`},cooldownSessions:3,isRelevant:async()=>{if(d1().hasVisitedPasses)return!1;let{eligible:Q}=R31();return Q}}],V75=[]});function E75(A){if(A.length===0)return;if(A.length===1)return A[0];let Q=A.map((B)=>({tip:B,sessions:X81(B.id)}));return Q.sort((B,G)=>G.sessions-B.sessions),Q[0]?.tip}async function DL2(A){if(NQ().spinnerTipsEnabled===!1)return;let Q=await E81(A);if(Q.length===0)return;return E75(Q)}function HL2(A){YL2(A.id),r("tengu_tip_shown",{tipIdLength:A.id,cooldownSessions:A.cooldownSessions})}var FL2=L(()=>{C70();T0();xQ();jB();xIA();O70()});function zL2(){let[A,Q]=yQ(),{toolPermissionContext:B}=A;CL2.useEffect(()=>{R70(B,Q)},[])}var CL2,R70;var UL2=L(()=>{o2();u2();f1A();CL2=o(WA(),1),R70=Z0(async(A,Q)=>{if(!A.isBypassPermissionsModeAvailable)return;if(!await _70())return;Q((G)=>{return{...G,toolPermissionContext:d_A(G.toolPermissionContext)}})})});function $L2(A,Q,B){let G=D81.useRef(!1);D81.useEffect(()=>{if(!o7()||G.current)return;if(G.current=!0,A)mGA(A,B)},[Q,A,B])}var D81;var wL2=L(()=>{JU();D81=o(WA(),1)});function T70({hostPattern:{host:A},onUserResponse:Q}){function B(Z){switch(Z){case"yes":Q({allow:!0,persistToSettings:!1});break;case"yes-dont-ask-again":Q({allow:!0,persistToSettings:!0});break;case"no":Q({allow:!1,persistToSettings:!1});break}}let G=[{label:"Yes",value:"yes"},{label:`Yes, and don't ask again for ${cA.bold(A)}`,value:"yes-dont-ask-again"},{label:`No, and tell Claude what to do differently ${cA.bold("(esc)")}`,value:"no"}];return HK.createElement(YZ,{title:"Network request outside of sandbox"},HK.createElement(j,{flexDirection:"column",paddingX:2,paddingY:1},HK.createElement(j,null,HK.createElement(z,{dimColor:!0},"Host:"),HK.createElement(z,null," ",A)),HK.createElement(j,{marginTop:1},HK.createElement(z,null,"Do you want to allow this connection?")),HK.createElement(j,null,HK.createElement(S0,{options:G,onChange:B,onCancel:()=>{Q({allow:!1,persistToSettings:!1})}}))))}var HK;var NL2=L(()=>{fA();Z8();UU();t2();T0();HK=o(WA(),1)});var D75,gIZ,H81=604800000,qL2=86400000,j70;var c_A=L(()=>{D75=Math.pow(10,8)*24*60*60*1000,gIZ=-D75,j70=Symbol.for("constructDateFrom")});function oU(A,Q){if(typeof A==="function")return A(Q);if(A&&typeof A==="object"&&j70 in A)return A[j70](Q);if(A instanceof Date)return new A.constructor(Q);return new Date(Q)}var In=L(()=>{c_A()});function RI(A,Q){return oU(Q||A,A)}var EN=L(()=>{In()});var LL2=()=>{};var ML2=()=>{};var OL2=()=>{};var RL2=()=>{};var _L2=()=>{};var TL2=()=>{};var jL2=()=>{};var PL2=()=>{};var SL2=()=>{};function Xn(){return H75}var H75;var p_A=L(()=>{H75={}});function ah(A,Q){let B=Xn(),G=Q?.weekStartsOn??Q?.locale?.options?.weekStartsOn??B.weekStartsOn??B.locale?.options?.weekStartsOn??0,Z=RI(A,Q?.in),Y=Z.getDay(),J=(Y<G?7:0)+Y-G;return Z.setDate(Z.getDate()-J),Z.setHours(0,0,0,0),Z}var lIA=L(()=>{p_A();EN()});function S0A(A,Q){return ah(A,{...Q,weekStartsOn:1})}var l_A=L(()=>{lIA()});function F81(A,Q){let B=RI(A,Q?.in),G=B.getFullYear(),Z=oU(B,0);Z.setFullYear(G+1,0,4),Z.setHours(0,0,0,0);let Y=S0A(Z),J=oU(B,0);J.setFullYear(G,0,4),J.setHours(0,0,0,0);let I=S0A(J);if(B.getTime()>=Y.getTime())return G+1;else if(B.getTime()>=I.getTime())return G;else return G-1}var C81=L(()=>{In();l_A();EN()});function P70(A){let Q=RI(A),B=new Date(Date.UTC(Q.getFullYear(),Q.getMonth(),Q.getDate(),Q.getHours(),Q.getMinutes(),Q.getSeconds(),Q.getMilliseconds()));return B.setUTCFullYear(Q.getFullYear()),+A-+B}var xL2=L(()=>{EN()});function yL2(A,...Q){let B=oU.bind(null,A||Q.find((G)=>typeof G==="object"));return Q.map(B)}var vL2=L(()=>{In()});function S70(A,Q){let B=RI(A,Q?.in);return B.setHours(0,0,0,0),B}var x70=L(()=>{EN()});function kL2(A,Q,B){let[G,Z]=yL2(B?.in,A,Q),Y=S70(G),J=S70(Z),I=+Y-P70(Y),X=+J-P70(J);return Math.round((I-X)/qL2)}var y70=L(()=>{xL2();vL2();c_A();x70()});function fL2(A,Q){let B=F81(A,Q),G=oU(Q?.in||A,0);return G.setFullYear(B,0,4),G.setHours(0,0,0,0),S0A(G)}var v70=L(()=>{In();C81();l_A()});var bL2=()=>{};var hL2=()=>{};var gL2=()=>{};var uL2=()=>{};var mL2=()=>{};var dL2=()=>{};var cL2=()=>{};var pL2=()=>{};var lL2=()=>{};var iL2=()=>{};var nL2=()=>{};var aL2=()=>{};var oL2=()=>{};var rL2=()=>{};var sL2=()=>{};var tL2=()=>{};var eL2=()=>{};var AM2=()=>{};function QM2(A){return A instanceof Date||typeof A==="object"&&Object.prototype.toString.call(A)==="[object Date]"}var k70=()=>{};function BM2(A){return!(!QM2(A)&&typeof A!=="number"||isNaN(+RI(A)))}var f70=L(()=>{k70();EN()});var GM2=()=>{};var ZM2=()=>{};var YM2=()=>{};var JM2=()=>{};var IM2=()=>{};var XM2=()=>{};var WM2=()=>{};var KM2=()=>{};var VM2=()=>{};var EM2=()=>{};var DM2=()=>{};var HM2=()=>{};var FM2=()=>{};var CM2=()=>{};var zM2=()=>{};var UM2=()=>{};var $M2=()=>{};var wM2=()=>{};var NM2=()=>{};var qM2=()=>{};var LM2=()=>{};var MM2=()=>{};var OM2=()=>{};var RM2=()=>{};var _M2=()=>{};var TM2=()=>{};var jM2=()=>{};var PM2=()=>{};var SM2=()=>{};var xM2=()=>{};var yM2=()=>{};var vM2=()=>{};var kM2=()=>{};function fM2(A,Q){let B=RI(A,Q?.in);return B.setFullYear(B.getFullYear(),0,1),B.setHours(0,0,0,0),B}var b70=L(()=>{EN()});var bM2=()=>{};var hM2=()=>{};var gM2=()=>{};var uM2=()=>{};var mM2=()=>{};var dM2=()=>{};var cM2=()=>{};var pM2=()=>{};var lM2=()=>{};var iM2=()=>{};var nM2=()=>{};var aM2=()=>{};var oM2=()=>{};var F75,rM2=(A,Q,B)=>{let G,Z=F75[A];if(typeof Z==="string")G=Z;else if(Q===1)G=Z.one;else G=Z.other.replace("{{count}}",Q.toString());if(B?.addSuffix)if(B.comparison&&B.comparison>0)return"in "+G;else return G+" ago";return G};var sM2=L(()=>{F75={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"less than a minute",other:"less than {{count}} minutes"},xMinutes:{one:"1 minute",other:"{{count}} minutes"},aboutXHours:{one:"about 1 hour",other:"about {{count}} hours"},xHours:{one:"1 hour",other:"{{count}} hours"},xDays:{one:"1 day",other:"{{count}} days"},aboutXWeeks:{one:"about 1 week",other:"about {{count}} weeks"},xWeeks:{one:"1 week",other:"{{count}} weeks"},aboutXMonths:{one:"about 1 month",other:"about {{count}} months"},xMonths:{one:"1 month",other:"{{count}} months"},aboutXYears:{one:"about 1 year",other:"about {{count}} years"},xYears:{one:"1 year",other:"{{count}} years"},overXYears:{one:"over 1 year",other:"over {{count}} years"},almostXYears:{one:"almost 1 year",other:"almost {{count}} years"}}});function z81(A){return(Q={})=>{let B=Q.width?String(Q.width):A.defaultWidth;return A.formats[B]||A.formats[A.defaultWidth]}}var C75,z75,U75,tM2;var eM2=L(()=>{C75={full:"EEEE, MMMM do, y",long:"MMMM do, y",medium:"MMM d, y",short:"MM/dd/yyyy"},z75={full:"h:mm:ss a zzzz",long:"h:mm:ss a z",medium:"h:mm:ss a",short:"h:mm a"},U75={full:"{{date}} 'at' {{time}}",long:"{{date}} 'at' {{time}}",medium:"{{date}}, {{time}}",short:"{{date}}, {{time}}"},tM2={date:z81({formats:C75,defaultWidth:"full"}),time:z81({formats:z75,defaultWidth:"full"}),dateTime:z81({formats:U75,defaultWidth:"full"})}});var $75,AO2=(A,Q,B,G)=>$75[A];var QO2=L(()=>{$75={lastWeek:"'last' eeee 'at' p",yesterday:"'yesterday at' p",today:"'today at' p",tomorrow:"'tomorrow at' p",nextWeek:"eeee 'at' p",other:"P"}});function iIA(A){return(Q,B)=>{let G=B?.context?String(B.context):"standalone",Z;if(G==="formatting"&&A.formattingValues){let J=A.defaultFormattingWidth||A.defaultWidth,I=B?.width?String(B.width):J;Z=A.formattingValues[I]||A.formattingValues[J]}else{let J=A.defaultWidth,I=B?.width?String(B.width):A.defaultWidth;Z=A.values[I]||A.values[J]}let Y=A.argumentCallback?A.argumentCallback(Q):Q;return Z[Y]}}var w75,N75,q75,L75,M75,O75,R75=(A,Q)=>{let B=Number(A),G=B%100;if(G>20||G<10)switch(G%10){case 1:return B+"st";case 2:return B+"nd";case 3:return B+"rd"}return B+"th"},BO2;var GO2=L(()=>{w75={narrow:["B","A"],abbreviated:["BC","AD"],wide:["Before Christ","Anno Domini"]},N75={narrow:["1","2","3","4"],abbreviated:["Q1","Q2","Q3","Q4"],wide:["1st quarter","2nd quarter","3rd quarter","4th quarter"]},q75={narrow:["J","F","M","A","M","J","J","A","S","O","N","D"],abbreviated:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],wide:["January","February","March","April","May","June","July","August","September","October","November","December"]},L75={narrow:["S","M","T","W","T","F","S"],short:["Su","Mo","Tu","We","Th","Fr","Sa"],abbreviated:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],wide:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]},M75={narrow:{am:"a",pm:"p",midnight:"mi",noon:"n",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},abbreviated:{am:"AM",pm:"PM",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},wide:{am:"a.m.",pm:"p.m.",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"}},O75={narrow:{am:"a",pm:"p",midnight:"mi",noon:"n",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"},abbreviated:{am:"AM",pm:"PM",midnight:"midnight",noon:"noon",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"},wide:{am:"a.m.",pm:"p.m.",midnight:"midnight",noon:"noon",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"}},BO2={ordinalNumber:R75,era:iIA({values:w75,defaultWidth:"wide"}),quarter:iIA({values:N75,defaultWidth:"wide",argumentCallback:(A)=>A-1}),month:iIA({values:q75,defaultWidth:"wide"}),day:iIA({values:L75,defaultWidth:"wide"}),dayPeriod:iIA({values:M75,defaultWidth:"wide",formattingValues:O75,defaultFormattingWidth:"wide"})}});function nIA(A){return(Q,B={})=>{let G=B.width,Z=G&&A.matchPatterns[G]||A.matchPatterns[A.defaultMatchWidth],Y=Q.match(Z);if(!Y)return null;let J=Y[0],I=G&&A.parsePatterns[G]||A.parsePatterns[A.defaultParseWidth],X=Array.isArray(I)?T75(I,(V)=>V.test(J)):_75(I,(V)=>V.test(J)),W;W=A.valueCallback?A.valueCallback(X):X,W=B.valueCallback?B.valueCallback(W):W;let K=Q.slice(J.length);return{value:W,rest:K}}}function _75(A,Q){for(let B in A)if(Object.prototype.hasOwnProperty.call(A,B)&&Q(A[B]))return B;return}function T75(A,Q){for(let B=0;B<A.length;B++)if(Q(A[B]))return B;return}function ZO2(A){return(Q,B={})=>{let G=Q.match(A.matchPattern);if(!G)return null;let Z=G[0],Y=Q.match(A.parsePattern);if(!Y)return null;let J=A.valueCallback?A.valueCallback(Y[0]):Y[0];J=B.valueCallback?B.valueCallback(J):J;let I=Q.slice(Z.length);return{value:J,rest:I}}}var j75,P75,S75,x75,y75,v75,k75,f75,b75,h75,g75,u75,YO2;var JO2=L(()=>{j75=/^(\d+)(th|st|nd|rd)?/i,P75=/\d+/i,S75={narrow:/^(b|a)/i,abbreviated:/^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,wide:/^(before christ|before common era|anno domini|common era)/i},x75={any:[/^b/i,/^(a|c)/i]},y75={narrow:/^[1234]/i,abbreviated:/^q[1234]/i,wide:/^[1234](th|st|nd|rd)? quarter/i},v75={any:[/1/i,/2/i,/3/i,/4/i]},k75={narrow:/^[jfmasond]/i,abbreviated:/^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,wide:/^(january|february|march|april|may|june|july|august|september|october|november|december)/i},f75={narrow:[/^j/i,/^f/i,/^m/i,/^a/i,/^m/i,/^j/i,/^j/i,/^a/i,/^s/i,/^o/i,/^n/i,/^d/i],any:[/^ja/i,/^f/i,/^mar/i,/^ap/i,/^may/i,/^jun/i,/^jul/i,/^au/i,/^s/i,/^o/i,/^n/i,/^d/i]},b75={narrow:/^[smtwf]/i,short:/^(su|mo|tu|we|th|fr|sa)/i,abbreviated:/^(sun|mon|tue|wed|thu|fri|sat)/i,wide:/^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i},h75={narrow:[/^s/i,/^m/i,/^t/i,/^w/i,/^t/i,/^f/i,/^s/i],any:[/^su/i,/^m/i,/^tu/i,/^w/i,/^th/i,/^f/i,/^sa/i]},g75={narrow:/^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,any:/^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i},u75={any:{am:/^a/i,pm:/^p/i,midnight:/^mi/i,noon:/^no/i,morning:/morning/i,afternoon:/afternoon/i,evening:/evening/i,night:/night/i}},YO2={ordinalNumber:ZO2({matchPattern:j75,parsePattern:P75,valueCallback:(A)=>parseInt(A,10)}),era:nIA({matchPatterns:S75,defaultMatchWidth:"wide",parsePatterns:x75,defaultParseWidth:"any"}),quarter:nIA({matchPatterns:y75,defaultMatchWidth:"wide",parsePatterns:v75,defaultParseWidth:"any",valueCallback:(A)=>A+1}),month:nIA({matchPatterns:k75,defaultMatchWidth:"wide",parsePatterns:f75,defaultParseWidth:"any"}),day:nIA({matchPatterns:b75,defaultMatchWidth:"wide",parsePatterns:h75,defaultParseWidth:"any"}),dayPeriod:nIA({matchPatterns:g75,defaultMatchWidth:"any",parsePatterns:u75,defaultParseWidth:"any"})}});var h70;var IO2=L(()=>{sM2();eM2();QO2();GO2();JO2();h70={code:"en-US",formatDistance:rM2,formatLong:tM2,formatRelative:AO2,localize:BO2,match:YO2,options:{weekStartsOn:0,firstWeekContainsDate:1}}});var XO2=L(()=>{IO2()});function WO2(A,Q){let B=RI(A,Q?.in);return kL2(B,fM2(B))+1}var g70=L(()=>{y70();b70();EN()});function KO2(A,Q){let B=RI(A,Q?.in),G=+S0A(B)-+fL2(B);return Math.round(G/H81)+1}var u70=L(()=>{c_A();l_A();v70();EN()});function U81(A,Q){let B=RI(A,Q?.in),G=B.getFullYear(),Z=Xn(),Y=Q?.firstWeekContainsDate??Q?.locale?.options?.firstWeekContainsDate??Z.firstWeekContainsDate??Z.locale?.options?.firstWeekContainsDate??1,J=oU(Q?.in||A,0);J.setFullYear(G+1,0,Y),J.setHours(0,0,0,0);let I=ah(J,Q),X=oU(Q?.in||A,0);X.setFullYear(G,0,Y),X.setHours(0,0,0,0);let W=ah(X,Q);if(+B>=+I)return G+1;else if(+B>=+W)return G;else return G-1}var $81=L(()=>{p_A();In();lIA();EN()});function VO2(A,Q){let B=Xn(),G=Q?.firstWeekContainsDate??Q?.locale?.options?.firstWeekContainsDate??B.firstWeekContainsDate??B.locale?.options?.firstWeekContainsDate??1,Z=U81(A,Q),Y=oU(Q?.in||A,0);return Y.setFullYear(Z,0,G),Y.setHours(0,0,0,0),ah(Y,Q)}var m70=L(()=>{p_A();In();$81();lIA()});function EO2(A,Q){let B=RI(A,Q?.in),G=+ah(B,Q)-+VO2(B,Q);return Math.round(G/H81)+1}var d70=L(()=>{c_A();lIA();m70();EN()});function Z7(A,Q){let B=A<0?"-":"",G=Math.abs(A).toString().padStart(Q,"0");return B+G}var oh;var DO2=L(()=>{oh={y(A,Q){let B=A.getFullYear(),G=B>0?B:1-B;return Z7(Q==="yy"?G%100:G,Q.length)},M(A,Q){let B=A.getMonth();return Q==="M"?String(B+1):Z7(B+1,2)},d(A,Q){return Z7(A.getDate(),Q.length)},a(A,Q){let B=A.getHours()/12>=1?"pm":"am";switch(Q){case"a":case"aa":return B.toUpperCase();case"aaa":return B;case"aaaaa":return B[0];case"aaaa":default:return B==="am"?"a.m.":"p.m."}},h(A,Q){return Z7(A.getHours()%12||12,Q.length)},H(A,Q){return Z7(A.getHours(),Q.length)},m(A,Q){return Z7(A.getMinutes(),Q.length)},s(A,Q){return Z7(A.getSeconds(),Q.length)},S(A,Q){let B=Q.length,G=A.getMilliseconds(),Z=Math.trunc(G*Math.pow(10,B-3));return Z7(Z,Q.length)}}});function HO2(A,Q=""){let B=A>0?"-":"+",G=Math.abs(A),Z=Math.trunc(G/60),Y=G%60;if(Y===0)return B+String(Z);return B+String(Z)+Q+Z7(Y,2)}function FO2(A,Q){if(A%60===0)return(A>0?"-":"+")+Z7(Math.abs(A)/60,2);return x0A(A,Q)}function x0A(A,Q=""){let B=A>0?"-":"+",G=Math.abs(A),Z=Z7(Math.trunc(G/60),2),Y=Z7(G%60,2);return B+Z+Q+Y}var aIA,c70;var CO2=L(()=>{g70();u70();C81();d70();$81();DO2();aIA={am:"am",pm:"pm",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},c70={G:function(A,Q,B){let G=A.getFullYear()>0?1:0;switch(Q){case"G":case"GG":case"GGG":return B.era(G,{width:"abbreviated"});case"GGGGG":return B.era(G,{width:"narrow"});case"GGGG":default:return B.era(G,{width:"wide"})}},y:function(A,Q,B){if(Q==="yo"){let G=A.getFullYear(),Z=G>0?G:1-G;return B.ordinalNumber(Z,{unit:"year"})}return oh.y(A,Q)},Y:function(A,Q,B,G){let Z=U81(A,G),Y=Z>0?Z:1-Z;if(Q==="YY"){let J=Y%100;return Z7(J,2)}if(Q==="Yo")return B.ordinalNumber(Y,{unit:"year"});return Z7(Y,Q.length)},R:function(A,Q){let B=F81(A);return Z7(B,Q.length)},u:function(A,Q){let B=A.getFullYear();return Z7(B,Q.length)},Q:function(A,Q,B){let G=Math.ceil((A.getMonth()+1)/3);switch(Q){case"Q":return String(G);case"QQ":return Z7(G,2);case"Qo":return B.ordinalNumber(G,{unit:"quarter"});case"QQQ":return B.quarter(G,{width:"abbreviated",context:"formatting"});case"QQQQQ":return B.quarter(G,{width:"narrow",context:"formatting"});case"QQQQ":default:return B.quarter(G,{width:"wide",context:"formatting"})}},q:function(A,Q,B){let G=Math.ceil((A.getMonth()+1)/3);switch(Q){case"q":return String(G);case"qq":return Z7(G,2);case"qo":return B.ordinalNumber(G,{unit:"quarter"});case"qqq":return B.quarter(G,{width:"abbreviated",context:"standalone"});case"qqqqq":return B.quarter(G,{width:"narrow",context:"standalone"});case"qqqq":default:return B.quarter(G,{width:"wide",context:"standalone"})}},M:function(A,Q,B){let G=A.getMonth();switch(Q){case"M":case"MM":return oh.M(A,Q);case"Mo":return B.ordinalNumber(G+1,{unit:"month"});case"MMM":return B.month(G,{width:"abbreviated",context:"formatting"});case"MMMMM":return B.month(G,{width:"narrow",context:"formatting"});case"MMMM":default:return B.month(G,{width:"wide",context:"formatting"})}},L:function(A,Q,B){let G=A.getMonth();switch(Q){case"L":return String(G+1);case"LL":return Z7(G+1,2);case"Lo":return B.ordinalNumber(G+1,{unit:"month"});case"LLL":return B.month(G,{width:"abbreviated",context:"standalone"});case"LLLLL":return B.month(G,{width:"narrow",context:"standalone"});case"LLLL":default:return B.month(G,{width:"wide",context:"standalone"})}},w:function(A,Q,B,G){let Z=EO2(A,G);if(Q==="wo")return B.ordinalNumber(Z,{unit:"week"});return Z7(Z,Q.length)},I:function(A,Q,B){let G=KO2(A);if(Q==="Io")return B.ordinalNumber(G,{unit:"week"});return Z7(G,Q.length)},d:function(A,Q,B){if(Q==="do")return B.ordinalNumber(A.getDate(),{unit:"date"});return oh.d(A,Q)},D:function(A,Q,B){let G=WO2(A);if(Q==="Do")return B.ordinalNumber(G,{unit:"dayOfYear"});return Z7(G,Q.length)},E:function(A,Q,B){let G=A.getDay();switch(Q){case"E":case"EE":case"EEE":return B.day(G,{width:"abbreviated",context:"formatting"});case"EEEEE":return B.day(G,{width:"narrow",context:"formatting"});case"EEEEEE":return B.day(G,{width:"short",context:"formatting"});case"EEEE":default:return B.day(G,{width:"wide",context:"formatting"})}},e:function(A,Q,B,G){let Z=A.getDay(),Y=(Z-G.weekStartsOn+8)%7||7;switch(Q){case"e":return String(Y);case"ee":return Z7(Y,2);case"eo":return B.ordinalNumber(Y,{unit:"day"});case"eee":return B.day(Z,{width:"abbreviated",context:"formatting"});case"eeeee":return B.day(Z,{width:"narrow",context:"formatting"});case"eeeeee":return B.day(Z,{width:"short",context:"formatting"});case"eeee":default:return B.day(Z,{width:"wide",context:"formatting"})}},c:function(A,Q,B,G){let Z=A.getDay(),Y=(Z-G.weekStartsOn+8)%7||7;switch(Q){case"c":return String(Y);case"cc":return Z7(Y,Q.length);case"co":return B.ordinalNumber(Y,{unit:"day"});case"ccc":return B.day(Z,{width:"abbreviated",context:"standalone"});case"ccccc":return B.day(Z,{width:"narrow",context:"standalone"});case"cccccc":return B.day(Z,{width:"short",context:"standalone"});case"cccc":default:return B.day(Z,{width:"wide",context:"standalone"})}},i:function(A,Q,B){let G=A.getDay(),Z=G===0?7:G;switch(Q){case"i":return String(Z);case"ii":return Z7(Z,Q.length);case"io":return B.ordinalNumber(Z,{unit:"day"});case"iii":return B.day(G,{width:"abbreviated",context:"formatting"});case"iiiii":return B.day(G,{width:"narrow",context:"formatting"});case"iiiiii":return B.day(G,{width:"short",context:"formatting"});case"iiii":default:return B.day(G,{width:"wide",context:"formatting"})}},a:function(A,Q,B){let Z=A.getHours()/12>=1?"pm":"am";switch(Q){case"a":case"aa":return B.dayPeriod(Z,{width:"abbreviated",context:"formatting"});case"aaa":return B.dayPeriod(Z,{width:"abbreviated",context:"formatting"}).toLowerCase();case"aaaaa":return B.dayPeriod(Z,{width:"narrow",context:"formatting"});case"aaaa":default:return B.dayPeriod(Z,{width:"wide",context:"formatting"})}},b:function(A,Q,B){let G=A.getHours(),Z;if(G===12)Z=aIA.noon;else if(G===0)Z=aIA.midnight;else Z=G/12>=1?"pm":"am";switch(Q){case"b":case"bb":return B.dayPeriod(Z,{width:"abbreviated",context:"formatting"});case"bbb":return B.dayPeriod(Z,{width:"abbreviated",context:"formatting"}).toLowerCase();case"bbbbb":return B.dayPeriod(Z,{width:"narrow",context:"formatting"});case"bbbb":default:return B.dayPeriod(Z,{width:"wide",context:"formatting"})}},B:function(A,Q,B){let G=A.getHours(),Z;if(G>=17)Z=aIA.evening;else if(G>=12)Z=aIA.afternoon;else if(G>=4)Z=aIA.morning;else Z=aIA.night;switch(Q){case"B":case"BB":case"BBB":return B.dayPeriod(Z,{width:"abbreviated",context:"formatting"});case"BBBBB":return B.dayPeriod(Z,{width:"narrow",context:"formatting"});case"BBBB":default:return B.dayPeriod(Z,{width:"wide",context:"formatting"})}},h:function(A,Q,B){if(Q==="ho"){let G=A.getHours()%12;if(G===0)G=12;return B.ordinalNumber(G,{unit:"hour"})}return oh.h(A,Q)},H:function(A,Q,B){if(Q==="Ho")return B.ordinalNumber(A.getHours(),{unit:"hour"});return oh.H(A,Q)},K:function(A,Q,B){let G=A.getHours()%12;if(Q==="Ko")return B.ordinalNumber(G,{unit:"hour"});return Z7(G,Q.length)},k:function(A,Q,B){let G=A.getHours();if(G===0)G=24;if(Q==="ko")return B.ordinalNumber(G,{unit:"hour"});return Z7(G,Q.length)},m:function(A,Q,B){if(Q==="mo")return B.ordinalNumber(A.getMinutes(),{unit:"minute"});return oh.m(A,Q)},s:function(A,Q,B){if(Q==="so")return B.ordinalNumber(A.getSeconds(),{unit:"second"});return oh.s(A,Q)},S:function(A,Q){return oh.S(A,Q)},X:function(A,Q,B){let G=A.getTimezoneOffset();if(G===0)return"Z";switch(Q){case"X":return FO2(G);case"XXXX":case"XX":return x0A(G);case"XXXXX":case"XXX":default:return x0A(G,":")}},x:function(A,Q,B){let G=A.getTimezoneOffset();switch(Q){case"x":return FO2(G);case"xxxx":case"xx":return x0A(G);case"xxxxx":case"xxx":default:return x0A(G,":")}},O:function(A,Q,B){let G=A.getTimezoneOffset();switch(Q){case"O":case"OO":case"OOO":return"GMT"+HO2(G,":");case"OOOO":default:return"GMT"+x0A(G,":")}},z:function(A,Q,B){let G=A.getTimezoneOffset();switch(Q){case"z":case"zz":case"zzz":return"GMT"+HO2(G,":");case"zzzz":default:return"GMT"+x0A(G,":")}},t:function(A,Q,B){let G=Math.trunc(+A/1000);return Z7(G,Q.length)},T:function(A,Q,B){return Z7(+A,Q.length)}}});var zO2=(A,Q)=>{switch(A){case"P":return Q.date({width:"short"});case"PP":return Q.date({width:"medium"});case"PPP":return Q.date({width:"long"});case"PPPP":default:return Q.date({width:"full"})}},UO2=(A,Q)=>{switch(A){case"p":return Q.time({width:"short"});case"pp":return Q.time({width:"medium"});case"ppp":return Q.time({width:"long"});case"pppp":default:return Q.time({width:"full"})}},m75=(A,Q)=>{let B=A.match(/(P+)(p+)?/)||[],G=B[1],Z=B[2];if(!Z)return zO2(A,Q);let Y;switch(G){case"P":Y=Q.dateTime({width:"short"});break;case"PP":Y=Q.dateTime({width:"medium"});break;case"PPP":Y=Q.dateTime({width:"long"});break;case"PPPP":default:Y=Q.dateTime({width:"full"});break}return Y.replace("{{date}}",zO2(G,Q)).replace("{{time}}",UO2(Z,Q))},$O2;var wO2=L(()=>{$O2={p:UO2,P:m75}});function NO2(A){return d75.test(A)}function qO2(A){return c75.test(A)}function LO2(A,Q,B){let G=l75(A,Q,B);if(console.warn(G),p75.includes(A))throw RangeError(G)}function l75(A,Q,B){let G=A[0]==="Y"?"years":"days of the month";return`Use \`${A.toLowerCase()}\` instead of \`${A}\` (in \`${Q}\`) for formatting ${G} to the input \`${B}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`}var d75,c75,p75;var MO2=L(()=>{d75=/^D+$/,c75=/^Y+$/,p75=["D","DD","YY","YYYY"]});function OO2(A,Q,B){let G=Xn(),Z=B?.locale??G.locale??h70,Y=B?.firstWeekContainsDate??B?.locale?.options?.firstWeekContainsDate??G.firstWeekContainsDate??G.locale?.options?.firstWeekContainsDate??1,J=B?.weekStartsOn??B?.locale?.options?.weekStartsOn??G.weekStartsOn??G.locale?.options?.weekStartsOn??0,I=RI(A,B?.in);if(!BM2(I))throw RangeError("Invalid time value");let X=Q.match(n75).map((K)=>{let V=K[0];if(V==="p"||V==="P"){let E=$O2[V];return E(K,Z.formatLong)}return K}).join("").match(i75).map((K)=>{if(K==="''")return{isToken:!1,value:"'"};let V=K[0];if(V==="'")return{isToken:!1,value:s75(K)};if(c70[V])return{isToken:!0,value:K};if(V.match(r75))throw RangeError("Format string contains an unescaped latin alphabet character `"+V+"`");return{isToken:!1,value:K}});if(Z.localize.preprocessor)X=Z.localize.preprocessor(I,X);let W={firstWeekContainsDate:Y,weekStartsOn:J,locale:Z};return X.map((K)=>{if(!K.isToken)return K.value;let V=K.value;if(!B?.useAdditionalWeekYearTokens&&qO2(V)||!B?.useAdditionalDayOfYearTokens&&NO2(V))LO2(V,Q,String(A));let E=c70[V[0]];return E(I,V,Z.localize,W)}).join("")}function s75(A){let Q=A.match(a75);if(!Q)return A;return Q[1].replace(o75,"'")}var i75,n75,a75,o75,r75;var RO2=L(()=>{XO2();p_A();CO2();wO2();MO2();f70();EN();i75=/[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,n75=/P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,a75=/^'([^]*?)'?$/,o75=/''/g,r75=/[a-zA-Z]/});var _O2=()=>{};var TO2=()=>{};var jO2=()=>{};var PO2=()=>{};var SO2=()=>{};var xO2=()=>{};var yO2=()=>{};var vO2=()=>{};var kO2=()=>{};var fO2=()=>{};var bO2=()=>{};var hO2=()=>{};var gO2=()=>{};var uO2=()=>{};var mO2=()=>{};var dO2=()=>{};var cO2=()=>{};var pO2=()=>{};var lO2=()=>{};var iO2=()=>{};var nO2=()=>{};var aO2=()=>{};var oO2=()=>{};var rO2=()=>{};var sO2=()=>{};var tO2=()=>{};var eO2=()=>{};var AR2=()=>{};var QR2=()=>{};var BR2=()=>{};var GR2=()=>{};var ZR2=()=>{};var YR2=()=>{};var JR2=()=>{};var IR2=()=>{};var XR2=()=>{};var WR2=()=>{};var KR2=()=>{};var VR2=()=>{};var ER2=()=>{};var DR2=()=>{};var HR2=()=>{};var FR2=()=>{};var CR2=()=>{};var zR2=()=>{};var UR2=()=>{};var $R2=()=>{};var wR2=()=>{};var NR2=()=>{};var qR2=()=>{};var LR2=()=>{};var MR2=()=>{};var OR2=()=>{};var RR2=()=>{};var _R2=()=>{};var TR2=()=>{};var jR2=()=>{};var PR2=()=>{};var SR2=()=>{};var xR2=()=>{};var yR2=()=>{};var vR2=()=>{};var kR2=()=>{};var fR2=()=>{};var bR2=()=>{};var hR2=()=>{};var gR2=()=>{};var uR2=()=>{};var mR2=()=>{};var dR2=()=>{};var cR2=()=>{};var pR2=()=>{};var lR2=()=>{};var iR2=()=>{};var nR2=()=>{};var aR2=()=>{};var oR2=()=>{};var rR2=()=>{};var sR2=()=>{};var tR2=()=>{};var eR2=()=>{};var A_2=()=>{};var Q_2=()=>{};var B_2=()=>{};var G_2=()=>{};var Z_2=()=>{};var Y_2=()=>{};var J_2=()=>{};var I_2=()=>{};var X_2=()=>{};var W_2=()=>{};var K_2=()=>{};var V_2=()=>{};var E_2=()=>{};var D_2=()=>{};var H_2=()=>{};var F_2=()=>{};var C_2=()=>{};var z_2=()=>{};var U_2=()=>{};var $_2=()=>{};var w_2=()=>{};var N_2=()=>{};var q_2=()=>{};var L_2=()=>{};var M_2=()=>{};var O_2=()=>{};var R_2=()=>{};var __2=()=>{};var T_2=()=>{};var j_2=()=>{};var P_2=()=>{};var S_2=()=>{};var x_2=()=>{};var y_2=()=>{};var v_2=()=>{};var k_2=()=>{};var f_2=()=>{};var b_2=()=>{};var h_2=()=>{};var g_2=()=>{};var u_2=()=>{};var m_2=()=>{};var d_2=()=>{};var c_2=()=>{};var p_2=()=>{};var l_2=()=>{};var i_2=()=>{};var n_2=()=>{};var a_2=()=>{};var o_2=()=>{};var r_2=()=>{};var s_2=()=>{};var t_2=()=>{};var e_2=()=>{};var AT2=()=>{};var QT2=()=>{};var BT2=()=>{};var GT2=()=>{};var ZT2=()=>{};var YT2=()=>{};var JT2=()=>{};var IT2=()=>{};var XT2=()=>{};var WT2=()=>{};var KT2=()=>{};var VT2=()=>{};var ET2=()=>{};var DT2=()=>{};var HT2=()=>{};var FT2=()=>{};var CT2=()=>{};var zT2=()=>{};var UT2=()=>{};var $T2=()=>{};var wT2=L(()=>{OL2();jL2();LL2();SL2();hL2();PL2();gL2();ML2();uL2();mL2();dL2();cL2();pL2();nL2();aL2();oL2();rL2();sL2();In();tL2();eL2();GM2();y70();ZM2();YM2();JM2();XM2();WM2();KM2();VM2();EM2();HM2();FM2();CM2();wM2();NM2();qM2();LM2();MM2();OM2();RM2();_M2();TM2();PM2();SM2();xM2();vM2();bM2();hM2();zM2();gM2();uM2();dM2();cM2();pM2();UM2();lM2();iM2();nM2();aM2();mM2();kM2();oM2();RO2();_O2();TO2();jO2();PO2();SO2();xO2();yO2();vO2();kO2();fO2();bO2();hO2();gO2();uO2();g70();mO2();cO2();pO2();lO2();iO2();nO2();u70();C81();aO2();oO2();rO2();sO2();tO2();IM2();eO2();AR2();QR2();d70();BR2();$81();ZR2();YR2();JR2();IR2();XR2();WR2();KR2();VR2();ER2();DR2();HR2();k70();FR2();CR2();zR2();UR2();$R2();$M2();dO2();RR2();_R2();TR2();AM2();PR2();xR2();yR2();kR2();fR2();bR2();gR2();SR2();uR2();RL2();_L2();mR2();dR2();cR2();pR2();lR2();iR2();nR2();aR2();oR2();rR2();sR2();tR2();f70();eR2();TL2();A_2();B_2();G_2();Y_2();J_2();GR2();I_2();Z_2();X_2();W_2();lL2();K_2();V_2();E_2();D_2();iL2();H_2();F_2();C_2();z_2();U_2();$_2();w_2();N_2();q_2();L_2();M_2();O_2();R_2();OR2();__2();T_2();j_2();P_2();S_2();x_2();y_2();v_2();k_2();f_2();b_2();h_2();g_2();u_2();m_2();d_2();c_2();l_2();i_2();LR2();n_2();a_2();o_2();MR2();qR2();bL2();r_2();s_2();p_2();t_2();e_2();NR2();AT2();QT2();x70();BT2();jR2();l_A();v70();vR2();yM2();jM2();hR2();GT2();ZT2();lIA();m70();b70();YT2();IT2();XT2();Q_2();WT2();DM2();KT2();VT2();JT2();ET2();DT2();HT2();FT2();EN();wR2();CT2();zT2();UT2();$T2()});function NT2(){let[A,Q]=i_A.useState([]),[B,G]=i_A.useState(0);if(i_A.useEffect(()=>{let Z=NB.getSandboxViolationStore();return Z.subscribe((J)=>{Q(J.slice(-10)),G(Z.getTotalCount())})},[]),!NB.isSandboxingEnabled()||dQ()==="linux")return null;if(B===0)return null;return NC.createElement(j,{flexDirection:"column",marginTop:1},NC.createElement(j,{marginLeft:0},NC.createElement(z,{color:"permission"},"‚ßà Sandbox blocked ",B," total"," ",B===1?"operation":"operations")),A.map((Z,Y)=>NC.createElement(j,{key:`${Z.timestamp.getTime()}-${Y}`,paddingLeft:2},NC.createElement(z,{dimColor:!0},OO2(Z.timestamp,"h:mm:ssa"),Z.command?` ${Z.command}:`:""," ",Z.line))),NC.createElement(j,{paddingLeft:2},NC.createElement(z,{dimColor:!0},"‚Ä¶ showing last ",Math.min(10,A.length)," of ",B)))}var NC,i_A;var qT2=L(()=>{fA();XI();wT2();k3();NC=o(WA(),1),i_A=o(WA(),1)});function w81(){let{addNotification:A}=xG(),[Q,B]=oIA.useState(()=>{let{errors:Z}=px();return Z}),G=oIA.useCallback(()=>{let{errors:Z}=px();B(Z)},[]);return V8A(G),oIA.useEffect(()=>{if(Q.length>0){let Z=`Found ${Q.length} invalid settings ${Q.length===1?"file":"files"} ¬∑ /doctor for details`,Y=!1,J="inactive",I=8000;A({key:"settings-errors",text:Z,color:"inactive",priority:"high",timeoutMs:8000})}},[Q,A]),Q}var oIA;var p70=L(()=>{jB();lcA();UC();oIA=o(WA(),1)});function MT2({mcpClients:A=[]}){let{addNotification:Q}=xG();LT2.useEffect(()=>{let B=A.filter((Z)=>Z.type==="failed"&&Z.config.type!=="sse-ide"&&Z.config.type!=="ws-ide"),G=A.filter((Z)=>Z.type==="needs-auth");if(B.length===0&&G.length===0)return;if(B.length>0)Q({key:"mcp-failed",jsx:bV.createElement(bV.Fragment,null,bV.createElement(z,{color:"error"},B.length," MCP"," ",B.length===1?"server":"servers"," failed"),bV.createElement(z,{dimColor:!0}," ¬∑ /mcp for info")),priority:"medium"});if(G.length)Q({key:"mcp-needs-auth",jsx:bV.createElement(bV.Fragment,null,bV.createElement(z,{color:"warning"},G.length," MCP"," ",G.length===1?"server needs":"servers need"," ","auth"),bV.createElement(z,{dimColor:!0}," ¬∑ /mcp for info")),priority:"medium"})},[Q,A])}var bV,LT2;var OT2=L(()=>{fA();UC();bV=o(WA(),1),LT2=o(WA(),1)});function RT2(){let{addNotification:A}=xG(),[Q]=yQ(),{installationStatus:B}=Q.plugins,{totalFailed:G,failedMarketplacesCount:Z,failedPluginsCount:Y}=N81.useMemo(()=>{if(!B)return{totalFailed:0,failedMarketplacesCount:0,failedPluginsCount:0};let J=B.marketplaces.filter((X)=>X.status==="failed"),I=B.plugins.filter((X)=>X.status==="failed");return{totalFailed:J.length+I.length,failedMarketplacesCount:J.length,failedPluginsCount:I.length}},[B]);N81.useEffect(()=>{if(!B){f("No installation status to monitor");return}if(G===0)return;if(f(`Plugin installation status: ${Z} failed marketplaces, ${Y} failed plugins`),G===0)return;f(`Adding notification for ${G} failed installations`),A({key:"plugin-install-failed",jsx:Py.createElement(Py.Fragment,null,Py.createElement(z,{color:"error"},G," plugin",G===1?"":"s"," failed to install"),Py.createElement(z,{dimColor:!0}," ¬∑ /plugin for details")),priority:"medium"})},[A,G,Z,Y])}var Py,N81;var _T2=L(()=>{fA();UC();u2();Y0();Py=o(WA(),1),N81=o(WA(),1)});async function TT2(){let A=NQ(),Q=new Map;if(A.extraKnownMarketplaces)for(let[B,G]of Object.entries(A.extraKnownMarketplaces))Q.set(B,G);return Q}async function jT2(A){try{let Q=await N5(),B=[];for(let[G]of A)if(!Q[G])B.push(G);return B}catch(Q){return s(Q instanceof Error?Q:Error(String(Q))),[]}}function PT2(){(async()=>{if(Gy())return;try{let A=await N5(),Q=Object.keys(A);if(Q.length===0)return;f(`Auto-updating ${Q.length} installed marketplaces in background`),await Promise.allSettled(Q.map(async(B)=>{try{f(`Auto-updating marketplace "${B}"`),await Mp(B),f(`Successfully auto-updated marketplace "${B}"`)}catch(G){f(`Failed to auto-update marketplace "${B}": ${G instanceof Error?G.message:String(G)}`,{level:"warn"})}}))}catch(A){f(`Failed to auto-update: ${A instanceof Error?A.message:String(A)}`,{level:"error"})}})()}var l70=L(()=>{jB();aW();h1();Y0();xQ()});import{rename as i70}from"fs/promises";import{existsSync as t75,mkdirSync as ST2,rmSync as e75}from"fs";import{dirname as xT2,sep as yT2,join as AG5}from"path";import{tmpdir as QG5}from"os";function vT2(){return new Date().toISOString()}async function qC(A,Q,B="user",G,Z){let Y=typeof Q.source==="string"&&Z?Z:Q.source,J=await ye(Y,{manifest:Q}),I=await K81(J.path),X=vT2(),W=J.manifest.version||Q.version||"unknown",K=typeof Q.source==="string",V=hS(A,W),E=J.path;if(J.path!==V){if(ST2(xT2(V),{recursive:!0}),t75(V))e75(V,{recursive:!0,force:!0});let D=J.path.endsWith(yT2)?J.path:J.path+yT2;if(V.startsWith(D)){let F=AG5(QG5(),`claude-plugin-temp-${Date.now()}`);await i70(J.path,F),ST2(xT2(V),{recursive:!0}),await i70(F,V)}else await i70(J.path,V);E=V}return L70(A,{version:W,installedAt:X,lastUpdated:X,installPath:E,gitCommitSha:I,isLocal:K},B,G),E}function kT2(A,Q="user",B){let G=vT2();L70(A.pluginId,{version:A.version||"unknown",installedAt:G,lastUpdated:G,installPath:A.installPath,isLocal:!0},Q,B)}var y0A=L(()=>{fT();YW()});import{join as BG5}from"path";async function n70(){let A=NQ(),Q=[];if(A.enabledPlugins){for(let[B,G]of Object.entries(A.enabledPlugins))if(B.includes("@")&&G)Q.push(B)}return Q}function fT2(){let A=new Map,Q=[{scope:"managed",source:"policySettings"},{scope:"user",source:"userSettings"},{scope:"project",source:"projectSettings"},{scope:"local",source:"localSettings"},{scope:"flag",source:"flagSettings"}];for(let{scope:B,source:G}of Q){let Z=uB(G);if(!Z?.enabledPlugins)continue;for(let[Y,J]of Object.entries(Z.enabledPlugins)){if(!Y.includes("@"))continue;if(J===!0)A.set(Y,B);else if(J===!1)A.delete(Y)}}return f(`Found ${A.size} enabled plugins with scopes: ${Array.from(A.entries()).map(([B,G])=>`${B}(${G})`).join(", ")}`),A}async function a70(){M70().catch((B)=>{s(B instanceof Error?B:Error(String(B)))});let A=q70(),Q=Object.keys(A.plugins);return f(`Found ${Q.length} installed plugins (V2 format)`),Q}async function bT2(A){try{let Q=await a70(),B=[];for(let G of A)if(!Q.includes(G))try{if(await JH(G))B.push(G)}catch(Z){f(`Failed to check plugin ${G} in marketplace: ${Z}`)}return B}catch(Q){return s(Q instanceof Error?Q:Error(String(Q))),[]}}async function hT2(A,Q,B="user"){let G=B!=="user"?r1():void 0,Z=Ty(B),Y=uB(Z),J={...Y?.enabledPlugins},I=[],X=[];for(let W=0;W<A.length;W++){let K=A[W];if(!K)continue;if(Q)Q(K,W+1,A.length);try{let V=await JH(K);if(!V){X.push({name:K,error:"Plugin not found in any marketplace"});continue}let{entry:E,marketplaceInstallLocation:D}=V;if(!w_(E.source))await qC(K,E,B,G);else kT2({pluginId:K,installPath:BG5(D,E.source),version:E.version},B,G);J[K]=!0,I.push(K)}catch(V){let E=V instanceof Error?V.message:String(V);X.push({name:K,error:E}),s(V instanceof Error?V:Error(String(V)))}}return E2(Z,{...Y,enabledPlugins:J}),{installed:I,failed:X}}var o70=L(()=>{jB();aW();h1();Y0();YW();jB();XQ();bL();y0A();pIA();pB();fT()});import{join as GG5,basename as ZG5}from"path";function gT2(A,Q){let B=[],G=jA();function Z(Y){try{let J=G.readdirSync(Y);for(let I of J){let X=GG5(Y,I.name);if(I.isDirectory())Z(X);else if(I.isFile()&&I.name.endsWith(".md")){let W=uT2(X,Q);if(W)B.push(W)}}}catch(J){f(`Failed to scan output-styles directory ${Y}: ${J}`,{level:"error"})}}return Z(A),B}function uT2(A,Q){let B=jA();try{let G=B.readFileSync(A,{encoding:"utf-8"}),{frontmatter:Z,content:Y}=dW(G),J=ZG5(A,".md"),I=Z.name||J,X=`${Q}:${I}`,W=Z.description||_y(Y,`Output style from ${Q} plugin`);return{name:X,description:W,prompt:Y.trim(),source:"plugin"}}catch(G){return f(`Failed to load output style from ${A}: ${G}`,{level:"error"}),null}}function s70(){r70.cache?.clear?.()}var r70;var q81=L(()=>{o2();XQ();YW();Y0();lx();r70=Z0(async()=>{let{enabled:A,errors:Q}=await h5(),B=[];if(Q.length>0)f(`Plugin loading errors: ${Q.map((G)=>oL(G)).join(", ")}`);for(let G of A){if(G.outputStylesPath)try{let Z=gT2(G.outputStylesPath,G.name);if(B.push(...Z),Z.length>0)f(`Loaded ${Z.length} output styles from plugin ${G.name} default directory`)}catch(Z){f(`Failed to load output styles from plugin ${G.name} default directory: ${Z}`,{level:"error"})}if(G.outputStylesPaths)for(let Z of G.outputStylesPaths)try{let J=jA().statSync(Z);if(J.isDirectory()){let I=gT2(Z,G.name);if(B.push(...I),I.length>0)f(`Loaded ${I.length} output styles from plugin ${G.name} custom path: ${Z}`)}else if(J.isFile()&&Z.endsWith(".md")){let I=uT2(Z,G.name);if(I)B.push(I),f(`Loaded output style from plugin ${G.name} custom file: ${Z}`)}}catch(Y){f(`Failed to load output styles from plugin ${G.name} custom path ${Z}: ${Y}`,{level:"error"})}}return f(`Total plugin output styles loaded: ${B.length}`),B})});function YG5(){Op(),n31(),GQ2(),Do1(),s70()}function VZ(){YG5(),mT2()}var rh=L(()=>{YW();v_A();uMA();HqA();q81();BC()});import{join as t70,dirname as JG5}from"path";function L81(A){if(!LC.includes(A))throw Error(`Invalid scope "${A}". Must be one of: ${LC.join(", ")}`)}function Wn(A){return LC.includes(A)}function th(A){return A==="project"||A==="local"?pQ():void 0}function IG5(A,Q,B){let G="";if(Object.keys(B?.enabledPlugins||{}).forEach((Z)=>{if(Z===A||Z===Q.name||Z.startsWith(`${Q.name}@`))G=Z}),!G)G=A.includes("@")?A:Q.name;return G}function dT2(A,Q){let{name:B,marketplace:G}=W81(A);return Q.find((Z)=>{if(Z.name===A||Z.name===B)return!0;if(G&&Z.source)return Z.name===B&&Z.source.includes(`@${G}`);return!1})}function sh(A){let B=pM().plugins[A];if(!B||B.length===0)return{scope:"user"};let G=pQ(),Z=B.find((I)=>I.scope==="local"&&I.projectPath===G);if(Z)return{scope:Z.scope,projectPath:Z.projectPath};let Y=B.find((I)=>I.scope==="project"&&I.projectPath===G);if(Y)return{scope:Y.scope,projectPath:Y.projectPath};let J=B.find((I)=>I.scope==="user");if(J)return{scope:J.scope};return{scope:B[0].scope,projectPath:B[0].projectPath}}function XG5(A,Q,B,G){let Z=G||sh(A),{scope:Y}=Z,J=Ty(Y),X={...uB(J)?.enabledPlugins};if(Object.keys(X).forEach((K)=>{if(K===A||K===B.name||K.startsWith(`${B.name}@`))X[K]=Q}),!(A in X))X[A]=Q;let{error:W}=E2(J,{enabledPlugins:X});if(W)throw W;VZ()}async function cT2(A,Q="user"){L81(Q);let{name:B,marketplace:G}=W81(A),Z,Y,J;if(G){let C=await JH(A);if(C)Z=C.entry,Y=G,J=C.marketplaceInstallLocation}else{let C=await N5();for(let[U,O]of Object.entries(C))try{let M=(await $w(U)).plugins.find((_)=>_.name===B);if(M){Z=M,Y=U,J=O.installLocation;break}}catch(q){s(q instanceof Error?q:Error(`Failed to load marketplace "${U}": ${q}`));continue}}if(!Z||!Y){let C=G?`marketplace "${G}"`:"any configured marketplace";return{success:!1,message:`Plugin "${B}" not found in ${C}`}}let I=Z,X=`${I.name}@${Y}`,W=th(Q),K,{source:V}=I;if(w_(V)){if(!J)return{success:!1,message:`Cannot install local plugin "${B}" without marketplace install location`};K=t70(J,V)}await qC(X,I,Q,W,K);let E=Ty(Q),H={...uB(E)?.enabledPlugins,[X]:!0},{error:F}=E2(E,{enabledPlugins:H});if(F)return{success:!1,message:`Failed to update settings: ${F.message}`};return VZ(),{success:!0,message:`Successfully installed plugin: ${X} (scope: ${Q})`,pluginId:X,pluginName:I.name,scope:Q}}async function a_A(A,Q="user"){L81(Q);let{enabled:B,disabled:G}=await h5(),Z=[...B,...G],Y=dT2(A,Z);if(!Y)return{success:!1,message:`Plugin "${A}" not found in installed plugins`};let J=Ty(Q),I=uB(J),X=IG5(A,Y,I),W=th(Q),V=pM().plugins[X],E=V?.find((U)=>U.scope===Q&&U.projectPath===W);if(!E){let{scope:U}=sh(X);if(U!==Q&&V&&V.length>0)return{success:!1,message:`Plugin "${A}" is installed in ${U} scope, not ${Q}. Use --scope ${U} to uninstall.`};return{success:!1,message:`Plugin "${A}" is not installed in ${Q} scope. Use --scope to specify the correct scope.`}}let D=E.installPath,H={...I?.enabledPlugins};H[X]=void 0,E2(J,{enabledPlugins:H}),VZ(),KL2(X,Q,W);let C=pM().plugins[X];if((!C||C.length===0)&&D);return{success:!0,message:`Successfully uninstalled plugin: ${Y.name} (scope: ${Q})`,pluginId:X,pluginName:Y.name,scope:Q}}async function pT2(A,Q,B){let G=Q?"enable":"disable";if(B)L81(B);let{enabled:Z,disabled:Y}=await h5(),I=dT2(A,Q?Y:Z);if(!I)return{success:!1,message:`Plugin "${A}" not found in ${Q?"disabled":"enabled"} plugins`};let X=A.includes("@")?A:`${I.name}@${I.source?.split("@")[1]||"unknown"}`,W;if(B){let K=th(B);W={scope:B,projectPath:K};let V=sh(X);if(V.scope!==B)return{success:!1,message:`Plugin "${A}" is installed at ${V.scope} scope, not ${B}. Use --scope ${V.scope} or omit --scope to auto-detect.`}}else W=sh(X);if(!Wn(W.scope))return{success:!1,message:`Managed plugins cannot be ${G}d. They can only be updated.`};try{XG5(X,Q,I,W)}catch(K){return{success:!1,message:K instanceof Error?K.message:`Failed to ${G} plugin`}}return{success:!0,message:`Successfully ${G}d plugin: ${I.name} (scope: ${W.scope})`,pluginId:X,pluginName:I.name,scope:W.scope}}async function v0A(A,Q){return pT2(A,!0,Q)}async function o_A(A,Q){return pT2(A,!1,Q)}async function r_A(A,Q){let{name:B,marketplace:G}=W81(A),Z=G?`${B}@${G}`:A,Y=await JH(A);if(!Y)return{success:!1,message:`Plugin "${B}" not found`,pluginId:Z,scope:Q};let{entry:J,marketplaceInstallLocation:I}=Y,W=V81().plugins[Z];if(!W||W.length===0)return{success:!1,message:`Plugin "${B}" is not installed`,pluginId:Z,scope:Q};let K=th(Q),V=W.find((E)=>E.scope===Q&&E.projectPath===K);if(!V){let E=K?`${Q} (${K})`:Q;return{success:!1,message:`Plugin "${B}" is not installed at scope ${E}`,pluginId:Z,scope:Q}}return WG5({pluginId:Z,pluginName:B,entry:J,marketplaceInstallLocation:I,installation:V,scope:Q,projectPath:K})}async function WG5({pluginId:A,pluginName:Q,entry:B,marketplaceInstallLocation:G,installation:Z,scope:Y,projectPath:J}){let I=jA(),X=Z.version,W,K,V=!1;if(typeof B.source!=="string"){let E=await ye(B.source,{manifest:{name:B.name}});W=E.path,V=!0,K=await Se(A,B.source,E.manifest,E.path,B.version)}else{if(!I.existsSync(G))return{success:!1,message:`Marketplace directory not found at ${G}`,pluginId:A,scope:Y};let E=I.statSync(G).isDirectory()?G:JG5(G);if(W=t70(E,B.source),!I.existsSync(W))return{success:!1,message:`Plugin source not found at ${W}`,pluginId:A,scope:Y};let D,H=t70(W,".claude-plugin","plugin.json");try{D=zsA(H,B.name,B.source)}catch{}K=await Se(A,B.source,D,W,B.version)}try{let E=hS(A,K);if(Z.version===K||Z.installPath===E)return{success:!0,message:`${Q} is already at the latest version (${K}).`,pluginId:A,newVersion:K,oldVersion:X,alreadyUpToDate:!0,scope:Y};if(!I.existsSync(E))await CsA(W,A,K,B);let H=Z.installPath;if(VL2(A,Y,J,E,K),H&&H!==E){let U=V81();if(!Object.values(U.plugins).some((q)=>q.some((M)=>M.installPath===H))&&I.existsSync(H));}let F=J?`${Y} (${J})`:Y;return{success:!0,message:`Plugin "${Q}" updated from ${X||"unknown"} to ${K} for scope ${F}. Restart to apply changes.`,pluginId:A,newVersion:K,oldVersion:X,scope:Y}}finally{if(V&&W!==hS(A,K))I.rmSync(W,{recursive:!0,force:!0})}}var LC,n_A;var s_A=L(()=>{YW();fT();y0A();aW();bL();jB();rh();pIA();g0();mp1();XQ();h1();LC=["user","project","local"],n_A=["user","project","local","managed"]});import{join as KG5}from"path";function e70(A,Q,B,G){A((Z)=>({...Z,plugins:{...Z.plugins,installationStatus:{...Z.plugins.installationStatus,marketplaces:Z.plugins.installationStatus.marketplaces.map((Y)=>Y.name===Q?{...Y,status:B,error:G}:Y)}}}))}function AG0(A,Q,B,G){A((Z)=>({...Z,plugins:{...Z.plugins,installationStatus:{...Z.plugins.installationStatus,plugins:Z.plugins.installationStatus.plugins.map((Y)=>Y.id===Q?{...Y,status:B,error:G}:Y)}}}))}async function VG5(A,Q,B){let G=[],Z=[];for(let Y of A){let J=Q.get(Y);if(!J)continue;e70(B,Y,"installing");try{await N_(J.source),G.push(Y),e70(B,Y,"installed"),HsA(),Op(),await EG5(Y,B)}catch(I){let X=I instanceof Error?I.message:String(I);Z.push({name:Y,error:X}),e70(B,Y,"failed",X),s(I instanceof Error?I:Error(String(I)))}}return{installed:G,failed:Z}}async function EG5(A,Q){try{let G=(await n70()).filter((Z)=>Z.endsWith(`@${A}`));if(G.length>0){let Z=await bT2(G);if(Z.length>0)f(`Installing ${Z.length} plugins from newly installed marketplace ${A}`),await lT2(Z,Q)}}catch(B){s(B instanceof Error?B:Error(String(B)))}}async function lT2(A,Q){let B=[],G=[],Z=fT2(),Y=new Map;for(let J of A){AG0(Q,J,"installing");try{let I=await JH(J);if(!I)throw Error("Plugin not found in any marketplace");let X=Z.get(J),{entry:W,marketplaceInstallLocation:K}=I,V=w_(W.source)?KG5(K,W.source):void 0;if(X==="flag"){let E=V??W.source;await ye(E,{manifest:W})}else{let E=X||"user",D=th(E);if(await qC(J,W,E,D,V),E!=="managed"){if(NQ().enabledPlugins?.[J]!==!0){let C=Y.get(E)??{};C[J]=!0,Y.set(E,C)}}}B.push(J),AG0(Q,J,"installed")}catch(I){let X=I instanceof Error?I.message:String(I);G.push({name:J,error:X}),AG0(Q,J,"failed",X),s(I instanceof Error?I:Error(String(I)))}}for(let[J,I]of Y)if(Object.keys(I).length>0){let X=Ty(J),W=uB(X);E2(X,{...W,enabledPlugins:{...W?.enabledPlugins,...I}})}return{installed:B,failed:G}}async function M81(A){f("performBackgroundPluginInstallations called");try{let Q=[],B=[],G=await N5(),Z=await TT2();if(Z.size>0){f(`Found ${Z.size} extra marketplaces in settings`);let I=await jT2(Z);if(I.length>0){f(`Installing ${I.length} marketplaces automatically`);for(let X of I){let W=Z.get(X);if(W)Q.push({name:X,marketplace:W})}}}let Y=await n70(),J=[];if(Y.length>0){f(`Found ${Y.length} enabled plugins`);let I=await a70(),X=Y.filter((K)=>!I.includes(K));f(`Found ${X.length} missing plugins (not installed): ${X.join(", ")}`);let W=[];for(let K of X){let[,V]=K.split("@");if(!V)W.push(K);else if(V in G||Z.has(V)||Q.some((E)=>E.name===V))W.push(K);else J.push(K)}if(J.length>0){let K=[...new Set(J.map((V)=>V.split("@")[1]))];f(`Cannot install ${J.length} plugins because their marketplaces are not installed or configured: ${K.join(", ")}`),f(`Uninstallable plugins: ${J.join(", ")}`)}if(W.length>0)f(`Installing ${W.length} plugins automatically`),B.push(...W)}if(f(`Setting installation status: ${Q.length} marketplaces, ${B.length} installable plugins, ${J.length} uninstallable plugins`),A((I)=>({...I,plugins:{...I.plugins,installationStatus:{marketplaces:Q.map(({name:X})=>({name:X,status:"pending"})),plugins:[...B.map((X)=>{let[W]=X.split("@");return{id:X,name:W||X,status:"pending"}}),...J.map((X)=>{let[W,K]=X.split("@");return{id:X,name:W||X,status:"failed",error:`Marketplace '${K}' is not installed or configured`}})]}}})),Q.length>0)VG5(Q.map((I)=>I.name),Z,A).catch((I)=>{s(I instanceof Error?I:Error(String(I)))});if(B.length>0){let I=B.filter((X)=>{let[,W]=X.split("@");return!Q.some((K)=>K.name===W)});if(I.length>0)lT2(I,A).catch((X)=>{s(X instanceof Error?X:Error(String(X)))})}}catch(Q){s(Q instanceof Error?Q:Error(String(Q)))}}var QG0=L(()=>{Y0();h1();l70();o70();pIA();s_A();aW();aW();YW();y0A();bL();jB()});async function iT2(A){if(f("performStartupChecks called"),!QY(!0)){f("Trust not accepted for current directory - skipping plugin installations");return}try{f("Starting background plugin installations"),await M81(A)}catch(Q){f(`Error initiating background plugin installations: ${Q}`)}}var nT2=L(()=>{Y0();QG0();xQ()});function aT2(A){let{addNotification:Q}=xG(),B=TeA(),G=Pa1(B,A),Z=Sa1(B),Y=k0A.useRef(null),[J,I]=k0A.useState(!1);k0A.useEffect(()=>{if(B.isUsingOverage&&!J)Q({key:"limit-reached",text:Z,priority:"immediate"}),I(!0);else if(!B.isUsingOverage&&J)I(!1)},[B.isUsingOverage,Z,J,Q]),k0A.useEffect(()=>{if(G&&G!==Y.current)Y.current=G,Q({key:"rate-limit-warning",jsx:t_A.createElement(z,null,t_A.createElement(z,{color:"warning"},G)),priority:"high"})},[G,Q])}var t_A,k0A;var oT2=L(()=>{UC();Il();fA();t_A=o(WA(),1),k0A=o(WA(),1)});function DG5(A){let Q=A.toLowerCase(),B=X6();if(Q.includes("claude-3-opus"))return{isDeprecated:!0,modelName:"Claude 3 Opus",retirementDate:B==="bedrock"?"January 15, 2026":"January 5, 2026"};if(Q.includes("claude-3-7-sonnet")){let G;if(B==="vertex")G="May 11, 2026";else if(B==="bedrock")G="April 28, 2026";else G="February 10, 2026";return{isDeprecated:!0,modelName:"Claude 3.7 Sonnet",retirementDate:G}}return{isDeprecated:!1}}function O81(A){if(!A)return null;let Q=DG5(A);if(!Q.isDeprecated)return null;return`‚ö† ${Q.modelName} will be retired on ${Q.retirementDate}. Consider switching to a newer model.`}var BG0=L(()=>{hX()});function rT2(A){let{addNotification:Q}=xG(),B=R81.useRef(null);R81.useEffect(()=>{let G=O81(A);if(G&&G!==B.current)B.current=G,Q({key:"model-deprecation-warning",text:G,color:"warning",priority:"high"});if(!G)B.current=null},[A,Q])}var R81;var sT2=L(()=>{UC();BG0();R81=o(WA(),1)});function eT2({ideSelection:A,mcpClients:Q,ideInstallationStatus:B}){let{addNotification:G}=xG(),Z=FIA(Q),Y=B?U_(B?.ideType):!1,J=B?.error||Y,I=Z==="connected"&&(A?.filePath||A?.text&&A.lineCount>0),X=Z==="connected"&&!I,W=J&&!Y&&!X&&!I,K=J&&Y&&!X&&!I;tT2.useEffect(()=>{if(ZW()||Z!==null)return;PwA(!0).then((V)=>{if(V.length>0){let E=V[0]?.name;if(E&&!K)G({key:"ide-status-hint",jsx:bT.createElement(z,{dimColor:!0},X1.circle," /ide for ",HG5(E)),priority:"low"});else if(!W&&Z==="disconnected")G({key:"ide-status-disconnected",jsx:bT.createElement(z,{color:"error",key:"ide-status"},X1.circle," IDE disconnected"),priority:"medium"});else if(K)G({key:"ide-status-jetbrains-disconnected",jsx:bT.createElement(z,{dimColor:!0},"IDE plugin not connected ¬∑ /status for info"),priority:"medium"});else if(X)G({key:"ide-status-connected",jsx:bT.createElement(z,{color:"ide",key:"ide-status"},X1.circle,"IDE connected"),priority:"low"});else if(W)G({key:"ide-status-install-error",jsx:bT.createElement(z,{color:"error"},"IDE extension install failed (see /status for info)"),priority:"medium"})}})},[G,Z,X,W,K])}function HG5(A){if(A==="Visual Studio Code")return"VS Code";return A}var tT2,bT;var Aj2=L(()=>{UC();PJ();O61();fA();g2();tT2=o(WA(),1),bT=o(WA(),1)});function Bj2(){let{addNotification:A}=xG();Qj2.useEffect(()=>{let B=d1().sonnet45MigrationTimestamp;if(B){if(Date.now()-B<3000)A({key:"sonnet-4.5-update",text:"Model updated to Sonnet 4.5",color:"suggestion",priority:"high",timeoutMs:3000})}},[A])}var Qj2;var Gj2=L(()=>{UC();xQ();Qj2=o(WA(),1)});function Yj2(){let{addNotification:A}=xG();Zj2.useEffect(()=>{if(d1().subscriptionNoticeCount??0>=FG5)return;CG5().then((Q)=>{if(Q===null)return;i0((B)=>({...B,subscriptionNoticeCount:(B.subscriptionNoticeCount??0)+1})),r("tengu_switch_to_subscription_notice_shown",{}),A({key:"switch-to-subscription",jsx:e_A.createElement(z,{color:"suggestion"},"Use your existing Claude ",Q," plan with Claude Code",e_A.createElement(z,{color:"text",dimColor:!0}," ","¬∑ /login to activate")),priority:"low"})})},[A])}async function CG5(){if(RB())return null;let A=await myA();if(!A)return null;if(A.account.has_claude_max)return"Max";if(A.account.has_claude_pro)return"Pro";return null}var e_A,Zj2,FG5=3;var Jj2=L(()=>{fA();pKA();xQ();T0();F2();UC();e_A=o(WA(),1),Zj2=o(WA(),1)});function Ij2(){let A=_81.useRef(!1);_81.useEffect(()=>{if(A.current)return;A.current=!0,v$2()},[])}var _81;var Xj2=L(()=>{N50();_81=o(WA(),1)});function Wj2({onRun:A,onCancel:Q,reason:B}){let G=rIA.useRef(!1);return k1(rIA.useCallback((Z,Y)=>{if(Y.escape)Q()},[Q])),rIA.useEffect(()=>{if(!G.current)G.current=!0,A()},[A]),QD.createElement(j,{flexDirection:"column",marginTop:1},QD.createElement(j,null,QD.createElement(z,{bold:!0},"Running /issue to capture feedback...")),QD.createElement(j,null,QD.createElement(z,{dimColor:!0},"Press ",QD.createElement(R0,{shortcut:"Esc",action:"cancel"})," anytime")),QD.createElement(j,null,QD.createElement(z,{dimColor:!0},"Reason: ",B)))}function GG0(A){return!1;switch(A){case"feedback_survey_bad":return!0;case"feedback_survey_good":default:return!1}}function Kj2(A){switch(A){case"feedback_survey_bad":return'You responded "Bad" to the feedback survey';case"feedback_survey_good":return'You responded "Good" to the feedback survey';default:return"Unknown reason"}}var QD,rIA;var Vj2=L(()=>{fA();s4();QD=o(WA(),1),rIA=o(WA(),1)});import{randomUUID as ZG0}from"crypto";function Ej2({mainThreadAgentDefinition:A,toolUseContext:Q,customSystemPrompt:B,defaultSystemPrompt:G,appendSystemPrompt:Z}){let Y=A?MM(A)?A.getSystemPrompt({toolUseContext:{options:Q.options}}):A.getSystemPrompt():void 0;return[...Y?[Y]:B?[B]:G,...Z?[Z]:[]]}function b0A({commands:A,debug:Q,initialPrompt:B,initialTools:G,initialMessages:Z,initialFileHistorySnapshots:Y,mcpClients:J,dynamicMcpConfig:I,mcpCliEndpoint:X,autoConnectIdeFlag:W,strictMcpConfig:K=!1,systemPrompt:V,appendSystemPrompt:E,onBeforeQuery:D,onTurnComplete:H,disabled:F=!1,mainThreadAgentDefinition:C,disableSlashCommands:U=!1}){let[O,q]=yQ(),{toolPermissionContext:M,verbose:_,mcp:T,plugins:y,agentDefinitions:h}=O,x=ai(),m=QB.useMemo(()=>UH(M),[M]);zL2();let[g,t]=QB.useState(I),p=QB.useCallback((w0)=>{t(w0)},[t]),[k,c]=QB.useState("prompt"),[e,AA]=QB.useState(1),[VA,OA]=QB.useState(!1),{addNotification:EA}=xG(),SA=Wq2(J,T.clients),[yA,ZA]=QB.useState(void 0),[GA,zA]=QB.useState(null),[bA,TA]=QB.useState(null),[G1,YA]=QB.useState(!1);Bj2(),Yj2(),eT2({ideSelection:yA,mcpClients:SA,ideInstallationStatus:bA}),MT2({mcpClients:SA}),RT2(),w81(),aT2(x),rT2(x),nq2(),BL2();let CA=QB.useMemo(()=>{return[...m,...G]},[m,G]);o31(),QB.useEffect(()=>{iT2(q)},[q]),QB.useEffect(()=>{},[q]);let MA=l31(CA,T.tools,M),NA=QB.useMemo(()=>{if(!C)return MA;let{resolvedTools:w0}=Ki(C,MA,!1);return w0},[C,MA]),UA=Q70(A,y.commands),LA=Q70(UA,T.commands),lA=QB.useMemo(()=>U?[]:LA,[U,LA]);bQ2(T.clients),qq2(T.clients,ZA);let[gA,I1]=QB.useState("responding"),[$1,RA]=QB.useState([]),[B1,m1]=QB.useState(null),[S1,H0]=QB.useState(!1),[ZQ,o0]=QB.useState(0),[EQ,WQ]=QB.useState(void 0),w1=QB.useCallback((w0)=>{if(H0(w0),w0)o0(0)},[]);aG(()=>{if(S1&&H5!=="tool-permission")o0((w0)=>w0+100)},100);let[eA,V1]=QB.useState(null);QB.useEffect(()=>{if(eA?.notifications)eA.notifications.forEach((w0)=>{EA({key:"auto-updater-notification",text:w0,priority:"low"})})},[eA,EA]);let[R1,G0]=QB.useState(null),[U0,C0]=QB.useState([]),[HA,wA]=QB.useState([]),[tA,N1]=QB.useState(Z??[]);Ij2();let[C1,D1]=QB.useState([]),[X0,p1]=QB.useState(""),[k0,KQ]=QB.useState("prompt"),[bB,IB]=QB.useState(),[W2,d0]=QB.useState({}),[OQ,fB]=QB.useState(0),[_9,GB]=QB.useState(0),[K1,iA]=QB.useState(0),[F1,A0]=QB.useState(null),[D0,YQ]=QB.useState(null),[Q2,K9]=QB.useState(null),[b9,g6]=QB.useState(!1),[T9,M6]=QB.useState(!1),[n6,k4]=QB.useState(ZG0()),[$2,s2]=QB.useState(d1().hasAcknowledgedCostThreshold),[H9,E5]=QB.useState(new Set),[w3,U6]=QB.useState("INSERT"),[h9,t0]=QB.useState(!1),[nQ,xB]=QB.useState(!1),[Y4,e4]=QB.useState(!1),[kG,DZ]=QB.useState(!1),[S3,N3]=QB.useState(!1),nA=QB.useRef(!1),IA=QB.useRef(null),[BA]=I2(),xA=QB.useCallback(()=>{DL2({theme:BA,readFileState:XB.current}).then(async(w0)=>{if(w0){let ZB=await w0.content({theme:BA});q((gB)=>({...gB,spinnerTip:ZB})),HL2(w0)}else q((ZB)=>({...ZB,spinnerTip:void 0}))})},[q,BA]),hA=QB.useCallback(()=>{w1(!1),WQ(void 0),GB(0),RA([]),A0(null),YQ(null),K9(null),xA(),L01()},[w1,xA]),dA=kN2(X0),q1=(!R1||R1.showSpinner===!0)&&U0.length===0&&(S1||EQ)&&!O.pendingWorkerRequest,v1=gq2(tA,S1,OQ),f1=QB.useMemo(()=>({...v1,handleSelect:(w0)=>{if(v1.handleSelect(w0),w0==="bad"&&GG0("feedback_survey_bad")||w0==="good"&&GG0("feedback_survey_good"))D5(w0==="bad"?"feedback_survey_bad":"feedback_survey_good")}}),[v1]),a1=mq2(tA,S1);xq2({autoConnectIdeFlag:W,ideToInstallExtension:GA,setDynamicMcpConfig:t,setShowIdeOnboarding:YA,setIDEInstallationState:TA}),$L2(Y,O.fileHistory,(w0)=>q((ZB)=>({...ZB,fileHistory:w0})));let e1=QB.useCallback(async(w0,ZB,gB)=>{r("tengu_session_resumed",{entrypoint:gB});let A6=FqA(ZB.messages),w2=await WU("resume",w0);if(A6.push(...w2),ceA(ZB),LoA(ZB),ZB.fileHistorySnapshots)mGA(ZB.fileHistorySnapshots,(p2)=>{q((UB)=>({...UB,fileHistory:p2}))}),etA(ZB);if(S2(A6,ZB.projectPath??pQ()),hA(),m1(null),!oD())await EI();k4(w0);let N4=uT1(w0);if(mT1(),DWA(),E$(w0),await eL(),N4)UPA(N4);N1(()=>A6),G0(null),p1(""),D1([])},[hA,q]),L0=W0(),LQ=QB.useMemo(()=>Wl(W0()),[]),XB=QB.useRef((()=>{let w0=Tb(T81);return w0.set(LQ,{content:JSON.stringify(O.todos[L0]||[]),timestamp:0,offset:void 0,limit:void 0}),w0})()),S2=QB.useCallback((w0,ZB)=>{let gB=s31(w0,ZB,T81);XB.current=ueA(XB.current,gB)},[]);QB.useEffect(()=>{if(Z&&Z.length>0)S2(Z,pQ())},[]);let{status:iB,reverify:c2}=LN2(),[O6,D5]=QB.useState(null),[F8,wK]=QB.useState(null),[JG,gJ]=QB.useState(!1),uJ=!S1&&T9;function _W(){if(JG||F8)return;if(b9)return"message-selector";if(HA[0])return"sandbox-permission";let w0=!R1||R1.shouldContinueAnimation;if(w0&&U0[0])return"tool-permission";if(w0&&O.workerPermissions.queue[0])return"worker-permission";if(w0&&O.workerSandboxPermissions.queue[0])return"worker-sandbox-permission";if(w0&&O.elicitation.queue[0])return"elicitation";if(w0&&uJ)return"cost";if(w0&&G1)return"ide-onboarding";return}let H5=_W();function IG(){if(H5==="elicitation")return;if(hA(),H5==="tool-permission")U0[0]?.onAbort(),C0([]);else if(H5==="worker-permission"){let w0=O.workerPermissions.queue[0];if(w0)PB1(w0.workerName,{decision:"rejected",resolvedBy:"leader"},w0.id,O.teamContext?.teamName),q((ZB)=>({...ZB,workerPermissions:{...ZB.workerPermissions,queue:ZB.workerPermissions.queue.slice(1)}}))}else B1?.abort()}let NK=QB.useCallback(async()=>{let w0=await eeA(X0,0,async()=>new Promise((ZB)=>q((gB)=>{return ZB(gB),gB})),q);if(!w0)return;p1(w0.text),KQ("prompt")},[q,p1,KQ,X0]);TN2(C0,IG,b9||h9,k,B1?.signal,NK,w3,R1?.isLocalJSXCommand,S3),QB.useEffect(()=>{if(sV()>=5&&!T9&&!$2){if(r("tengu_cost_threshold_reached",{}),yuA())M6(!0)}},[tA,T9,$2]);let RX=QB.useCallback(async(w0)=>{if(cMA())return new Promise((ZB)=>{let gB=CQ2();if(!zQ2(w0.host,gB)){wA((w2)=>[...w2,{hostPattern:w0,resolvePromise:ZB}]);return}qQ2({requestId:gB,host:w0.host,resolve:ZB}),q((w2)=>({...w2,pendingSandboxRequest:{requestId:gB,host:w0.host}}))});return new Promise((ZB)=>{wA((gB)=>[...gB,{hostPattern:w0,resolvePromise:ZB}])})},[q]);if(NB.isSandboxingEnabled())NB.initialize(RX).catch((w0)=>{process.stderr.write(`
2676:`)},ZB=()=>{iH((gB)=>gB+1)};return S7?.on("suspend",w0),S7?.on("resume",ZB),()=>{S7?.off("suspend",w0),S7?.off("resume",ZB)}},[S7]);let PI=QB.useMemo(()=>UY(C1).filter(vIA),[C1]),BO=QB.useMemo(()=>{let w0=[...PI,...UY(tA).filter(vIA)];return $$2(w0,H9)},[PI,tA,H9]),MN=QB.useMemo(()=>{if(!S1)return null;let w0=tA.filter((_4)=>_4.type==="progress"&&_4.data.type==="hook_progress"&&(_4.data.hookEvent==="Stop"||_4.data.hookEvent==="SubagentStop"));if(w0.length===0)return null;let ZB=[...new Set(w0.map((_4)=>_4.toolUseID))],gB=ZB[ZB.length-1];if(!gB)return null;if(tA.some((_4)=>_4.type==="system"&&_4.subtype==="stop_hook_summary"&&_4.toolUseID===gB))return null;let w2=w0.filter((_4)=>_4.toolUseID===gB),N4=w2.length,p2=tA.filter((_4)=>{if(_4.type!=="attachment")return!1;let MY=_4.attachment;return"hookEvent"in MY&&(MY.hookEvent==="Stop"||MY.hookEvent==="SubagentStop")&&"toolUseID"in MY&&MY.toolUseID===gB}).length,UB=w2.find((_4)=>_4.data.statusMessage)?.data.statusMessage;if(UB)return N4===1?`${UB}‚Ä¶`:`${UB}‚Ä¶ ${p2}/${N4}`;let Q6=w2[0]?.data.hookEvent==="SubagentStop"?"subagent stop":"stop";return N4===1?`running ${Q6} hook`:`running stop hooks‚Ä¶ ${p2}/${N4}`},[tA,S1]);wq2(k,c,AA,OA,EI);let cZ=O.todos[L0];if(RN2(cZ),k==="transcript")return v2.createElement(v2.Fragment,null,v2.createElement(Qn,{messages:tA,normalizedMessageHistory:PI,tools:NA,verbose:!0,toolJSX:null,toolUseConfirmQueue:[],inProgressToolUseIDs:H9,isMessageSelectorVisible:!1,conversationId:n6,screen:k,agentDefinitions:h,screenToggleId:e,streamingToolUses:$1,showAllInTranscript:VA,onOpenRateLimitOptions:pH,isLoading:S1}),R1&&v2.createElement(j,{flexDirection:"column",width:"100%"},R1.jsx),v2.createElement(NT2,null),v2.createElement(j,{alignItems:"center",alignSelf:"center",borderTopDimColor:!0,borderBottom:!1,borderLeft:!1,borderRight:!1,borderStyle:"single",marginTop:1,paddingLeft:2,width:"100%"},v2.createElement(z,{dimColor:!0},"Showing detailed transcript ¬∑ ctrl+o to toggle")));return v2.createElement(b61,{key:J7,dynamicMcpConfig:g,isStrictMcpConfig:K,mcpCliEndpoint:X},v2.createElement(Qn,{messages:tA,normalizedMessageHistory:PI,tools:NA,verbose:_,toolJSX:R1,toolUseConfirmQueue:U0,inProgressToolUseIDs:H9,isMessageSelectorVisible:b9,conversationId:n6,screen:k,screenToggleId:e,streamingToolUses:$1,showAllInTranscript:VA,agentDefinitions:h,onOpenRateLimitOptions:pH,isLoading:S1}),v2.createElement(fq2,null),!F&&EQ&&v2.createElement(q0A,{param:{text:EQ,type:"text"},addMargin:!0,verbose:_}),R1&&v2.createElement(j,{flexDirection:"column",width:"100%"},R1.jsx),v2.createElement(j,{flexDirection:"column",width:"100%"},!1,q1&&v2.createElement(qnB,{mode:gA,spinnerTip:O.spinnerTip,currentResponseLength:_9,overrideMessage:F1,spinnerSuffix:MN,verbose:_,elapsedTimeMs:ZQ,todos:cZ,overrideColor:D0,overrideShimmerColor:Q2,hasActiveTools:H9.size>0,hideThinkingIndicator:BO&&!_}),!q1&&O.showExpandedTodos&&v2.createElement(j,{width:"100%",flexDirection:"column"},v2.createElement(pl,{todos:cZ||[],isStandalone:!0})),H5==="sandbox-permission"&&v2.createElement(T70,{key:HA[0].hostPattern.host,hostPattern:HA[0].hostPattern,onUserResponse:(w0)=>{let{allow:ZB,persistToSettings:gB}=w0,A6=HA[0];if(!A6)return;let w2=A6.hostPattern.host;if(gB){let N4={type:"addRules",rules:[{toolName:rX,ruleContent:`domain:${w2}`}],behavior:ZB?"allow":"deny",destination:"localSettings"};q((p2)=>({...p2,toolPermissionContext:eI(p2.toolPermissionContext,N4)})),eP(N4),NB.refreshConfig()}wA((N4)=>{return N4.filter((p2)=>p2.hostPattern.host===w2).forEach((p2)=>p2.resolvePromise(ZB)),N4.filter((p2)=>p2.hostPattern.host!==w2)})}}),H5==="tool-permission"&&v2.createElement(n32,{key:U0[0]?.toolUseID,onDone:()=>C0(([w0,...ZB])=>ZB),onReject:NK,toolUseConfirm:U0[0],toolUseContext:HZ(tA,tA,B1??g9(),[],void 0,x),verbose:_}),H5==="worker-permission"&&O.workerPermissions.queue[0]&&v2.createElement(RQ2,{key:O.workerPermissions.queue[0].id,request:O.workerPermissions.queue[0],workerColor:Object.values(O.teamContext?.teammates??{}).find((w0)=>w0.name===O.workerPermissions.queue[0]?.workerName)?.color,onDone:()=>{q((w0)=>({...w0,workerPermissions:{...w0.workerPermissions,queue:w0.workerPermissions.queue.slice(1)}}))},onApprove:(w0)=>{let ZB=O.workerPermissions.queue[0];if(ZB)PB1(ZB.workerName,{decision:"approved",resolvedBy:"leader",updatedInput:w0},ZB.id,O.teamContext?.teamName)},onDeny:(w0)=>{let ZB=O.workerPermissions.queue[0];if(ZB)PB1(ZB.workerName,{decision:"rejected",resolvedBy:"leader",feedback:w0},ZB.id,O.teamContext?.teamName)}}),O.pendingWorkerRequest&&v2.createElement(XB0,{toolName:O.pendingWorkerRequest.toolName,description:O.pendingWorkerRequest.description}),O.pendingSandboxRequest&&v2.createElement(XB0,{toolName:"Network Access",description:`Waiting for leader to approve network access to ${O.pendingSandboxRequest.host}`}),H5==="worker-sandbox-permission"&&v2.createElement(T70,{key:O.workerSandboxPermissions.queue[0].requestId,hostPattern:{host:O.workerSandboxPermissions.queue[0].host,port:void 0},onUserResponse:(w0)=>{let{allow:ZB,persistToSettings:gB}=w0,A6=O.workerSandboxPermissions.queue[0];if(!A6)return;let w2=A6.host;if(UQ2(A6.workerName,A6.requestId,w2,ZB,O.teamContext?.teamName),gB&&ZB){let N4={type:"addRules",rules:[{toolName:rX,ruleContent:`domain:${w2}`}],behavior:"allow",destination:"localSettings"};q((p2)=>({...p2,toolPermissionContext:eI(p2.toolPermissionContext,N4)})),eP(N4),NB.refreshConfig()}q((N4)=>({...N4,workerSandboxPermissions:{...N4.workerSandboxPermissions,queue:N4.workerSandboxPermissions.queue.slice(1)}}))}}),H5==="elicitation"&&v2.createElement(t32,{serverName:O.elicitation.queue[0].serverName,request:O.elicitation.queue[0].request,onResponse:(w0,ZB)=>{let gB=O.elicitation.queue[0];if(gB)q((A6)=>({...A6,elicitation:{queue:A6.elicitation.queue.slice(1)}})),gB.respond({action:w0,content:ZB})},signal:O.elicitation.queue[0].signal}),H5==="cost"&&v2.createElement(IQ2,{onDone:()=>{M6(!1),s2(!0),i0((w0)=>({...w0,hasAcknowledgedCostThreshold:!0})),r("tengu_cost_threshold_acknowledged",{})}}),H5==="ide-onboarding"&&v2.createElement(ADB,{onDone:()=>YA(!1),installationStatus:bA}),F8,!R1?.shouldHidePromptInput&&!H5&&!JG&&!F&&v2.createElement(v2.Fragment,null,O6&&v2.createElement(Wj2,{onRun:a6,onCancel:gC,reason:Kj2(O6)}),a1.state!=="closed"?v2.createElement(V70,{state:a1.state,handleSelect:a1.handleSelect,inputValue:X0,setInputValue:p1,message:"How did that compaction go? (optional)"}):v2.createElement(V70,{state:f1.state,handleSelect:f1.handleSelect,inputValue:X0,setInputValue:p1}),v2.createElement(UN2,{debug:Q,ideSelection:yA,getToolUseContext:HZ,toolPermissionContext:M,setToolPermissionContext:_X,apiKeyStatus:iB,commands:lA,agents:h.activeAgents,isLoading:S1,onExit:async()=>{gJ(!0);let w0=await Q81.call(()=>{});wK(w0)},verbose:_,messages:tA,onAutoUpdaterResult:V1,autoUpdaterResult:eA,input:X0,onInputChange:mJ,mode:k0,onModeChange:KQ,stashedPrompt:bB,setStashedPrompt:IB,submitCount:OQ,onShowMessageSelector:()=>g6((w0)=>!w0),mcpClients:SA,pastedContents:W2,setPastedContents:d0,vimMode:w3,setVimMode:U6,showBashesDialog:h9,setShowBashesDialog:t0,showDiffDialog:nQ,setShowDiffDialog:xB,tasksSelected:Y4,setTasksSelected:e4,diffSelected:kG,setDiffSelected:DZ,onSubmit:x3,isSearchingHistory:S3,setIsSearchingHistory:N3}))),H5==="message-selector"&&v2.createElement(yQ2,{messages:tA,onPreRestore:IG,onRestoreCode:async(w0)=>{await kNA((ZB)=>{q((gB)=>({...gB,fileHistory:ZB(gB.fileHistory)}))},w0.uuid)},onRestoreMessage:async(w0)=>{let ZB=tA.indexOf(w0),gB=tA.slice(0,ZB);setImmediate(async()=>{if(!oD())await EI();N1([...gB]),k4(ZG0()),q((w2)=>({...w2,todos:{...w2.todos,[L0]:w0.todos??[]},promptSuggestion:{text:null,shownAt:0,acceptedAt:0}})),XZA(w0.todos??[],L0);let A6=Dj2(w0);if(A6!==null){let w2=Q9(A6,"bash-input"),N4=Q9(A6,"command-name");if(w2)p1(w2),KQ("bash");else if(N4){let p2=Q9(A6,"command-args")||"";p1(`${N4} ${p2}`),KQ("prompt")}else p1(A6),KQ("prompt")}if(Array.isArray(w0.message.content)&&w0.message.content.some((w2)=>w2.type==="image")){let w2=w0.message.content.filter((N4)=>N4.type==="image");if(w2.length>0){let N4={};w2.forEach((p2,UB)=>{if(p2.source.type==="base64")N4[UB+1]={id:UB+1,type:"image",content:p2.source.data,mediaType:p2.source.media_type}}),d0(N4)}}})},onClose:()=>g6(!1)}))}var v2,QB,T81=100;var j81=L(()=>{fA();XQ2();UE();UC();AMA();_w();g0();VQ2();SB1();vB1();_Q2();TQ2();dl();SQ2();pMA();hQ2();a32();e32();$N2();SG();V31();Ii();dx();IC();tq();qN2();nd();MN2();_N2();jN2();yN2();fN2();tK();xQ();T0();HB();tf();Fs();qM();iY();Gq2();Iq2();P_A();Wi();Kq2();e50();A70();Hq2();G70();q_A();bLA();KCA();Nq2();TAA();Lq2();$H();FT();$1A();lRA();u2();hIA();Kl();cF();R8();CZA();J70();JU();Tq2();Pq2();PJ();yq2();X70();d_();te();Ep1();qA0();LZ();ii();bq2();uq2();dq2();lq2();aq2();GL2();FL2();UL2();XI();wL2();NL2();qT2();p70();OT2();_T2();nT2();W31();oT2();sT2();Aj2();Gj2();Jj2();Xj2();Vj2();v2=o(WA(),1),QB=o(WA(),1)});import{randomUUID as zG5}from"crypto";async function*sIA({agentDefinition:A,promptMessages:Q,toolUseContext:B,canUseTool:G,isAsync:Z,forkContextMessages:Y,querySource:J,override:I,model:X}){let W=await B.getAppState(),K=W.toolPermissionContext.mode,V=U3A(A.model,B.options.mainLoopModel,X,K),E=I?.agentId?I.agentId:QAA(),H=[...Y?dQ0(Y):[],...Q],F=Y!==void 0?UAA(B.readFileState):Tb(T81),[C,U]=await Promise.all([I?.userContext??_V(),I?.systemContext??nE()]),O=A.permissionMode,q=async()=>{let c=await B.getAppState(),e=c.toolPermissionContext;if(O&&c.toolPermissionContext.mode!=="bypassPermissions")e={...e,mode:O};if(Z)e={...e,shouldAvoidPermissionPrompts:!0};return{...c,toolPermissionContext:e,queuedCommands:[]}},_=Ki(A,B.options.tools,Z).resolvedTools,T=Array.from(W.toolPermissionContext.additionalWorkingDirectories.keys()),y=I?.systemPrompt?I.systemPrompt:await UG5(A,B,V,T),h=[],x=I?.abortController?I.abortController:Z?new AbortController:B.abortController,m=[];for await(let c of YG0(E,A.agentType,x.signal))if(c.additionalContexts&&c.additionalContexts.length>0)m.push(...c.additionalContexts);if(m.length>0){let c=A4({type:"hook_additional_context",content:m,hookName:"SubagentStart",toolUseID:zG5(),hookEvent:"SubagentStart"});H.push(c)}let g=A.skills??[];if(g.length>0){let c=await BJA(r1()),e=[];for(let AA of g){if(!Uh(AA,c)){f(`[Agent: ${A.agentType}] Warning: Skill '${AA}' specified in frontmatter was not found`,{level:"warn"});continue}let VA=aw(AA,c);if(VA.type!=="prompt"){f(`[Agent: ${A.agentType}] Warning: Skill '${AA}' is not a prompt-based skill`,{level:"warn"});continue}e.push({skillName:AA,skill:VA})}for(let{skillName:AA,skill:VA}of e){let OA=await VA.getPromptForCommand("",B);f(`[Agent: ${A.agentType}] Preloaded skill '${AA}'`);let EA=q90(AA,VA.progressMessage);H.push(u0({content:[{type:"text",text:EA},...OA]}))}}let t={isNonInteractiveSession:Z?!0:B.options.isNonInteractiveSession??!1,hasAppendSystemPrompt:B.options.hasAppendSystemPrompt,tools:_,commands:[],debug:B.options.debug,verbose:B.options.verbose,mainLoopModel:V,maxThinkingTokens:Kh(H),mcpClients:B.options.mcpClients,mcpResources:B.options.mcpResources,agentDefinitions:B.options.agentDefinitions},p=vMA(B,{options:t,agentId:E,messages:H,readFileState:F,abortController:x,getAppState:q,shareSetAppState:!Z,shareSetResponseLength:!0,criticalSystemReminder_EXPERIMENTAL:A.criticalSystemReminder_EXPERIMENTAL});await _n1(H,E).catch((c)=>f(`Failed to record sidechain transcript: ${c}`));let k=H.length>0?H[H.length-1].uuid:null;for await(let c of LU({messages:H,systemPrompt:y,userContext:C,systemContext:U,canUseTool:G,toolUseContext:p,querySource:J}))if(c.type==="assistant"||c.type==="user"||c.type==="progress"||c.type==="system"&&c.subtype==="compact_boundary")h.push(c),await _n1([c],E,k).catch((e)=>f(`Failed to record sidechain transcript: ${e}`)),k=c.uuid,yield c;if(x.signal.aborted)throw new UJ;if(MM(A)&&A.callback)A.callback()}function dQ0(A){let Q=new Set;for(let B of A)if(B?.type==="user"){let Z=B.message.content;if(Array.isArray(Z)){for(let Y of Z)if(Y.type==="tool_result"&&Y.tool_use_id)Q.add(Y.tool_use_id)}}return A.filter((B)=>{if(B?.type==="assistant"){let Z=B.message.content;if(Array.isArray(Z))return!Z.some((J)=>J.type==="tool_use"&&J.id&&!Q.has(J.id))}return!0})}async function UG5(A,Q,B,G){try{let Z=A.getSystemPrompt({toolUseContext:Q});return await ATA([Z],B,G)}catch(Z){return await ATA([Hj2],B,G)}}var HB1=L(()=>{Wi();eZ();rS();dx();Ii();l2();qM();$1A();FT();_w();j81();Tw();KM();R8();Y0();xMA();M9();BC();pB();HB();ROA();DB1()});function Fj2({agentType:A,description:Q,toolUseCount:B,tokens:G,color:Z,isLast:Y,isResolved:J,isError:I,isAsync:X=!1,shouldAnimate:W,lastToolInfo:K,hideType:V=!1}){let E=Y?"‚îî‚îÄ":"‚îú‚îÄ",D=()=>{if(!J)return K||"Initializing‚Ä¶";return X?"Launched":"Done"};return j8.createElement(j,{flexDirection:"column"},j8.createElement(j,{paddingLeft:3},j8.createElement(z,{dimColor:!J},E," ",V?j8.createElement(z,{bold:!0},Q||A):j8.createElement(j8.Fragment,null,j8.createElement(z,{bold:!0,backgroundColor:Z,color:Z?"inverseText":void 0},A),Q&&j8.createElement(z,null," (",Q,")"))," ¬∑ ",X&&J?j8.createElement(z,null,"Running in background"):j8.createElement(j8.Fragment,null,B," tool ",B===1?"use":"uses"),G!==null&&j8.createElement(j8.Fragment,null," ¬∑ ",g3(G)," tokens"))),j8.createElement(j,{paddingLeft:3,flexDirection:"row"},j8.createElement(z,{dimColor:!J},Y?" ":"‚îÇ"),j8.createElement(h0,null,j8.createElement(z,{dimColor:!0},D()))))}var j8;var Cj2=L(()=>{fA();h4();j8=o(WA(),1)});function QTA({prompt:A,theme:Q,dim:B=!1}){return GQ.createElement(j,{flexDirection:"column"},GQ.createElement(z,{color:"success",bold:!0},"Prompt:"),GQ.createElement(j,{paddingLeft:2},GQ.createElement(z,{dimColor:B},Q?y1A(A,Q):A)))}function IG0({content:A,theme:Q}){return GQ.createElement(j,{flexDirection:"column"},GQ.createElement(z,{color:"success",bold:!0},"Response:"),A.map((B,G)=>GQ.createElement(j,{key:G,paddingLeft:2,marginTop:G===0?0:1},GQ.createElement(z,null,Q?y1A(B.text,Q):B.text))))}function zj2(A,Q,{tools:B,verbose:G,theme:Z}){if(A.status==="async_launched"){let{prompt:F}=A;return GQ.createElement(j,{flexDirection:"column"},GQ.createElement(h0,{height:1},GQ.createElement(z,null,"Backgrounded agent",!G&&GQ.createElement(z,{dimColor:!0}," (",GQ.createElement(LB,null,GQ.createElement(R0,{shortcut:"‚Üì",action:"manage"}),F&&GQ.createElement(R0,{shortcut:"ctrl+o",action:"expand"})),")"))),G&&F&&GQ.createElement(h0,null,GQ.createElement(QTA,{prompt:F,theme:Z})))}if(A.status!=="completed")return null;let{agentId:Y,totalDurationMs:J,totalToolUseCount:I,totalTokens:X,usage:W,content:K,prompt:V}=A,D=`Done (${[I===1?"1 tool use":`${I} tool uses`,g3(X)+" tokens",lK(J)].join(" ¬∑ ")})`,H=hE({content:D,usage:W});return GQ.createElement(j,{flexDirection:"column"},!1,G&&V&&GQ.createElement(h0,null,GQ.createElement(QTA,{prompt:V,theme:Z})),G?GQ.createElement(bd1,null,Q.map((F)=>GQ.createElement(h0,{key:F.uuid},GQ.createElement(ST,{message:F.data.message,messages:F.data.normalizedMessages,addMargin:!1,tools:B,verbose:G,erroredToolUseIDs:new Set,inProgressToolUseIDs:new Set,resolvedToolUseIDs:new Set,progressMessagesForMessage:Q,shouldAnimate:!1,shouldShowDot:!1,isTranscriptMode:!1,isStatic:!0})))):null,G&&K&&K.length>0&&GQ.createElement(h0,null,GQ.createElement(IG0,{content:K,theme:Z})),GQ.createElement(h0,{height:1},GQ.createElement(ST,{message:H,messages:UY([H]),addMargin:!1,tools:B,verbose:G,erroredToolUseIDs:new Set,inProgressToolUseIDs:new Set,resolvedToolUseIDs:new Set,progressMessagesForMessage:[],shouldAnimate:!1,shouldShowDot:!1,isTranscriptMode:!1,isStatic:!0})))}function Uj2({description:A,prompt:Q}){if(!A||!Q)return null;return A}function P81(A,{tools:Q,verbose:B,terminalSize:G,inProgressToolCallCount:Z}){if(!A.length)return GQ.createElement(h0,{height:1},GQ.createElement(z,{dimColor:!0},NG5));let Y=(Z??1)*$G5+wG5,J=!B&&G&&G.rows&&G.rows<Y,I=()=>{let D=A.filter((C)=>{return C.data.message.message.content.some((O)=>O.type==="tool_use")}).length,H=[...A].reverse().find((C)=>C.data.message.type==="assistant"),F=null;if(H?.data.message.type==="assistant"){let C=H.data.message.message.usage;F=(C.cache_creation_input_tokens??0)+(C.cache_read_input_tokens??0)+C.input_tokens+C.output_tokens}return{toolUseCount:D,tokens:F}};if(J){let{toolUseCount:D,tokens:H}=I();return GQ.createElement(h0,{height:1},GQ.createElement(z,{dimColor:!0},"In progress‚Ä¶ ¬∑ ",GQ.createElement(z,{bold:!0},D)," tool"," ",D===1?"use":"uses",H&&` ¬∑ ${g3(H)} tokens`," ¬∑"," ",GQ.createElement(R0,{shortcut:"ctrl+o",action:"expand",parens:!0})))}let X=A.filter((D)=>{return D.data.message.message.content.some((F)=>F.type==="tool_use")}).length,W=B?A:A.slice(-JG0),K=W.filter((D)=>{return D.data.message.message.content.some((F)=>F.type==="tool_use")}).length,V=X-K;if(!B&&A.length>JG0)W=A.slice(-JG0+1);let E=A[0]?.data.prompt;return GQ.createElement(h0,null,GQ.createElement(j,{flexDirection:"column"},GQ.createElement(bd1,null,B&&E&&GQ.createElement(j,{marginBottom:1},GQ.createElement(QTA,{prompt:E})),W.map((D)=>GQ.createElement(j,{key:D.uuid,height:1,overflow:"hidden"},GQ.createElement(ST,{message:D.data.message,messages:D.data.normalizedMessages,addMargin:!1,tools:Q,verbose:B,erroredToolUseIDs:new Set,inProgressToolUseIDs:new Set,resolvedToolUseIDs:EG0(A),progressMessagesForMessage:A,shouldAnimate:!1,shouldShowDot:!1,style:"condensed",isTranscriptMode:!1,isStatic:!0})))),V>0&&GQ.createElement(z,{dimColor:!0},"+",V," more tool ",V===1?"use":"uses"," ",GQ.createElement(D_,null))))}function $j2(A,{progressMessagesForMessage:Q,tools:B,verbose:G}){let Z=Q[0]?.data?.agentId;return GQ.createElement(GQ.Fragment,null,!1,P81(Q,{tools:B,verbose:G}),GQ.createElement(m8,null))}function wj2(A,{progressMessagesForMessage:Q,tools:B,verbose:G}){return GQ.createElement(GQ.Fragment,null,P81(Q,{tools:B,verbose:G}),GQ.createElement(K3,{result:A,verbose:G}))}function qG5(A){let Q=A.filter((Z)=>{let Y=Z.data.message;return Y.type==="user"&&Y.message.content.some((J)=>J.type==="tool_result")}).length,B=[...A].reverse().find((Z)=>Z.data.message.type==="assistant"),G=null;if(B?.data.message.type==="assistant"){let Z=B.data.message.message.usage;G=(Z.cache_creation_input_tokens??0)+(Z.cache_read_input_tokens??0)+Z.input_tokens+Z.output_tokens}return{toolUseCount:Q,tokens:G}}function Nj2(A,Q){let{shouldAnimate:B,tools:G}=Q,Z=A.map(({param:V,isResolved:E,isError:D,progressMessages:H})=>{let F=qG5(H),C=LG5(H,G),U=VG0.safeParse(V.input),O=U.success?XG0(U.data):"Task",q=U.success?U.data.description:void 0,M=U.success?WG0(U.data):void 0,_=U.success&&"run_in_background"in U.data&&U.data.run_in_background===!0;return{id:V.id,agentType:O,description:q,toolUseCount:F.toolUseCount,tokens:F.tokens,isResolved:E,isError:D,isAsync:_,color:M,lastToolInfo:C}}),Y=A.some((V)=>!V.isResolved),J=A.some((V)=>V.isError),I=!Y,X=Z.length>0&&Z.every((V)=>V.agentType===Z[0]?.agentType),W=X?Z[0]?.agentType:null,K=Z.every((V)=>V.isAsync);return GQ.createElement(j,{flexDirection:"column",marginTop:1},GQ.createElement(j,{flexDirection:"row"},GQ.createElement(C0A,{shouldAnimate:B&&Y,isUnresolved:Y,isError:J}),GQ.createElement(z,null,I?GQ.createElement(GQ.Fragment,null,GQ.createElement(z,{bold:!0},A.length)," ",W?`${W} agents`:"agents"," ",K?"launched":"finished"):GQ.createElement(GQ.Fragment,null,"Running ",GQ.createElement(z,{bold:!0},A.length)," ",W?`${W} agents`:"agents","‚Ä¶")," "),GQ.createElement(D_,null)),Z.map((V,E)=>GQ.createElement(Fj2,{key:V.id,agentType:V.agentType,description:V.description,toolUseCount:V.toolUseCount,tokens:V.tokens,color:V.color,isLast:E===Z.length-1,isResolved:V.isResolved,isError:V.isError,isAsync:V.isAsync,shouldAnimate:B,lastToolInfo:V.lastToolInfo,hideType:X})))}function XG0(A){if(A?.subagent_type&&A.subagent_type!==MB1.agentType)return A.subagent_type;return"Task"}function WG0(A){if(!A?.subagent_type)return;return QZA(A.subagent_type)}function LG5(A,Q){let B=[...A].reverse().find((G)=>{let Z=G.data.message;return Z.type==="user"&&Z.message.content.some((Y)=>Y.type==="tool_result")});if(B?.data.message.type==="user"){let G=B.data.message.message.content.find((Z)=>Z.type==="tool_result");if(G?.type==="tool_result"){let Z=G.tool_use_id,Y=A.find((J)=>{let I=J.data.message;return I.type==="assistant"&&I.message.content.some((X)=>X.type==="tool_use"&&X.id===Z)});if(Y?.data.message.type==="assistant"){let J=Y.data.message.message.content.find((I)=>I.type==="tool_use"&&I.id===Z);if(J?.type==="tool_use"){let I=Q.find((V)=>V.name===J.name);if(!I)return J.name;let X=J.input,W=I.inputSchema.safeParse(X),K=I.userFacingName(W.success?W.data:void 0);if(I.getToolUseSummary){let V=I.getToolUseSummary(W.success?W.data:void 0);if(V)return`${K}: ${V}`}return K}}}}return null}var GQ,JG0=3,$G5=9,wG5=7,NG5="Initializing‚Ä¶";var KG0=L(()=>{fA();lW();DI();m21();h4();PIA();HB();HB();GB0();YM();Ue();s4();l6();o61();Cj2();eNA();xMA();M9();GQ=o(WA(),1)});function S81({onBackground:A}){k1((B,G)=>{if(B==="b"&&G.ctrl)A()});let Q=JQ.terminal==="tmux"?"ctrl+b ctrl+b":"ctrl+b";return $Y.createElement(j,{paddingLeft:5},$Y.createElement(z,{dimColor:!0},$Y.createElement(R0,{shortcut:Q,action:"run in background"})))}function Lj2(A,{verbose:Q,theme:B}){let{command:G}=A;if(!G)return null;let Z=G;if(G.includes(`"$(cat <<'EOF'`)){let Y=G.match(/^(.*?)"?\$\(cat <<'EOF'\n([\s\S]*?)\n\s*EOF\n\s*\)"(.*)$/);if(Y&&Y[1]&&Y[2]){let J=Y[1],I=Y[2],X=Y[3]||"";Z=`${J.trim()} "${I.trim()}"${X.trim()}`}}if(!Q){let Y=Z.split(`
3759:Other exit codes - show stderr to user only`,matcherMetadata:{fieldToMatch:"notification_type",values:["permission_prompt","idle_prompt","auth_success","elicitation_dialog"]}},UserPromptSubmit:{summary:"When the user submits a prompt",description:`Input to command is JSON with original user prompt text.
4312:`,signal:Q,enablePromptCaching:!1,options:{querySource:"bash_extract_prefix",agents:[],isNonInteractiveSession:B,hasAppendSystemPrompt:!1,mcpTools:[],agentIdOrSessionId:W0()}});clearTimeout(G);let I=Date.now()-Z,X=typeof J.message.content==="string"?J.message.content:Array.isArray(J.message.content)?J.message.content.find((W)=>W.type==="text")?.text??"none":"none";if(X.startsWith(tW))r("tengu_bash_prefix",{success:!1,error:"API error",durationMs:I}),Y=null;else if(X==="command_injection_detected")r("tengu_bash_prefix",{success:!1,error:"command_injection_detected",durationMs:I}),Y={commandPrefix:null};else if(X==="git")r("tengu_bash_prefix",{success:!1,error:'prefix "git"',durationMs:I}),Y={commandPrefix:null};else if(X==="none")r("tengu_bash_prefix",{success:!1,error:'prefix "none"',durationMs:I}),Y={commandPrefix:null};else if(!A.startsWith(X))r("tengu_bash_prefix",{success:!1,error:"command did not start with prefix",durationMs:I}),Y={commandPrefix:null};else r("tengu_bash_prefix",{success:!0,durationMs:I}),Y={commandPrefix:X};return Y}catch(J){throw clearTimeout(G),J}},(A)=>A),gg2=new Set(["&&","||",";",";;","|"]),zK5=new Set([...gg2,">&",">",">>"])});var ug2=L(()=>{h1();k8A()});function pG0(A){return dcA(A)}function IL(A){let Q=A.match(/^([^(]+)\(([^)]+)\)$/);if(!Q)return{toolName:A};let B=Q[1],G=Q[2];if(!B||!G)return{toolName:A};return{toolName:B,ruleContent:G}}function B5(A){return A.ruleContent?`${A.toolName}(${A.ruleContent})`:A.toolName}function GXA(A){return oY0.flatMap((Q)=>(A.alwaysAllowRules[Q]||[]).map((B)=>({source:Q,ruleBehavior:"allow",ruleValue:IL(B)})))}function JK(A,Q){if(Q)switch(Q.type){case"hook":return Q.reason?`Hook '${Q.hookName}' blocked this action: ${Q.reason}`:`Hook '${Q.hookName}' requires approval for this ${A} command`;case"rule":{let G=B5(Q.rule.ruleValue),Z=pG0(Q.rule.source);return`Permission rule '${G}' from ${Z} requires approval for this ${A} command`}case"subcommandResults":{let G=[];for(let[Z,Y]of Q.reasons)if(Y.behavior==="ask"||Y.behavior==="passthrough")if(A==="Bash"){let{commandWithoutRedirections:J,redirections:I}=UT(Z),X=I.length>0?J:Z;G.push(X)}else G.push(Z);if(G.length>0)return`This ${A} command contains multiple operations. The following part${G.length>1?"s":""} require${G.length>1?"":"s"} approval: ${G.join(", ")}`;return`This ${A} command contains multiple operations that require approval`}case"permissionPromptTool":return`Tool '${Q.permissionPromptToolName}' requires approval for this ${A} command`;case"sandboxOverride":return"Run outside of the sandbox";case"classifier":return`Classifier '${Q.classifier}' requires approval for this ${A} command: ${Q.reason}`;case"workingDir":return Q.reason;case"other":return Q.reason;case"mode":return`Current permission mode (${Bf(Q.mode)}) requires approval for this ${A} command`;case"asyncAgent":return Q.reason}return`Claude requested permissions to use ${A}, but you haven't granted it yet.`}function AXA(A){return oY0.flatMap((Q)=>(A.alwaysDenyRules[Q]||[]).map((B)=>({source:Q,ruleBehavior:"deny",ruleValue:IL(B)})))}function r81(A){return oY0.flatMap((Q)=>(A.alwaysAskRules[Q]||[]).map((B)=>({source:Q,ruleBehavior:"ask",ruleValue:IL(B)})))}function rY0(A,Q){if(Q.ruleValue.ruleContent!==void 0)return!1;if(Q.ruleValue.toolName===A.name)return!0;let B=KV(Q.ruleValue.toolName),G=KV(A.name);return B!==null&&G!==null&&B.toolName===void 0&&B.serverName===G.serverName}function mB0(A,Q){return GXA(A).find((B)=>rY0(Q,B))||null}function dB0(A,Q){return AXA(A).find((B)=>rY0(Q,B))||null}function cB0(A,Q){return r81(A).find((B)=>rY0(Q,B))||null}function jU(A,Q,B){return sY0(A,Q.name,B)}function sY0(A,Q,B){let G=new Map,Z=[];switch(B){case"allow":Z=GXA(A);break;case"deny":Z=AXA(A);break;case"ask":Z=r81(A);break}for(let Y of Z)if(Y.ruleValue.toolName===Q&&Y.ruleValue.ruleContent!==void 0&&Y.ruleBehavior===B)G.set(Y.ruleValue.ruleContent,Y);return G}async function LK5(A,Q,B,G){if(B.abortController.signal.aborted)throw new UJ;let Z=await B.getAppState(),Y=dB0(Z.toolPermissionContext,A);if(Y)return{behavior:"deny",decisionReason:{type:"rule",rule:Y},message:`Permission to use ${A.name} has been denied.`};let J=cB0(Z.toolPermissionContext,A);if(J){if(!(A.name===e9&&NB.isSandboxingEnabled()&&NB.isAutoAllowBashIfSandboxedEnabled()))return{behavior:"ask",decisionReason:{type:"rule",rule:J},message:JK(A.name)}}let I={behavior:"passthrough",message:JK(A.name)};try{let V=A.inputSchema.parse(Q);I=await A.checkPermissions(V,B)}catch(V){s(V)}if(I?.behavior==="deny")return I;if(A.requiresUserInteraction?.()&&I?.behavior==="ask")return I;if(Z=await B.getAppState(),Z.toolPermissionContext.mode==="bypassPermissions"||Z.toolPermissionContext.mode==="plan"&&Z.toolPermissionContext.isBypassPermissionsModeAvailable)return{behavior:"allow",updatedInput:Q,decisionReason:{type:"mode",mode:Z.toolPermissionContext.mode}};let W=mB0(Z.toolPermissionContext,A);if(W)return{behavior:"allow",updatedInput:Q,decisionReason:{type:"rule",rule:W}};let K=I.behavior==="passthrough"?{...I,behavior:"ask",message:JK(A.name,I.decisionReason)}:I;if(K.behavior==="ask"&&K.suggestions)f(`Permission suggestions for ${A.name}: ${JSON.stringify(K.suggestions,null,2)}`);return K}async function Ux2({rule:A,initialContext:Q,setToolPermissionContext:B}){if(A.source==="policySettings"||A.source==="flagSettings"||A.source==="command")throw Error("Cannot delete permission rules from read-only settings");let G=eI(Q,{type:"removeRules",rules:[A.ruleValue],behavior:A.ruleBehavior,destination:A.source});switch(A.source){case"localSettings":case"userSettings":case"projectSettings":{fiQ(A);break}case"cliArg":case"session":break}B(G)}function mg2(A,Q){let B=new Map;for(let Z of A){let Y=`${Z.source}:${Z.ruleBehavior}`;if(!B.has(Y))B.set(Y,[]);B.get(Y).push(Z.ruleValue)}let G=[];for(let[Z,Y]of B){let[J,I]=Z.split(":");G.push({type:Q,rules:Y,behavior:I,destination:J})}return G}function jS2(A,Q){let B=mg2(Q,"addRules");return sk(A,B)}function dg2(A,Q){let B=mg2(Q,"replaceRules");return sk(A,B)}var oY0,iU=async(A,Q,B,G,Z)=>{let Y=await LK5(A,Q,B,G);if(Y.behavior==="ask"){let J=await B.getAppState();if(J.toolPermissionContext.mode==="dontAsk")return{behavior:"deny",decisionReason:{type:"mode",mode:"dontAsk"},message:`Permission to use ${A.name} has been auto-denied in dontAsk mode.`};if(J.toolPermissionContext.shouldAvoidPermissionPrompts)return{behavior:"deny",decisionReason:{type:"asyncAgent",reason:"Permission prompts are not available in this context"},message:`Permission to use ${A.name} has been auto-denied (prompts unavailable).`}}return Y};var oG=L(()=>{tK();eZ();h1();Y0();_s();tI();SJ();XI();Gw();RU();ug2();J4();oY0=[...JL,"cliArg","command","session"]});function cg2(){}function r51(){let A=NQ()||{},Q=d1().env||{},B=A.env||{};for(let[G,Z]of Object.entries(Q))if(xLA.has(G.toUpperCase()))process.env[G]=Z;for(let[G,Z]of Object.entries(B))if(xLA.has(G.toUpperCase()))process.env[G]=Z;cg2()}function dTA(){let A=NQ()||{};Object.assign(process.env,d1().env),Object.assign(process.env,A.env),cg2()}var cTA=L(()=>{xQ();jB();WA0()});function MK5({filePath:A,errorDescription:Q,onExit:B,onReset:G}){k1((J,I)=>{if(I.escape)B()});let Z=_Q();return uH.default.createElement(uH.default.Fragment,null,uH.default.createElement(j,{flexDirection:"column",borderColor:"error",borderStyle:"round",padding:1,width:70,gap:1},uH.default.createElement(z,{bold:!0},"Configuration Error"),uH.default.createElement(j,{flexDirection:"column",gap:1},uH.default.createElement(z,null,"The configuration file at ",uH.default.createElement(z,{bold:!0},A)," contains invalid JSON."),uH.default.createElement(z,null,Q)),uH.default.createElement(j,{flexDirection:"column"},uH.default.createElement(z,{bold:!0},"Choose an option:"),uH.default.createElement(S0,{options:[{label:"Exit and fix manually",value:"exit"},{label:"Reset with default configuration",value:"reset"}],onChange:(J)=>{if(J==="exit")B();else G()},onCancel:B}))),Z.pending?uH.default.createElement(z,{dimColor:!0},"Press ",Z.keyName," again to exit"):uH.default.createElement(oK,null))}async function pg2({error:A}){let Q={exitOnCtrlC:!1,theme:OK5};await new Promise(async(B)=>{let{unmount:G}=await $5(uH.default.createElement(u5,null,uH.default.createElement(MK5,{filePath:A.filePath,errorDescription:A.message,onExit:()=>{G(),B(),process.exit(1)},onReset:()=>{jA().writeFileSync(A.filePath,JSON.stringify(A.defaultConfig,null,2),{flush:!1,encoding:"utf8"}),G(),B(),process.exit(0)}})),Q)})}var uH,OK5="dark";var lg2=L(()=>{fA();Y3();fA();XQ();c9();u2();uH=o(WA(),1)});import{realpathSync as RK5,existsSync as _K5}from"fs";async function ig2(){try{let A=await tL();if(!A){f("Not in a GitHub repository, skipping path mapping update");return}let Q;try{Q=RK5(pQ())}catch{Q=pQ()}let B=A.toLowerCase(),Z=d1().githubRepoPaths?.[B]??[];if(Z.includes(Q)){f(`Path ${Q} already tracked for repo ${B}`);return}let Y=[Q,...Z];i0((J)=>({...J,githubRepoPaths:{...J.githubRepoPaths,[B]:Y}})),f(`Added ${Q} to tracked paths for repo ${B}`)}catch(A){f(`Error updating repo path mapping: ${A}`)}}function ng2(A){let Q=d1(),B=A.toLowerCase();return Q.githubRepoPaths?.[B]??[]}function ag2(A){return A.filter((Q)=>_K5(Q))}async function og2(A,Q){try{let{stdout:B,code:G}=await L3("git",["remote","get-url","origin"],{cwd:A,preserveOutputOnError:!1});if(G!==0||!B)return!1;let Z=Cb(B.trim());if(!Z)return!1;return Z.toLowerCase()===Q.toLowerCase()}catch{return!1}}function rg2(A,Q){let B=d1(),G=A.toLowerCase(),Z=B.githubRepoPaths?.[G]??[],Y=Z.filter((I)=>I!==Q);if(Y.length===Z.length)return;let J={...B.githubRepoPaths};if(Y.length===0)delete J[G];else J[G]=Y;i0((I)=>({...I,githubRepoPaths:J})),f(`Removed ${Q} from tracked paths for repo ${G}`)}var s51=L(()=>{BAA();xQ();g0();Y0();I6()});function g5(A){return A.replace(/[^a-zA-Z0-9_-]/g,"_")}import{join as tg2}from"path";import{tmpdir as TK5}from"os";import{writeFile as jK5,mkdir as PK5,rm as sg2,readdir as SK5}from"fs/promises";function Eg(){return process.env.USE_MCP_CLI_DIR||tg2(TK5(),"claude-code-mcp-cli")}function wXA(){if(uZ()){let A=process.env.CLAUDE_CODE_SESSION_ID;if(A)return A}return W0()}function eg2(){if(!uZ())return;U8(async()=>{try{let A=t51();await sg2(A,{force:!0});let Q=Eg();if((await SK5(Q)).length===0)await sg2(Q,{recursive:!0,force:!0})}catch{}})}function t51(){let A=wXA();return tg2(Eg(),`${A}.json`)}function xK5(A){let Q={name:A.name,type:A.type};if(A.type==="connected")return{...Q,capabilities:A.capabilities};return Q}async function yK5(A){let Q="";try{Q=await A.description({},{isNonInteractiveSession:!1,toolPermissionContext:{mode:"default",additionalWorkingDirectories:new Map,alwaysAllowRules:{},alwaysDenyRules:{},alwaysAskRules:{},isBypassPermissionsModeAvailable:!1},tools:[]})}catch{}return{name:A.name,description:Q,inputJSONSchema:A.inputJSONSchema,isMcp:A.isMcp,originalToolName:A.originalMcpToolName}}async function Au2(A,Q,B){if(!uZ())return;try{await PK5(Eg(),{recursive:!0});let G=await Promise.all(Q.filter((X)=>X.isMcp).map(yK5)),Z={},Y={};for(let X of A){Z[X.name]=X.config;let W=g5(X.name);if(Y[W]&&Y[W]!==X.name)console.warn(`Warning: MCP server name collision detected. Both "${Y[W]}" and "${X.name}" normalize to "${W}". Only "${X.name}" will be accessible via normalized lookup.`);Y[W]=X.name}let J={clients:A.map(xK5),configs:Z,tools:G,resources:B,normalizedNames:Y},I=t51();await jK5(I,JSON.stringify(J,null,2))}catch{}}var NXA=L(()=>{g0();bW();CV()});function e51(){if(tY0)return;Bu2(),tY0=!0}function Bu2(){let A=diB();if(A)DK0(A,(B,G)=>{let Z=A?.createCounter(B,G);return{add(Y,J={}){let X={...HYA(),...J};Z?.add(Y,X)}}})}var tY0=!1,Qu2;var eY0=L(()=>{Ta();g0();xQ();xQ();cTA();eZ();lg2();iY();bW();o2();g0();IA0();oHA();N01();Xd();u6A();$9A();Rs();F2();LYA();xQ();g0();Xq();k10();s51();NXA();CV();SNA();cY();Qu2=Z0(()=>{L9("init_function_start");try{pTA(),L9("init_configs_enabled"),r51(),L9("init_safe_env_vars_applied"),NF.initialize(),L9("init_settings_detector_initialized"),Gu2(),L9("init_after_graceful_shutdown"),xbQ(),L9("init_after_1p_event_logging"),ou0(),L9("init_after_oauth_populate");let A=KHA()&&!QY(!0)&&!D4(),Q=BnB(),B=A||Q;if(Q)QnB();if(L9("init_after_defer_check"),!B)Bu2(),tY0=!0;if(L9("init_telemetry_setup"),Zu2(),NCQ(),RCQ(),L9("init_network_configured"),ag0(),qsB(),ig2(),YLB(),U8(JLB),uZ())process.env.CLAUDE_CODE_SESSION_ID=W0(),eg2();if($XA())Yu2();L9("init_function_end")}catch(A){if(A instanceof Qz)return pg2({error:A});else throw A}})});function Nn(){return{settings:R7(),tasks:{},verbose:!1,mainLoopModel:null,mainLoopModelForSession:null,statusLineText:void 0,showExpandedTodos:!1,toolPermissionContext:s$(),agent:void 0,agentDefinitions:{activeAgents:[],allAgents:[]},fileHistory:{snapshots:[],trackedFiles:new Set},mcp:{clients:[],tools:[],commands:[],resources:{}},plugins:{enabled:[],disabled:[],commands:[],agents:[],errors:[],installationStatus:{marketplaces:[],plugins:[]}},todos:{},notifications:{current:null,queue:[]},elicitation:{queue:[]},thinkingEnabled:LB1(),feedbackSurvey:{timeLastShown:null,submitCountAtLastAppearance:null},sessionHooks:{},inbox:{messages:[]},workerPermissions:{queue:[],selectedIndex:0},workerSandboxPermissions:{queue:[],selectedIndex:0},pendingWorkerRequest:null,pendingSandboxRequest:null,promptSuggestion:{text:null,shownAt:0,acceptedAt:0},queuedCommands:[],gitDiff:{stats:null,perFileStats:new Map,hunks:new Map,lastUpdated:0}}}function u5({children:A,initialState:Q,onChangeAppState:B}){if(dV.useContext(Ju2))throw Error("AppStateProvider can not be nested within another AppStateProvider");let[Z,Y]=dV.useState({currentState:Q??Nn(),previousState:null}),J=dV.useCallback((X)=>{Y(({currentState:W})=>{let K={currentState:X(W),previousState:W};return B?.({newState:K.currentState,oldState:K.previousState}),K})},[B]),I=dV.useMemo(()=>{let X=[Z.currentState,J];return X.__IS_INITIALIZED__=!0,X},[Z.currentState,J]);return dV.useEffect(()=>{let{toolPermissionContext:X}=Z.currentState;if(X.isBypassPermissionsModeAvailable&&ZTA())f("Disabling bypass permissions mode on mount (remote settings loaded before mount)"),J((W)=>({...W,toolPermissionContext:d_A(W.toolPermissionContext)}))},[]),V8A(dV.useCallback((X,W)=>{f(`Settings changed from ${X}, updating AppState`);let K=icA();r51(),e51(),J((V)=>{let E=dg2(V.toolPermissionContext,K);if(E.isBypassPermissionsModeAvailable&&ZTA())E=d_A(E);return{...V,settings:W,toolPermissionContext:E}})},[J])),dV.default.createElement(Ju2.Provider,{value:!0},dV.default.createElement(AJ0.Provider,{value:I},A))}function yQ(){let A=dV.useContext(AJ0);if(!A.__IS_INITIALIZED__)throw ReferenceError("useAppState cannot be called outside of an <AppStateProvider />");return A}function fF2(){let A=dV.useContext(AJ0);if(!A.__IS_INITIALIZED__)return null;return A}var dV,AJ0,Ju2;var u2=L(()=>{lcA();oG();_s();f1A();qM();jB();Y0();eY0();cTA();dV=o(WA(),1);AJ0=dV.default.createContext([{},(A)=>A]),Ju2=dV.default.createContext(!1)});function xG(){let[A,Q]=yQ(),B=lTA.useCallback(()=>{Q((Z)=>{let Y=vK5(Z.notifications.queue);if(Z.notifications.current!==null||!Y)return Z;return GQA=setTimeout(()=>{GQA=null,Q((J)=>{if(J.notifications.current?.key!==Y.key)return J;return{...J,notifications:{queue:J.notifications.queue,current:null}}}),B()},Y.timeoutMs??Iu2),{...Z,notifications:{queue:Z.notifications.queue.filter((J)=>J!==Y),current:Y}}})},[Q]),G=lTA.useCallback((Z)=>{if(Z.priority==="immediate"){if(GQA)clearTimeout(GQA),GQA=null;GQA=setTimeout(()=>{GQA=null,Q((Y)=>{if(Y.notifications.current?.key!==Z.key)return Y;return{...Y,notifications:{queue:Y.notifications.queue.filter((J)=>!Z.invalidates?.includes(J.key)),current:null}}}),B()},Z.timeoutMs??Iu2),Q((Y)=>({...Y,notifications:{current:Z,queue:[...Y.notifications.current?[Y.notifications.current]:[],...Y.notifications.queue].filter((J)=>J.priority!=="immediate"&&!Z.invalidates?.includes(J.key))}}));return}Q((Y)=>{if(Z.priority==="immediate")return Y;let I=!new Set(Y.notifications.queue.map((X)=>X.key)).has(Z.key)&&Y.notifications.current?.key!==Z.key;return{...Y,notifications:{current:Y.notifications.current,queue:I?[...Y.notifications.queue.filter((X)=>X.priority!=="immediate"&&!Z.invalidates?.includes(X.key)),Z]:Y.notifications.queue}}}),B()},[Q,B]);return lTA.useEffect(()=>{if(A.notifications.queue.length>0)B()},[]),{addNotification:G}}function vK5(A){return A.sort((Q,B)=>{let G=Xu2[Q.priority]??999,Z=Xu2[B.priority]??999;return G-Z})[0]}var lTA,Iu2=8000,GQA=null,Xu2;var UC=L(()=>{u2();lTA=o(WA(),1);Xu2={immediate:0,high:1,medium:2,low:3}});function Wu2(A){return function(Q){return(new Map(A).get(Q)??(()=>{}))(Q)}}function g61({value:A,onChange:Q,onSubmit:B,onExit:G,onExitMessage:Z,onHistoryUp:Y,onHistoryDown:J,onHistoryReset:I,mask:X="",multiline:W=!1,cursorChar:K,invert:V,columns:E,onImagePaste:D,disableCursorMovementForUpDownKeys:H=!1,externalOffset:F,onOffsetChange:C,inputFilter:U}){let O=F,q=C,M=O3.fromText(A,E,O),{addNotification:_}=xG(),T=lk((GA)=>{Z?.(GA,"Ctrl-C")},()=>G?.(),()=>{if(A)Q(""),q(0),I?.()}),y=lk((GA)=>{if(!A||!GA)return;_({key:"escape-again-to-clear",text:"Press Escape again to clear",priority:"immediate",timeoutMs:1000})},()=>{if(A){if(A.trim()!=="")Ns(A);Q(""),q(0),I?.()}});function h(){if(A.trim()!=="")Ns(A),I?.();return O3.fromText("",E,0)}let x=lk((GA)=>{if(A!=="")return;Z?.(GA,"Ctrl-D")},()=>{if(A!=="")return;G?.()});function m(){if(M.text==="")return x(),M;return M.del()}function g(){if(!D)return;OcA().then((GA)=>{if(GA)D(GA.base64,GA.mediaType);else _({key:"no-image-in-clipboard",text:`No image found in clipboard. Use ${qs.displayText} to paste images.`,priority:"immediate",timeoutMs:1000})})}function t(){let{cursor:GA,killed:zA}=M.deleteToLineEnd();return sdA(zA,!0),GA}function p(){let{cursor:GA,killed:zA}=M.deleteToLineStart();return sdA(zA,!0),GA}function k(){let{cursor:GA,killed:zA}=M.deleteWordBefore();return sdA(zA,!0),GA}function c(){let GA=mdQ();if(GA.length>0)return M.insert(GA);return M}let e=Wu2([["a",()=>M.startOfLine()],["b",()=>M.left()],["c",T],["d",m],["e",()=>M.endOfLine()],["f",()=>M.right()],["h",()=>M.backspace()],["k",t],["l",()=>h()],["n",()=>EA()],["p",()=>OA()],["u",p],["w",k],["y",c]]),AA=Wu2([["b",()=>M.prevWord()],["f",()=>M.nextWord()],["d",()=>M.deleteWordAfter()]]);function VA(GA){if(W&&M.offset>0&&M.text[M.offset-1]==="\\")return clQ(),M.backspace().insert(`
4699:${_9}`)}if(Object.keys(OQ).length>0){let _9=cr(OQ,(GB)=>({...GB,scope:"dynamic"}));YA={...YA,..._9}}}let CA=I.strictMcpConfig||!1;if(gi1()){if(CA)process.stderr.write(cA.red("You cannot use --strict-mcp-config when an enterprise MCP config is present")),process.exit(1);if(YA&&!fwB(YA))process.stderr.write(cA.red("You cannot dynamically configure MCP servers when an enterprise MCP config is present")),process.exit(1)}let MA,NA,{toolPermissionContext:UA,warnings:LA}=_S2({allowedToolsCli:D,disallowedToolsCli:H,baseToolsCli:E,permissionMode:TA,allowDangerouslySkipPermissions:V,addDirs:U});LA.forEach((d0)=>{console.error(d0)}),Ou2();let{servers:lA}=CA?{servers:{}}:await T_(),gA={...lA,...YA},I1={},$1={};for(let[d0,OQ]of Object.entries(gA)){let fB=OQ;if(fB.type==="sdk")I1[d0]=fB;else $1[d0]=fB}if(L9("action_mcp_configs_loaded"),g&&g!=="text"&&g!=="stream-json")console.error(`Error: Invalid input format "${g}".`),process.exit(1);if(g==="stream-json"&&m!=="stream-json")console.error("Error: --input-format=stream-json requires output-format=stream-json."),process.exit(1);if(SA){if(g!=="stream-json"||m!=="stream-json")console.error("Error: --sdk-url requires both --input-format=stream-json and --output-format=stream-json."),process.exit(1)}if(I.replayUserMessages){if(g!=="stream-json"||m!=="stream-json")console.error("Error: --replay-user-messages requires both --input-format=stream-json and --output-format=stream-json."),process.exit(1)}if(T){if(!GA||m!=="stream-json")Uv("Error: --include-partial-messages requires --print and --output-format=stream-json."),process.exit(1)}if(E.length>0&&!GA)Uv("Error: --tools can only be used with --print mode."),process.exit(1);if(I.sessionPersistence===!1&&!GA)Uv("Error: --no-session-persistence can only be used with --print mode."),process.exit(1);let RA=await ZF5(J||"",g??"text");L9("action_after_input_prompt");let B1=UH(UA);L9("action_tools_loaded");let m1;if(Oq2({isNonInteractiveSession:GA})&&I.jsonSchema)m1=JSON.parse(I.jsonSchema);if(m1){let d0=r31(m1);if(d0)B1=[...B1,d0],r("tengu_structured_output_enabled",{schema_property_count:Object.keys(m1.properties||{}).length,has_required_fields:Boolean(m1.required)});else r("tengu_structured_output_failure",{error:"Invalid JSON schema"})}L9("action_before_setup"),await m71(WI0(),TA,V,c,_?QC(_):void 0),L9("action_after_setup");let S1=I.model==="default"?xk():I.model,H0=O==="default"?xk():O,ZQ=r1(),[o0,EQ]=await Promise.all([FC(ZQ),JQ2(ZQ)]);L9("action_commands_loaded");let WQ=[];if(h)try{let d0=h8(h);if(d0)WQ=_B1(d0,"flagSettings")}catch(d0){s(d0 instanceof Error?d0:Error(String(d0)))}let w1=[...EQ.allAgents,...WQ],eA={...EQ,allAgents:w1,activeAgents:ix(w1)},V1=x??R7().agent,R1;if(V1){if(R1=eA.activeAgents.find((d0)=>d0.agentType===V1),!R1)f(`Warning: agent "${V1}" not found. Available agents: ${eA.activeAgents.map((d0)=>d0.agentType).join(", ")}. Using default behavior.`)}if(!GA){if(await Hp2(TA,V,o0)&&J?.trim().toLowerCase()==="/login")J=""}if(process.exitCode!==void 0){f("Graceful shutdown initiated, skipping further initialization");return}uRB().catch((d0)=>s(d0)),yvQ(),zw2(),Xp2(),td2(D4());let G0=PtA($1),U0=NA===void 0&&(RA||GA)?await G0:{clients:[],tools:[],commands:[]},C0=MA?MA:U0.clients,HA=NA?NA:U0.tools,wA=NA?[]:U0.commands,tA;if(NA!==void 0)tA=new JjA(C0,HA);else if(_n())tA=new JjA(C0,HA),tA.start().then(({url:d0})=>{let OQ=tA.getSecret();XQA({url:d0,key:OQ}),f(`[MCP CLI Endpoint] Started at ${d0}`)}).catch((d0)=>{s(d0 instanceof Error?d0:Error(String(d0)))}),U8(async()=>{await tA?.stop()});d3("info","started"),U8(async()=>{d3("info","exited")}),JF5({hasInitialPrompt:Boolean(J),hasStdin:Boolean(RA),verbose:t,debug:X,debugToStderr:W,print:p??!1,outputFormat:m??"text",inputFormat:g??"text",numAllowedTools:D.length,numDisallowedTools:H.length,mcpClientCount:Object.keys(gA).length,worktree:c,skipWebFetchPreflight:R7().skipWebFetchPreflight,githubActionInputs:process.env.GITHUB_ACTION_INPUTS,dangerouslySkipPermissionsPassed:K??!1,modeIsBypass:TA==="bypassPermissions",allowDangerouslySkipPermissionsPassed:V,systemPromptFlag:zA?I.systemPromptFile?"file":"flag":void 0,appendSystemPromptFlag:bA?I.appendSystemPromptFile?"file":"flag":void 0}),U02($1,UA),meA(null,"initialization"),lH5(),iH5(),await EL2(),L9("action_after_plugins_init");let N1=S1;if(!N1&&R1?.model&&R1.model!=="inherit")N1=nI(R1.model);if(Oa(N1),GA){if(m==="stream-json"||m==="json")lK0(!0);dTA();let d0=k?[]:o0.filter((fB)=>fB.type==="prompt"&&!fB.disableNonInteractive||fB.type==="local"&&fB.supportsNonInteractive),OQ=Nn();if(OQ={...OQ,mcp:{...OQ.mcp,clients:C0,commands:wA,tools:HA},toolPermissionContext:UA},UA.mode==="bypassPermissions"||V)TS2(UA);if(I.sessionPersistence===!1)hK0(!0);cc2(RA,async()=>OQ,(fB)=>{let _9=OQ;OQ=fB(OQ),uy({newState:OQ,oldState:_9})},d0,B1,I1,eA.activeAgents,{continue:I.continue,resume:I.resume,verbose:t,outputFormat:m,jsonSchema:m1,permissionPromptToolName:I.permissionPromptTool,allowedTools:D,maxThinkingTokens:I.maxThinkingTokens,maxTurns:I.maxTurns,maxBudgetUsd:I.maxBudgetUsd,systemPrompt:zA,appendSystemPrompt:bA,userSpecifiedModel:S1,fallbackModel:H0,sdkBetas:q.length>0?q:void 0,teleport:yA,sdkUrl:SA,replayUserMessages:I.replayUserMessages,includePartialMessages:T,forkSession:I.forkSession||!1,resumeSessionAt:I.resumeSessionAt||void 0,rewindFiles:I.rewindFiles,enableAuthStatus:I.enableAuthStatus});return}let C1=GF5(!1);nLB(),r("tengu_startup_manual_model_config",{cli_flag:I.model,env_var:process.env.ANTHROPIC_MODEL,settings_file:(R7()||{}).model,subscriptionType:d6(),agent:V1});let D1=I.model||process.env.ANTHROPIC_MODEL||R7().model;if(RB()&&!lq()&&D1!==void 0&&FmA(D1))console.error(cA.yellow("Your plan doesn't include Opus in Claude Code. You can turn on /extra-usage or /upgrade to Max to access it. The current model is now Sonnet."));EK0(CmA()||null);let X0=zPA(),p1=nI(X0??xk()),k0=O81(p1),KQ=[];if(G1)KQ.push({key:"permission-mode-notification",text:G1,priority:"high"});if(k0)KQ.push({key:"model-deprecation-warning",text:k0,color:"warning",priority:"high"});let bB=W0(),IB={settings:R7(),tasks:{},verbose:t??d1().verbose??!1,mainLoopModel:X0,mainLoopModelForSession:null,showExpandedTodos:d1().showExpandedTodos??!1,toolPermissionContext:UA,agent:R1?.agentType,agentDefinitions:eA,mcp:{clients:[],tools:[],commands:[],resources:{}},plugins:{enabled:[],disabled:[],commands:[],agents:[],errors:[],installationStatus:{marketplaces:[],plugins:[]}},statusLineText:void 0,notifications:{current:null,queue:KQ},elicitation:{queue:[]},todos:{[bB]:jb(bB)},fileHistory:{snapshots:[],trackedFiles:new Set},thinkingEnabled:LB1(),feedbackSurvey:{timeLastShown:null,submitCountAtLastAppearance:null},sessionHooks:{},inbox:{messages:[]},promptSuggestion:{text:null,shownAt:0,acceptedAt:0},queuedCommands:[],workerPermissions:{queue:[],selectedIndex:0},workerSandboxPermissions:{queue:[],selectedIndex:0},pendingWorkerRequest:null,pendingSandboxRequest:null,gitDiff:{stats:null,perFileStats:new Map,hunks:new Map,lastUpdated:0}},W2=NA?[]:HA;if(aH5(),I.continue)try{r("tengu_continue",{});let d0=await Dl(void 0,void 0);if(!d0)console.error("No conversation found to continue"),process.exit(1);if(!I.forkSession){if(d0.sessionId)E$(d0.sessionId),await eL(),bHA(d0.sessionId)}await $5(o8.default.createElement(u5,{initialState:IB,onChangeAppState:uy},o8.default.createElement(b0A,{debug:X||W,initialPrompt:RA,commands:[...o0,...wA],initialTools:W2,initialMessages:d0.messages,initialFileHistorySnapshots:d0.fileHistorySnapshots,mcpClients:C0,dynamicMcpConfig:YA,mcpCliEndpoint:tA,autoConnectIdeFlag:M,strictMcpConfig:CA,systemPrompt:zA,appendSystemPrompt:bA,mainThreadAgentDefinition:R1,disableSlashCommands:k})),C1)}catch(d0){s(d0 instanceof Error?d0:Error(String(d0))),process.exit(1)}else if(I.resume||yA||ZA){let d0=null,OQ=void 0,fB=QC(I.resume),_9=void 0;if(I.resume&&typeof I.resume==="string"&&!fB){let GB=I.resume.trim();if(GB){let K1=await fGA(GB,{exact:!0});if(K1.length===1)fB=x_(K1[0])??null;else _9=GB}}if(ZA){r("tengu_remote_create_session",{description_length:String(ZA.length)});let GB=await ErB(ZA,new AbortController().signal);if(!GB)r("tengu_remote_create_session_error",{error:"unable_to_create_session"}),process.stderr.write(cA.red(`Error: Unable to create remote session[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "CLAUDE_CODE_SESSION_ACCESS_TOKEN" bundles/ClaudeCodeCode/cli.js bundles/ClaudeAgentSDKCode/cli.js'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 39ms:[0m
[2mbundles/ClaudeCodeCode/cli.js:983:`)||[];for(let G of B){let[Z,Y]=G.split("@");if(Z==="anthropic.claude-code"&&Y)return Y}return null}function f_3(){try{if(dQ()!=="macos")return null;let Q=process.ppid;for(let B=0;B<10;B++){if(!Q||Q===0||Q===1)break;let G=dG(`ps -o command= -p ${Q}`)?.trim();if(G){let Y={"Visual Studio Code.app":"code","Cursor.app":"cursor","Windsurf.app":"windsurf","Visual Studio Code - Insiders.app":"code","VSCodium.app":"codium"},J="/Contents/MacOS/Electron";for(let[I,X]of Object.entries(Y)){let W=G.indexOf(I+"/Contents/MacOS/Electron");if(W!==-1){let K=W+I.length;return G.substring(0,K)+"/Contents/Resources/app/bin/"+X}}}let Z=dG(`ps -o ppid= -p ${Q}`)?.trim();if(!Z)break;Q=parseInt(Z.trim())}return null}catch{return null}}function VDB(A){let Q=f_3();if(Q){if(jA().existsSync(Q))return Q}switch(A){case"vscode":return"code";case"cursor":return"cursor";case"windsurf":return"windsurf";default:break}return null}function drA(){let A=[];try{let Q=dQ();if(Q==="macos"){let B=dG('ps aux | grep -E "Visual Studio Code|Code Helper|Cursor Helper|Windsurf Helper|IntelliJ IDEA|PyCharm|WebStorm|PhpStorm|RubyMine|CLion|GoLand|Rider|DataGrip|AppCode|DataSpell|Aqua|Gateway|Fleet|Android Studio" | grep -v grep')??"";for(let[G,Z]of Object.entries(b7A))for(let Y of Z.processKeywordsMac)if(B.includes(Y)){A.push(G);break}}else if(Q==="windows"){let G=(dG('tasklist | findstr /I "Code.exe Cursor.exe Windsurf.exe idea64.exe pycharm64.exe webstorm64.exe phpstorm64.exe rubymine64.exe clion64.exe goland64.exe rider64.exe datagrip64.exe appcode.exe dataspell64.exe aqua64.exe gateway64.exe fleet.exe studio64.exe"')??"").toLowerCase();for(let[Z,Y]of Object.entries(b7A))for(let J of Y.processKeywordsWindows)if(G.includes(J.toLowerCase())){A.push(Z);break}}else if(Q==="linux"){let G=(dG('ps aux | grep -E "code|cursor|windsurf|idea|pycharm|webstorm|phpstorm|rubymine|clion|goland|rider|datagrip|dataspell|aqua|gateway|fleet|android-studio" | grep -v grep')??"").toLowerCase();for(let[Z,Y]of Object.entries(b7A))for(let J of Y.processKeywordsLinux)if(G.includes(J)){if(Z!=="vscode"){A.push(Z);break}else if(!G.includes("cursor")&&!G.includes("appcode")){A.push(Z);break}}}}catch(Q){s(Q)}return A}function crA(A){let Q=A.find((B)=>B.type==="connected"&&B.name==="ide");return zp1(Q)}function zp1(A){let Q=A?.config;return Q?.type==="sse-ide"||Q?.type==="ws-ide"?Q.ideName:ZW()?WV(Rz.terminal):null}function WV(A){if(!A)return"IDE";let Q=b7A[A];if(Q)return Q.displayName;let B=JDB[A.toLowerCase().trim()];if(B)return B;let G=A.split(" ")[0],Z=G?O_3(G).toLowerCase():null;if(Z){let Y=JDB[Z];if(Y)return Y;return gHA(Z)}return gHA(A)}function ez(A){if(!A)return;let Q=A.find((B)=>B.type==="connected"&&B.name==="ide");return Q?.type==="connected"?Q:void 0}async function FDB(A){try{await Bb("closeAllDiffTabs",{},A)}catch(Q){}}async function CDB(A,Q,B,G){GDB().then(A);let Z=d1().autoInstallIdeExtension??!0;if(process.env.CLAUDE_CODE_IDE_SKIP_AUTO_INSTALL!=="true"&&Z){let Y=Q??k7A();if(Y){if(grA(Y))ZDB(Y).then(async(J)=>{x_3(Y).catch((I)=>{return{installed:!1,error:I.message||"Installation failed",installedVersion:null,ideType:Y}}).then((I)=>{if(G(I),I?.installed)GDB().then(A);if(!J&&I?.installed===!0&&!krA())B()})});else if(U_(Y)&&!krA())ZDB(Y).then(async(J)=>{if(J)B()})}}}var IDB,b7A,TwA,jwA,ZW,S_3,Go7,frA=null,y_3="anthropic.claude-code",EDB,DDB,HDB,JDB,zDB;var PJ=L(()=>{$8();rQ();PuA();I6();xQ();T0();sT1();o2();g0();XQ();h1();k3();$_();Vp1();Ep1();Dp1();Y0();LZ();ur();IDB=o(zR(),1);b7A={cursor:{ideKind:"vscode",displayName:"Cursor",processKeywordsMac:["Cursor Helper","Cursor.app"],processKeywordsWindows:["cursor.exe"],processKeywordsLinux:["cursor"]},windsurf:{ideKind:"vscode",displayName:"Windsurf",processKeywordsMac:["Windsurf Helper","Windsurf.app"],processKeywordsWindows:["windsurf.exe"],processKeywordsLinux:["windsurf"]},vscode:{ideKind:"vscode",displayName:"VS Code",processKeywordsMac:["Visual Studio Code","Code Helper"],processKeywordsWindows:["code.exe"],processKeywordsLinux:["code"]},intellij:{ideKind:"jetbrains",displayName:"IntelliJ IDEA",processKeywordsMac:["IntelliJ IDEA"],processKeywordsWindows:["idea64.exe"],processKeywordsLinux:["idea","intellij"]},pycharm:{ideKind:"jetbrains",displayName:"PyCharm",processKeywordsMac:["PyCharm"],processKeywordsWindows:["pycharm64.exe"],processKeywordsLinux:["pycharm"]},webstorm:{ideKind:"jetbrains",displayName:"WebStorm",processKeywordsMac:["WebStorm"],processKeywordsWindows:["webstorm64.exe"],processKeywordsLinux:["webstorm"]},phpstorm:{ideKind:"jetbrains",displayName:"PhpStorm",processKeywordsMac:["PhpStorm"],processKeywordsWindows:["phpstorm64.exe"],processKeywordsLinux:["phpstorm"]},rubymine:{ideKind:"jetbrains",displayName:"RubyMine",processKeywordsMac:["RubyMine"],processKeywordsWindows:["rubymine64.exe"],processKeywordsLinux:["rubymine"]},clion:{ideKind:"jetbrains",displayName:"CLion",processKeywordsMac:["CLion"],processKeywordsWindows:["clion64.exe"],processKeywordsLinux:["clion"]},goland:{ideKind:"jetbrains",displayName:"GoLand",processKeywordsMac:["GoLand"],processKeywordsWindows:["goland64.exe"],processKeywordsLinux:["goland"]},rider:{ideKind:"jetbrains",displayName:"Rider",processKeywordsMac:["Rider"],processKeywordsWindows:["rider64.exe"],processKeywordsLinux:["rider"]},datagrip:{ideKind:"jetbrains",displayName:"DataGrip",processKeywordsMac:["DataGrip"],processKeywordsWindows:["datagrip64.exe"],processKeywordsLinux:["datagrip"]},appcode:{ideKind:"jetbrains",displayName:"AppCode",processKeywordsMac:["AppCode"],processKeywordsWindows:["appcode.exe"],processKeywordsLinux:["appcode"]},dataspell:{ideKind:"jetbrains",displayName:"DataSpell",processKeywordsMac:["DataSpell"],processKeywordsWindows:["dataspell64.exe"],processKeywordsLinux:["dataspell"]},aqua:{ideKind:"jetbrains",displayName:"Aqua",processKeywordsMac:[],processKeywordsWindows:["aqua64.exe"],processKeywordsLinux:[]},gateway:{ideKind:"jetbrains",displayName:"Gateway",processKeywordsMac:[],processKeywordsWindows:["gateway64.exe"],processKeywordsLinux:[]},fleet:{ideKind:"jetbrains",displayName:"Fleet",processKeywordsMac:[],processKeywordsWindows:["fleet.exe"],processKeywordsLinux:[]},androidstudio:{ideKind:"jetbrains",displayName:"Android Studio",processKeywordsMac:["Android Studio"],processKeywordsWindows:["studio64.exe"],processKeywordsLinux:["android-studio"]}};TwA=Z0(()=>{return grA(JQ.terminal)}),jwA=Z0(()=>{return U_(Rz.terminal)}),ZW=Z0(()=>{return TwA()||jwA()||Boolean(process.env.FORCE_CODE_TERMINAL)});S_3=R_3(import.meta.url),Go7=hrA(S_3,"../");EDB=Z0(()=>{try{return dG("cursor --version"),!0}catch{return!1}}),DDB=Z0(()=>{try{return dG("windsurf --version"),!0}catch{return!1}}),HDB=Z0(()=>{try{let A=dG("code --help");return Boolean(A&&A.includes("Visual Studio Code"))}catch{return!1}});JDB={code:"VS Code",cursor:"Cursor",windsurf:"Windsurf",antigravity:"Antigravity",vi:"Vim",vim:"Vim",nano:"nano",notepad:"Notepad","start /wait notepad":"Notepad",emacs:"Emacs",subl:"Sublime Text",atom:"Atom"};zDB=Z0(async(A,Q)=>{if(process.env.CLAUDE_CODE_IDE_HOST_OVERRIDE)return process.env.CLAUDE_CODE_IDE_HOST_OVERRIDE;if(dQ()!=="wsl"||!A)return"127.0.0.1";try{let G=M_3("ip route show | grep -i default",{encoding:"utf8"}).match(/default via (\d+\.\d+\.\d+\.\d+)/);if(G){let Z=G[1];if(await Fp1(Z,Q))return Z}}catch(B){}return"127.0.0.1"})});function b_3(){let A=RK0();if(A!==void 0)return A;let Q=process.env.CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR;if(!Q)return xBA(null),null;let B=parseInt(Q,10);if(Number.isNaN(B))return f(`CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR must be a valid file descriptor number, got: ${Q}`,{level:"error"}),xBA(null),null;try{let G=jA(),Z=process.platform==="darwin"||process.platform==="freebsd"?`/dev/fd/${B}`:`/proc/self/fd/${B}`,Y=G.readFileSync(Z,{encoding:"utf8"}).trim();if(!Y)return f("File descriptor contained empty token",{level:"error"}),xBA(null),null;return f(`Successfully read token from file descriptor ${B}`),xBA(Y),Y}catch(G){return f(`Failed to read token from file descriptor ${B}: ${G instanceof Error?G.message:String(G)}`,{level:"error"}),xBA(null),null}}function Le(){let A=process.env.CLAUDE_CODE_SESSION_ACCESS_TOKEN;if(A)return A;return b_3()}var prA=L(()=>{Y0();XQ();g0()});function h_3(A){let Q=A,B="",G=0,Z=10;while(Q!==B&&G<Z)B=Q,Q=Q.normalize("NFKC"),Q=Q.replace(/[\p{Cf}\p{Co}\p{Cn}]/gu,""),Q=Q.replace(/[\u200B-\u200F]/g,"").replace(/[\u202A-\u202E]/g,"").replace(/[\u2066-\u2069]/g,"").replace(/[\uFEFF]/g,"").replace(/[\uE000-\uF8FF]/g,""),G++;if(G>=Z)throw Error(`Unicode sanitization reached maximum iterations (${Z}) for input: ${A.slice(0,100)}`);return Q}function wp(A){if(typeof A==="string")return h_3(A);if(Array.isArray(A))return A.map(wp);if(A!==null&&typeof A==="object"){let Q={};for(let[B,G]of Object.entries(A))Q[wp(B)]=wp(G);return Q}return A}function lrA(){return parseInt(process.env.MAX_MCP_OUTPUT_TOKENS??"25000",10)}function $DB(A){return A.type==="text"}function wDB(A){return A.type==="image"}function Up1(A){if(!A)return 0;if(typeof A==="string")return OG(A);return A.reduce((Q,B)=>{if($DB(B))return Q+OG(B.text);else if(wDB(B))return Q+UDB;return Q},0)}function u_3(){return lrA()*4}function m_3(){return`
bundles/ClaudeCodeCode/cli.js:4686:`)),process.exit(1)}}function AF5(){L9("eagerLoadSettings_start");let A=process.argv.findIndex((B)=>B==="--settings");if(A!==-1&&A+1<process.argv.length){let B=process.argv[A+1];if(B)tH5(B)}let Q=process.argv.findIndex((B)=>B==="--setting-sources");if(Q!==-1&&Q+1<process.argv.length){let B=process.argv[Q+1];if(B!==void 0)eH5(B)}L9("eagerLoadSettings_end")}function QF5(A){if(process.env.CLAUDE_CODE_ENTRYPOINT)return;let Q=process.argv.slice(2),B=Q.indexOf("mcp");if(B!==-1&&Q[B+1]==="serve"){process.env.CLAUDE_CODE_ENTRYPOINT="mcp";return}if(z0(process.env.CLAUDE_CODE_ACTION)){process.env.CLAUDE_CODE_ENTRYPOINT="claude-code-github-action";return}process.env.CLAUDE_CODE_ENTRYPOINT=A?"sdk-cli":"cli"}async function BF5(){L9("main_function_start"),process.env.NoDefaultCurrentDirectoryInExePath="1",xm2(),process.on("exit",()=>{IF5()}),process.on("SIGINT",()=>{process.exit(0)}),L9("main_warning_handler_initialized");let A=process.argv.slice(2),Q=A.includes("-p")||A.includes("--print"),B=A.some((J)=>J.startsWith("--sdk-url")),G=Q||B||!process.stdout.isTTY;LK0(!G),QF5(G);let Y=(()=>{if(process.env.GITHUB_ACTIONS==="true")return"github-action";if(process.env.CLAUDE_CODE_ENTRYPOINT==="sdk-ts")return"sdk-typescript";if(process.env.CLAUDE_CODE_ENTRYPOINT==="sdk-py")return"sdk-python";if(process.env.CLAUDE_CODE_ENTRYPOINT==="sdk-cli")return"sdk-cli";if(process.env.CLAUDE_CODE_ENTRYPOINT==="claude-vscode")return"claude-vscode";if(process.env.CLAUDE_CODE_SESSION_ACCESS_TOKEN||process.env.CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR)return"remote";return"cli"})();MK0(Y),L9("main_client_type_determined"),AF5(),L9("main_before_run"),process.title="claude",await YF5(),L9("main_after_run")}function GF5(A){let Q=0,B={exitOnCtrlC:A,onFlicker:(G,Z,Y,J)=>{if(J==="resize")return;let I=Date.now();if(I-Q<1000)r("tengu_flicker",{desiredHeight:G,actualHeight:Z,ink2Enabled:Y,reason:J});Q=I}};if(!process.stdin.isTTY&&!z0(!1)&&!process.argv.includes("mcp")){if(r("tengu_stdin_interactive",{}),process.platform!=="win32")try{let G=cH5("/dev/tty","r");B={...B,stdin:new dH5(G)}}catch(G){s(G)}}return B}async function ZF5(A,Q){if(!process.stdin.isTTY&&!process.argv.includes("mcp")){if(Q==="stream-json")return process.stdin;process.stdin.setEncoding("utf8");let B="";return process.stdin.on("data",(G)=>{B+=G}),await new Promise((G)=>{process.stdin.on("end",G)}),[A,B].filter(Boolean).join(`
bundles/ClaudeAgentSDKCode/cli.js:983:`)||[];for(let G of B){let[Z,Y]=G.split("@");if(Z==="anthropic.claude-code"&&Y)return Y}return null}function DR6(){try{if(pQ()!=="macos")return null;let Q=process.ppid;for(let B=0;B<10;B++){if(!Q||Q===0||Q===1)break;let G=pG(`ps -o command= -p ${Q}`)?.trim();if(G){let Y={"Visual Studio Code.app":"code","Cursor.app":"cursor","Windsurf.app":"windsurf","Visual Studio Code - Insiders.app":"code","VSCodium.app":"codium"},J="/Contents/MacOS/Electron";for(let[I,X]of Object.entries(Y)){let W=G.indexOf(I+"/Contents/MacOS/Electron");if(W!==-1){let K=W+I.length;return G.substring(0,K)+"/Contents/Resources/app/bin/"+X}}}let Z=pG(`ps -o ppid= -p ${Q}`)?.trim();if(!Z)break;Q=parseInt(Z.trim())}return null}catch{return null}}function kEB(A){let Q=DR6();if(Q){if(jA().existsSync(Q))return Q}switch(A){case"vscode":return"code";case"cursor":return"cursor";case"windsurf":return"windsurf";default:break}return null}function prA(){let A=[];try{let Q=pQ();if(Q==="macos"){let B=pG('ps aux | grep -E "Visual Studio Code|Code Helper|Cursor Helper|Windsurf Helper|IntelliJ IDEA|PyCharm|WebStorm|PhpStorm|RubyMine|CLion|GoLand|Rider|DataGrip|AppCode|DataSpell|Aqua|Gateway|Fleet|Android Studio" | grep -v grep')??"";for(let[G,Z]of Object.entries(b7A))for(let Y of Z.processKeywordsMac)if(B.includes(Y)){A.push(G);break}}else if(Q==="windows"){let G=(pG('tasklist | findstr /I "Code.exe Cursor.exe Windsurf.exe idea64.exe pycharm64.exe webstorm64.exe phpstorm64.exe rubymine64.exe clion64.exe goland64.exe rider64.exe datagrip64.exe appcode.exe dataspell64.exe aqua64.exe gateway64.exe fleet.exe studio64.exe"')??"").toLowerCase();for(let[Z,Y]of Object.entries(b7A))for(let J of Y.processKeywordsWindows)if(G.includes(J.toLowerCase())){A.push(Z);break}}else if(Q==="linux"){let G=(pG('ps aux | grep -E "code|cursor|windsurf|idea|pycharm|webstorm|phpstorm|rubymine|clion|goland|rider|datagrip|dataspell|aqua|gateway|fleet|android-studio" | grep -v grep')??"").toLowerCase();for(let[Z,Y]of Object.entries(b7A))for(let J of Y.processKeywordsLinux)if(G.includes(J)){if(Z!=="vscode"){A.push(Z);break}else if(!G.includes("cursor")&&!G.includes("appcode")){A.push(Z);break}}}}catch(Q){r(Q)}return A}function lrA(A){let Q=A.find((B)=>B.type==="connected"&&B.name==="ide");return ec1(Q)}function ec1(A){let Q=A?.config;return Q?.type==="sse-ide"||Q?.type==="ws-ide"?Q.ideName:BW()?DV(bz.terminal):null}function DV(A){if(!A)return"IDE";let Q=b7A[A];if(Q)return Q.displayName;let B=PEB[A.toLowerCase().trim()];if(B)return B;let G=A.split(" ")[0],Z=G?BR6(G).toLowerCase():null;if(Z){let Y=PEB[Z];if(Y)return Y;return lHA(Z)}return lHA(A)}function VU(A){if(!A)return;let Q=A.find((B)=>B.type==="connected"&&B.name==="ide");return Q?.type==="connected"?Q:void 0}async function gEB(A){try{await Rb("closeAllDiffTabs",{},A)}catch(Q){}}async function uEB(A,Q,B,G){_EB().then(A);let Z=c1().autoInstallIdeExtension??!0;if(process.env.CLAUDE_CODE_IDE_SKIP_AUTO_INSTALL!=="true"&&Z){let Y=Q??k7A();if(Y){if(mrA(Y))TEB(Y).then(async(J)=>{WR6(Y).catch((I)=>{return{installed:!1,error:I.message||"Installation failed",installedVersion:null,ideType:Y}}).then((I)=>{if(G(I),I?.installed)_EB().then(A);if(!J&&I?.installed===!0&&!brA())B()})});else if(O_(Y)&&!brA())TEB(Y).then(async(J)=>{if(J)B()})}}}var SEB,b7A,ywA,vwA,BW,XR6,vn7,hrA=null,KR6="anthropic.claude-code",fEB,bEB,hEB,PEB,mEB;var RJ=q(()=>{R8();sQ();PuA();Q3();vQ();_0();xT1();p2();u0();YQ();g1();Z8();R_();nc1();ac1();oc1();Q0();NZ();er();SEB=o(_R(),1);b7A={cursor:{ideKind:"vscode",displayName:"Cursor",processKeywordsMac:["Cursor Helper","Cursor.app"],processKeywordsWindows:["cursor.exe"],processKeywordsLinux:["cursor"]},windsurf:{ideKind:"vscode",displayName:"Windsurf",processKeywordsMac:["Windsurf Helper","Windsurf.app"],processKeywordsWindows:["windsurf.exe"],processKeywordsLinux:["windsurf"]},vscode:{ideKind:"vscode",displayName:"VS Code",processKeywordsMac:["Visual Studio Code","Code Helper"],processKeywordsWindows:["code.exe"],processKeywordsLinux:["code"]},intellij:{ideKind:"jetbrains",displayName:"IntelliJ IDEA",processKeywordsMac:["IntelliJ IDEA"],processKeywordsWindows:["idea64.exe"],processKeywordsLinux:["idea","intellij"]},pycharm:{ideKind:"jetbrains",displayName:"PyCharm",processKeywordsMac:["PyCharm"],processKeywordsWindows:["pycharm64.exe"],processKeywordsLinux:["pycharm"]},webstorm:{ideKind:"jetbrains",displayName:"WebStorm",processKeywordsMac:["WebStorm"],processKeywordsWindows:["webstorm64.exe"],processKeywordsLinux:["webstorm"]},phpstorm:{ideKind:"jetbrains",displayName:"PhpStorm",processKeywordsMac:["PhpStorm"],processKeywordsWindows:["phpstorm64.exe"],processKeywordsLinux:["phpstorm"]},rubymine:{ideKind:"jetbrains",displayName:"RubyMine",processKeywordsMac:["RubyMine"],processKeywordsWindows:["rubymine64.exe"],processKeywordsLinux:["rubymine"]},clion:{ideKind:"jetbrains",displayName:"CLion",processKeywordsMac:["CLion"],processKeywordsWindows:["clion64.exe"],processKeywordsLinux:["clion"]},goland:{ideKind:"jetbrains",displayName:"GoLand",processKeywordsMac:["GoLand"],processKeywordsWindows:["goland64.exe"],processKeywordsLinux:["goland"]},rider:{ideKind:"jetbrains",displayName:"Rider",processKeywordsMac:["Rider"],processKeywordsWindows:["rider64.exe"],processKeywordsLinux:["rider"]},datagrip:{ideKind:"jetbrains",displayName:"DataGrip",processKeywordsMac:["DataGrip"],processKeywordsWindows:["datagrip64.exe"],processKeywordsLinux:["datagrip"]},appcode:{ideKind:"jetbrains",displayName:"AppCode",processKeywordsMac:["AppCode"],processKeywordsWindows:["appcode.exe"],processKeywordsLinux:["appcode"]},dataspell:{ideKind:"jetbrains",displayName:"DataSpell",processKeywordsMac:["DataSpell"],processKeywordsWindows:["dataspell64.exe"],processKeywordsLinux:["dataspell"]},aqua:{ideKind:"jetbrains",displayName:"Aqua",processKeywordsMac:[],processKeywordsWindows:["aqua64.exe"],processKeywordsLinux:[]},gateway:{ideKind:"jetbrains",displayName:"Gateway",processKeywordsMac:[],processKeywordsWindows:["gateway64.exe"],processKeywordsLinux:[]},fleet:{ideKind:"jetbrains",displayName:"Fleet",processKeywordsMac:[],processKeywordsWindows:["fleet.exe"],processKeywordsLinux:[]},androidstudio:{ideKind:"jetbrains",displayName:"Android Studio",processKeywordsMac:["Android Studio"],processKeywordsWindows:["studio64.exe"],processKeywordsLinux:["android-studio"]}};ywA=Z0(()=>{return mrA(QQ.terminal)}),vwA=Z0(()=>{return O_(bz.terminal)}),BW=Z0(()=>{return ywA()||vwA()||Boolean(process.env.FORCE_CODE_TERMINAL)});XR6=GR6(import.meta.url),vn7=urA(XR6,"../");fEB=Z0(()=>{try{return pG("cursor --version"),!0}catch{return!1}}),bEB=Z0(()=>{try{return pG("windsurf --version"),!0}catch{return!1}}),hEB=Z0(()=>{try{let A=pG("code --help");return Boolean(A&&A.includes("Visual Studio Code"))}catch{return!1}});PEB={code:"VS Code",cursor:"Cursor",windsurf:"Windsurf",antigravity:"Antigravity",vi:"Vim",vim:"Vim",nano:"nano",notepad:"Notepad","start /wait notepad":"Notepad",emacs:"Emacs",subl:"Sublime Text",atom:"Atom"};mEB=Z0(async(A,Q)=>{if(process.env.CLAUDE_CODE_IDE_HOST_OVERRIDE)return process.env.CLAUDE_CODE_IDE_HOST_OVERRIDE;if(pQ()!=="wsl"||!A)return"127.0.0.1";try{let G=QR6("ip route show | grep -i default",{encoding:"utf8"}).match(/default via (\d+\.\d+\.\d+\.\d+)/);if(G){let Z=G[1];if(await sc1(Z,Q))return Z}}catch(B){}return"127.0.0.1"})});function HR6(){let A=ZK0();if(A!==void 0)return A;let Q=process.env.CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR;if(!Q)return SBA(null),null;let B=parseInt(Q,10);if(Number.isNaN(B))return f(`CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR must be a valid file descriptor number, got: ${Q}`,{level:"error"}),SBA(null),null;try{let G=jA(),Z=process.platform==="darwin"||process.platform==="freebsd"?`/dev/fd/${B}`:`/proc/self/fd/${B}`,Y=G.readFileSync(Z,{encoding:"utf8"}).trim();if(!Y)return f("File descriptor contained empty token",{level:"error"}),SBA(null),null;return f(`Successfully read token from file descriptor ${B}`),SBA(Y),Y}catch(G){return f(`Failed to read token from file descriptor ${B}: ${G instanceof Error?G.message:String(G)}`,{level:"error"}),SBA(null),null}}function fe(){let A=process.env.CLAUDE_CODE_SESSION_ACCESS_TOKEN;if(A)return A;return HR6()}var irA=q(()=>{Q0();YQ();u0()});function FR6(A){let Q=A,B="",G=0,Z=10;while(Q!==B&&G<Z)B=Q,Q=Q.normalize("NFKC"),Q=Q.replace(/[\p{Cf}\p{Co}\p{Cn}]/gu,""),Q=Q.replace(/[\u200B-\u200F]/g,"").replace(/[\u202A-\u202E]/g,"").replace(/[\u2066-\u2069]/g,"").replace(/[\uFEFF]/g,"").replace(/[\uE000-\uF8FF]/g,""),G++;if(G>=Z)throw Error(`Unicode sanitization reached maximum iterations (${Z}) for input: ${A.slice(0,100)}`);return Q}function fp(A){if(typeof A==="string")return FR6(A);if(Array.isArray(A))return A.map(fp);if(A!==null&&typeof A==="object"){let Q={};for(let[B,G]of Object.entries(A))Q[fp(B)]=fp(G);return Q}return A}function nrA(){return parseInt(process.env.MAX_MCP_OUTPUT_TOKENS??"25000",10)}function cEB(A){return A.type==="text"}function pEB(A){return A.type==="image"}function Ap1(A){if(!A)return 0;if(typeof A==="string")return jG(A);return A.reduce((Q,B)=>{if(cEB(B))return Q+jG(B.text);else if(pEB(B))return Q+dEB;return Q},0)}function zR6(){return nrA()*4}function UR6(){return`
bundles/ClaudeAgentSDKCode/cli.js:4696:`)),process.exit(1)}}function vD5(){w9("eagerLoadSettings_start");let A=process.argv.findIndex((B)=>B==="--settings");if(A!==-1&&A+1<process.argv.length){let B=process.argv[A+1];if(B)xD5(B)}let Q=process.argv.findIndex((B)=>B==="--setting-sources");if(Q!==-1&&Q+1<process.argv.length){let B=process.argv[Q+1];if(B!==void 0)yD5(B)}w9("eagerLoadSettings_end")}function kD5(A){if(process.env.CLAUDE_CODE_ENTRYPOINT)return;let Q=process.argv.slice(2),B=Q.indexOf("mcp");if(B!==-1&&Q[B+1]==="serve"){process.env.CLAUDE_CODE_ENTRYPOINT="mcp";return}if(C0(process.env.CLAUDE_CODE_ACTION)){process.env.CLAUDE_CODE_ENTRYPOINT="claude-code-github-action";return}process.env.CLAUDE_CODE_ENTRYPOINT=A?"sdk-cli":"cli"}async function fD5(){w9("main_function_start"),process.env.NoDefaultCurrentDirectoryInExePath="1",Tu2(),process.on("exit",()=>{mD5()}),process.on("SIGINT",()=>{process.exit(0)}),w9("main_warning_handler_initialized");let A=process.argv.slice(2),Q=A.includes("-p")||A.includes("--print"),B=A.some((J)=>J.startsWith("--sdk-url")),G=Q||B||!process.stdout.isTTY;QK0(!G),kD5(G);let Y=(()=>{if(process.env.GITHUB_ACTIONS==="true")return"github-action";if(process.env.CLAUDE_CODE_ENTRYPOINT==="sdk-ts")return"sdk-typescript";if(process.env.CLAUDE_CODE_ENTRYPOINT==="sdk-py")return"sdk-python";if(process.env.CLAUDE_CODE_ENTRYPOINT==="sdk-cli")return"sdk-cli";if(process.env.CLAUDE_CODE_ENTRYPOINT==="claude-vscode")return"claude-vscode";if(process.env.CLAUDE_CODE_SESSION_ACCESS_TOKEN||process.env.CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR)return"remote";return"cli"})();BK0(Y),w9("main_client_type_determined"),vD5(),w9("main_before_run"),process.title="claude",await gD5(),w9("main_after_run")}function bD5(A){let Q=0,B={exitOnCtrlC:A,onFlicker:(G,Z,Y,J)=>{if(J==="resize")return;let I=Date.now();if(I-Q<1000)s("tengu_flicker",{desiredHeight:G,actualHeight:Z,ink2Enabled:Y,reason:J});Q=I}};if(!process.stdin.isTTY&&!C0(!1)&&!process.argv.includes("mcp")){if(s("tengu_stdin_interactive",{}),process.platform!=="win32")try{let G=LD5("/dev/tty","r");B={...B,stdin:new qD5(G)}}catch(G){r(G)}}return B}async function hD5(A,Q){if(!process.stdin.isTTY&&!process.argv.includes("mcp")){if(Q==="stream-json")return process.stdin;process.stdin.setEncoding("utf8");let B="";return process.stdin.on("data",(G)=>{B+=G}),await new Promise((G)=>{process.stdin.on("end",G)}),[A,B].filter(Boolean).join(`[0m


[35m[3mthinking[0m[0m
**Examining authentication processes**

I noticed that our earlier search for overlay tokens didn‚Äôt yield results due to size limitations, but it looks like there‚Äôs some precedence in the legacy spec file. It‚Äôs worth relying on that. In the bundles, I see that `fe()` uses the `CLAUDE_CODE_SESSION_ACCESS_TOKEN`, likely for authentication. Phase 5 appears to involve state models and incorporating this token could be necessary. I‚Äôll need to check the keychain for secrets, as it might be important for this phase's validation. I'll inspect the implementation in NodeHost further.
[35m[3mthinking[0m[0m
**Continuing with node secrets**

I see that the node host might include `createNodeSecrets` further down in the file. I‚Äôll need to explore that part later to understand its functionality better. It‚Äôs important to keep track of how secrets are being handled, as this could impact authentication or security within the project. So, I'll make a note to revisit this section to ensure I'm on top of any crucial details that might arise later.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "createNodeSecrets|keychain|security" -n src/platform/node/host.ts'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 54ms:[0m
[2m346:      const { stdout } = await execFile("security", ["find-generic-password", "-a", account, "-w", "-s", service], {
372:function createNodeSecrets(options: NodeHostOptions): HostSecrets {
408:  const secrets = createNodeSecrets(options);[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '300,520p' src/platform/node/host.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 57ms:[0m
[2m          const base = entry.name.slice(0, -".json".length);
          const decoded = decodeStorageSegment(base);
          if (decoded === null) continue;
          if (listOpts?.prefix && !decoded.startsWith(listOpts.prefix)) continue;
          keys.push(decoded);
        }
        keys.sort();
        return keys;
      } catch (error) {
        if ((error as NodeJS.ErrnoException).code === "ENOENT") return [];
        throw error;
      }
    }
  };
}

type ClaudeCodeCredentials = { accessToken?: string };

function configDirHashSuffix(configDir: string): string {
  if (!process.env.CLAUDE_CONFIG_DIR) return "";[0m

[35m[3mthinking[0m[0m
**Implementing state model**

I‚Äôm working on the Node secrets retrieval, which uses environment variables and the keychain via `security`. That‚Äôs a solid start. Now it‚Äôs time to tackle Phase 5, focusing on the state model. I‚Äôm wondering if I should incorporate the session access token, but I‚Äôll keep it simple for now. It‚Äôs crucial not to implement future phases yet. I‚Äôll create a state model with minimal placeholders for settings and inspect the existing storage in core/types/host.ts.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/types/host.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 56ms:[0m
[2mimport type { HostEvent } from "./events.js";
import type { WorkspaceId } from "./workspace.js";

export type CapabilityUnavailableReason =
  | { kind: "not-provided"; message?: string }
  | { kind: "unsupported"; message?: string }
  | { kind: "disabled"; message?: string }
  | { kind: "policy-denied"; message?: string; policyId?: string };

export type Capability<T> =
  | { kind: "available"; value: T }
  | { kind: "unavailable"; reason: CapabilityUnavailableReason };

export function availableCapability<T>(value: T): Capability<T> {
  return { kind: "available", value };
}

export function unavailableCapability(reason: CapabilityUnavailableReason): Capability<never> {
  return { kind: "unavailable", reason };
}[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '260,520p' src/core/types/host.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 55ms:[0m
[2m): CapabilityValue<HostCapabilities[K]> {
  const cap = host[key] as Capability<unknown>;
  if (cap.kind === "available") return cap.value as CapabilityValue<HostCapabilities[K]>;
  if (cap.reason.kind === "policy-denied") {
    throw new CapabilityPolicyDeniedError(String(key), {
      ...(cap.reason.policyId !== undefined ? { policyId: cap.reason.policyId } : {}),
      ...(cap.reason.message !== undefined ? { message: cap.reason.message } : {})
    });
  }
  throw new CapabilityUnavailableError(String(key), cap.reason);
}[0m





[35m[3mthinking[0m[0m
**Defining overlay selection script**

I'm planning to create a script to validate that selecting the active overlay returns the first one based on precedence. The goal is to implement a deterministic overlay-selection algorithm that incorporates priority tiers and stable tie-breakers, asserting this with golden tests from the legacy behavior.

Each overlay request will include an `id`, `kind`, `priorityTier`, and `createdSeq`. I'll define `kindOrder` to sort by tier and use a stable tie-breaker along with defined `OverlayPriorityTier` unions. This should help maintain consistent behavior through legacy queues.
[35m[3mthinking[0m[0m
**Implementing overlay selection algorithm**

I've figured out that the selection among overlays relies on a fixed precedence defined by `LEGACY_OVERLAY_PRECEDENCE`, rather than being dynamic. So, to proceed with the algorithm: I'll determine which overlay types have pending items and select the one with the lowest index in the precedence list. If there are multiple of the same kind, I'll pick the oldest request.

Next, for notification queue semantics like immediate versus queued notifications, I'll implement a `Notification` type from the legacy spec and create pure queue functions. I need to ensure I'm accurately matching legacy semantics, particularly for priorities like immediate, high, medium, and low.
[35m[3mthinking[0m[0m
**Structuring notification queue**

I'm outlining how the notification queue will function. The `queue` will be a list of pending notifications that excludes the current one. When enqueueing a notification, if its `invalidates` include certain keys, I'll remove those from the queue and clear the current if there's a match.

For immediate notifications, I'll set it as current and possibly push the existing current to the queue, unless invalidated. Otherwise, I'll organize the queue based on priority and sequence. I'll also implement functions for advancing the notification queue and dismissing notifications, while addressing specific concurrency rules and cancellation propagation.
[35m[3mthinking[0m[0m
**Implementing ElicitationRequest model**

I‚Äôm planning to create the `ElicitationRequest` model that will include properties like `id`, `prompt`, `kind`, and a `concurrency` option. For now, I'll set it to serial and maintain an `active` request alongside a queue. The permission prompt will need to handle tool approvals and the 'don't ask again' option, but I can't implement persistence just yet due to phase 7.

I'll also outline how the permission queue semantics will function, including separate modeling for the sandbox network. As for queue persistence, most elements will be treated as ephemeral, but pending decisions may persist. I'll establish the `QueuePersistencePolicy` for managing different queue behaviors and ensure we enforce a single active session within the app state.
[35m[3mthinking[0m[0m
**Setting up session management**

I‚Äôm designing the store to include an `activeSessionId` along with a `sessions` map, allowing multiple sessions to be persisted while ensuring only one is active at a time. I'll model resource sharing across sessions‚Äîthings like MCP connections, caches, and network budgets‚Äîin a dedicated `shared` section of the app state, but actual implementation isn't quite ready.

For persistence and hydration, I plan to implement `StatePersistence` functions, starting with `serializeStateSnapshot(snapshot: StateSnapshot): string` using stable JSON serialization, likely utilizing existing `canonicalJson` functions. I'll need to check the related files for more details.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,220p' src/core/types/canonicalJson.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 59ms:[0m
[2mimport type { JsonArray, JsonObject, JsonValue } from "./json.js";

export type CanonicalJsonStringifyOptions = {
  pretty?: boolean;
};

function isPlainObject(value: unknown): value is Record<string, unknown> {
  if (value === null) return false;
  if (typeof value !== "object") return false;
  const proto = Object.getPrototypeOf(value);
  return proto === Object.prototype || proto === null;
}

function toCanonicalJsonValue(value: unknown, seen: Set<unknown>): JsonValue {
  if (value === null) return null;

  if (typeof value === "string" || typeof value === "boolean") return value;
  if (typeof value === "number") {
    if (!Number.isFinite(value)) throw new TypeError("Non-finite numbers are not JSON-serializable");
    return value;[0m

[35m[3mthinking[0m[0m
**Researching AppState and settings**

I‚Äôm considering if the `settings` field in storage might be typed as unknown, which seems fine for now. I should reference the CLI encyclopedia to confirm the state naming and event taxonomy. There might be something about AppState in there, but I‚Äôm not entirely sure. Therefore, I‚Äôll search the relevant sections of the CLI encyclopedia for terms like "AppState" and "notifications" to read and gather more information.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"AppState|notifications\\:|elicitation|overlay\" CLI_ENCYCLOPEDIA.md | head -n 80"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 62ms:[0m
[2m709:1. Load current app state: `state = await ctx.getAppState()`.
943:- a file watcher + subscription mechanism so the UI/AppState can react to changes
1266:There is a React-side hook that listens for changes and updates AppState:
1355:3. **Session hooks**: temporary in-memory hooks stored in `AppState.sessionHooks`.
1428:Session hooks are stored in `AppState.sessionHooks[sessionId]` and can be added/cleared at runtime.
1432:- `MF8(setAppState, sessionId, event, matcher, hook, onHookSuccess?)` writes into `sessionHooks`
1433:- `mMA(setAppState, sessionId, event, matcher, callback, errorMessage, opts?)` is a convenience that creates a `{type:"function", callback, timeout, ...}` hook and calls `MF8(...)`
1436:- `jB1(setAppState, sessionId)` clears all session hooks for that session
1440:- `RG0(reason, { setAppState })` calls `jB1(setAppState, W0())` after running `SessionEnd` hooks
1749:   - an overridden `getAppState()` that temporarily modifies `toolPermissionContext`:
1825:- If a `setAppState` callback is provided, it clears all session hooks for the current session:
1826:  - 2.0.67: `RG0(...)` calls `jB1(setAppState, W0())`
1833:## Chapter 7 ‚Äî AppState runtime + notifications (React/Ink state backbone)
1835:This chapter documents the ‚Äúruntime state container‚Äù that the Ink/React UI uses everywhere: an `AppStateProvider` plus helper hooks for reading/updating state, reacting to settings changes, and showing transient notifications.
1839:- the `AppState` object is the CLI‚Äôs *single source of truth* for UI screens, queues, and runtime flags
1850:| AppStateProvider component | `n5(...)` | `u5(...)` |
1874:### 7.2 The `AppState` object (what lives in global UI state)
1876:`bn()` / `Nn()` returns the baseline `AppState`. It is intentionally ‚Äúwide‚Äù and groups multiple subsystems:
1895:- `elicitation`: `{ queue: [] }`
1915:type AppState = {[0m

[35m[3mthinking[0m[0m
**Looking into the CLI Encyclopedia**

I need to check the CLI Encyclopedia, especially Chapter 7, since it contains detailed app state information related to overlay and notification semantics. I'll focus on sections 7.2 and nearby paragraphs to gather all the relevant details. It‚Äôs going to be important to accurately understand that content. Let‚Äôs dive into those sections and extract what‚Äôs needed for my understanding!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "nl -ba CLI_ENCYCLOPEDIA.md | sed -n '1830,2100p'"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 56ms:[0m
[2m  1830	
  1831	---
  1832	
  1833	## Chapter 7 ‚Äî AppState runtime + notifications (React/Ink state backbone)
  1834	
  1835	This chapter documents the ‚Äúruntime state container‚Äù that the Ink/React UI uses everywhere: an `AppStateProvider` plus helper hooks for reading/updating state, reacting to settings changes, and showing transient notifications.
  1836	
  1837	Even though this is ‚Äújust React state‚Äù, it is **first-party product logic** because:
  1838	
  1839	- the `AppState` object is the CLI‚Äôs *single source of truth* for UI screens, queues, and runtime flags
  1840	- it stitches together: settings, tool permissions, plugins, MCP, tasks, file history, notifications, and more
  1841	- it exposes a stable abstraction boundary for a TypeScript rewrite (treat it like a Redux slice, but implemented with context + tuple)
  1842	
  1843	### 7.1 Symbol map (2.0.67 vs 2.0.69)
  1844	
  1845	Provider and hooks:
  1846	
  1847	| Concept | 2.0.67 symbol | 2.0.69 symbol |
  1848	|---|---:|---:|
  1849	| Default state factory | `bn()` | `Nn()` |[0m

[35m[3mthinking[0m[0m
**Implementing overlay selections**

This gives me the specific notification algorithm I need, plus details on overlay selection. I‚Äôll make sure to implement everything as specified. I realize I also need to read the overlay selection section, particularly around 2565, to get all the context I need. It looks like I should open sections from about 2540 to 2660 to ensure I gather all relevant information. I'm curious if there are any additional considerations to keep in mind!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "nl -ba CLI_ENCYCLOPEDIA.md | sed -n '2520,2665p'"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 57ms:[0m
[2m  2520	
  2521	- `wC = "StructuredOutput"`
  2522	- `Z70` = the ‚ÄúStructuredOutput‚Äù tool object (always enabled, read-only, etc.)
  2523	
  2524	This tool is treated specially:
  2525	
  2526	- It is excluded from the normal `UH()` list so it doesn‚Äôt appear as an ordinary tool.
  2527	- It is used when the CLI wants the model to produce a JSON-schema-validated final output.
  2528	
  2529	The 2.0.67 equivalent constant is `PC`.
  2530	
  2531	### 9.6 Screen state machine + transcript mode
  2532	
  2533	The UI has a ‚Äúscreen mode‚Äù string state, with at least:
  2534	
  2535	- `"prompt"`: normal REPL
  2536	- `"transcript"`: condensed transcript view with special hotkeys
  2537	
  2538	The transcript view renders the same message list component in a different style and shows a hint:
  2539	[0m





[35m[3mthinking[0m[0m
**Planning script development**

I'm looking to create the script `scripts/phase5-state-golden.ts`, which will import our core/state modules and handle legacy precedence. Since scripts are outside the core, they can import from `src`. It‚Äôs useful to note that we can run this with bun since it supports TypeScript files. 

We‚Äôll define functions like `selectActiveOverlay` with different states, ensuring they align with `LEGACY_OVERLAY_PRECEDENCE`. I‚Äôll implement test cases to check notification semantics and overlay precedence, using Node's `assert` module.
[35m[3mthinking[0m[0m
**Refining notification algorithm**

I'm considering an algorithm for handling non-immediate enqueues, which will only add notifications if the key isn't present. Invalidated notifications will be dropped, triggering a "drain" that selects the next notification by priority when the current one is null. I can't start timers in pure functions, but I can create a `notificationDrain` function to handle this. 

For immediate notifications, I'll requeue the previous ones while filtering out any duplicates. To simulate timeouts, I‚Äôll implement `expireCurrentNotification` in `core/state/notifications.ts`, which will update the state after clearing the current notification for a specific key, while keeping side effects managed within runtime tasks.
[35m[3mthinking[0m[0m
**Structuring the notifications reducer**

I‚Äôm planning to implement the notifications reducer as a pure function that returns effects for the runtime to handle expiration. Here's the systematic approach I‚Äôm taking:

First, I‚Äôll define a `StateEffect` union, including `scheduleTimeout`. The reducer function, `reduceAppState`, will return an object containing both the new state and any effects or UI events, ensuring clear separation of side effects.

For notifications, when setting the current notification, I‚Äôll add an effect to schedule a timeout. When that timeout triggers, the runtime will dispatch a `ui/notification-timeout` action, which will check if the key matches before clearing the current notification and pruning any invalidated queues. This setup will allow us to test by dispatching actions effectively.
[35m[3mthinking[0m[0m
**Designing the store for state management**

I‚Äôm considering including `store.subscribeEffects`, but the plan emphasizes separating effects from UI events. Therefore, I plan to develop a store that provides a `dispatch` function, returning `Promise<void>`, although it works immediately. Instead of awaiting effect handlers, I‚Äôll create a pure `reduce` function along with a compact `createStore` that manages actions, emitting events and effects separately.

I‚Äôll implement the `StateStore` interface with methods for dispatching actions, retrieving state, and subscribing to events and effects. It's important to ensure that our state is serializable for persistence, making a distinction between ephemeral UI overlays and persistent states clear.
[35m[3mthinking[0m[0m
**Determining persistence for notifications and sessions**

I‚Äôm reflecting on whether notifications should persist across restarts. They seem to be more ephemeral, so maybe they shouldn‚Äôt. However, elicitation prompts could potentially need to persist if a server asks the user and the app restarts. 

To minimize persistence, I think we should store sessions and transcripts, but not notification queues. I‚Äôll define a persisted snapshot that includes session data, the active session ID, and any pending permission decisions. 

In terms of crash recovery, I‚Äôll implement mechanisms for marking incomplete tool runs and design a `recoverFromSnapshot` function to handle any tool runs that were in progress. Now, it‚Äôs time to implement these structures!
[35mPlan update[0m
[3mImplement Phase 5 state model, queues, and persistence per the rewrite checklist and legacy CLI behavior.[0m
  [36m‚Üí[0m Read Phase 5 requirements
  [2m‚Ä¢[0m [2mInspect legacy AppState behavior[0m
  [2m‚Ä¢[0m [2mImplement core state modules[0m
  [2m‚Ä¢[0m [2mAdd golden validation script[0m
  [2m‚Ä¢[0m [2mRun validations and CLI command[0m
  [2m‚Ä¢[0m [2mWrite Phase 5 changelog[0m

[35m[3mthinking[0m[0m
**Updating progress plan**

I‚Äôve already gone through the Phase 5 section and looked into the legacy behavior from the CLI encyclopedia. I think I can mark step 1 as complete, and step 2 is currently in progress. Now, I'll need to adjust the plan based on this update. It feels good to make progress, but I want to ensure everything aligns correctly moving forward. Let's keep this organized!
[35mPlan update[0m
  [32m‚úì[0m Read Phase 5 requirements
  [36m‚Üí[0m Inspect legacy AppState behavior
  [2m‚Ä¢[0m [2mImplement core state modules[0m
  [2m‚Ä¢[0m [2mAdd golden validation script[0m
  [2m‚Ä¢[0m [2mRun validations and CLI command[0m
  [2m‚Ä¢[0m [2mWrite Phase 5 changelog[0m

[35m[3mthinking[0m[0m
**Evaluating progress**

I've inspected the legacy behavior and I'm ready to mark step 2 as completed. Now, I'm moving on to step 3, which is currently in progress. I want to make sure each part is thoroughly checked. I‚Äôm curious about any challenges that may arise in this next stage and how I can address them effectively. It‚Äôs important to maintain clarity throughout this process!
[35mPlan update[0m
  [32m‚úì[0m Read Phase 5 requirements
  [32m‚úì[0m Inspect legacy AppState behavior
  [36m‚Üí[0m Implement core state modules
  [2m‚Ä¢[0m [2mAdd golden validation script[0m
  [2m‚Ä¢[0m [2mRun validations and CLI command[0m
  [2m‚Ä¢[0m [2mWrite Phase 5 changelog[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "StatePlaceholder" -S src'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 79ms:[0m
[2msrc/core/state/index.ts:1:export type StatePlaceholder = {[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,220p' src/core/runtime/ids.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 51ms:[0m
[2mexport type IdSource = {
  nextId: (prefix?: string) => string;
};

export type UuidLike = {
  randomUUID: () => string;
};

export function createMonotonicIdSource(options: { startAt?: number } = {}): IdSource {
  let counter = options.startAt ?? 0;
  return {
    nextId(prefix) {
      counter += 1;
      const body = String(counter);
      return prefix ? `${prefix}_${body}` : body;
    }
  };
}

export function createUuidIdSource(uuid: UuidLike): IdSource {[0m
[3m[35mfile update[0m[0m
[35mD /Users/ronaldeddings/ClaudeCodeTS/src/core/state/index.ts[0m
[31mexport type StatePlaceholder = {[0m
[31m  phase: "2";[0m
[31m};[0m
[31m[0m
[32mapply_patch(auto_approved=true) exited 0 in 7ms:[0m
[2mSuccess. Updated the following files:[0m
[2mD src/core/state/index.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-

[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-

[3m[35mfile update[0m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/types/state.ts[0m
[32mimport type { VersionedEnvelopeBase } from "./schema.js";[0m
[32mimport { SCHEMA_VERSION } from "./schema.js";[0m
[32mimport type { CancellationReason } from "./runtime.js";[0m
[32m[0m
[32mexport type AppId = string & { readonly __brand: "AppId" };[0m
[32mexport type SessionId = string & { readonly __brand: "SessionId" };[0m
[32mexport type AttachmentId = string & { readonly __brand: "AttachmentId" };[0m
[32mexport type ToolRunId = string & { readonly __brand: "ToolRunId" };[0m
[32mexport type HookRunId = string & { readonly __brand: "HookRunId" };[0m
[32mexport type McpConnectionId = string & { readonly __brand: "McpConnectionId" };[0m
[32m[0m
[32mexport function asAppId(value: string): AppId {[0m
[32m  return value as AppId;[0m
[32m}[0m
[32mexport function asSessionId(value: string): SessionId {[0m
[32m  return value as SessionId;[0m
[32m}[0m
[32mexport function asAttachmentId(value: string): AttachmentId {[0m
[32m  return value as AttachmentId;[0m
[32m}[0m
[32mexport function asToolRunId(value: string): ToolRunId {[0m
[32m  return value as ToolRunId;[0m
[32m}[0m
[32mexport function asHookRunId(value: string): HookRunId {[0m
[32m  return value as HookRunId;[0m
[32m}[0m
[32mexport function asMcpConnectionId(value: string): McpConnectionId {[0m
[32m  return value as McpConnectionId;[0m
[32m}[0m
[32m[0m
[32mexport type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";[0m
[32m[0m
[32mexport type Sensitive<T> = { kind: "sensitive"; value: T };[0m
[32mexport type Redacted = { kind: "redacted" };[0m
[32mexport function sensitive<T>(value: T): Sensitive<T> {[0m
[32m  return { kind: "sensitive", value };[0m
[32m}[0m
[32mexport const REDACTED: Redacted = { kind: "redacted" };[0m
[32m[0m
[32mexport type AttachmentRefV1 = {[0m
[32m  id: AttachmentId;[0m
[32m  createdAtMonoMs: number;[0m
[32m  kind: "text" | "json" | "binary";[0m
[32m  mediaType?: string;[0m
[32m  byteLength?: number;[0m
[32m  sha256Hex?: string;[0m
[32m  storageKey?: string;[0m
[32m  inlineText?: string;[0m
[32m  inlineJson?: unknown;[0m
[32m};[0m
[32m[0m
[32mexport type TranscriptEventBaseV1 = {[0m
[32m  id: string;[0m
[32m  tsMonoMs: number;[0m
[32m  tsWallMs?: number;[0m
[32m  sensitivity?: "public" | "internal" | "pii" | "secret";[0m
[32m};[0m
[32m[0m
[32mexport type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {[0m
[32m  type: "message";[0m
[32m  role: "user" | "assistant" | "system";[0m
[32m  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;[0m
[32m};[0m
[32m[0m
[32mexport type TranscriptToolEventV1 = TranscriptEventBaseV1 & {[0m
[32m  type: "tool";[0m
[32m  toolRunId: ToolRunId;[0m
[32m  stage: "start" | "stream" | "result" | "error" | "cancelled";[0m
[32m  toolName: string;[0m
[32m  input?: unknown;[0m
[32m  output?: unknown;[0m
[32m  error?: string;[0m
[32m};[0m
[32m[0m
[32mexport type TranscriptHookEventV1 = TranscriptEventBaseV1 & {[0m
[32m  type: "hook";[0m
[32m  hookRunId: HookRunId;[0m
[32m  stage: "start" | "stream" | "result" | "error" | "cancelled";[0m
[32m  eventName: string;[0m
[32m  selectedHooks?: string[];[0m
[32m  message?: string;[0m
[32m  result?: unknown;[0m
[32m  error?: string;[0m
[32m};[0m
[32m[0m
[32mexport type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {[0m
[32m  type: "mcp";[0m
[32m  connectionId: McpConnectionId;[0m
[32m  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";[0m
[32m  serverName?: string;[0m
[32m  payload?: unknown;[0m
[32m  error?: string;[0m
[32m};[0m
[32m[0m
[32mexport type TranscriptEventV1 =[0m
[32m  | TranscriptMessageEventV1[0m
[32m  | TranscriptToolEventV1[0m
[32m  | TranscriptHookEventV1[0m
[32m  | TranscriptMcpEventV1;[0m
[32m[0m
[32mexport type TranscriptLogV1 = {[0m
[32m  schemaVersion: 1;[0m
[32m  events: TranscriptEventV1[];[0m
[32m  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };[0m
[32m};[0m
[32m[0m
[32mexport type ToolRunEntityV1 = {[0m
[32m  id: ToolRunId;[0m
[32m  toolName: string;[0m
[32m  createdAtMonoMs: number;[0m
[32m  startedAtMonoMs?: number;[0m
[32m  endedAtMonoMs?: number;[0m
[32m  status: "created" | "running" | "completed" | "error" | "cancelled";[0m
[32m  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };[0m
[32m  input?: unknown;[0m
[32m  output?: unknown;[0m
[32m  error?: string;[0m
[32m  cancelled?: CancellationReason;[0m
[32m};[0m
[32m[0m
[32mexport type HookRunEntityV1 = {[0m
[32m  id: HookRunId;[0m
[32m  eventName: string;[0m
[32m  createdAtMonoMs: number;[0m
[32m  startedAtMonoMs?: number;[0m
[32m  endedAtMonoMs?: number;[0m
[32m  status: "created" | "running" | "completed" | "error" | "cancelled";[0m
[32m  selectedHooks?: string[];[0m
[32m  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;[0m
[32m  error?: string;[0m
[32m  cancelled?: CancellationReason;[0m
[32m};[0m
[32m[0m
[32mexport type McpConnectionEntityV1 = {[0m
[32m  id: McpConnectionId;[0m
[32m  serverName: string;[0m
[32m  mode: "direct" | "endpoint";[0m
[32m  status: "disconnected" | "connecting" | "connected" | "error";[0m
[32m  connectedAtMonoMs?: number;[0m
[32m  disconnectedAtMonoMs?: number;[0m
[32m  toolsSnapshot?: unknown;[0m
[32m  resourcesSnapshot?: unknown;[0m
[32m  error?: string;[0m
[32m};[0m
[32m[0m
[32mexport type PersistedSessionStateV1 = {[0m
[32m  schemaVersion: 1;[0m
[32m  id: SessionId;[0m
[32m  lifecycle: SessionLifecycleState;[0m
[32m  createdAtMonoMs: number;[0m
[32m  updatedAtMonoMs: number;[0m
[32m  endedAtMonoMs?: number;[0m
[32m  error?: string;[0m
[32m  transcript: TranscriptLogV1;[0m
[32m  attachments: Record<string, AttachmentRefV1>;[0m
[32m  toolRuns: Record<string, ToolRunEntityV1>;[0m
[32m  hookRuns: Record<string, HookRunEntityV1>;[0m
[32m  mcpConnections: Record<string, McpConnectionEntityV1>;[0m
[32m};[0m
[32m[0m
[32mexport type PersistedAppStateV1 = {[0m
[32m  schemaVersion: 1;[0m
[32m  appId: AppId;[0m
[32m  createdAtMonoMs: number;[0m
[32m  updatedAtMonoMs: number;[0m
[32m  activeSessionId?: SessionId;[0m
[32m  sessions: Record<string, PersistedSessionStateV1>;[0m
[32m};[0m
[32m[0m
[32mexport type StateSnapshotV1 = VersionedEnvelopeBase & {[0m
[32m  kind: "state_snapshot";[0m
[32m  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;[0m
[32m  state: PersistedAppStateV1;[0m
[32m};[0m
[32m[0m
[32mapply_patch(auto_approved=true) exited 0 in 30ms:[0m
[2mSuccess. Updated the following files:[0m
[2mA src/core/types/state.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/types/index.ts[0m
@@ -9 +9,2 @@
 export * from "./runtime.js";
[32m+export * from "./state.js";[0m
[32mapply_patch(auto_approved=true) exited 0 in 18ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/types/index.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/types/events.ts[0m
@@ -3,2 +3,3 @@
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
[32m+import type { StateSnapshotV1 } from "./state.js";[0m
 
@@ -28,3 +29,3 @@
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
[31m-  | { type: "state/snapshot"; snapshot: unknown }[0m
[32m+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }[0m
   | { type: "settings/snapshot"; settings: unknown }
[32mapply_patch(auto_approved=true) exited 0 in 26ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/types/events.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+






[35m[3mthinking[0m[0m
**Evaluating UI overlays**

It looks like the UI shows a ‚ÄúWaiting for leader...‚Äù overlay, and I‚Äôm considering the type‚Äîpossibly something like "sandbox-permission" or "pending-sandbox." The legacy types include "sandbox-permission" and "worker-permission". There‚Äôs also "pendingWorkerRequest," but I‚Äôm not sure if that fits in with the overlay. Maybe we need to explore CLI encyclopedia 9.8.2 to clarify whether it‚Äôs "sandbox-permission" or a new type like "sandbox-permission-waiting." For now, I‚Äôll define input `pendingSandboxRequestActive` to prioritize it.
[35m[3mthinking[0m[0m
**Defining overlay selections**

I‚Äôm working on the precedence list, where step 3 indicates that "sandbox permission requests" include both local queue and any pending sandbox requests. So, I‚Äôll treat `sandboxPermissions.queue.length > 0` or `pendingSandboxRequest != null` as a sign of a "sandbox-permission" overlay. For the worker side, if there‚Äôs a worker permissions queue or a `pendingWorkerRequest`, we‚Äôll consider it a worker-permission overlay too. I‚Äôll define `OverlaySelectionInputs`, export `LEGACY_OVERLAY_PRECEDENCE`, and set up the notification types and priorities as outlined.
[35m[3mthinking[0m[0m
**Defining notification effects**

I need to define `NotificationEffect`, which includes scheduling effects for notifications. For the notifications module, this might look like: `{ type: "effect/notification-schedule-timeout"; key: string; timeoutMs: number }` or `{ type: "effect/notification-cancel-timeout"; key?: string }`. The reducer will collect these effects, and I‚Äôll implement pure functions like `addNotification(state, notif)`. If the notification's priority is immediate, I‚Äôll requeue the previous current notification and handle timeouts by canceling existing ones, setting new ones, and filtering out others in the queue.
[35m[3mthinking[0m[0m
**Handling immediate notifications**

When adding an immediate notification, the effects should cancel the current timeout if one exists and schedule a new timeout for the `notif.key`. The new queue will be constructed by combining the previous current notification (if it exists) with the existing queue, filtering out any notifications marked "immediate" or those whose keys are in the invalidates. It seems reasonable to also remove the new notification if it's a duplicate. If the notification is non-immediate, it will only enqueue if its key isn‚Äôt already present, and I‚Äôll ensure the next notification is shown if idle.
[35m[3mthinking[0m[0m
**Implementing notification and state management**

I'm setting the immediate notification as current, removing it from the queue, and starting a timeout to clear it, followed by a call to drain again. The `drainNotifications(state)` function will handle this, while `expireNotification(state, key)` will clear the current notification if it matches the key and remove any invalidated queued items. Now, I'll define the `AppState` type, which includes various UI structures and notification states. For utilities, I‚Äôll also implement a generic `PriorityQueue<T>` and `ExclusiveQueue` in the state management. Tracking app persistence and crash recovery will be key, with functions to manage state snapshots and restore functionality.
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+

[3m[35mfile update[0m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/state/overlays.ts[0m
[32mexport type OverlayKind =[0m
[32m  | "message-selector"[0m
[32m  | "sandbox-permission"[0m
[32m  | "tool-permission"[0m
[32m  | "worker-permission"[0m
[32m  | "worker-sandbox-permission"[0m
[32m  | "elicitation"[0m
[32m  | "cost"[0m
[32m  | "ide-onboarding";[0m
[32m[0m
[32mexport const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [[0m
[32m  "message-selector",[0m
[32m  "sandbox-permission",[0m
[32m  "tool-permission",[0m
[32m  "worker-permission",[0m
[32m  "worker-sandbox-permission",[0m
[32m  "elicitation",[0m
[32m  "cost",[0m
[32m  "ide-onboarding"[0m
[32m] as const;[0m
[32m[0m
[32mexport type OverlaySelectionInputs = {[0m
[32m  exiting?: boolean;[0m
[32m  exitMessageActive?: boolean;[0m
[32m  messageSelectorOpen?: boolean;[0m
[32m  sandboxPermissionQueueLength?: number;[0m
[32m  pendingSandboxRequestActive?: boolean;[0m
[32m  toolPermissionActive?: boolean;[0m
[32m  workerPermissionQueueLength?: number;[0m
[32m  pendingWorkerRequestActive?: boolean;[0m
[32m  workerSandboxPermissionQueueLength?: number;[0m
[32m  elicitationQueueLength?: number;[0m
[32m  costNoticeActive?: boolean;[0m
[32m  ideOnboardingActive?: boolean;[0m
[32m};[0m
[32m[0m
[32mexport function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {[0m
[32m  if (inputs.exiting || inputs.exitMessageActive) return null;[0m
[32m  if (inputs.messageSelectorOpen) return "message-selector";[0m
[32m[0m
[32m  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;[0m
[32m  if (hasSandboxPrompt) return "sandbox-permission";[0m
[32m[0m
[32m  if (inputs.toolPermissionActive) return "tool-permission";[0m
[32m[0m
[32m  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;[0m
[32m  if (hasWorkerPermission) return "worker-permission";[0m
[32m[0m
[32m  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";[0m
[32m  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";[0m
[32m  if (inputs.costNoticeActive) return "cost";[0m
[32m  if (inputs.ideOnboardingActive) return "ide-onboarding";[0m
[32m  return null;[0m
[32m}[0m
[32m[0m
[32mapply_patch(auto_approved=true) exited 0 in 28ms:[0m
[2mSuccess. Updated the following files:[0m
[2mA src/core/state/overlays.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/state/overlays.ts b/src/core/state/overlays.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a352707c5371f79c9647ad52dbc67193bd99cc40
--- /dev/null
+++ b/src/core/state/overlays.ts
@@ -0,0 +1,55 @@
+export type OverlayKind =
+  | "message-selector"
+  | "sandbox-permission"
+  | "tool-permission"
+  | "worker-permission"
+  | "worker-sandbox-permission"
+  | "elicitation"
+  | "cost"
+  | "ide-onboarding";
+
+export const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [
+  "message-selector",
+  "sandbox-permission",
+  "tool-permission",
+  "worker-permission",
+  "worker-sandbox-permission",
+  "elicitation",
+  "cost",
+  "ide-onboarding"
+] as const;
+
+export type OverlaySelectionInputs = {
+  exiting?: boolean;
+  exitMessageActive?: boolean;
+  messageSelectorOpen?: boolean;
+  sandboxPermissionQueueLength?: number;
+  pendingSandboxRequestActive?: boolean;
+  toolPermissionActive?: boolean;
+  workerPermissionQueueLength?: number;
+  pendingWorkerRequestActive?: boolean;
+  workerSandboxPermissionQueueLength?: number;
+  elicitationQueueLength?: number;
+  costNoticeActive?: boolean;
+  ideOnboardingActive?: boolean;
+};
+
+export function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {
+  if (inputs.exiting || inputs.exitMessageActive) return null;
+  if (inputs.messageSelectorOpen) return "message-selector";
+
+  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;
+  if (hasSandboxPrompt) return "sandbox-permission";
+
+  if (inputs.toolPermissionActive) return "tool-permission";
+
+  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
+  if (hasWorkerPermission) return "worker-permission";
+
+  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
+  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";
+  if (inputs.costNoticeActive) return "cost";
+  if (inputs.ideOnboardingActive) return "ide-onboarding";
+  return null;
+}
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/state/overlays.ts b/src/core/state/overlays.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a352707c5371f79c9647ad52dbc67193bd99cc40
--- /dev/null
+++ b/src/core/state/overlays.ts
@@ -0,0 +1,55 @@
+export type OverlayKind =
+  | "message-selector"
+  | "sandbox-permission"
+  | "tool-permission"
+  | "worker-permission"
+  | "worker-sandbox-permission"
+  | "elicitation"
+  | "cost"
+  | "ide-onboarding";
+
+export const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [
+  "message-selector",
+  "sandbox-permission",
+  "tool-permission",
+  "worker-permission",
+  "worker-sandbox-permission",
+  "elicitation",
+  "cost",
+  "ide-onboarding"
+] as const;
+
+export type OverlaySelectionInputs = {
+  exiting?: boolean;
+  exitMessageActive?: boolean;
+  messageSelectorOpen?: boolean;
+  sandboxPermissionQueueLength?: number;
+  pendingSandboxRequestActive?: boolean;
+  toolPermissionActive?: boolean;
+  workerPermissionQueueLength?: number;
+  pendingWorkerRequestActive?: boolean;
+  workerSandboxPermissionQueueLength?: number;
+  elicitationQueueLength?: number;
+  costNoticeActive?: boolean;
+  ideOnboardingActive?: boolean;
+};
+
+export function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {
+  if (inputs.exiting || inputs.exitMessageActive) return null;
+  if (inputs.messageSelectorOpen) return "message-selector";
+
+  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;
+  if (hasSandboxPrompt) return "sandbox-permission";
+
+  if (inputs.toolPermissionActive) return "tool-permission";
+
+  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
+  if (hasWorkerPermission) return "worker-permission";
+
+  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
+  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";
+  if (inputs.costNoticeActive) return "cost";
+  if (inputs.ideOnboardingActive) return "ide-onboarding";
+  return null;
+}
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+

[3m[35mfile update[0m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/state/notifications.ts[0m
[32mexport type NotificationPriority = "immediate" | "high" | "medium" | "low";[0m
[32m[0m
[32mexport type Notification = {[0m
[32m  key: string;[0m
[32m  text: string;[0m
[32m  priority: NotificationPriority;[0m
[32m  color?: string;[0m
[32m  timeoutMs?: number;[0m
[32m  invalidates?: string[];[0m
[32m};[0m
[32m[0m
[32mexport type NotificationState = {[0m
[32m  current: Notification | null;[0m
[32m  queue: Notification[];[0m
[32m};[0m
[32m[0m
[32mexport const DEFAULT_NOTIFICATION_TIMEOUT_MS = 8000;[0m
[32m[0m
[32mexport type NotificationEffect =[0m
[32m  | { type: "effect/notification-cancel-timeout" }[0m
[32m  | { type: "effect/notification-schedule-timeout"; key: string; timeoutMs: number };[0m
[32m[0m
[32mconst priorityOrder: Record<NotificationPriority, number> = {[0m
[32m  immediate: 0,[0m
[32m  high: 1,[0m
[32m  medium: 2,[0m
[32m  low: 3[0m
[32m};[0m
[32m[0m
[32mfunction sortByPriority(queue: Notification[]): Notification[] {[0m
[32m  return queue[0m
[32m    .slice()[0m
[32m    .sort((a, b) => (priorityOrder[a.priority] < priorityOrder[b.priority] ? -1 : priorityOrder[a.priority] > priorityOrder[b.priority] ? 1 : 0));[0m
[32m}[0m
[32m[0m
[32mfunction removeInvalidated(queue: Notification[], invalidates: readonly string[] | undefined): Notification[] {[0m
[32m  if (!invalidates || invalidates.length === 0) return queue;[0m
[32m  const invalidated = new Set(invalidates);[0m
[32m  return queue.filter((n) => !invalidated.has(n.key));[0m
[32m}[0m
[32m[0m
[32mfunction dedupeByKey(queue: Notification[], key: string): Notification[] {[0m
[32m  return queue.filter((n) => n.key !== key);[0m
[32m}[0m
[32m[0m
[32mexport function drainNotifications(state: NotificationState): { state: NotificationState; effects: NotificationEffect[] } {[0m
[32m  if (state.current) return { state, effects: [] };[0m
[32m  if (state.queue.length === 0) return { state, effects: [] };[0m
[32m[0m
[32m  const sorted = sortByPriority(state.queue);[0m
[32m  const next = sorted[0];[0m
[32m  const remaining = sorted.slice(1);[0m
[32m  const timeoutMs = next.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;[0m
[32m  return {[0m
[32m    state: { current: next, queue: remaining },[0m
[32m    effects: [{ type: "effect/notification-schedule-timeout", key: next.key, timeoutMs }][0m
[32m  };[0m
[32m}[0m
[32m[0m
[32mexport function addNotification(state: NotificationState, notification: Notification): { state: NotificationState; effects: NotificationEffect[] } {[0m
[32m  const invalidates = notification.invalidates ?? [];[0m
[32m[0m
[32m  if (notification.priority === "immediate") {[0m
[32m    const prevCurrent = state.current;[0m
[32m    const merged = [...(prevCurrent ? [prevCurrent] : []), ...state.queue];[0m
[32m    const filtered = removeInvalidated([0m
[32m      merged.filter((n) => n.priority !== "immediate"),[0m
[32m      invalidates[0m
[32m    );[0m
[32m[0m
[32m    const nextState: NotificationState = {[0m
[32m      current: notification,[0m
[32m      queue: dedupeByKey(filtered, notification.key)[0m
[32m    };[0m
[32m[0m
[32m    const timeoutMs = notification.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;[0m
[32m    return {[0m
[32m      state: nextState,[0m
[32m      effects: [[0m
[32m        { type: "effect/notification-cancel-timeout" },[0m
[32m        { type: "effect/notification-schedule-timeout", key: notification.key, timeoutMs }[0m
[32m      ][0m
[32m    };[0m
[32m  }[0m
[32m[0m
[32m  const currentKey = state.current?.key ?? null;[0m
[32m  const alreadyQueued = state.queue.some((n) => n.key === notification.key);[0m
[32m  if (currentKey === notification.key || alreadyQueued) {[0m
[32m    const pruned = removeInvalidated(state.queue, invalidates);[0m
[32m    const drained = drainNotifications({ current: state.current, queue: pruned });[0m
[32m    return drained;[0m
[32m  }[0m
[32m[0m
[32m  const pruned = removeInvalidated(state.queue, invalidates);[0m
[32m  const next = { current: state.current, queue: [...pruned, notification] };[0m
[32m  return drainNotifications(next);[0m
[32m}[0m
[32m[0m
[32mexport function expireCurrentNotification([0m
[32m  state: NotificationState,[0m
[32m  key: string[0m
[32m): { state: NotificationState; effects: NotificationEffect[] } {[0m
[32m  if (!state.current || state.current.key !== key) return { state, effects: [] };[0m
[32m[0m
[32m  const invalidates = state.current.invalidates ?? [];[0m
[32m  const pruned = removeInvalidated(state.queue.filter((n) => n.priority !== "immediate"), invalidates);[0m
[32m  const cleared: NotificationState = { current: null, queue: pruned };[0m
[32m  return drainNotifications(cleared);[0m
[32m}[0m
[32m[0m
[32mapply_patch(auto_approved=true) exited 0 in 33ms:[0m
[2mSuccess. Updated the following files:[0m
[2mA src/core/state/notifications.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/state/notifications.ts b/src/core/state/notifications.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f8dde458abe0ab190a09282b2445f708c11d9bc
--- /dev/null
+++ b/src/core/state/notifications.ts
@@ -0,0 +1,110 @@
+export type NotificationPriority = "immediate" | "high" | "medium" | "low";
+
+export type Notification = {
+  key: string;
+  text: string;
+  priority: NotificationPriority;
+  color?: string;
+  timeoutMs?: number;
+  invalidates?: string[];
+};
+
+export type NotificationState = {
+  current: Notification | null;
+  queue: Notification[];
+};
+
+export const DEFAULT_NOTIFICATION_TIMEOUT_MS = 8000;
+
+export type NotificationEffect =
+  | { type: "effect/notification-cancel-timeout" }
+  | { type: "effect/notification-schedule-timeout"; key: string; timeoutMs: number };
+
+const priorityOrder: Record<NotificationPriority, number> = {
+  immediate: 0,
+  high: 1,
+  medium: 2,
+  low: 3
+};
+
+function sortByPriority(queue: Notification[]): Notification[] {
+  return queue
+    .slice()
+    .sort((a, b) => (priorityOrder[a.priority] < priorityOrder[b.priority] ? -1 : priorityOrder[a.priority] > priorityOrder[b.priority] ? 1 : 0));
+}
+
+function removeInvalidated(queue: Notification[], invalidates: readonly string[] | undefined): Notification[] {
+  if (!invalidates || invalidates.length === 0) return queue;
+  const invalidated = new Set(invalidates);
+  return queue.filter((n) => !invalidated.has(n.key));
+}
+
+function dedupeByKey(queue: Notification[], key: string): Notification[] {
+  return queue.filter((n) => n.key !== key);
+}
+
+export function drainNotifications(state: NotificationState): { state: NotificationState; effects: NotificationEffect[] } {
+  if (state.current) return { state, effects: [] };
+  if (state.queue.length === 0) return { state, effects: [] };
+
+  const sorted = sortByPriority(state.queue);
+  const next = sorted[0];
+  const remaining = sorted.slice(1);
+  const timeoutMs = next.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+  return {
+    state: { current: next, queue: remaining },
+    effects: [{ type: "effect/notification-schedule-timeout", key: next.key, timeoutMs }]
+  };
+}
+
+export function addNotification(state: NotificationState, notification: Notification): { state: NotificationState; effects: NotificationEffect[] } {
+  const invalidates = notification.invalidates ?? [];
+
+  if (notification.priority === "immediate") {
+    const prevCurrent = state.current;
+    const merged = [...(prevCurrent ? [prevCurrent] : []), ...state.queue];
+    const filtered = removeInvalidated(
+      merged.filter((n) => n.priority !== "immediate"),
+      invalidates
+    );
+
+    const nextState: NotificationState = {
+      current: notification,
+      queue: dedupeByKey(filtered, notification.key)
+    };
+
+    const timeoutMs = notification.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+    return {
+      state: nextState,
+      effects: [
+        { type: "effect/notification-cancel-timeout" },
+        { type: "effect/notification-schedule-timeout", key: notification.key, timeoutMs }
+      ]
+    };
+  }
+
+  const currentKey = state.current?.key ?? null;
+  const alreadyQueued = state.queue.some((n) => n.key === notification.key);
+  if (currentKey === notification.key || alreadyQueued) {
+    const pruned = removeInvalidated(state.queue, invalidates);
+    const drained = drainNotifications({ current: state.current, queue: pruned });
+    return drained;
+  }
+
+  const pruned = removeInvalidated(state.queue, invalidates);
+  const next = { current: state.current, queue: [...pruned, notification] };
+  return drainNotifications(next);
+}
+
+export function expireCurrentNotification(
+  state: NotificationState,
+  key: string
+): { state: NotificationState; effects: NotificationEffect[] } {
+  if (!state.current || state.current.key !== key) return { state, effects: [] };
+
+  const invalidates = state.current.invalidates ?? [];
+  const pruned = removeInvalidated(state.queue.filter((n) => n.priority !== "immediate"), invalidates);
+  const cleared: NotificationState = { current: null, queue: pruned };
+  return drainNotifications(cleared);
+}
+
diff --git a/src/core/state/overlays.ts b/src/core/state/overlays.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a352707c5371f79c9647ad52dbc67193bd99cc40
--- /dev/null
+++ b/src/core/state/overlays.ts
@@ -0,0 +1,55 @@
+export type OverlayKind =
+  | "message-selector"
+  | "sandbox-permission"
+  | "tool-permission"
+  | "worker-permission"
+  | "worker-sandbox-permission"
+  | "elicitation"
+  | "cost"
+  | "ide-onboarding";
+
+export const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [
+  "message-selector",
+  "sandbox-permission",
+  "tool-permission",
+  "worker-permission",
+  "worker-sandbox-permission",
+  "elicitation",
+  "cost",
+  "ide-onboarding"
+] as const;
+
+export type OverlaySelectionInputs = {
+  exiting?: boolean;
+  exitMessageActive?: boolean;
+  messageSelectorOpen?: boolean;
+  sandboxPermissionQueueLength?: number;
+  pendingSandboxRequestActive?: boolean;
+  toolPermissionActive?: boolean;
+  workerPermissionQueueLength?: number;
+  pendingWorkerRequestActive?: boolean;
+  workerSandboxPermissionQueueLength?: number;
+  elicitationQueueLength?: number;
+  costNoticeActive?: boolean;
+  ideOnboardingActive?: boolean;
+};
+
+export function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {
+  if (inputs.exiting || inputs.exitMessageActive) return null;
+  if (inputs.messageSelectorOpen) return "message-selector";
+
+  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;
+  if (hasSandboxPrompt) return "sandbox-permission";
+
+  if (inputs.toolPermissionActive) return "tool-permission";
+
+  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
+  if (hasWorkerPermission) return "worker-permission";
+
+  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
+  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";
+  if (inputs.costNoticeActive) return "cost";
+  if (inputs.ideOnboardingActive) return "ide-onboarding";
+  return null;
+}
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+


[35m[3mthinking[0m[0m
**Implementing helper module**

I need to focus on formatting the sortByPriority line since it‚Äôs long, but it might be okay as-is. I‚Äôll make sure to run a typecheck to catch any potential issues before moving forward. The next step is to implement the transcript helper module, so I want to ensure everything is in good shape before I do that. It feels important to stay organized and double-check my work to avoid any mistakes!
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/state/notifications.ts b/src/core/state/notifications.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f8dde458abe0ab190a09282b2445f708c11d9bc
--- /dev/null
+++ b/src/core/state/notifications.ts
@@ -0,0 +1,110 @@
+export type NotificationPriority = "immediate" | "high" | "medium" | "low";
+
+export type Notification = {
+  key: string;
+  text: string;
+  priority: NotificationPriority;
+  color?: string;
+  timeoutMs?: number;
+  invalidates?: string[];
+};
+
+export type NotificationState = {
+  current: Notification | null;
+  queue: Notification[];
+};
+
+export const DEFAULT_NOTIFICATION_TIMEOUT_MS = 8000;
+
+export type NotificationEffect =
+  | { type: "effect/notification-cancel-timeout" }
+  | { type: "effect/notification-schedule-timeout"; key: string; timeoutMs: number };
+
+const priorityOrder: Record<NotificationPriority, number> = {
+  immediate: 0,
+  high: 1,
+  medium: 2,
+  low: 3
+};
+
+function sortByPriority(queue: Notification[]): Notification[] {
+  return queue
+    .slice()
+    .sort((a, b) => (priorityOrder[a.priority] < priorityOrder[b.priority] ? -1 : priorityOrder[a.priority] > priorityOrder[b.priority] ? 1 : 0));
+}
+
+function removeInvalidated(queue: Notification[], invalidates: readonly string[] | undefined): Notification[] {
+  if (!invalidates || invalidates.length === 0) return queue;
+  const invalidated = new Set(invalidates);
+  return queue.filter((n) => !invalidated.has(n.key));
+}
+
+function dedupeByKey(queue: Notification[], key: string): Notification[] {
+  return queue.filter((n) => n.key !== key);
+}
+
+export function drainNotifications(state: NotificationState): { state: NotificationState; effects: NotificationEffect[] } {
+  if (state.current) return { state, effects: [] };
+  if (state.queue.length === 0) return { state, effects: [] };
+
+  const sorted = sortByPriority(state.queue);
+  const next = sorted[0];
+  const remaining = sorted.slice(1);
+  const timeoutMs = next.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+  return {
+    state: { current: next, queue: remaining },
+    effects: [{ type: "effect/notification-schedule-timeout", key: next.key, timeoutMs }]
+  };
+}
+
+export function addNotification(state: NotificationState, notification: Notification): { state: NotificationState; effects: NotificationEffect[] } {
+  const invalidates = notification.invalidates ?? [];
+
+  if (notification.priority === "immediate") {
+    const prevCurrent = state.current;
+    const merged = [...(prevCurrent ? [prevCurrent] : []), ...state.queue];
+    const filtered = removeInvalidated(
+      merged.filter((n) => n.priority !== "immediate"),
+      invalidates
+    );
+
+    const nextState: NotificationState = {
+      current: notification,
+      queue: dedupeByKey(filtered, notification.key)
+    };
+
+    const timeoutMs = notification.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+    return {
+      state: nextState,
+      effects: [
+        { type: "effect/notification-cancel-timeout" },
+        { type: "effect/notification-schedule-timeout", key: notification.key, timeoutMs }
+      ]
+    };
+  }
+
+  const currentKey = state.current?.key ?? null;
+  const alreadyQueued = state.queue.some((n) => n.key === notification.key);
+  if (currentKey === notification.key || alreadyQueued) {
+    const pruned = removeInvalidated(state.queue, invalidates);
+    const drained = drainNotifications({ current: state.current, queue: pruned });
+    return drained;
+  }
+
+  const pruned = removeInvalidated(state.queue, invalidates);
+  const next = { current: state.current, queue: [...pruned, notification] };
+  return drainNotifications(next);
+}
+
+export function expireCurrentNotification(
+  state: NotificationState,
+  key: string
+): { state: NotificationState; effects: NotificationEffect[] } {
+  if (!state.current || state.current.key !== key) return { state, effects: [] };
+
+  const invalidates = state.current.invalidates ?? [];
+  const pruned = removeInvalidated(state.queue.filter((n) => n.priority !== "immediate"), invalidates);
+  const cleared: NotificationState = { current: null, queue: pruned };
+  return drainNotifications(cleared);
+}
+
diff --git a/src/core/state/overlays.ts b/src/core/state/overlays.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a352707c5371f79c9647ad52dbc67193bd99cc40
--- /dev/null
+++ b/src/core/state/overlays.ts
@@ -0,0 +1,55 @@
+export type OverlayKind =
+  | "message-selector"
+  | "sandbox-permission"
+  | "tool-permission"
+  | "worker-permission"
+  | "worker-sandbox-permission"
+  | "elicitation"
+  | "cost"
+  | "ide-onboarding";
+
+export const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [
+  "message-selector",
+  "sandbox-permission",
+  "tool-permission",
+  "worker-permission",
+  "worker-sandbox-permission",
+  "elicitation",
+  "cost",
+  "ide-onboarding"
+] as const;
+
+export type OverlaySelectionInputs = {
+  exiting?: boolean;
+  exitMessageActive?: boolean;
+  messageSelectorOpen?: boolean;
+  sandboxPermissionQueueLength?: number;
+  pendingSandboxRequestActive?: boolean;
+  toolPermissionActive?: boolean;
+  workerPermissionQueueLength?: number;
+  pendingWorkerRequestActive?: boolean;
+  workerSandboxPermissionQueueLength?: number;
+  elicitationQueueLength?: number;
+  costNoticeActive?: boolean;
+  ideOnboardingActive?: boolean;
+};
+
+export function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {
+  if (inputs.exiting || inputs.exitMessageActive) return null;
+  if (inputs.messageSelectorOpen) return "message-selector";
+
+  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;
+  if (hasSandboxPrompt) return "sandbox-permission";
+
+  if (inputs.toolPermissionActive) return "tool-permission";
+
+  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
+  if (hasWorkerPermission) return "worker-permission";
+
+  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
+  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";
+  if (inputs.costNoticeActive) return "cost";
+  if (inputs.ideOnboardingActive) return "ide-onboarding";
+  return null;
+}
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+

[3m[35mfile update[0m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/state/transcript.ts[0m
[32mimport type { HostCrypto } from "../types/host.js";[0m
[32mimport { canonicalJsonStringify } from "../types/canonicalJson.js";[0m
[32mimport { REDACTED, type Sensitive, type TranscriptEventV1, type TranscriptLogV1 } from "../types/state.js";[0m
[32m[0m
[32mexport type RedactionStats = {[0m
[32m  redactedNodes: number;[0m
[32m};[0m
[32m[0m
[32mfunction isPlainObject(value: unknown): value is Record<string, unknown> {[0m
[32m  if (value === null || typeof value !== "object") return false;[0m
[32m  const proto = Object.getPrototypeOf(value);[0m
[32m  return proto === Object.prototype || proto === null;[0m
[32m}[0m
[32m[0m
[32mfunction isSensitive(value: unknown): value is Sensitive<unknown> {[0m
[32m  return isPlainObject(value) && value["kind"] === "sensitive" && "value" in value;[0m
[32m}[0m
[32m[0m
[32mfunction redactValue(value: unknown, stats: RedactionStats): unknown {[0m
[32m  if (isSensitive(value)) {[0m
[32m    stats.redactedNodes += 1;[0m
[32m    return REDACTED;[0m
[32m  }[0m
[32m  if (value === null) return null;[0m
[32m  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") return value;[0m
[32m  if (Array.isArray(value)) return value.map((v) => redactValue(v, stats));[0m
[32m  if (isPlainObject(value)) {[0m
[32m    const out: Record<string, unknown> = {};[0m
[32m    for (const [k, v] of Object.entries(value)) out[k] = redactValue(v, stats);[0m
[32m    return out;[0m
[32m  }[0m
[32m  return value;[0m
[32m}[0m
[32m[0m
[32mexport function redactTranscriptEvent(event: TranscriptEventV1): { event: TranscriptEventV1; stats: RedactionStats } {[0m
[32m  const stats: RedactionStats = { redactedNodes: 0 };[0m
[32m  const redacted = redactValue(event, stats) as TranscriptEventV1;[0m
[32m  return { event: redacted, stats };[0m
[32m}[0m
[32m[0m
[32mexport function redactTranscriptLog(log: TranscriptLogV1): { log: TranscriptLogV1; stats: RedactionStats } {[0m
[32m  const stats: RedactionStats = { redactedNodes: 0 };[0m
[32m  const events = log.events.map((evt) => redactValue(evt, stats) as TranscriptEventV1);[0m
[32m  return { log: { ...log, events }, stats };[0m
[32m}[0m
[32m[0m
[32mfunction bytesToHex(bytes: Uint8Array): string {[0m
[32m  let out = "";[0m
[32m  for (const b of bytes) out += b.toString(16).padStart(2, "0");[0m
[32m  return out;[0m
[32m}[0m
[32m[0m
[32mexport async function computeTranscriptSummary([0m
[32m  log: TranscriptLogV1,[0m
[32m  crypto: HostCrypto[0m
[32m): Promise<{ eventCount: number; sha256Hex: string; redactedNodes: number }> {[0m
[32m  const { log: redacted, stats } = redactTranscriptLog(log);[0m
[32m  const json = canonicalJsonStringify(redacted, { pretty: false });[0m
[32m  const data = new TextEncoder().encode(json);[0m
[32m  const digest = await crypto.digest("SHA-256", data);[0m
[32m  return { eventCount: redacted.events.length, sha256Hex: bytesToHex(digest), redactedNodes: stats.redactedNodes };[0m
[32m}[0m
[32m[0m
[32mapply_patch(auto_approved=true) exited 0 in 37ms:[0m
[2mSuccess. Updated the following files:[0m
[2mA src/core/state/transcript.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/state/notifications.ts b/src/core/state/notifications.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f8dde458abe0ab190a09282b2445f708c11d9bc
--- /dev/null
+++ b/src/core/state/notifications.ts
@@ -0,0 +1,110 @@
+export type NotificationPriority = "immediate" | "high" | "medium" | "low";
+
+export type Notification = {
+  key: string;
+  text: string;
+  priority: NotificationPriority;
+  color?: string;
+  timeoutMs?: number;
+  invalidates?: string[];
+};
+
+export type NotificationState = {
+  current: Notification | null;
+  queue: Notification[];
+};
+
+export const DEFAULT_NOTIFICATION_TIMEOUT_MS = 8000;
+
+export type NotificationEffect =
+  | { type: "effect/notification-cancel-timeout" }
+  | { type: "effect/notification-schedule-timeout"; key: string; timeoutMs: number };
+
+const priorityOrder: Record<NotificationPriority, number> = {
+  immediate: 0,
+  high: 1,
+  medium: 2,
+  low: 3
+};
+
+function sortByPriority(queue: Notification[]): Notification[] {
+  return queue
+    .slice()
+    .sort((a, b) => (priorityOrder[a.priority] < priorityOrder[b.priority] ? -1 : priorityOrder[a.priority] > priorityOrder[b.priority] ? 1 : 0));
+}
+
+function removeInvalidated(queue: Notification[], invalidates: readonly string[] | undefined): Notification[] {
+  if (!invalidates || invalidates.length === 0) return queue;
+  const invalidated = new Set(invalidates);
+  return queue.filter((n) => !invalidated.has(n.key));
+}
+
+function dedupeByKey(queue: Notification[], key: string): Notification[] {
+  return queue.filter((n) => n.key !== key);
+}
+
+export function drainNotifications(state: NotificationState): { state: NotificationState; effects: NotificationEffect[] } {
+  if (state.current) return { state, effects: [] };
+  if (state.queue.length === 0) return { state, effects: [] };
+
+  const sorted = sortByPriority(state.queue);
+  const next = sorted[0];
+  const remaining = sorted.slice(1);
+  const timeoutMs = next.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+  return {
+    state: { current: next, queue: remaining },
+    effects: [{ type: "effect/notification-schedule-timeout", key: next.key, timeoutMs }]
+  };
+}
+
+export function addNotification(state: NotificationState, notification: Notification): { state: NotificationState; effects: NotificationEffect[] } {
+  const invalidates = notification.invalidates ?? [];
+
+  if (notification.priority === "immediate") {
+    const prevCurrent = state.current;
+    const merged = [...(prevCurrent ? [prevCurrent] : []), ...state.queue];
+    const filtered = removeInvalidated(
+      merged.filter((n) => n.priority !== "immediate"),
+      invalidates
+    );
+
+    const nextState: NotificationState = {
+      current: notification,
+      queue: dedupeByKey(filtered, notification.key)
+    };
+
+    const timeoutMs = notification.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+    return {
+      state: nextState,
+      effects: [
+        { type: "effect/notification-cancel-timeout" },
+        { type: "effect/notification-schedule-timeout", key: notification.key, timeoutMs }
+      ]
+    };
+  }
+
+  const currentKey = state.current?.key ?? null;
+  const alreadyQueued = state.queue.some((n) => n.key === notification.key);
+  if (currentKey === notification.key || alreadyQueued) {
+    const pruned = removeInvalidated(state.queue, invalidates);
+    const drained = drainNotifications({ current: state.current, queue: pruned });
+    return drained;
+  }
+
+  const pruned = removeInvalidated(state.queue, invalidates);
+  const next = { current: state.current, queue: [...pruned, notification] };
+  return drainNotifications(next);
+}
+
+export function expireCurrentNotification(
+  state: NotificationState,
+  key: string
+): { state: NotificationState; effects: NotificationEffect[] } {
+  if (!state.current || state.current.key !== key) return { state, effects: [] };
+
+  const invalidates = state.current.invalidates ?? [];
+  const pruned = removeInvalidated(state.queue.filter((n) => n.priority !== "immediate"), invalidates);
+  const cleared: NotificationState = { current: null, queue: pruned };
+  return drainNotifications(cleared);
+}
+
diff --git a/src/core/state/overlays.ts b/src/core/state/overlays.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a352707c5371f79c9647ad52dbc67193bd99cc40
--- /dev/null
+++ b/src/core/state/overlays.ts
@@ -0,0 +1,55 @@
+export type OverlayKind =
+  | "message-selector"
+  | "sandbox-permission"
+  | "tool-permission"
+  | "worker-permission"
+  | "worker-sandbox-permission"
+  | "elicitation"
+  | "cost"
+  | "ide-onboarding";
+
+export const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [
+  "message-selector",
+  "sandbox-permission",
+  "tool-permission",
+  "worker-permission",
+  "worker-sandbox-permission",
+  "elicitation",
+  "cost",
+  "ide-onboarding"
+] as const;
+
+export type OverlaySelectionInputs = {
+  exiting?: boolean;
+  exitMessageActive?: boolean;
+  messageSelectorOpen?: boolean;
+  sandboxPermissionQueueLength?: number;
+  pendingSandboxRequestActive?: boolean;
+  toolPermissionActive?: boolean;
+  workerPermissionQueueLength?: number;
+  pendingWorkerRequestActive?: boolean;
+  workerSandboxPermissionQueueLength?: number;
+  elicitationQueueLength?: number;
+  costNoticeActive?: boolean;
+  ideOnboardingActive?: boolean;
+};
+
+export function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {
+  if (inputs.exiting || inputs.exitMessageActive) return null;
+  if (inputs.messageSelectorOpen) return "message-selector";
+
+  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;
+  if (hasSandboxPrompt) return "sandbox-permission";
+
+  if (inputs.toolPermissionActive) return "tool-permission";
+
+  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
+  if (hasWorkerPermission) return "worker-permission";
+
+  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
+  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";
+  if (inputs.costNoticeActive) return "cost";
+  if (inputs.ideOnboardingActive) return "ide-onboarding";
+  return null;
+}
+
diff --git a/src/core/state/transcript.ts b/src/core/state/transcript.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f9b512d495cf977b0b62fbbe91b1247887087dab
--- /dev/null
+++ b/src/core/state/transcript.ts
@@ -0,0 +1,63 @@
+import type { HostCrypto } from "../types/host.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import { REDACTED, type Sensitive, type TranscriptEventV1, type TranscriptLogV1 } from "../types/state.js";
+
+export type RedactionStats = {
+  redactedNodes: number;
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  if (value === null || typeof value !== "object") return false;
+  const proto = Object.getPrototypeOf(value);
+  return proto === Object.prototype || proto === null;
+}
+
+function isSensitive(value: unknown): value is Sensitive<unknown> {
+  return isPlainObject(value) && value["kind"] === "sensitive" && "value" in value;
+}
+
+function redactValue(value: unknown, stats: RedactionStats): unknown {
+  if (isSensitive(value)) {
+    stats.redactedNodes += 1;
+    return REDACTED;
+  }
+  if (value === null) return null;
+  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") return value;
+  if (Array.isArray(value)) return value.map((v) => redactValue(v, stats));
+  if (isPlainObject(value)) {
+    const out: Record<string, unknown> = {};
+    for (const [k, v] of Object.entries(value)) out[k] = redactValue(v, stats);
+    return out;
+  }
+  return value;
+}
+
+export function redactTranscriptEvent(event: TranscriptEventV1): { event: TranscriptEventV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const redacted = redactValue(event, stats) as TranscriptEventV1;
+  return { event: redacted, stats };
+}
+
+export function redactTranscriptLog(log: TranscriptLogV1): { log: TranscriptLogV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const events = log.events.map((evt) => redactValue(evt, stats) as TranscriptEventV1);
+  return { log: { ...log, events }, stats };
+}
+
+function bytesToHex(bytes: Uint8Array): string {
+  let out = "";
+  for (const b of bytes) out += b.toString(16).padStart(2, "0");
+  return out;
+}
+
+export async function computeTranscriptSummary(
+  log: TranscriptLogV1,
+  crypto: HostCrypto
+): Promise<{ eventCount: number; sha256Hex: string; redactedNodes: number }> {
+  const { log: redacted, stats } = redactTranscriptLog(log);
+  const json = canonicalJsonStringify(redacted, { pretty: false });
+  const data = new TextEncoder().encode(json);
+  const digest = await crypto.digest("SHA-256", data);
+  return { eventCount: redacted.events.length, sha256Hex: bytesToHex(digest), redactedNodes: stats.redactedNodes };
+}
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+


[35m[3mthinking[0m[0m
**Implementing persistence module**

I‚Äôm noting that the TextEncoder seems to be global in many environments, but to be on the safe side with Node, it does exist there too. While thinking about portability, I realize we may need a polyfill, but it‚Äôs essential that the core doesn‚Äôt import anything from Node. That's manageable. Now, I can focus on implementing the persistence module next! Let's keep moving forward with this!
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/state/notifications.ts b/src/core/state/notifications.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f8dde458abe0ab190a09282b2445f708c11d9bc
--- /dev/null
+++ b/src/core/state/notifications.ts
@@ -0,0 +1,110 @@
+export type NotificationPriority = "immediate" | "high" | "medium" | "low";
+
+export type Notification = {
+  key: string;
+  text: string;
+  priority: NotificationPriority;
+  color?: string;
+  timeoutMs?: number;
+  invalidates?: string[];
+};
+
+export type NotificationState = {
+  current: Notification | null;
+  queue: Notification[];
+};
+
+export const DEFAULT_NOTIFICATION_TIMEOUT_MS = 8000;
+
+export type NotificationEffect =
+  | { type: "effect/notification-cancel-timeout" }
+  | { type: "effect/notification-schedule-timeout"; key: string; timeoutMs: number };
+
+const priorityOrder: Record<NotificationPriority, number> = {
+  immediate: 0,
+  high: 1,
+  medium: 2,
+  low: 3
+};
+
+function sortByPriority(queue: Notification[]): Notification[] {
+  return queue
+    .slice()
+    .sort((a, b) => (priorityOrder[a.priority] < priorityOrder[b.priority] ? -1 : priorityOrder[a.priority] > priorityOrder[b.priority] ? 1 : 0));
+}
+
+function removeInvalidated(queue: Notification[], invalidates: readonly string[] | undefined): Notification[] {
+  if (!invalidates || invalidates.length === 0) return queue;
+  const invalidated = new Set(invalidates);
+  return queue.filter((n) => !invalidated.has(n.key));
+}
+
+function dedupeByKey(queue: Notification[], key: string): Notification[] {
+  return queue.filter((n) => n.key !== key);
+}
+
+export function drainNotifications(state: NotificationState): { state: NotificationState; effects: NotificationEffect[] } {
+  if (state.current) return { state, effects: [] };
+  if (state.queue.length === 0) return { state, effects: [] };
+
+  const sorted = sortByPriority(state.queue);
+  const next = sorted[0];
+  const remaining = sorted.slice(1);
+  const timeoutMs = next.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+  return {
+    state: { current: next, queue: remaining },
+    effects: [{ type: "effect/notification-schedule-timeout", key: next.key, timeoutMs }]
+  };
+}
+
+export function addNotification(state: NotificationState, notification: Notification): { state: NotificationState; effects: NotificationEffect[] } {
+  const invalidates = notification.invalidates ?? [];
+
+  if (notification.priority === "immediate") {
+    const prevCurrent = state.current;
+    const merged = [...(prevCurrent ? [prevCurrent] : []), ...state.queue];
+    const filtered = removeInvalidated(
+      merged.filter((n) => n.priority !== "immediate"),
+      invalidates
+    );
+
+    const nextState: NotificationState = {
+      current: notification,
+      queue: dedupeByKey(filtered, notification.key)
+    };
+
+    const timeoutMs = notification.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+    return {
+      state: nextState,
+      effects: [
+        { type: "effect/notification-cancel-timeout" },
+        { type: "effect/notification-schedule-timeout", key: notification.key, timeoutMs }
+      ]
+    };
+  }
+
+  const currentKey = state.current?.key ?? null;
+  const alreadyQueued = state.queue.some((n) => n.key === notification.key);
+  if (currentKey === notification.key || alreadyQueued) {
+    const pruned = removeInvalidated(state.queue, invalidates);
+    const drained = drainNotifications({ current: state.current, queue: pruned });
+    return drained;
+  }
+
+  const pruned = removeInvalidated(state.queue, invalidates);
+  const next = { current: state.current, queue: [...pruned, notification] };
+  return drainNotifications(next);
+}
+
+export function expireCurrentNotification(
+  state: NotificationState,
+  key: string
+): { state: NotificationState; effects: NotificationEffect[] } {
+  if (!state.current || state.current.key !== key) return { state, effects: [] };
+
+  const invalidates = state.current.invalidates ?? [];
+  const pruned = removeInvalidated(state.queue.filter((n) => n.priority !== "immediate"), invalidates);
+  const cleared: NotificationState = { current: null, queue: pruned };
+  return drainNotifications(cleared);
+}
+
diff --git a/src/core/state/overlays.ts b/src/core/state/overlays.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a352707c5371f79c9647ad52dbc67193bd99cc40
--- /dev/null
+++ b/src/core/state/overlays.ts
@@ -0,0 +1,55 @@
+export type OverlayKind =
+  | "message-selector"
+  | "sandbox-permission"
+  | "tool-permission"
+  | "worker-permission"
+  | "worker-sandbox-permission"
+  | "elicitation"
+  | "cost"
+  | "ide-onboarding";
+
+export const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [
+  "message-selector",
+  "sandbox-permission",
+  "tool-permission",
+  "worker-permission",
+  "worker-sandbox-permission",
+  "elicitation",
+  "cost",
+  "ide-onboarding"
+] as const;
+
+export type OverlaySelectionInputs = {
+  exiting?: boolean;
+  exitMessageActive?: boolean;
+  messageSelectorOpen?: boolean;
+  sandboxPermissionQueueLength?: number;
+  pendingSandboxRequestActive?: boolean;
+  toolPermissionActive?: boolean;
+  workerPermissionQueueLength?: number;
+  pendingWorkerRequestActive?: boolean;
+  workerSandboxPermissionQueueLength?: number;
+  elicitationQueueLength?: number;
+  costNoticeActive?: boolean;
+  ideOnboardingActive?: boolean;
+};
+
+export function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {
+  if (inputs.exiting || inputs.exitMessageActive) return null;
+  if (inputs.messageSelectorOpen) return "message-selector";
+
+  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;
+  if (hasSandboxPrompt) return "sandbox-permission";
+
+  if (inputs.toolPermissionActive) return "tool-permission";
+
+  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
+  if (hasWorkerPermission) return "worker-permission";
+
+  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
+  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";
+  if (inputs.costNoticeActive) return "cost";
+  if (inputs.ideOnboardingActive) return "ide-onboarding";
+  return null;
+}
+
diff --git a/src/core/state/transcript.ts b/src/core/state/transcript.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f9b512d495cf977b0b62fbbe91b1247887087dab
--- /dev/null
+++ b/src/core/state/transcript.ts
@@ -0,0 +1,63 @@
+import type { HostCrypto } from "../types/host.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import { REDACTED, type Sensitive, type TranscriptEventV1, type TranscriptLogV1 } from "../types/state.js";
+
+export type RedactionStats = {
+  redactedNodes: number;
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  if (value === null || typeof value !== "object") return false;
+  const proto = Object.getPrototypeOf(value);
+  return proto === Object.prototype || proto === null;
+}
+
+function isSensitive(value: unknown): value is Sensitive<unknown> {
+  return isPlainObject(value) && value["kind"] === "sensitive" && "value" in value;
+}
+
+function redactValue(value: unknown, stats: RedactionStats): unknown {
+  if (isSensitive(value)) {
+    stats.redactedNodes += 1;
+    return REDACTED;
+  }
+  if (value === null) return null;
+  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") return value;
+  if (Array.isArray(value)) return value.map((v) => redactValue(v, stats));
+  if (isPlainObject(value)) {
+    const out: Record<string, unknown> = {};
+    for (const [k, v] of Object.entries(value)) out[k] = redactValue(v, stats);
+    return out;
+  }
+  return value;
+}
+
+export function redactTranscriptEvent(event: TranscriptEventV1): { event: TranscriptEventV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const redacted = redactValue(event, stats) as TranscriptEventV1;
+  return { event: redacted, stats };
+}
+
+export function redactTranscriptLog(log: TranscriptLogV1): { log: TranscriptLogV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const events = log.events.map((evt) => redactValue(evt, stats) as TranscriptEventV1);
+  return { log: { ...log, events }, stats };
+}
+
+function bytesToHex(bytes: Uint8Array): string {
+  let out = "";
+  for (const b of bytes) out += b.toString(16).padStart(2, "0");
+  return out;
+}
+
+export async function computeTranscriptSummary(
+  log: TranscriptLogV1,
+  crypto: HostCrypto
+): Promise<{ eventCount: number; sha256Hex: string; redactedNodes: number }> {
+  const { log: redacted, stats } = redactTranscriptLog(log);
+  const json = canonicalJsonStringify(redacted, { pretty: false });
+  const data = new TextEncoder().encode(json);
+  const digest = await crypto.digest("SHA-256", data);
+  return { eventCount: redacted.events.length, sha256Hex: bytesToHex(digest), redactedNodes: stats.redactedNodes };
+}
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+

[3m[35mfile update[0m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/state/persistence.ts[0m
[32mimport type { HostStorage, StorageNamespace } from "../types/host.js";[0m
[32mimport type { PersistedAppStateV1, StateSnapshotV1 } from "../types/state.js";[0m
[32mimport { SCHEMA_VERSION } from "../types/schema.js";[0m
[32mimport { canonicalJsonStringify } from "../types/canonicalJson.js";[0m
[32m[0m
[32mexport const STATE_SNAPSHOT_STORAGE_KEY = "state/state_snapshot";[0m
[32m[0m
[32mexport type StateMigrationNote = {[0m
[32m  fromVersion: number;[0m
[32m  toVersion: number;[0m
[32m  note: string;[0m
[32m};[0m
[32m[0m
[32mexport type HydrationRecoveryNote = {[0m
[32m  kind: "tool_run_cancelled" | "hook_run_cancelled" | "other";[0m
[32m  sessionId: string;[0m
[32m  entityId: string;[0m
[32m  message: string;[0m
[32m};[0m
[32m[0m
[32mexport type HydrationResult = {[0m
[32m  persisted: PersistedAppStateV1;[0m
[32m  migrations: StateMigrationNote[];[0m
[32m  recovery: HydrationRecoveryNote[];[0m
[32m};[0m
[32m[0m
[32mexport class InvalidStateSnapshotError extends Error {[0m
[32m  readonly name = "InvalidStateSnapshotError";[0m
[32m  constructor(message: string) {[0m
[32m    super(message);[0m
[32m  }[0m
[32m}[0m
[32m[0m
[32mexport function encodeStateSnapshot(snapshot: StateSnapshotV1): string {[0m
[32m  return canonicalJsonStringify(snapshot);[0m
[32m}[0m
[32m[0m
[32mexport function decodeStateSnapshot(text: string): StateSnapshotV1 {[0m
[32m  const parsed = JSON.parse(text) as unknown;[0m
[32m  if (!parsed || typeof parsed !== "object") throw new InvalidStateSnapshotError("Snapshot is not an object");[0m
[32m  const obj = parsed as Record<string, unknown>;[0m
[32m  if (obj["kind"] !== "state_snapshot") throw new InvalidStateSnapshotError("Snapshot kind mismatch");[0m
[32m  if (obj["schemaVersion"] !== SCHEMA_VERSION.stateSnapshot) {[0m
[32m    throw new InvalidStateSnapshotError(`Unsupported state snapshot version: ${String(obj["schemaVersion"])}`);[0m
[32m  }[0m
[32m  if (!("state" in obj)) throw new InvalidStateSnapshotError("Snapshot missing state");[0m
[32m  return parsed as StateSnapshotV1;[0m
[32m}[0m
[32m[0m
[32mexport function migrateStateSnapshot(snapshot: StateSnapshotV1): HydrationResult {[0m
[32m  const migrations: StateMigrationNote[] = [];[0m
[32m  const recovery: HydrationRecoveryNote[] = [];[0m
[32m[0m
[32m  if (snapshot.schemaVersion !== SCHEMA_VERSION.stateSnapshot) {[0m
[32m    throw new InvalidStateSnapshotError(`Unsupported state snapshot schemaVersion: ${snapshot.schemaVersion}`);[0m
[32m  }[0m
[32m[0m
[32m  return { persisted: snapshot.state, migrations, recovery };[0m
[32m}[0m
[32m[0m
[32mexport async function loadStateSnapshot([0m
[32m  storage: HostStorage,[0m
[32m  namespace: StorageNamespace,[0m
[32m  key: string = STATE_SNAPSHOT_STORAGE_KEY[0m
[32m): Promise<StateSnapshotV1 | null> {[0m
[32m  const found = await storage.get(namespace, key);[0m
[32m  if (!found) return null;[0m
[32m  return decodeStateSnapshot(found.value);[0m
[32m}[0m
[32m[0m
[32mexport async function saveStateSnapshot([0m
[32m  storage: HostStorage,[0m
[32m  namespace: StorageNamespace,[0m
[32m  snapshot: StateSnapshotV1,[0m
[32m  key: string = STATE_SNAPSHOT_STORAGE_KEY,[0m
[32m  options?: { expectedVersion?: string | null }[0m
[32m): Promise<{ version: string }> {[0m
[32m  const encoded = encodeStateSnapshot(snapshot);[0m
[32m  const res = await storage.set(namespace, key, encoded, options);[0m
[32m  return res;[0m
[32m}[0m
[32m[0m
[32mapply_patch(auto_approved=true) exited 0 in 44ms:[0m
[2mSuccess. Updated the following files:[0m
[2mA src/core/state/persistence.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/state/notifications.ts b/src/core/state/notifications.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f8dde458abe0ab190a09282b2445f708c11d9bc
--- /dev/null
+++ b/src/core/state/notifications.ts
@@ -0,0 +1,110 @@
+export type NotificationPriority = "immediate" | "high" | "medium" | "low";
+
+export type Notification = {
+  key: string;
+  text: string;
+  priority: NotificationPriority;
+  color?: string;
+  timeoutMs?: number;
+  invalidates?: string[];
+};
+
+export type NotificationState = {
+  current: Notification | null;
+  queue: Notification[];
+};
+
+export const DEFAULT_NOTIFICATION_TIMEOUT_MS = 8000;
+
+export type NotificationEffect =
+  | { type: "effect/notification-cancel-timeout" }
+  | { type: "effect/notification-schedule-timeout"; key: string; timeoutMs: number };
+
+const priorityOrder: Record<NotificationPriority, number> = {
+  immediate: 0,
+  high: 1,
+  medium: 2,
+  low: 3
+};
+
+function sortByPriority(queue: Notification[]): Notification[] {
+  return queue
+    .slice()
+    .sort((a, b) => (priorityOrder[a.priority] < priorityOrder[b.priority] ? -1 : priorityOrder[a.priority] > priorityOrder[b.priority] ? 1 : 0));
+}
+
+function removeInvalidated(queue: Notification[], invalidates: readonly string[] | undefined): Notification[] {
+  if (!invalidates || invalidates.length === 0) return queue;
+  const invalidated = new Set(invalidates);
+  return queue.filter((n) => !invalidated.has(n.key));
+}
+
+function dedupeByKey(queue: Notification[], key: string): Notification[] {
+  return queue.filter((n) => n.key !== key);
+}
+
+export function drainNotifications(state: NotificationState): { state: NotificationState; effects: NotificationEffect[] } {
+  if (state.current) return { state, effects: [] };
+  if (state.queue.length === 0) return { state, effects: [] };
+
+  const sorted = sortByPriority(state.queue);
+  const next = sorted[0];
+  const remaining = sorted.slice(1);
+  const timeoutMs = next.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+  return {
+    state: { current: next, queue: remaining },
+    effects: [{ type: "effect/notification-schedule-timeout", key: next.key, timeoutMs }]
+  };
+}
+
+export function addNotification(state: NotificationState, notification: Notification): { state: NotificationState; effects: NotificationEffect[] } {
+  const invalidates = notification.invalidates ?? [];
+
+  if (notification.priority === "immediate") {
+    const prevCurrent = state.current;
+    const merged = [...(prevCurrent ? [prevCurrent] : []), ...state.queue];
+    const filtered = removeInvalidated(
+      merged.filter((n) => n.priority !== "immediate"),
+      invalidates
+    );
+
+    const nextState: NotificationState = {
+      current: notification,
+      queue: dedupeByKey(filtered, notification.key)
+    };
+
+    const timeoutMs = notification.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+    return {
+      state: nextState,
+      effects: [
+        { type: "effect/notification-cancel-timeout" },
+        { type: "effect/notification-schedule-timeout", key: notification.key, timeoutMs }
+      ]
+    };
+  }
+
+  const currentKey = state.current?.key ?? null;
+  const alreadyQueued = state.queue.some((n) => n.key === notification.key);
+  if (currentKey === notification.key || alreadyQueued) {
+    const pruned = removeInvalidated(state.queue, invalidates);
+    const drained = drainNotifications({ current: state.current, queue: pruned });
+    return drained;
+  }
+
+  const pruned = removeInvalidated(state.queue, invalidates);
+  const next = { current: state.current, queue: [...pruned, notification] };
+  return drainNotifications(next);
+}
+
+export function expireCurrentNotification(
+  state: NotificationState,
+  key: string
+): { state: NotificationState; effects: NotificationEffect[] } {
+  if (!state.current || state.current.key !== key) return { state, effects: [] };
+
+  const invalidates = state.current.invalidates ?? [];
+  const pruned = removeInvalidated(state.queue.filter((n) => n.priority !== "immediate"), invalidates);
+  const cleared: NotificationState = { current: null, queue: pruned };
+  return drainNotifications(cleared);
+}
+
diff --git a/src/core/state/overlays.ts b/src/core/state/overlays.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a352707c5371f79c9647ad52dbc67193bd99cc40
--- /dev/null
+++ b/src/core/state/overlays.ts
@@ -0,0 +1,55 @@
+export type OverlayKind =
+  | "message-selector"
+  | "sandbox-permission"
+  | "tool-permission"
+  | "worker-permission"
+  | "worker-sandbox-permission"
+  | "elicitation"
+  | "cost"
+  | "ide-onboarding";
+
+export const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [
+  "message-selector",
+  "sandbox-permission",
+  "tool-permission",
+  "worker-permission",
+  "worker-sandbox-permission",
+  "elicitation",
+  "cost",
+  "ide-onboarding"
+] as const;
+
+export type OverlaySelectionInputs = {
+  exiting?: boolean;
+  exitMessageActive?: boolean;
+  messageSelectorOpen?: boolean;
+  sandboxPermissionQueueLength?: number;
+  pendingSandboxRequestActive?: boolean;
+  toolPermissionActive?: boolean;
+  workerPermissionQueueLength?: number;
+  pendingWorkerRequestActive?: boolean;
+  workerSandboxPermissionQueueLength?: number;
+  elicitationQueueLength?: number;
+  costNoticeActive?: boolean;
+  ideOnboardingActive?: boolean;
+};
+
+export function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {
+  if (inputs.exiting || inputs.exitMessageActive) return null;
+  if (inputs.messageSelectorOpen) return "message-selector";
+
+  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;
+  if (hasSandboxPrompt) return "sandbox-permission";
+
+  if (inputs.toolPermissionActive) return "tool-permission";
+
+  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
+  if (hasWorkerPermission) return "worker-permission";
+
+  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
+  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";
+  if (inputs.costNoticeActive) return "cost";
+  if (inputs.ideOnboardingActive) return "ide-onboarding";
+  return null;
+}
+
diff --git a/src/core/state/persistence.ts b/src/core/state/persistence.ts
new file mode 100644
index 0000000000000000000000000000000000000000..504af5f7dce298785ae86601827c122322a0cdd4
--- /dev/null
+++ b/src/core/state/persistence.ts
@@ -0,0 +1,82 @@
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import type { PersistedAppStateV1, StateSnapshotV1 } from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+
+export const STATE_SNAPSHOT_STORAGE_KEY = "state/state_snapshot";
+
+export type StateMigrationNote = {
+  fromVersion: number;
+  toVersion: number;
+  note: string;
+};
+
+export type HydrationRecoveryNote = {
+  kind: "tool_run_cancelled" | "hook_run_cancelled" | "other";
+  sessionId: string;
+  entityId: string;
+  message: string;
+};
+
+export type HydrationResult = {
+  persisted: PersistedAppStateV1;
+  migrations: StateMigrationNote[];
+  recovery: HydrationRecoveryNote[];
+};
+
+export class InvalidStateSnapshotError extends Error {
+  readonly name = "InvalidStateSnapshotError";
+  constructor(message: string) {
+    super(message);
+  }
+}
+
+export function encodeStateSnapshot(snapshot: StateSnapshotV1): string {
+  return canonicalJsonStringify(snapshot);
+}
+
+export function decodeStateSnapshot(text: string): StateSnapshotV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new InvalidStateSnapshotError("Snapshot is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["kind"] !== "state_snapshot") throw new InvalidStateSnapshotError("Snapshot kind mismatch");
+  if (obj["schemaVersion"] !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot version: ${String(obj["schemaVersion"])}`);
+  }
+  if (!("state" in obj)) throw new InvalidStateSnapshotError("Snapshot missing state");
+  return parsed as StateSnapshotV1;
+}
+
+export function migrateStateSnapshot(snapshot: StateSnapshotV1): HydrationResult {
+  const migrations: StateMigrationNote[] = [];
+  const recovery: HydrationRecoveryNote[] = [];
+
+  if (snapshot.schemaVersion !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot schemaVersion: ${snapshot.schemaVersion}`);
+  }
+
+  return { persisted: snapshot.state, migrations, recovery };
+}
+
+export async function loadStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY
+): Promise<StateSnapshotV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeStateSnapshot(found.value);
+}
+
+export async function saveStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  snapshot: StateSnapshotV1,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeStateSnapshot(snapshot);
+  const res = await storage.set(namespace, key, encoded, options);
+  return res;
+}
+
diff --git a/src/core/state/transcript.ts b/src/core/state/transcript.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f9b512d495cf977b0b62fbbe91b1247887087dab
--- /dev/null
+++ b/src/core/state/transcript.ts
@@ -0,0 +1,63 @@
+import type { HostCrypto } from "../types/host.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import { REDACTED, type Sensitive, type TranscriptEventV1, type TranscriptLogV1 } from "../types/state.js";
+
+export type RedactionStats = {
+  redactedNodes: number;
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  if (value === null || typeof value !== "object") return false;
+  const proto = Object.getPrototypeOf(value);
+  return proto === Object.prototype || proto === null;
+}
+
+function isSensitive(value: unknown): value is Sensitive<unknown> {
+  return isPlainObject(value) && value["kind"] === "sensitive" && "value" in value;
+}
+
+function redactValue(value: unknown, stats: RedactionStats): unknown {
+  if (isSensitive(value)) {
+    stats.redactedNodes += 1;
+    return REDACTED;
+  }
+  if (value === null) return null;
+  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") return value;
+  if (Array.isArray(value)) return value.map((v) => redactValue(v, stats));
+  if (isPlainObject(value)) {
+    const out: Record<string, unknown> = {};
+    for (const [k, v] of Object.entries(value)) out[k] = redactValue(v, stats);
+    return out;
+  }
+  return value;
+}
+
+export function redactTranscriptEvent(event: TranscriptEventV1): { event: TranscriptEventV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const redacted = redactValue(event, stats) as TranscriptEventV1;
+  return { event: redacted, stats };
+}
+
+export function redactTranscriptLog(log: TranscriptLogV1): { log: TranscriptLogV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const events = log.events.map((evt) => redactValue(evt, stats) as TranscriptEventV1);
+  return { log: { ...log, events }, stats };
+}
+
+function bytesToHex(bytes: Uint8Array): string {
+  let out = "";
+  for (const b of bytes) out += b.toString(16).padStart(2, "0");
+  return out;
+}
+
+export async function computeTranscriptSummary(
+  log: TranscriptLogV1,
+  crypto: HostCrypto
+): Promise<{ eventCount: number; sha256Hex: string; redactedNodes: number }> {
+  const { log: redacted, stats } = redactTranscriptLog(log);
+  const json = canonicalJsonStringify(redacted, { pretty: false });
+  const data = new TextEncoder().encode(json);
+  const digest = await crypto.digest("SHA-256", data);
+  return { eventCount: redacted.events.length, sha256Hex: bytesToHex(digest), redactedNodes: stats.redactedNodes };
+}
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+


[35m[3mthinking[0m[0m
**Planning migration functionality**

I see that the migration function is just a stub right now. For phase 5, it clearly needs crash recovery semantics, which are currently missing. I‚Äôm considering adding recovery in model/hydration instead of persistence. The plan requires these semantics, so I‚Äôll implement `recoverPersistedAppState` in the model and call this during the hydrate process. It seems like I also need to adjust persistence accordingly. I should create `appState.ts` with creation, hydration, and reducers.
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/state/notifications.ts b/src/core/state/notifications.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f8dde458abe0ab190a09282b2445f708c11d9bc
--- /dev/null
+++ b/src/core/state/notifications.ts
@@ -0,0 +1,110 @@
+export type NotificationPriority = "immediate" | "high" | "medium" | "low";
+
+export type Notification = {
+  key: string;
+  text: string;
+  priority: NotificationPriority;
+  color?: string;
+  timeoutMs?: number;
+  invalidates?: string[];
+};
+
+export type NotificationState = {
+  current: Notification | null;
+  queue: Notification[];
+};
+
+export const DEFAULT_NOTIFICATION_TIMEOUT_MS = 8000;
+
+export type NotificationEffect =
+  | { type: "effect/notification-cancel-timeout" }
+  | { type: "effect/notification-schedule-timeout"; key: string; timeoutMs: number };
+
+const priorityOrder: Record<NotificationPriority, number> = {
+  immediate: 0,
+  high: 1,
+  medium: 2,
+  low: 3
+};
+
+function sortByPriority(queue: Notification[]): Notification[] {
+  return queue
+    .slice()
+    .sort((a, b) => (priorityOrder[a.priority] < priorityOrder[b.priority] ? -1 : priorityOrder[a.priority] > priorityOrder[b.priority] ? 1 : 0));
+}
+
+function removeInvalidated(queue: Notification[], invalidates: readonly string[] | undefined): Notification[] {
+  if (!invalidates || invalidates.length === 0) return queue;
+  const invalidated = new Set(invalidates);
+  return queue.filter((n) => !invalidated.has(n.key));
+}
+
+function dedupeByKey(queue: Notification[], key: string): Notification[] {
+  return queue.filter((n) => n.key !== key);
+}
+
+export function drainNotifications(state: NotificationState): { state: NotificationState; effects: NotificationEffect[] } {
+  if (state.current) return { state, effects: [] };
+  if (state.queue.length === 0) return { state, effects: [] };
+
+  const sorted = sortByPriority(state.queue);
+  const next = sorted[0];
+  const remaining = sorted.slice(1);
+  const timeoutMs = next.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+  return {
+    state: { current: next, queue: remaining },
+    effects: [{ type: "effect/notification-schedule-timeout", key: next.key, timeoutMs }]
+  };
+}
+
+export function addNotification(state: NotificationState, notification: Notification): { state: NotificationState; effects: NotificationEffect[] } {
+  const invalidates = notification.invalidates ?? [];
+
+  if (notification.priority === "immediate") {
+    const prevCurrent = state.current;
+    const merged = [...(prevCurrent ? [prevCurrent] : []), ...state.queue];
+    const filtered = removeInvalidated(
+      merged.filter((n) => n.priority !== "immediate"),
+      invalidates
+    );
+
+    const nextState: NotificationState = {
+      current: notification,
+      queue: dedupeByKey(filtered, notification.key)
+    };
+
+    const timeoutMs = notification.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+    return {
+      state: nextState,
+      effects: [
+        { type: "effect/notification-cancel-timeout" },
+        { type: "effect/notification-schedule-timeout", key: notification.key, timeoutMs }
+      ]
+    };
+  }
+
+  const currentKey = state.current?.key ?? null;
+  const alreadyQueued = state.queue.some((n) => n.key === notification.key);
+  if (currentKey === notification.key || alreadyQueued) {
+    const pruned = removeInvalidated(state.queue, invalidates);
+    const drained = drainNotifications({ current: state.current, queue: pruned });
+    return drained;
+  }
+
+  const pruned = removeInvalidated(state.queue, invalidates);
+  const next = { current: state.current, queue: [...pruned, notification] };
+  return drainNotifications(next);
+}
+
+export function expireCurrentNotification(
+  state: NotificationState,
+  key: string
+): { state: NotificationState; effects: NotificationEffect[] } {
+  if (!state.current || state.current.key !== key) return { state, effects: [] };
+
+  const invalidates = state.current.invalidates ?? [];
+  const pruned = removeInvalidated(state.queue.filter((n) => n.priority !== "immediate"), invalidates);
+  const cleared: NotificationState = { current: null, queue: pruned };
+  return drainNotifications(cleared);
+}
+
diff --git a/src/core/state/overlays.ts b/src/core/state/overlays.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a352707c5371f79c9647ad52dbc67193bd99cc40
--- /dev/null
+++ b/src/core/state/overlays.ts
@@ -0,0 +1,55 @@
+export type OverlayKind =
+  | "message-selector"
+  | "sandbox-permission"
+  | "tool-permission"
+  | "worker-permission"
+  | "worker-sandbox-permission"
+  | "elicitation"
+  | "cost"
+  | "ide-onboarding";
+
+export const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [
+  "message-selector",
+  "sandbox-permission",
+  "tool-permission",
+  "worker-permission",
+  "worker-sandbox-permission",
+  "elicitation",
+  "cost",
+  "ide-onboarding"
+] as const;
+
+export type OverlaySelectionInputs = {
+  exiting?: boolean;
+  exitMessageActive?: boolean;
+  messageSelectorOpen?: boolean;
+  sandboxPermissionQueueLength?: number;
+  pendingSandboxRequestActive?: boolean;
+  toolPermissionActive?: boolean;
+  workerPermissionQueueLength?: number;
+  pendingWorkerRequestActive?: boolean;
+  workerSandboxPermissionQueueLength?: number;
+  elicitationQueueLength?: number;
+  costNoticeActive?: boolean;
+  ideOnboardingActive?: boolean;
+};
+
+export function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {
+  if (inputs.exiting || inputs.exitMessageActive) return null;
+  if (inputs.messageSelectorOpen) return "message-selector";
+
+  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;
+  if (hasSandboxPrompt) return "sandbox-permission";
+
+  if (inputs.toolPermissionActive) return "tool-permission";
+
+  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
+  if (hasWorkerPermission) return "worker-permission";
+
+  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
+  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";
+  if (inputs.costNoticeActive) return "cost";
+  if (inputs.ideOnboardingActive) return "ide-onboarding";
+  return null;
+}
+
diff --git a/src/core/state/persistence.ts b/src/core/state/persistence.ts
new file mode 100644
index 0000000000000000000000000000000000000000..504af5f7dce298785ae86601827c122322a0cdd4
--- /dev/null
+++ b/src/core/state/persistence.ts
@@ -0,0 +1,82 @@
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import type { PersistedAppStateV1, StateSnapshotV1 } from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+
+export const STATE_SNAPSHOT_STORAGE_KEY = "state/state_snapshot";
+
+export type StateMigrationNote = {
+  fromVersion: number;
+  toVersion: number;
+  note: string;
+};
+
+export type HydrationRecoveryNote = {
+  kind: "tool_run_cancelled" | "hook_run_cancelled" | "other";
+  sessionId: string;
+  entityId: string;
+  message: string;
+};
+
+export type HydrationResult = {
+  persisted: PersistedAppStateV1;
+  migrations: StateMigrationNote[];
+  recovery: HydrationRecoveryNote[];
+};
+
+export class InvalidStateSnapshotError extends Error {
+  readonly name = "InvalidStateSnapshotError";
+  constructor(message: string) {
+    super(message);
+  }
+}
+
+export function encodeStateSnapshot(snapshot: StateSnapshotV1): string {
+  return canonicalJsonStringify(snapshot);
+}
+
+export function decodeStateSnapshot(text: string): StateSnapshotV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new InvalidStateSnapshotError("Snapshot is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["kind"] !== "state_snapshot") throw new InvalidStateSnapshotError("Snapshot kind mismatch");
+  if (obj["schemaVersion"] !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot version: ${String(obj["schemaVersion"])}`);
+  }
+  if (!("state" in obj)) throw new InvalidStateSnapshotError("Snapshot missing state");
+  return parsed as StateSnapshotV1;
+}
+
+export function migrateStateSnapshot(snapshot: StateSnapshotV1): HydrationResult {
+  const migrations: StateMigrationNote[] = [];
+  const recovery: HydrationRecoveryNote[] = [];
+
+  if (snapshot.schemaVersion !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot schemaVersion: ${snapshot.schemaVersion}`);
+  }
+
+  return { persisted: snapshot.state, migrations, recovery };
+}
+
+export async function loadStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY
+): Promise<StateSnapshotV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeStateSnapshot(found.value);
+}
+
+export async function saveStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  snapshot: StateSnapshotV1,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeStateSnapshot(snapshot);
+  const res = await storage.set(namespace, key, encoded, options);
+  return res;
+}
+
diff --git a/src/core/state/transcript.ts b/src/core/state/transcript.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f9b512d495cf977b0b62fbbe91b1247887087dab
--- /dev/null
+++ b/src/core/state/transcript.ts
@@ -0,0 +1,63 @@
+import type { HostCrypto } from "../types/host.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import { REDACTED, type Sensitive, type TranscriptEventV1, type TranscriptLogV1 } from "../types/state.js";
+
+export type RedactionStats = {
+  redactedNodes: number;
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  if (value === null || typeof value !== "object") return false;
+  const proto = Object.getPrototypeOf(value);
+  return proto === Object.prototype || proto === null;
+}
+
+function isSensitive(value: unknown): value is Sensitive<unknown> {
+  return isPlainObject(value) && value["kind"] === "sensitive" && "value" in value;
+}
+
+function redactValue(value: unknown, stats: RedactionStats): unknown {
+  if (isSensitive(value)) {
+    stats.redactedNodes += 1;
+    return REDACTED;
+  }
+  if (value === null) return null;
+  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") return value;
+  if (Array.isArray(value)) return value.map((v) => redactValue(v, stats));
+  if (isPlainObject(value)) {
+    const out: Record<string, unknown> = {};
+    for (const [k, v] of Object.entries(value)) out[k] = redactValue(v, stats);
+    return out;
+  }
+  return value;
+}
+
+export function redactTranscriptEvent(event: TranscriptEventV1): { event: TranscriptEventV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const redacted = redactValue(event, stats) as TranscriptEventV1;
+  return { event: redacted, stats };
+}
+
+export function redactTranscriptLog(log: TranscriptLogV1): { log: TranscriptLogV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const events = log.events.map((evt) => redactValue(evt, stats) as TranscriptEventV1);
+  return { log: { ...log, events }, stats };
+}
+
+function bytesToHex(bytes: Uint8Array): string {
+  let out = "";
+  for (const b of bytes) out += b.toString(16).padStart(2, "0");
+  return out;
+}
+
+export async function computeTranscriptSummary(
+  log: TranscriptLogV1,
+  crypto: HostCrypto
+): Promise<{ eventCount: number; sha256Hex: string; redactedNodes: number }> {
+  const { log: redacted, stats } = redactTranscriptLog(log);
+  const json = canonicalJsonStringify(redacted, { pretty: false });
+  const data = new TextEncoder().encode(json);
+  const digest = await crypto.digest("SHA-256", data);
+  return { eventCount: redacted.events.length, sha256Hex: bytesToHex(digest), redactedNodes: stats.redactedNodes };
+}
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+

[3m[35mfile update[0m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/state/state.ts[0m
[32mimport type { IdSource } from "../runtime/ids.js";[0m
[32mimport type { MonotonicClock } from "../runtime/clock.js";[0m
[32mimport {[0m
[32m  asAppId,[0m
[32m  asSessionId,[0m
[32m  type PersistedAppStateV1,[0m
[32m  type PersistedSessionStateV1,[0m
[32m  type SessionId,[0m
[32m  type SessionLifecycleState,[0m
[32m  type StateSnapshotV1,[0m
[32m  type TranscriptLogV1[0m
[32m} from "../types/state.js";[0m
[32mimport { SCHEMA_VERSION } from "../types/schema.js";[0m
[32mimport type { CancellationReason } from "../types/runtime.js";[0m
[32mimport type { Notification, NotificationEffect, NotificationState } from "./notifications.js";[0m
[32mimport { addNotification, expireCurrentNotification } from "./notifications.js";[0m
[32m[0m
[32mexport type SandboxHostPattern = { host: string; port?: number };[0m
[32m[0m
[32mexport type SandboxPermissionRequest = {[0m
[32m  requestId: string;[0m
[32m  hostPattern: SandboxHostPattern;[0m
[32m  createdAtMonoMs: number;[0m
[32m  origin: "local" | "worker" | "leader";[0m
[32m};[0m
[32m[0m
[32mexport type ToolPermissionRequest = {[0m
[32m  requestId: string;[0m
[32m  toolName: string;[0m
[32m  createdAtMonoMs: number;[0m
[32m  message?: string;[0m
[32m};[0m
[32m[0m
[32mexport type ElicitationRequest = {[0m
[32m  requestId: string;[0m
[32m  createdAtMonoMs: number;[0m
[32m  prompt: string;[0m
[32m  source: "mcp";[0m
[32m  concurrency: "serial" | "parallel";[0m
[32m};[0m
[32m[0m
[32mexport type WorkerPermissionQueueState = {[0m
[32m  queue: Array<{ requestId: string; createdAtMonoMs: number; message?: string }>;[0m
[32m  selectedIndex: number;[0m
[32m};[0m
[32m[0m
[32mexport type UiState = {[0m
[32m  notifications: NotificationState;[0m
[32m  sandboxPermissions: { queue: SandboxPermissionRequest[]; pendingLeaderRequest: { requestId: string; host: string } | null };[0m
[32m  toolPermission: { active: ToolPermissionRequest | null };[0m
[32m  workerPermissions: WorkerPermissionQueueState;[0m
[32m  workerSandboxPermissions: WorkerPermissionQueueState;[0m
[32m  elicitation: { queue: ElicitationRequest[] };[0m
[32m  messageSelectorOpen: boolean;[0m
[32m  costNoticeActive: boolean;[0m
[32m  ideOnboardingActive: boolean;[0m
[32m  exiting: boolean;[0m
[32m  exitMessageActive: boolean;[0m
[32m};[0m
[32m[0m
[32mexport type AppState = {[0m
[32m  persisted: PersistedAppStateV1;[0m
[32m  ui: UiState;[0m
[32m};[0m
[32m[0m
[32mexport type StateEffect = NotificationEffect;[0m
[32m[0m
[32mexport type StateUiEvent = { type: "ui/state-changed"; actionType: StateAction["type"] };[0m
[32m[0m
[32mexport type StateAction =[0m
[32m  | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }[0m
[32m  | { type: "app/session-created"; session: PersistedSessionStateV1 }[0m
[32m  | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }[0m
[32m  | { type: "ui/notification/add"; notification: Notification }[0m
[32m  | { type: "ui/notification/expired"; key: string }[0m
[32m  | { type: "ui/message-selector/set-open"; open: boolean }[0m
[32m  | { type: "ui/exit/set"; exiting: boolean; exitMessageActive?: boolean };[0m
[32m[0m
[32mexport type StateCommand =[0m
[32m  | { type: "cmd/create-session"; sessionId?: SessionId; activate?: boolean; nowMonoMs?: number }[0m
[32m  | { type: "cmd/restore-from-snapshot"; snapshot: StateSnapshotV1 };[0m
[32m[0m
[32mexport function createEmptyTranscriptLog(nowMonoMs: number): TranscriptLogV1 {[0m
[32m  return { schemaVersion: 1, events: [], bounded: undefined };[0m
[32m}[0m
[32m[0m
[32mexport function createEmptyUiState(): UiState {[0m
[32m  return {[0m
[32m    notifications: { current: null, queue: [] },[0m
[32m    sandboxPermissions: { queue: [], pendingLeaderRequest: null },[0m
[32m    toolPermission: { active: null },[0m
[32m    workerPermissions: { queue: [], selectedIndex: 0 },[0m
[32m    workerSandboxPermissions: { queue: [], selectedIndex: 0 },[0m
[32m    elicitation: { queue: [] },[0m
[32m    messageSelectorOpen: false,[0m
[32m    costNoticeActive: false,[0m
[32m    ideOnboardingActive: false,[0m
[32m    exiting: false,[0m
[32m    exitMessageActive: false[0m
[32m  };[0m
[32m}[0m
[32m[0m
[32mexport function createEmptyPersistedAppState(options: { idSource: IdSource; clock: MonotonicClock }): PersistedAppStateV1 {[0m
[32m  const now = options.clock.nowMs();[0m
[32m  return {[0m
[32m    schemaVersion: 1,[0m
[32m    appId: asAppId(options.idSource.nextId("app")),[0m
[32m    createdAtMonoMs: now,[0m
[32m    updatedAtMonoMs: now,[0m
[32m    sessions: {}[0m
[32m  };[0m
[32m}[0m
[32m[0m
[32mexport function createAppState(options: { idSource: IdSource; clock: MonotonicClock }): AppState {[0m
[32m  return { persisted: createEmptyPersistedAppState(options), ui: createEmptyUiState() };[0m
[32m}[0m
[32m[0m
[32mexport function createStateSnapshot(persisted: PersistedAppStateV1): StateSnapshotV1 {[0m
[32m  return { kind: "state_snapshot", schemaVersion: SCHEMA_VERSION.stateSnapshot, state: persisted };[0m
[32m}[0m
[32m[0m
[32mexport type CrashRecoveryReport = {[0m
[32m  cancelledToolRuns: Array<{ sessionId: SessionId; toolRunId: string }>;[0m
[32m  cancelledHookRuns: Array<{ sessionId: SessionId; hookRunId: string }>;[0m
[32m};[0m
[32m[0m
[32mexport function recoverPersistedAppState([0m
[32m  persisted: PersistedAppStateV1,[0m
[32m  nowMonoMs: number[0m
[32m): { persisted: PersistedAppStateV1; report: CrashRecoveryReport } {[0m
[32m  const report: CrashRecoveryReport = { cancelledToolRuns: [], cancelledHookRuns: [] };[0m
[32m  const nextSessions: Record<string, PersistedSessionStateV1> = {};[0m
[32m[0m
[32m  const crashCancel: CancellationReason = { kind: "unknown", message: "Recovered from crash (tool/hook run left in-flight)" };[0m
[32m[0m
[32m  for (const [sessionKey, session] of Object.entries(persisted.sessions)) {[0m
[32m    const nextToolRuns: typeof session.toolRuns = {};[0m
[32m    for (const [id, run] of Object.entries(session.toolRuns)) {[0m
[32m      if (run.status === "running" || run.status === "created") {[0m
[32m        nextToolRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };[0m
[32m        report.cancelledToolRuns.push({ sessionId: session.id, toolRunId: id });[0m
[32m      } else {[0m
[32m        nextToolRuns[id] = run;[0m
[32m      }[0m
[32m    }[0m
[32m[0m
[32m    const nextHookRuns: typeof session.hookRuns = {};[0m
[32m    for (const [id, run] of Object.entries(session.hookRuns)) {[0m
[32m      if (run.status === "running" || run.status === "created") {[0m
[32m        nextHookRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };[0m
[32m        report.cancelledHookRuns.push({ sessionId: session.id, hookRunId: id });[0m
[32m      } else {[0m
[32m        nextHookRuns[id] = run;[0m
[32m      }[0m
[32m    }[0m
[32m[0m
[32m    nextSessions[sessionKey] = {[0m
[32m      ...session,[0m
[32m      toolRuns: nextToolRuns,[0m
[32m      hookRuns: nextHookRuns,[0m
[32m      updatedAtMonoMs: nowMonoMs[0m
[32m    };[0m
[32m  }[0m
[32m[0m
[32m  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };[0m
[32m}[0m
[32m[0m
[32mexport function reduceAppState(state: AppState, action: StateAction): { state: AppState; effects: StateEffect[]; events: StateUiEvent[] } {[0m
[32m  switch (action.type) {[0m
[32m    case "app/restore-persisted": {[0m
[32m      const next: AppState = { persisted: action.persisted, ui: createEmptyUiState() };[0m
[32m      return { state: next, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };[0m
[32m    }[0m
[32m    case "app/session-created": {[0m
[32m      const sessions = { ...state.persisted.sessions, [action.session.id]: action.session };[0m
[32m      const nextPersisted: PersistedAppStateV1 = {[0m
[32m        ...state.persisted,[0m
[32m        sessions,[0m
[32m        activeSessionId: state.persisted.activeSessionId ?? action.session.id,[0m
[32m        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.session.updatedAtMonoMs)[0m
[32m      };[0m
[32m      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };[0m
[32m    }[0m
[32m    case "app/session-lifecycle-set": {[0m
[32m      const session = state.persisted.sessions[action.sessionId];[0m
[32m      if (!session) return { state, effects: [], events: [] };[0m
[32m      const nextSession: PersistedSessionStateV1 = {[0m
[32m        ...session,[0m
[32m        lifecycle: action.lifecycle,[0m
[32m        updatedAtMonoMs: action.tsMonoMs,[0m
[32m        ...(action.lifecycle === "ended" ? { endedAtMonoMs: action.tsMonoMs } : {}),[0m
[32m        ...(action.lifecycle === "error" ? { error: action.error ?? session.error ?? "Session error" } : {})[0m
[32m      };[0m
[32m      const nextPersisted: PersistedAppStateV1 = {[0m
[32m        ...state.persisted,[0m
[32m        sessions: { ...state.persisted.sessions, [action.sessionId]: nextSession },[0m
[32m        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs)[0m
[32m      };[0m
[32m      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };[0m
[32m    }[0m
[32m    case "ui/notification/add": {[0m
[32m      const { state: nextNotif, effects } = addNotification(state.ui.notifications, action.notification);[0m
[32m      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };[0m
[32m    }[0m
[32m    case "ui/notification/expired": {[0m
[32m      const { state: nextNotif, effects } = expireCurrentNotification(state.ui.notifications, action.key);[0m
[32m      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };[0m
[32m    }[0m
[32m    case "ui/message-selector/set-open": {[0m
[32m      return {[0m
[32m        state: { ...state, ui: { ...state.ui, messageSelectorOpen: action.open } },[0m
[32m        effects: [],[0m
[32m        events: [{ type: "ui/state-changed", actionType: action.type }][0m
[32m      };[0m
[32m    }[0m
[32m    case "ui/exit/set": {[0m
[32m      return {[0m
[32m        state: {[0m
[32m          ...state,[0m
[32m          ui: {[0m
[32m            ...state.ui,[0m
[32m            exiting: action.exiting,[0m
[32m            exitMessageActive: action.exitMessageActive ?? state.ui.exitMessageActive[0m
[32m          }[0m
[32m        },[0m
[32m        effects: [],[0m
[32m        events: [{ type: "ui/state-changed", actionType: action.type }][0m
[32m      };[0m
[32m    }[0m
[32m  }[0m
[32m}[0m
[32m[0m
[32mexport function commandToActions([0m
[32m  state: AppState,[0m
[32m  command: StateCommand,[0m
[32m  deps: { idSource: IdSource; clock: MonotonicClock }[0m
[32m): StateAction[] {[0m
[32m  switch (command.type) {[0m
[32m    case "cmd/create-session": {[0m
[32m      const sessionId = command.sessionId ?? asSessionId(deps.idSource.nextId("sess"));[0m
[32m      const now = command.nowMonoMs ?? deps.clock.nowMs();[0m
[32m      const session: PersistedSessionStateV1 = {[0m
[32m        schemaVersion: 1,[0m
[32m        id: sessionId,[0m
[32m        lifecycle: "created",[0m
[32m        createdAtMonoMs: now,[0m
[32m        updatedAtMonoMs: now,[0m
[32m        transcript: createEmptyTranscriptLog(now),[0m
[32m        attachments: {},[0m
[32m        toolRuns: {},[0m
[32m        hookRuns: {},[0m
[32m        mcpConnections: {}[0m
[32m      };[0m
[32m      const actions: StateAction[] = [{ type: "app/session-created", session }];[0m
[32m      if (command.activate) actions.push({ type: "app/session-lifecycle-set", sessionId, lifecycle: "active", tsMonoMs: now });[0m
[32m      return actions;[0m
[32m    }[0m
[32m    case "cmd/restore-from-snapshot": {[0m
[32m      const recovered = recoverPersistedAppState(command.snapshot.state, deps.clock.nowMs());[0m
[32m      return [{ type: "app/restore-persisted", persisted: recovered.persisted }];[0m
[32m    }[0m
[32m  }[0m
[32m}[0m
[32m[0m
[32mapply_patch(auto_approved=true) exited 0 in 52ms:[0m
[2mSuccess. Updated the following files:[0m
[2mA src/core/state/state.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/state/notifications.ts b/src/core/state/notifications.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f8dde458abe0ab190a09282b2445f708c11d9bc
--- /dev/null
+++ b/src/core/state/notifications.ts
@@ -0,0 +1,110 @@
+export type NotificationPriority = "immediate" | "high" | "medium" | "low";
+
+export type Notification = {
+  key: string;
+  text: string;
+  priority: NotificationPriority;
+  color?: string;
+  timeoutMs?: number;
+  invalidates?: string[];
+};
+
+export type NotificationState = {
+  current: Notification | null;
+  queue: Notification[];
+};
+
+export const DEFAULT_NOTIFICATION_TIMEOUT_MS = 8000;
+
+export type NotificationEffect =
+  | { type: "effect/notification-cancel-timeout" }
+  | { type: "effect/notification-schedule-timeout"; key: string; timeoutMs: number };
+
+const priorityOrder: Record<NotificationPriority, number> = {
+  immediate: 0,
+  high: 1,
+  medium: 2,
+  low: 3
+};
+
+function sortByPriority(queue: Notification[]): Notification[] {
+  return queue
+    .slice()
+    .sort((a, b) => (priorityOrder[a.priority] < priorityOrder[b.priority] ? -1 : priorityOrder[a.priority] > priorityOrder[b.priority] ? 1 : 0));
+}
+
+function removeInvalidated(queue: Notification[], invalidates: readonly string[] | undefined): Notification[] {
+  if (!invalidates || invalidates.length === 0) return queue;
+  const invalidated = new Set(invalidates);
+  return queue.filter((n) => !invalidated.has(n.key));
+}
+
+function dedupeByKey(queue: Notification[], key: string): Notification[] {
+  return queue.filter((n) => n.key !== key);
+}
+
+export function drainNotifications(state: NotificationState): { state: NotificationState; effects: NotificationEffect[] } {
+  if (state.current) return { state, effects: [] };
+  if (state.queue.length === 0) return { state, effects: [] };
+
+  const sorted = sortByPriority(state.queue);
+  const next = sorted[0];
+  const remaining = sorted.slice(1);
+  const timeoutMs = next.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+  return {
+    state: { current: next, queue: remaining },
+    effects: [{ type: "effect/notification-schedule-timeout", key: next.key, timeoutMs }]
+  };
+}
+
+export function addNotification(state: NotificationState, notification: Notification): { state: NotificationState; effects: NotificationEffect[] } {
+  const invalidates = notification.invalidates ?? [];
+
+  if (notification.priority === "immediate") {
+    const prevCurrent = state.current;
+    const merged = [...(prevCurrent ? [prevCurrent] : []), ...state.queue];
+    const filtered = removeInvalidated(
+      merged.filter((n) => n.priority !== "immediate"),
+      invalidates
+    );
+
+    const nextState: NotificationState = {
+      current: notification,
+      queue: dedupeByKey(filtered, notification.key)
+    };
+
+    const timeoutMs = notification.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+    return {
+      state: nextState,
+      effects: [
+        { type: "effect/notification-cancel-timeout" },
+        { type: "effect/notification-schedule-timeout", key: notification.key, timeoutMs }
+      ]
+    };
+  }
+
+  const currentKey = state.current?.key ?? null;
+  const alreadyQueued = state.queue.some((n) => n.key === notification.key);
+  if (currentKey === notification.key || alreadyQueued) {
+    const pruned = removeInvalidated(state.queue, invalidates);
+    const drained = drainNotifications({ current: state.current, queue: pruned });
+    return drained;
+  }
+
+  const pruned = removeInvalidated(state.queue, invalidates);
+  const next = { current: state.current, queue: [...pruned, notification] };
+  return drainNotifications(next);
+}
+
+export function expireCurrentNotification(
+  state: NotificationState,
+  key: string
+): { state: NotificationState; effects: NotificationEffect[] } {
+  if (!state.current || state.current.key !== key) return { state, effects: [] };
+
+  const invalidates = state.current.invalidates ?? [];
+  const pruned = removeInvalidated(state.queue.filter((n) => n.priority !== "immediate"), invalidates);
+  const cleared: NotificationState = { current: null, queue: pruned };
+  return drainNotifications(cleared);
+}
+
diff --git a/src/core/state/overlays.ts b/src/core/state/overlays.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a352707c5371f79c9647ad52dbc67193bd99cc40
--- /dev/null
+++ b/src/core/state/overlays.ts
@@ -0,0 +1,55 @@
+export type OverlayKind =
+  | "message-selector"
+  | "sandbox-permission"
+  | "tool-permission"
+  | "worker-permission"
+  | "worker-sandbox-permission"
+  | "elicitation"
+  | "cost"
+  | "ide-onboarding";
+
+export const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [
+  "message-selector",
+  "sandbox-permission",
+  "tool-permission",
+  "worker-permission",
+  "worker-sandbox-permission",
+  "elicitation",
+  "cost",
+  "ide-onboarding"
+] as const;
+
+export type OverlaySelectionInputs = {
+  exiting?: boolean;
+  exitMessageActive?: boolean;
+  messageSelectorOpen?: boolean;
+  sandboxPermissionQueueLength?: number;
+  pendingSandboxRequestActive?: boolean;
+  toolPermissionActive?: boolean;
+  workerPermissionQueueLength?: number;
+  pendingWorkerRequestActive?: boolean;
+  workerSandboxPermissionQueueLength?: number;
+  elicitationQueueLength?: number;
+  costNoticeActive?: boolean;
+  ideOnboardingActive?: boolean;
+};
+
+export function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {
+  if (inputs.exiting || inputs.exitMessageActive) return null;
+  if (inputs.messageSelectorOpen) return "message-selector";
+
+  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;
+  if (hasSandboxPrompt) return "sandbox-permission";
+
+  if (inputs.toolPermissionActive) return "tool-permission";
+
+  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
+  if (hasWorkerPermission) return "worker-permission";
+
+  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
+  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";
+  if (inputs.costNoticeActive) return "cost";
+  if (inputs.ideOnboardingActive) return "ide-onboarding";
+  return null;
+}
+
diff --git a/src/core/state/persistence.ts b/src/core/state/persistence.ts
new file mode 100644
index 0000000000000000000000000000000000000000..504af5f7dce298785ae86601827c122322a0cdd4
--- /dev/null
+++ b/src/core/state/persistence.ts
@@ -0,0 +1,82 @@
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import type { PersistedAppStateV1, StateSnapshotV1 } from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+
+export const STATE_SNAPSHOT_STORAGE_KEY = "state/state_snapshot";
+
+export type StateMigrationNote = {
+  fromVersion: number;
+  toVersion: number;
+  note: string;
+};
+
+export type HydrationRecoveryNote = {
+  kind: "tool_run_cancelled" | "hook_run_cancelled" | "other";
+  sessionId: string;
+  entityId: string;
+  message: string;
+};
+
+export type HydrationResult = {
+  persisted: PersistedAppStateV1;
+  migrations: StateMigrationNote[];
+  recovery: HydrationRecoveryNote[];
+};
+
+export class InvalidStateSnapshotError extends Error {
+  readonly name = "InvalidStateSnapshotError";
+  constructor(message: string) {
+    super(message);
+  }
+}
+
+export function encodeStateSnapshot(snapshot: StateSnapshotV1): string {
+  return canonicalJsonStringify(snapshot);
+}
+
+export function decodeStateSnapshot(text: string): StateSnapshotV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new InvalidStateSnapshotError("Snapshot is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["kind"] !== "state_snapshot") throw new InvalidStateSnapshotError("Snapshot kind mismatch");
+  if (obj["schemaVersion"] !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot version: ${String(obj["schemaVersion"])}`);
+  }
+  if (!("state" in obj)) throw new InvalidStateSnapshotError("Snapshot missing state");
+  return parsed as StateSnapshotV1;
+}
+
+export function migrateStateSnapshot(snapshot: StateSnapshotV1): HydrationResult {
+  const migrations: StateMigrationNote[] = [];
+  const recovery: HydrationRecoveryNote[] = [];
+
+  if (snapshot.schemaVersion !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot schemaVersion: ${snapshot.schemaVersion}`);
+  }
+
+  return { persisted: snapshot.state, migrations, recovery };
+}
+
+export async function loadStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY
+): Promise<StateSnapshotV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeStateSnapshot(found.value);
+}
+
+export async function saveStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  snapshot: StateSnapshotV1,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeStateSnapshot(snapshot);
+  const res = await storage.set(namespace, key, encoded, options);
+  return res;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..809c20a9646f83664161d132ecd72d2df942adbf
--- /dev/null
+++ b/src/core/state/state.ts
@@ -0,0 +1,264 @@
+import type { IdSource } from "../runtime/ids.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import {
+  asAppId,
+  asSessionId,
+  type PersistedAppStateV1,
+  type PersistedSessionStateV1,
+  type SessionId,
+  type SessionLifecycleState,
+  type StateSnapshotV1,
+  type TranscriptLogV1
+} from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { Notification, NotificationEffect, NotificationState } from "./notifications.js";
+import { addNotification, expireCurrentNotification } from "./notifications.js";
+
+export type SandboxHostPattern = { host: string; port?: number };
+
+export type SandboxPermissionRequest = {
+  requestId: string;
+  hostPattern: SandboxHostPattern;
+  createdAtMonoMs: number;
+  origin: "local" | "worker" | "leader";
+};
+
+export type ToolPermissionRequest = {
+  requestId: string;
+  toolName: string;
+  createdAtMonoMs: number;
+  message?: string;
+};
+
+export type ElicitationRequest = {
+  requestId: string;
+  createdAtMonoMs: number;
+  prompt: string;
+  source: "mcp";
+  concurrency: "serial" | "parallel";
+};
+
+export type WorkerPermissionQueueState = {
+  queue: Array<{ requestId: string; createdAtMonoMs: number; message?: string }>;
+  selectedIndex: number;
+};
+
+export type UiState = {
+  notifications: NotificationState;
+  sandboxPermissions: { queue: SandboxPermissionRequest[]; pendingLeaderRequest: { requestId: string; host: string } | null };
+  toolPermission: { active: ToolPermissionRequest | null };
+  workerPermissions: WorkerPermissionQueueState;
+  workerSandboxPermissions: WorkerPermissionQueueState;
+  elicitation: { queue: ElicitationRequest[] };
+  messageSelectorOpen: boolean;
+  costNoticeActive: boolean;
+  ideOnboardingActive: boolean;
+  exiting: boolean;
+  exitMessageActive: boolean;
+};
+
+export type AppState = {
+  persisted: PersistedAppStateV1;
+  ui: UiState;
+};
+
+export type StateEffect = NotificationEffect;
+
+export type StateUiEvent = { type: "ui/state-changed"; actionType: StateAction["type"] };
+
+export type StateAction =
+  | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
+  | { type: "app/session-created"; session: PersistedSessionStateV1 }
+  | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "ui/notification/add"; notification: Notification }
+  | { type: "ui/notification/expired"; key: string }
+  | { type: "ui/message-selector/set-open"; open: boolean }
+  | { type: "ui/exit/set"; exiting: boolean; exitMessageActive?: boolean };
+
+export type StateCommand =
+  | { type: "cmd/create-session"; sessionId?: SessionId; activate?: boolean; nowMonoMs?: number }
+  | { type: "cmd/restore-from-snapshot"; snapshot: StateSnapshotV1 };
+
+export function createEmptyTranscriptLog(nowMonoMs: number): TranscriptLogV1 {
+  return { schemaVersion: 1, events: [], bounded: undefined };
+}
+
+export function createEmptyUiState(): UiState {
+  return {
+    notifications: { current: null, queue: [] },
+    sandboxPermissions: { queue: [], pendingLeaderRequest: null },
+    toolPermission: { active: null },
+    workerPermissions: { queue: [], selectedIndex: 0 },
+    workerSandboxPermissions: { queue: [], selectedIndex: 0 },
+    elicitation: { queue: [] },
+    messageSelectorOpen: false,
+    costNoticeActive: false,
+    ideOnboardingActive: false,
+    exiting: false,
+    exitMessageActive: false
+  };
+}
+
+export function createEmptyPersistedAppState(options: { idSource: IdSource; clock: MonotonicClock }): PersistedAppStateV1 {
+  const now = options.clock.nowMs();
+  return {
+    schemaVersion: 1,
+    appId: asAppId(options.idSource.nextId("app")),
+    createdAtMonoMs: now,
+    updatedAtMonoMs: now,
+    sessions: {}
+  };
+}
+
+export function createAppState(options: { idSource: IdSource; clock: MonotonicClock }): AppState {
+  return { persisted: createEmptyPersistedAppState(options), ui: createEmptyUiState() };
+}
+
+export function createStateSnapshot(persisted: PersistedAppStateV1): StateSnapshotV1 {
+  return { kind: "state_snapshot", schemaVersion: SCHEMA_VERSION.stateSnapshot, state: persisted };
+}
+
+export type CrashRecoveryReport = {
+  cancelledToolRuns: Array<{ sessionId: SessionId; toolRunId: string }>;
+  cancelledHookRuns: Array<{ sessionId: SessionId; hookRunId: string }>;
+};
+
+export function recoverPersistedAppState(
+  persisted: PersistedAppStateV1,
+  nowMonoMs: number
+): { persisted: PersistedAppStateV1; report: CrashRecoveryReport } {
+  const report: CrashRecoveryReport = { cancelledToolRuns: [], cancelledHookRuns: [] };
+  const nextSessions: Record<string, PersistedSessionStateV1> = {};
+
+  const crashCancel: CancellationReason = { kind: "unknown", message: "Recovered from crash (tool/hook run left in-flight)" };
+
+  for (const [sessionKey, session] of Object.entries(persisted.sessions)) {
+    const nextToolRuns: typeof session.toolRuns = {};
+    for (const [id, run] of Object.entries(session.toolRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextToolRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledToolRuns.push({ sessionId: session.id, toolRunId: id });
+      } else {
+        nextToolRuns[id] = run;
+      }
+    }
+
+    const nextHookRuns: typeof session.hookRuns = {};
+    for (const [id, run] of Object.entries(session.hookRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextHookRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledHookRuns.push({ sessionId: session.id, hookRunId: id });
+      } else {
+        nextHookRuns[id] = run;
+      }
+    }
+
+    nextSessions[sessionKey] = {
+      ...session,
+      toolRuns: nextToolRuns,
+      hookRuns: nextHookRuns,
+      updatedAtMonoMs: nowMonoMs
+    };
+  }
+
+  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+}
+
+export function reduceAppState(state: AppState, action: StateAction): { state: AppState; effects: StateEffect[]; events: StateUiEvent[] } {
+  switch (action.type) {
+    case "app/restore-persisted": {
+      const next: AppState = { persisted: action.persisted, ui: createEmptyUiState() };
+      return { state: next, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-created": {
+      const sessions = { ...state.persisted.sessions, [action.session.id]: action.session };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions,
+        activeSessionId: state.persisted.activeSessionId ?? action.session.id,
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.session.updatedAtMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-lifecycle-set": {
+      const session = state.persisted.sessions[action.sessionId];
+      if (!session) return { state, effects: [], events: [] };
+      const nextSession: PersistedSessionStateV1 = {
+        ...session,
+        lifecycle: action.lifecycle,
+        updatedAtMonoMs: action.tsMonoMs,
+        ...(action.lifecycle === "ended" ? { endedAtMonoMs: action.tsMonoMs } : {}),
+        ...(action.lifecycle === "error" ? { error: action.error ?? session.error ?? "Session error" } : {})
+      };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions: { ...state.persisted.sessions, [action.sessionId]: nextSession },
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/add": {
+      const { state: nextNotif, effects } = addNotification(state.ui.notifications, action.notification);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/expired": {
+      const { state: nextNotif, effects } = expireCurrentNotification(state.ui.notifications, action.key);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/message-selector/set-open": {
+      return {
+        state: { ...state, ui: { ...state.ui, messageSelectorOpen: action.open } },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+    case "ui/exit/set": {
+      return {
+        state: {
+          ...state,
+          ui: {
+            ...state.ui,
+            exiting: action.exiting,
+            exitMessageActive: action.exitMessageActive ?? state.ui.exitMessageActive
+          }
+        },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+  }
+}
+
+export function commandToActions(
+  state: AppState,
+  command: StateCommand,
+  deps: { idSource: IdSource; clock: MonotonicClock }
+): StateAction[] {
+  switch (command.type) {
+    case "cmd/create-session": {
+      const sessionId = command.sessionId ?? asSessionId(deps.idSource.nextId("sess"));
+      const now = command.nowMonoMs ?? deps.clock.nowMs();
+      const session: PersistedSessionStateV1 = {
+        schemaVersion: 1,
+        id: sessionId,
+        lifecycle: "created",
+        createdAtMonoMs: now,
+        updatedAtMonoMs: now,
+        transcript: createEmptyTranscriptLog(now),
+        attachments: {},
+        toolRuns: {},
+        hookRuns: {},
+        mcpConnections: {}
+      };
+      const actions: StateAction[] = [{ type: "app/session-created", session }];
+      if (command.activate) actions.push({ type: "app/session-lifecycle-set", sessionId, lifecycle: "active", tsMonoMs: now });
+      return actions;
+    }
+    case "cmd/restore-from-snapshot": {
+      const recovered = recoverPersistedAppState(command.snapshot.state, deps.clock.nowMs());
+      return [{ type: "app/restore-persisted", persisted: recovered.persisted }];
+    }
+  }
+}
+
diff --git a/src/core/state/transcript.ts b/src/core/state/transcript.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f9b512d495cf977b0b62fbbe91b1247887087dab
--- /dev/null
+++ b/src/core/state/transcript.ts
@@ -0,0 +1,63 @@
+import type { HostCrypto } from "../types/host.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import { REDACTED, type Sensitive, type TranscriptEventV1, type TranscriptLogV1 } from "../types/state.js";
+
+export type RedactionStats = {
+  redactedNodes: number;
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  if (value === null || typeof value !== "object") return false;
+  const proto = Object.getPrototypeOf(value);
+  return proto === Object.prototype || proto === null;
+}
+
+function isSensitive(value: unknown): value is Sensitive<unknown> {
+  return isPlainObject(value) && value["kind"] === "sensitive" && "value" in value;
+}
+
+function redactValue(value: unknown, stats: RedactionStats): unknown {
+  if (isSensitive(value)) {
+    stats.redactedNodes += 1;
+    return REDACTED;
+  }
+  if (value === null) return null;
+  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") return value;
+  if (Array.isArray(value)) return value.map((v) => redactValue(v, stats));
+  if (isPlainObject(value)) {
+    const out: Record<string, unknown> = {};
+    for (const [k, v] of Object.entries(value)) out[k] = redactValue(v, stats);
+    return out;
+  }
+  return value;
+}
+
+export function redactTranscriptEvent(event: TranscriptEventV1): { event: TranscriptEventV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const redacted = redactValue(event, stats) as TranscriptEventV1;
+  return { event: redacted, stats };
+}
+
+export function redactTranscriptLog(log: TranscriptLogV1): { log: TranscriptLogV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const events = log.events.map((evt) => redactValue(evt, stats) as TranscriptEventV1);
+  return { log: { ...log, events }, stats };
+}
+
+function bytesToHex(bytes: Uint8Array): string {
+  let out = "";
+  for (const b of bytes) out += b.toString(16).padStart(2, "0");
+  return out;
+}
+
+export async function computeTranscriptSummary(
+  log: TranscriptLogV1,
+  crypto: HostCrypto
+): Promise<{ eventCount: number; sha256Hex: string; redactedNodes: number }> {
+  const { log: redacted, stats } = redactTranscriptLog(log);
+  const json = canonicalJsonStringify(redacted, { pretty: false });
+  const data = new TextEncoder().encode(json);
+  const digest = await crypto.digest("SHA-256", data);
+  return { eventCount: redacted.events.length, sha256Hex: bytesToHex(digest), redactedNodes: stats.redactedNodes };
+}
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/state/notifications.ts b/src/core/state/notifications.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f8dde458abe0ab190a09282b2445f708c11d9bc
--- /dev/null
+++ b/src/core/state/notifications.ts
@@ -0,0 +1,110 @@
+export type NotificationPriority = "immediate" | "high" | "medium" | "low";
+
+export type Notification = {
+  key: string;
+  text: string;
+  priority: NotificationPriority;
+  color?: string;
+  timeoutMs?: number;
+  invalidates?: string[];
+};
+
+export type NotificationState = {
+  current: Notification | null;
+  queue: Notification[];
+};
+
+export const DEFAULT_NOTIFICATION_TIMEOUT_MS = 8000;
+
+export type NotificationEffect =
+  | { type: "effect/notification-cancel-timeout" }
+  | { type: "effect/notification-schedule-timeout"; key: string; timeoutMs: number };
+
+const priorityOrder: Record<NotificationPriority, number> = {
+  immediate: 0,
+  high: 1,
+  medium: 2,
+  low: 3
+};
+
+function sortByPriority(queue: Notification[]): Notification[] {
+  return queue
+    .slice()
+    .sort((a, b) => (priorityOrder[a.priority] < priorityOrder[b.priority] ? -1 : priorityOrder[a.priority] > priorityOrder[b.priority] ? 1 : 0));
+}
+
+function removeInvalidated(queue: Notification[], invalidates: readonly string[] | undefined): Notification[] {
+  if (!invalidates || invalidates.length === 0) return queue;
+  const invalidated = new Set(invalidates);
+  return queue.filter((n) => !invalidated.has(n.key));
+}
+
+function dedupeByKey(queue: Notification[], key: string): Notification[] {
+  return queue.filter((n) => n.key !== key);
+}
+
+export function drainNotifications(state: NotificationState): { state: NotificationState; effects: NotificationEffect[] } {
+  if (state.current) return { state, effects: [] };
+  if (state.queue.length === 0) return { state, effects: [] };
+
+  const sorted = sortByPriority(state.queue);
+  const next = sorted[0];
+  const remaining = sorted.slice(1);
+  const timeoutMs = next.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+  return {
+    state: { current: next, queue: remaining },
+    effects: [{ type: "effect/notification-schedule-timeout", key: next.key, timeoutMs }]
+  };
+}
+
+export function addNotification(state: NotificationState, notification: Notification): { state: NotificationState; effects: NotificationEffect[] } {
+  const invalidates = notification.invalidates ?? [];
+
+  if (notification.priority === "immediate") {
+    const prevCurrent = state.current;
+    const merged = [...(prevCurrent ? [prevCurrent] : []), ...state.queue];
+    const filtered = removeInvalidated(
+      merged.filter((n) => n.priority !== "immediate"),
+      invalidates
+    );
+
+    const nextState: NotificationState = {
+      current: notification,
+      queue: dedupeByKey(filtered, notification.key)
+    };
+
+    const timeoutMs = notification.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+    return {
+      state: nextState,
+      effects: [
+        { type: "effect/notification-cancel-timeout" },
+        { type: "effect/notification-schedule-timeout", key: notification.key, timeoutMs }
+      ]
+    };
+  }
+
+  const currentKey = state.current?.key ?? null;
+  const alreadyQueued = state.queue.some((n) => n.key === notification.key);
+  if (currentKey === notification.key || alreadyQueued) {
+    const pruned = removeInvalidated(state.queue, invalidates);
+    const drained = drainNotifications({ current: state.current, queue: pruned });
+    return drained;
+  }
+
+  const pruned = removeInvalidated(state.queue, invalidates);
+  const next = { current: state.current, queue: [...pruned, notification] };
+  return drainNotifications(next);
+}
+
+export function expireCurrentNotification(
+  state: NotificationState,
+  key: string
+): { state: NotificationState; effects: NotificationEffect[] } {
+  if (!state.current || state.current.key !== key) return { state, effects: [] };
+
+  const invalidates = state.current.invalidates ?? [];
+  const pruned = removeInvalidated(state.queue.filter((n) => n.priority !== "immediate"), invalidates);
+  const cleared: NotificationState = { current: null, queue: pruned };
+  return drainNotifications(cleared);
+}
+
diff --git a/src/core/state/overlays.ts b/src/core/state/overlays.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a352707c5371f79c9647ad52dbc67193bd99cc40
--- /dev/null
+++ b/src/core/state/overlays.ts
@@ -0,0 +1,55 @@
+export type OverlayKind =
+  | "message-selector"
+  | "sandbox-permission"
+  | "tool-permission"
+  | "worker-permission"
+  | "worker-sandbox-permission"
+  | "elicitation"
+  | "cost"
+  | "ide-onboarding";
+
+export const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [
+  "message-selector",
+  "sandbox-permission",
+  "tool-permission",
+  "worker-permission",
+  "worker-sandbox-permission",
+  "elicitation",
+  "cost",
+  "ide-onboarding"
+] as const;
+
+export type OverlaySelectionInputs = {
+  exiting?: boolean;
+  exitMessageActive?: boolean;
+  messageSelectorOpen?: boolean;
+  sandboxPermissionQueueLength?: number;
+  pendingSandboxRequestActive?: boolean;
+  toolPermissionActive?: boolean;
+  workerPermissionQueueLength?: number;
+  pendingWorkerRequestActive?: boolean;
+  workerSandboxPermissionQueueLength?: number;
+  elicitationQueueLength?: number;
+  costNoticeActive?: boolean;
+  ideOnboardingActive?: boolean;
+};
+
+export function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {
+  if (inputs.exiting || inputs.exitMessageActive) return null;
+  if (inputs.messageSelectorOpen) return "message-selector";
+
+  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;
+  if (hasSandboxPrompt) return "sandbox-permission";
+
+  if (inputs.toolPermissionActive) return "tool-permission";
+
+  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
+  if (hasWorkerPermission) return "worker-permission";
+
+  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
+  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";
+  if (inputs.costNoticeActive) return "cost";
+  if (inputs.ideOnboardingActive) return "ide-onboarding";
+  return null;
+}
+
diff --git a/src/core/state/persistence.ts b/src/core/state/persistence.ts
new file mode 100644
index 0000000000000000000000000000000000000000..504af5f7dce298785ae86601827c122322a0cdd4
--- /dev/null
+++ b/src/core/state/persistence.ts
@@ -0,0 +1,82 @@
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import type { PersistedAppStateV1, StateSnapshotV1 } from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+
+export const STATE_SNAPSHOT_STORAGE_KEY = "state/state_snapshot";
+
+export type StateMigrationNote = {
+  fromVersion: number;
+  toVersion: number;
+  note: string;
+};
+
+export type HydrationRecoveryNote = {
+  kind: "tool_run_cancelled" | "hook_run_cancelled" | "other";
+  sessionId: string;
+  entityId: string;
+  message: string;
+};
+
+export type HydrationResult = {
+  persisted: PersistedAppStateV1;
+  migrations: StateMigrationNote[];
+  recovery: HydrationRecoveryNote[];
+};
+
+export class InvalidStateSnapshotError extends Error {
+  readonly name = "InvalidStateSnapshotError";
+  constructor(message: string) {
+    super(message);
+  }
+}
+
+export function encodeStateSnapshot(snapshot: StateSnapshotV1): string {
+  return canonicalJsonStringify(snapshot);
+}
+
+export function decodeStateSnapshot(text: string): StateSnapshotV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new InvalidStateSnapshotError("Snapshot is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["kind"] !== "state_snapshot") throw new InvalidStateSnapshotError("Snapshot kind mismatch");
+  if (obj["schemaVersion"] !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot version: ${String(obj["schemaVersion"])}`);
+  }
+  if (!("state" in obj)) throw new InvalidStateSnapshotError("Snapshot missing state");
+  return parsed as StateSnapshotV1;
+}
+
+export function migrateStateSnapshot(snapshot: StateSnapshotV1): HydrationResult {
+  const migrations: StateMigrationNote[] = [];
+  const recovery: HydrationRecoveryNote[] = [];
+
+  if (snapshot.schemaVersion !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot schemaVersion: ${snapshot.schemaVersion}`);
+  }
+
+  return { persisted: snapshot.state, migrations, recovery };
+}
+
+export async function loadStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY
+): Promise<StateSnapshotV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeStateSnapshot(found.value);
+}
+
+export async function saveStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  snapshot: StateSnapshotV1,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeStateSnapshot(snapshot);
+  const res = await storage.set(namespace, key, encoded, options);
+  return res;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..809c20a9646f83664161d132ecd72d2df942adbf
--- /dev/null
+++ b/src/core/state/state.ts
@@ -0,0 +1,264 @@
+import type { IdSource } from "../runtime/ids.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import {
+  asAppId,
+  asSessionId,
+  type PersistedAppStateV1,
+  type PersistedSessionStateV1,
+  type SessionId,
+  type SessionLifecycleState,
+  type StateSnapshotV1,
+  type TranscriptLogV1
+} from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { Notification, NotificationEffect, NotificationState } from "./notifications.js";
+import { addNotification, expireCurrentNotification } from "./notifications.js";
+
+export type SandboxHostPattern = { host: string; port?: number };
+
+export type SandboxPermissionRequest = {
+  requestId: string;
+  hostPattern: SandboxHostPattern;
+  createdAtMonoMs: number;
+  origin: "local" | "worker" | "leader";
+};
+
+export type ToolPermissionRequest = {
+  requestId: string;
+  toolName: string;
+  createdAtMonoMs: number;
+  message?: string;
+};
+
+export type ElicitationRequest = {
+  requestId: string;
+  createdAtMonoMs: number;
+  prompt: string;
+  source: "mcp";
+  concurrency: "serial" | "parallel";
+};
+
+export type WorkerPermissionQueueState = {
+  queue: Array<{ requestId: string; createdAtMonoMs: number; message?: string }>;
+  selectedIndex: number;
+};
+
+export type UiState = {
+  notifications: NotificationState;
+  sandboxPermissions: { queue: SandboxPermissionRequest[]; pendingLeaderRequest: { requestId: string; host: string } | null };
+  toolPermission: { active: ToolPermissionRequest | null };
+  workerPermissions: WorkerPermissionQueueState;
+  workerSandboxPermissions: WorkerPermissionQueueState;
+  elicitation: { queue: ElicitationRequest[] };
+  messageSelectorOpen: boolean;
+  costNoticeActive: boolean;
+  ideOnboardingActive: boolean;
+  exiting: boolean;
+  exitMessageActive: boolean;
+};
+
+export type AppState = {
+  persisted: PersistedAppStateV1;
+  ui: UiState;
+};
+
+export type StateEffect = NotificationEffect;
+
+export type StateUiEvent = { type: "ui/state-changed"; actionType: StateAction["type"] };
+
+export type StateAction =
+  | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
+  | { type: "app/session-created"; session: PersistedSessionStateV1 }
+  | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "ui/notification/add"; notification: Notification }
+  | { type: "ui/notification/expired"; key: string }
+  | { type: "ui/message-selector/set-open"; open: boolean }
+  | { type: "ui/exit/set"; exiting: boolean; exitMessageActive?: boolean };
+
+export type StateCommand =
+  | { type: "cmd/create-session"; sessionId?: SessionId; activate?: boolean; nowMonoMs?: number }
+  | { type: "cmd/restore-from-snapshot"; snapshot: StateSnapshotV1 };
+
+export function createEmptyTranscriptLog(nowMonoMs: number): TranscriptLogV1 {
+  return { schemaVersion: 1, events: [], bounded: undefined };
+}
+
+export function createEmptyUiState(): UiState {
+  return {
+    notifications: { current: null, queue: [] },
+    sandboxPermissions: { queue: [], pendingLeaderRequest: null },
+    toolPermission: { active: null },
+    workerPermissions: { queue: [], selectedIndex: 0 },
+    workerSandboxPermissions: { queue: [], selectedIndex: 0 },
+    elicitation: { queue: [] },
+    messageSelectorOpen: false,
+    costNoticeActive: false,
+    ideOnboardingActive: false,
+    exiting: false,
+    exitMessageActive: false
+  };
+}
+
+export function createEmptyPersistedAppState(options: { idSource: IdSource; clock: MonotonicClock }): PersistedAppStateV1 {
+  const now = options.clock.nowMs();
+  return {
+    schemaVersion: 1,
+    appId: asAppId(options.idSource.nextId("app")),
+    createdAtMonoMs: now,
+    updatedAtMonoMs: now,
+    sessions: {}
+  };
+}
+
+export function createAppState(options: { idSource: IdSource; clock: MonotonicClock }): AppState {
+  return { persisted: createEmptyPersistedAppState(options), ui: createEmptyUiState() };
+}
+
+export function createStateSnapshot(persisted: PersistedAppStateV1): StateSnapshotV1 {
+  return { kind: "state_snapshot", schemaVersion: SCHEMA_VERSION.stateSnapshot, state: persisted };
+}
+
+export type CrashRecoveryReport = {
+  cancelledToolRuns: Array<{ sessionId: SessionId; toolRunId: string }>;
+  cancelledHookRuns: Array<{ sessionId: SessionId; hookRunId: string }>;
+};
+
+export function recoverPersistedAppState(
+  persisted: PersistedAppStateV1,
+  nowMonoMs: number
+): { persisted: PersistedAppStateV1; report: CrashRecoveryReport } {
+  const report: CrashRecoveryReport = { cancelledToolRuns: [], cancelledHookRuns: [] };
+  const nextSessions: Record<string, PersistedSessionStateV1> = {};
+
+  const crashCancel: CancellationReason = { kind: "unknown", message: "Recovered from crash (tool/hook run left in-flight)" };
+
+  for (const [sessionKey, session] of Object.entries(persisted.sessions)) {
+    const nextToolRuns: typeof session.toolRuns = {};
+    for (const [id, run] of Object.entries(session.toolRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextToolRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledToolRuns.push({ sessionId: session.id, toolRunId: id });
+      } else {
+        nextToolRuns[id] = run;
+      }
+    }
+
+    const nextHookRuns: typeof session.hookRuns = {};
+    for (const [id, run] of Object.entries(session.hookRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextHookRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledHookRuns.push({ sessionId: session.id, hookRunId: id });
+      } else {
+        nextHookRuns[id] = run;
+      }
+    }
+
+    nextSessions[sessionKey] = {
+      ...session,
+      toolRuns: nextToolRuns,
+      hookRuns: nextHookRuns,
+      updatedAtMonoMs: nowMonoMs
+    };
+  }
+
+  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+}
+
+export function reduceAppState(state: AppState, action: StateAction): { state: AppState; effects: StateEffect[]; events: StateUiEvent[] } {
+  switch (action.type) {
+    case "app/restore-persisted": {
+      const next: AppState = { persisted: action.persisted, ui: createEmptyUiState() };
+      return { state: next, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-created": {
+      const sessions = { ...state.persisted.sessions, [action.session.id]: action.session };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions,
+        activeSessionId: state.persisted.activeSessionId ?? action.session.id,
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.session.updatedAtMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-lifecycle-set": {
+      const session = state.persisted.sessions[action.sessionId];
+      if (!session) return { state, effects: [], events: [] };
+      const nextSession: PersistedSessionStateV1 = {
+        ...session,
+        lifecycle: action.lifecycle,
+        updatedAtMonoMs: action.tsMonoMs,
+        ...(action.lifecycle === "ended" ? { endedAtMonoMs: action.tsMonoMs } : {}),
+        ...(action.lifecycle === "error" ? { error: action.error ?? session.error ?? "Session error" } : {})
+      };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions: { ...state.persisted.sessions, [action.sessionId]: nextSession },
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/add": {
+      const { state: nextNotif, effects } = addNotification(state.ui.notifications, action.notification);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/expired": {
+      const { state: nextNotif, effects } = expireCurrentNotification(state.ui.notifications, action.key);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/message-selector/set-open": {
+      return {
+        state: { ...state, ui: { ...state.ui, messageSelectorOpen: action.open } },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+    case "ui/exit/set": {
+      return {
+        state: {
+          ...state,
+          ui: {
+            ...state.ui,
+            exiting: action.exiting,
+            exitMessageActive: action.exitMessageActive ?? state.ui.exitMessageActive
+          }
+        },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+  }
+}
+
+export function commandToActions(
+  state: AppState,
+  command: StateCommand,
+  deps: { idSource: IdSource; clock: MonotonicClock }
+): StateAction[] {
+  switch (command.type) {
+    case "cmd/create-session": {
+      const sessionId = command.sessionId ?? asSessionId(deps.idSource.nextId("sess"));
+      const now = command.nowMonoMs ?? deps.clock.nowMs();
+      const session: PersistedSessionStateV1 = {
+        schemaVersion: 1,
+        id: sessionId,
+        lifecycle: "created",
+        createdAtMonoMs: now,
+        updatedAtMonoMs: now,
+        transcript: createEmptyTranscriptLog(now),
+        attachments: {},
+        toolRuns: {},
+        hookRuns: {},
+        mcpConnections: {}
+      };
+      const actions: StateAction[] = [{ type: "app/session-created", session }];
+      if (command.activate) actions.push({ type: "app/session-lifecycle-set", sessionId, lifecycle: "active", tsMonoMs: now });
+      return actions;
+    }
+    case "cmd/restore-from-snapshot": {
+      const recovered = recoverPersistedAppState(command.snapshot.state, deps.clock.nowMs());
+      return [{ type: "app/restore-persisted", persisted: recovered.persisted }];
+    }
+  }
+}
+
diff --git a/src/core/state/transcript.ts b/src/core/state/transcript.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f9b512d495cf977b0b62fbbe91b1247887087dab
--- /dev/null
+++ b/src/core/state/transcript.ts
@@ -0,0 +1,63 @@
+import type { HostCrypto } from "../types/host.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import { REDACTED, type Sensitive, type TranscriptEventV1, type TranscriptLogV1 } from "../types/state.js";
+
+export type RedactionStats = {
+  redactedNodes: number;
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  if (value === null || typeof value !== "object") return false;
+  const proto = Object.getPrototypeOf(value);
+  return proto === Object.prototype || proto === null;
+}
+
+function isSensitive(value: unknown): value is Sensitive<unknown> {
+  return isPlainObject(value) && value["kind"] === "sensitive" && "value" in value;
+}
+
+function redactValue(value: unknown, stats: RedactionStats): unknown {
+  if (isSensitive(value)) {
+    stats.redactedNodes += 1;
+    return REDACTED;
+  }
+  if (value === null) return null;
+  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") return value;
+  if (Array.isArray(value)) return value.map((v) => redactValue(v, stats));
+  if (isPlainObject(value)) {
+    const out: Record<string, unknown> = {};
+    for (const [k, v] of Object.entries(value)) out[k] = redactValue(v, stats);
+    return out;
+  }
+  return value;
+}
+
+export function redactTranscriptEvent(event: TranscriptEventV1): { event: TranscriptEventV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const redacted = redactValue(event, stats) as TranscriptEventV1;
+  return { event: redacted, stats };
+}
+
+export function redactTranscriptLog(log: TranscriptLogV1): { log: TranscriptLogV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const events = log.events.map((evt) => redactValue(evt, stats) as TranscriptEventV1);
+  return { log: { ...log, events }, stats };
+}
+
+function bytesToHex(bytes: Uint8Array): string {
+  let out = "";
+  for (const b of bytes) out += b.toString(16).padStart(2, "0");
+  return out;
+}
+
+export async function computeTranscriptSummary(
+  log: TranscriptLogV1,
+  crypto: HostCrypto
+): Promise<{ eventCount: number; sha256Hex: string; redactedNodes: number }> {
+  const { log: redacted, stats } = redactTranscriptLog(log);
+  const json = canonicalJsonStringify(redacted, { pretty: false });
+  const data = new TextEncoder().encode(json);
+  const digest = await crypto.digest("SHA-256", data);
+  return { eventCount: redacted.events.length, sha256Hex: bytesToHex(digest), redactedNodes: stats.redactedNodes };
+}
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+

[3m[35mfile update[0m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/state/store.ts[0m
[32mimport type { IdSource } from "../runtime/ids.js";[0m
[32mimport type { MonotonicClock } from "../runtime/clock.js";[0m
[32mimport { BoundedAsyncQueue } from "../runtime/queue.js";[0m
[32mimport type { StateSnapshotV1 } from "../types/state.js";[0m
[32mimport type { AppState, StateAction, StateCommand, StateEffect, StateUiEvent } from "./state.js";[0m
[32mimport { commandToActions, createAppState, createStateSnapshot, reduceAppState } from "./state.js";[0m
[32m[0m
[32mexport type StateStoreOptions = {[0m
[32m  idSource: IdSource;[0m
[32m  clock: MonotonicClock;[0m
[32m  eventBufferSize?: number;[0m
[32m  effectBufferSize?: number;[0m
[32m};[0m
[32m[0m
[32mexport type Unsubscribe = () => void;[0m
[32m[0m
[32mexport type Subscription<T> = AsyncIterable<T> & { unsubscribe: Unsubscribe };[0m
[32m[0m
[32mexport type StateStore = {[0m
[32m  getState: () => AppState;[0m
[32m  dispatch: (action: StateAction) => Promise<void>;[0m
[32m  dispatchCommand: (command: StateCommand) => Promise<void>;[0m
[32m  snapshotPersisted: () => StateSnapshotV1;[0m
[32m  restoreFromSnapshot: (snapshot: StateSnapshotV1) => Promise<void>;[0m
[32m  subscribeUi: () => Subscription<StateUiEvent>;[0m
[32m  subscribeEffects: () => Subscription<StateEffect>;[0m
[32m};[0m
[32m[0m
[32mtype Subscriber<T> = {[0m
[32m  id: string;[0m
[32m  queue: BoundedAsyncQueue<T>;[0m
[32m};[0m
[32m[0m
[32mexport function createStateStore(options: StateStoreOptions): StateStore {[0m
[32m  const deps = { idSource: options.idSource, clock: options.clock };[0m
[32m  let state = createAppState(deps);[0m
[32m[0m
[32m  const uiSubscribers = new Map<string, Subscriber<StateUiEvent>>();[0m
[32m  const effectSubscribers = new Map<string, Subscriber<StateEffect>>();[0m
[32m[0m
[32m  const eventBufferSize = Math.max(0, options.eventBufferSize ?? 256);[0m
[32m  const effectBufferSize = Math.max(0, options.effectBufferSize ?? 256);[0m
[32m[0m
[32m  async function fanOut<T>(subscribers: Map<string, Subscriber<T>>, value: T): Promise<void> {[0m
[32m    const deliveries: Array<Promise<void>> = [];[0m
[32m    for (const sub of subscribers.values()) deliveries.push(sub.queue.push(value));[0m
[32m    await Promise.all(deliveries);[0m
[32m  }[0m
[32m[0m
[32m  async function applyAction(action: StateAction): Promise<void> {[0m
[32m    const reduced = reduceAppState(state, action);[0m
[32m    state = reduced.state;[0m
[32m    for (const evt of reduced.events) await fanOut(uiSubscribers, evt);[0m
[32m    for (const eff of reduced.effects) await fanOut(effectSubscribers, eff);[0m
[32m  }[0m
[32m[0m
[32m  function subscribe<T>(subscribers: Map<string, Subscriber<T>>, maxSize: number): Subscription<T> {[0m
[32m    const id = options.idSource.nextId("store_sub");[0m
[32m    const queue = new BoundedAsyncQueue<T>({ maxSize, dropPolicy: "drop_oldest" });[0m
[32m    subscribers.set(id, { id, queue });[0m
[32m    const iterator = (async function* (): AsyncGenerator<T> {[0m
[32m      for await (const item of queue) yield item;[0m
[32m    })();[0m
[32m    return Object.assign(iterator, {[0m
[32m      unsubscribe: () => {[0m
[32m        subscribers.delete(id);[0m
[32m        queue.close({ kind: "closed", message: "unsubscribed" });[0m
[32m      }[0m
[32m    });[0m
[32m  }[0m
[32m[0m
[32m  return {[0m
[32m    getState: () => state,[0m
[32m    dispatch: async (action) => {[0m
[32m      await applyAction(action);[0m
[32m    },[0m
[32m    dispatchCommand: async (command) => {[0m
[32m      const actions = commandToActions(state, command, deps);[0m
[32m      for (const action of actions) await applyAction(action);[0m
[32m    },[0m
[32m    snapshotPersisted: () => createStateSnapshot(state.persisted),[0m
[32m    restoreFromSnapshot: async (snapshot) => {[0m
[32m      await applyAction({ type: "app/restore-persisted", persisted: snapshot.state });[0m
[32m    },[0m
[32m    subscribeUi: () => subscribe(uiSubscribers, eventBufferSize),[0m
[32m    subscribeEffects: () => subscribe(effectSubscribers, effectBufferSize)[0m
[32m  };[0m
[32m}[0m
[32m[0m
[32mapply_patch(auto_approved=true) exited 0 in 57ms:[0m
[2mSuccess. Updated the following files:[0m
[2mA src/core/state/store.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/state/notifications.ts b/src/core/state/notifications.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f8dde458abe0ab190a09282b2445f708c11d9bc
--- /dev/null
+++ b/src/core/state/notifications.ts
@@ -0,0 +1,110 @@
+export type NotificationPriority = "immediate" | "high" | "medium" | "low";
+
+export type Notification = {
+  key: string;
+  text: string;
+  priority: NotificationPriority;
+  color?: string;
+  timeoutMs?: number;
+  invalidates?: string[];
+};
+
+export type NotificationState = {
+  current: Notification | null;
+  queue: Notification[];
+};
+
+export const DEFAULT_NOTIFICATION_TIMEOUT_MS = 8000;
+
+export type NotificationEffect =
+  | { type: "effect/notification-cancel-timeout" }
+  | { type: "effect/notification-schedule-timeout"; key: string; timeoutMs: number };
+
+const priorityOrder: Record<NotificationPriority, number> = {
+  immediate: 0,
+  high: 1,
+  medium: 2,
+  low: 3
+};
+
+function sortByPriority(queue: Notification[]): Notification[] {
+  return queue
+    .slice()
+    .sort((a, b) => (priorityOrder[a.priority] < priorityOrder[b.priority] ? -1 : priorityOrder[a.priority] > priorityOrder[b.priority] ? 1 : 0));
+}
+
+function removeInvalidated(queue: Notification[], invalidates: readonly string[] | undefined): Notification[] {
+  if (!invalidates || invalidates.length === 0) return queue;
+  const invalidated = new Set(invalidates);
+  return queue.filter((n) => !invalidated.has(n.key));
+}
+
+function dedupeByKey(queue: Notification[], key: string): Notification[] {
+  return queue.filter((n) => n.key !== key);
+}
+
+export function drainNotifications(state: NotificationState): { state: NotificationState; effects: NotificationEffect[] } {
+  if (state.current) return { state, effects: [] };
+  if (state.queue.length === 0) return { state, effects: [] };
+
+  const sorted = sortByPriority(state.queue);
+  const next = sorted[0];
+  const remaining = sorted.slice(1);
+  const timeoutMs = next.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+  return {
+    state: { current: next, queue: remaining },
+    effects: [{ type: "effect/notification-schedule-timeout", key: next.key, timeoutMs }]
+  };
+}
+
+export function addNotification(state: NotificationState, notification: Notification): { state: NotificationState; effects: NotificationEffect[] } {
+  const invalidates = notification.invalidates ?? [];
+
+  if (notification.priority === "immediate") {
+    const prevCurrent = state.current;
+    const merged = [...(prevCurrent ? [prevCurrent] : []), ...state.queue];
+    const filtered = removeInvalidated(
+      merged.filter((n) => n.priority !== "immediate"),
+      invalidates
+    );
+
+    const nextState: NotificationState = {
+      current: notification,
+      queue: dedupeByKey(filtered, notification.key)
+    };
+
+    const timeoutMs = notification.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+    return {
+      state: nextState,
+      effects: [
+        { type: "effect/notification-cancel-timeout" },
+        { type: "effect/notification-schedule-timeout", key: notification.key, timeoutMs }
+      ]
+    };
+  }
+
+  const currentKey = state.current?.key ?? null;
+  const alreadyQueued = state.queue.some((n) => n.key === notification.key);
+  if (currentKey === notification.key || alreadyQueued) {
+    const pruned = removeInvalidated(state.queue, invalidates);
+    const drained = drainNotifications({ current: state.current, queue: pruned });
+    return drained;
+  }
+
+  const pruned = removeInvalidated(state.queue, invalidates);
+  const next = { current: state.current, queue: [...pruned, notification] };
+  return drainNotifications(next);
+}
+
+export function expireCurrentNotification(
+  state: NotificationState,
+  key: string
+): { state: NotificationState; effects: NotificationEffect[] } {
+  if (!state.current || state.current.key !== key) return { state, effects: [] };
+
+  const invalidates = state.current.invalidates ?? [];
+  const pruned = removeInvalidated(state.queue.filter((n) => n.priority !== "immediate"), invalidates);
+  const cleared: NotificationState = { current: null, queue: pruned };
+  return drainNotifications(cleared);
+}
+
diff --git a/src/core/state/overlays.ts b/src/core/state/overlays.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a352707c5371f79c9647ad52dbc67193bd99cc40
--- /dev/null
+++ b/src/core/state/overlays.ts
@@ -0,0 +1,55 @@
+export type OverlayKind =
+  | "message-selector"
+  | "sandbox-permission"
+  | "tool-permission"
+  | "worker-permission"
+  | "worker-sandbox-permission"
+  | "elicitation"
+  | "cost"
+  | "ide-onboarding";
+
+export const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [
+  "message-selector",
+  "sandbox-permission",
+  "tool-permission",
+  "worker-permission",
+  "worker-sandbox-permission",
+  "elicitation",
+  "cost",
+  "ide-onboarding"
+] as const;
+
+export type OverlaySelectionInputs = {
+  exiting?: boolean;
+  exitMessageActive?: boolean;
+  messageSelectorOpen?: boolean;
+  sandboxPermissionQueueLength?: number;
+  pendingSandboxRequestActive?: boolean;
+  toolPermissionActive?: boolean;
+  workerPermissionQueueLength?: number;
+  pendingWorkerRequestActive?: boolean;
+  workerSandboxPermissionQueueLength?: number;
+  elicitationQueueLength?: number;
+  costNoticeActive?: boolean;
+  ideOnboardingActive?: boolean;
+};
+
+export function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {
+  if (inputs.exiting || inputs.exitMessageActive) return null;
+  if (inputs.messageSelectorOpen) return "message-selector";
+
+  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;
+  if (hasSandboxPrompt) return "sandbox-permission";
+
+  if (inputs.toolPermissionActive) return "tool-permission";
+
+  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
+  if (hasWorkerPermission) return "worker-permission";
+
+  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
+  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";
+  if (inputs.costNoticeActive) return "cost";
+  if (inputs.ideOnboardingActive) return "ide-onboarding";
+  return null;
+}
+
diff --git a/src/core/state/persistence.ts b/src/core/state/persistence.ts
new file mode 100644
index 0000000000000000000000000000000000000000..504af5f7dce298785ae86601827c122322a0cdd4
--- /dev/null
+++ b/src/core/state/persistence.ts
@@ -0,0 +1,82 @@
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import type { PersistedAppStateV1, StateSnapshotV1 } from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+
+export const STATE_SNAPSHOT_STORAGE_KEY = "state/state_snapshot";
+
+export type StateMigrationNote = {
+  fromVersion: number;
+  toVersion: number;
+  note: string;
+};
+
+export type HydrationRecoveryNote = {
+  kind: "tool_run_cancelled" | "hook_run_cancelled" | "other";
+  sessionId: string;
+  entityId: string;
+  message: string;
+};
+
+export type HydrationResult = {
+  persisted: PersistedAppStateV1;
+  migrations: StateMigrationNote[];
+  recovery: HydrationRecoveryNote[];
+};
+
+export class InvalidStateSnapshotError extends Error {
+  readonly name = "InvalidStateSnapshotError";
+  constructor(message: string) {
+    super(message);
+  }
+}
+
+export function encodeStateSnapshot(snapshot: StateSnapshotV1): string {
+  return canonicalJsonStringify(snapshot);
+}
+
+export function decodeStateSnapshot(text: string): StateSnapshotV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new InvalidStateSnapshotError("Snapshot is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["kind"] !== "state_snapshot") throw new InvalidStateSnapshotError("Snapshot kind mismatch");
+  if (obj["schemaVersion"] !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot version: ${String(obj["schemaVersion"])}`);
+  }
+  if (!("state" in obj)) throw new InvalidStateSnapshotError("Snapshot missing state");
+  return parsed as StateSnapshotV1;
+}
+
+export function migrateStateSnapshot(snapshot: StateSnapshotV1): HydrationResult {
+  const migrations: StateMigrationNote[] = [];
+  const recovery: HydrationRecoveryNote[] = [];
+
+  if (snapshot.schemaVersion !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot schemaVersion: ${snapshot.schemaVersion}`);
+  }
+
+  return { persisted: snapshot.state, migrations, recovery };
+}
+
+export async function loadStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY
+): Promise<StateSnapshotV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeStateSnapshot(found.value);
+}
+
+export async function saveStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  snapshot: StateSnapshotV1,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeStateSnapshot(snapshot);
+  const res = await storage.set(namespace, key, encoded, options);
+  return res;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..809c20a9646f83664161d132ecd72d2df942adbf
--- /dev/null
+++ b/src/core/state/state.ts
@@ -0,0 +1,264 @@
+import type { IdSource } from "../runtime/ids.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import {
+  asAppId,
+  asSessionId,
+  type PersistedAppStateV1,
+  type PersistedSessionStateV1,
+  type SessionId,
+  type SessionLifecycleState,
+  type StateSnapshotV1,
+  type TranscriptLogV1
+} from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { Notification, NotificationEffect, NotificationState } from "./notifications.js";
+import { addNotification, expireCurrentNotification } from "./notifications.js";
+
+export type SandboxHostPattern = { host: string; port?: number };
+
+export type SandboxPermissionRequest = {
+  requestId: string;
+  hostPattern: SandboxHostPattern;
+  createdAtMonoMs: number;
+  origin: "local" | "worker" | "leader";
+};
+
+export type ToolPermissionRequest = {
+  requestId: string;
+  toolName: string;
+  createdAtMonoMs: number;
+  message?: string;
+};
+
+export type ElicitationRequest = {
+  requestId: string;
+  createdAtMonoMs: number;
+  prompt: string;
+  source: "mcp";
+  concurrency: "serial" | "parallel";
+};
+
+export type WorkerPermissionQueueState = {
+  queue: Array<{ requestId: string; createdAtMonoMs: number; message?: string }>;
+  selectedIndex: number;
+};
+
+export type UiState = {
+  notifications: NotificationState;
+  sandboxPermissions: { queue: SandboxPermissionRequest[]; pendingLeaderRequest: { requestId: string; host: string } | null };
+  toolPermission: { active: ToolPermissionRequest | null };
+  workerPermissions: WorkerPermissionQueueState;
+  workerSandboxPermissions: WorkerPermissionQueueState;
+  elicitation: { queue: ElicitationRequest[] };
+  messageSelectorOpen: boolean;
+  costNoticeActive: boolean;
+  ideOnboardingActive: boolean;
+  exiting: boolean;
+  exitMessageActive: boolean;
+};
+
+export type AppState = {
+  persisted: PersistedAppStateV1;
+  ui: UiState;
+};
+
+export type StateEffect = NotificationEffect;
+
+export type StateUiEvent = { type: "ui/state-changed"; actionType: StateAction["type"] };
+
+export type StateAction =
+  | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
+  | { type: "app/session-created"; session: PersistedSessionStateV1 }
+  | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "ui/notification/add"; notification: Notification }
+  | { type: "ui/notification/expired"; key: string }
+  | { type: "ui/message-selector/set-open"; open: boolean }
+  | { type: "ui/exit/set"; exiting: boolean; exitMessageActive?: boolean };
+
+export type StateCommand =
+  | { type: "cmd/create-session"; sessionId?: SessionId; activate?: boolean; nowMonoMs?: number }
+  | { type: "cmd/restore-from-snapshot"; snapshot: StateSnapshotV1 };
+
+export function createEmptyTranscriptLog(nowMonoMs: number): TranscriptLogV1 {
+  return { schemaVersion: 1, events: [], bounded: undefined };
+}
+
+export function createEmptyUiState(): UiState {
+  return {
+    notifications: { current: null, queue: [] },
+    sandboxPermissions: { queue: [], pendingLeaderRequest: null },
+    toolPermission: { active: null },
+    workerPermissions: { queue: [], selectedIndex: 0 },
+    workerSandboxPermissions: { queue: [], selectedIndex: 0 },
+    elicitation: { queue: [] },
+    messageSelectorOpen: false,
+    costNoticeActive: false,
+    ideOnboardingActive: false,
+    exiting: false,
+    exitMessageActive: false
+  };
+}
+
+export function createEmptyPersistedAppState(options: { idSource: IdSource; clock: MonotonicClock }): PersistedAppStateV1 {
+  const now = options.clock.nowMs();
+  return {
+    schemaVersion: 1,
+    appId: asAppId(options.idSource.nextId("app")),
+    createdAtMonoMs: now,
+    updatedAtMonoMs: now,
+    sessions: {}
+  };
+}
+
+export function createAppState(options: { idSource: IdSource; clock: MonotonicClock }): AppState {
+  return { persisted: createEmptyPersistedAppState(options), ui: createEmptyUiState() };
+}
+
+export function createStateSnapshot(persisted: PersistedAppStateV1): StateSnapshotV1 {
+  return { kind: "state_snapshot", schemaVersion: SCHEMA_VERSION.stateSnapshot, state: persisted };
+}
+
+export type CrashRecoveryReport = {
+  cancelledToolRuns: Array<{ sessionId: SessionId; toolRunId: string }>;
+  cancelledHookRuns: Array<{ sessionId: SessionId; hookRunId: string }>;
+};
+
+export function recoverPersistedAppState(
+  persisted: PersistedAppStateV1,
+  nowMonoMs: number
+): { persisted: PersistedAppStateV1; report: CrashRecoveryReport } {
+  const report: CrashRecoveryReport = { cancelledToolRuns: [], cancelledHookRuns: [] };
+  const nextSessions: Record<string, PersistedSessionStateV1> = {};
+
+  const crashCancel: CancellationReason = { kind: "unknown", message: "Recovered from crash (tool/hook run left in-flight)" };
+
+  for (const [sessionKey, session] of Object.entries(persisted.sessions)) {
+    const nextToolRuns: typeof session.toolRuns = {};
+    for (const [id, run] of Object.entries(session.toolRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextToolRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledToolRuns.push({ sessionId: session.id, toolRunId: id });
+      } else {
+        nextToolRuns[id] = run;
+      }
+    }
+
+    const nextHookRuns: typeof session.hookRuns = {};
+    for (const [id, run] of Object.entries(session.hookRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextHookRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledHookRuns.push({ sessionId: session.id, hookRunId: id });
+      } else {
+        nextHookRuns[id] = run;
+      }
+    }
+
+    nextSessions[sessionKey] = {
+      ...session,
+      toolRuns: nextToolRuns,
+      hookRuns: nextHookRuns,
+      updatedAtMonoMs: nowMonoMs
+    };
+  }
+
+  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+}
+
+export function reduceAppState(state: AppState, action: StateAction): { state: AppState; effects: StateEffect[]; events: StateUiEvent[] } {
+  switch (action.type) {
+    case "app/restore-persisted": {
+      const next: AppState = { persisted: action.persisted, ui: createEmptyUiState() };
+      return { state: next, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-created": {
+      const sessions = { ...state.persisted.sessions, [action.session.id]: action.session };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions,
+        activeSessionId: state.persisted.activeSessionId ?? action.session.id,
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.session.updatedAtMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-lifecycle-set": {
+      const session = state.persisted.sessions[action.sessionId];
+      if (!session) return { state, effects: [], events: [] };
+      const nextSession: PersistedSessionStateV1 = {
+        ...session,
+        lifecycle: action.lifecycle,
+        updatedAtMonoMs: action.tsMonoMs,
+        ...(action.lifecycle === "ended" ? { endedAtMonoMs: action.tsMonoMs } : {}),
+        ...(action.lifecycle === "error" ? { error: action.error ?? session.error ?? "Session error" } : {})
+      };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions: { ...state.persisted.sessions, [action.sessionId]: nextSession },
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/add": {
+      const { state: nextNotif, effects } = addNotification(state.ui.notifications, action.notification);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/expired": {
+      const { state: nextNotif, effects } = expireCurrentNotification(state.ui.notifications, action.key);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/message-selector/set-open": {
+      return {
+        state: { ...state, ui: { ...state.ui, messageSelectorOpen: action.open } },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+    case "ui/exit/set": {
+      return {
+        state: {
+          ...state,
+          ui: {
+            ...state.ui,
+            exiting: action.exiting,
+            exitMessageActive: action.exitMessageActive ?? state.ui.exitMessageActive
+          }
+        },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+  }
+}
+
+export function commandToActions(
+  state: AppState,
+  command: StateCommand,
+  deps: { idSource: IdSource; clock: MonotonicClock }
+): StateAction[] {
+  switch (command.type) {
+    case "cmd/create-session": {
+      const sessionId = command.sessionId ?? asSessionId(deps.idSource.nextId("sess"));
+      const now = command.nowMonoMs ?? deps.clock.nowMs();
+      const session: PersistedSessionStateV1 = {
+        schemaVersion: 1,
+        id: sessionId,
+        lifecycle: "created",
+        createdAtMonoMs: now,
+        updatedAtMonoMs: now,
+        transcript: createEmptyTranscriptLog(now),
+        attachments: {},
+        toolRuns: {},
+        hookRuns: {},
+        mcpConnections: {}
+      };
+      const actions: StateAction[] = [{ type: "app/session-created", session }];
+      if (command.activate) actions.push({ type: "app/session-lifecycle-set", sessionId, lifecycle: "active", tsMonoMs: now });
+      return actions;
+    }
+    case "cmd/restore-from-snapshot": {
+      const recovered = recoverPersistedAppState(command.snapshot.state, deps.clock.nowMs());
+      return [{ type: "app/restore-persisted", persisted: recovered.persisted }];
+    }
+  }
+}
+
diff --git a/src/core/state/store.ts b/src/core/state/store.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f85b21e6ff7f0ec5be5a8dd9fd4cec4658e397f2
--- /dev/null
+++ b/src/core/state/store.ts
@@ -0,0 +1,89 @@
+import type { IdSource } from "../runtime/ids.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import { BoundedAsyncQueue } from "../runtime/queue.js";
+import type { StateSnapshotV1 } from "../types/state.js";
+import type { AppState, StateAction, StateCommand, StateEffect, StateUiEvent } from "./state.js";
+import { commandToActions, createAppState, createStateSnapshot, reduceAppState } from "./state.js";
+
+export type StateStoreOptions = {
+  idSource: IdSource;
+  clock: MonotonicClock;
+  eventBufferSize?: number;
+  effectBufferSize?: number;
+};
+
+export type Unsubscribe = () => void;
+
+export type Subscription<T> = AsyncIterable<T> & { unsubscribe: Unsubscribe };
+
+export type StateStore = {
+  getState: () => AppState;
+  dispatch: (action: StateAction) => Promise<void>;
+  dispatchCommand: (command: StateCommand) => Promise<void>;
+  snapshotPersisted: () => StateSnapshotV1;
+  restoreFromSnapshot: (snapshot: StateSnapshotV1) => Promise<void>;
+  subscribeUi: () => Subscription<StateUiEvent>;
+  subscribeEffects: () => Subscription<StateEffect>;
+};
+
+type Subscriber<T> = {
+  id: string;
+  queue: BoundedAsyncQueue<T>;
+};
+
+export function createStateStore(options: StateStoreOptions): StateStore {
+  const deps = { idSource: options.idSource, clock: options.clock };
+  let state = createAppState(deps);
+
+  const uiSubscribers = new Map<string, Subscriber<StateUiEvent>>();
+  const effectSubscribers = new Map<string, Subscriber<StateEffect>>();
+
+  const eventBufferSize = Math.max(0, options.eventBufferSize ?? 256);
+  const effectBufferSize = Math.max(0, options.effectBufferSize ?? 256);
+
+  async function fanOut<T>(subscribers: Map<string, Subscriber<T>>, value: T): Promise<void> {
+    const deliveries: Array<Promise<void>> = [];
+    for (const sub of subscribers.values()) deliveries.push(sub.queue.push(value));
+    await Promise.all(deliveries);
+  }
+
+  async function applyAction(action: StateAction): Promise<void> {
+    const reduced = reduceAppState(state, action);
+    state = reduced.state;
+    for (const evt of reduced.events) await fanOut(uiSubscribers, evt);
+    for (const eff of reduced.effects) await fanOut(effectSubscribers, eff);
+  }
+
+  function subscribe<T>(subscribers: Map<string, Subscriber<T>>, maxSize: number): Subscription<T> {
+    const id = options.idSource.nextId("store_sub");
+    const queue = new BoundedAsyncQueue<T>({ maxSize, dropPolicy: "drop_oldest" });
+    subscribers.set(id, { id, queue });
+    const iterator = (async function* (): AsyncGenerator<T> {
+      for await (const item of queue) yield item;
+    })();
+    return Object.assign(iterator, {
+      unsubscribe: () => {
+        subscribers.delete(id);
+        queue.close({ kind: "closed", message: "unsubscribed" });
+      }
+    });
+  }
+
+  return {
+    getState: () => state,
+    dispatch: async (action) => {
+      await applyAction(action);
+    },
+    dispatchCommand: async (command) => {
+      const actions = commandToActions(state, command, deps);
+      for (const action of actions) await applyAction(action);
+    },
+    snapshotPersisted: () => createStateSnapshot(state.persisted),
+    restoreFromSnapshot: async (snapshot) => {
+      await applyAction({ type: "app/restore-persisted", persisted: snapshot.state });
+    },
+    subscribeUi: () => subscribe(uiSubscribers, eventBufferSize),
+    subscribeEffects: () => subscribe(effectSubscribers, effectBufferSize)
+  };
+}
+
diff --git a/src/core/state/transcript.ts b/src/core/state/transcript.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f9b512d495cf977b0b62fbbe91b1247887087dab
--- /dev/null
+++ b/src/core/state/transcript.ts
@@ -0,0 +1,63 @@
+import type { HostCrypto } from "../types/host.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import { REDACTED, type Sensitive, type TranscriptEventV1, type TranscriptLogV1 } from "../types/state.js";
+
+export type RedactionStats = {
+  redactedNodes: number;
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  if (value === null || typeof value !== "object") return false;
+  const proto = Object.getPrototypeOf(value);
+  return proto === Object.prototype || proto === null;
+}
+
+function isSensitive(value: unknown): value is Sensitive<unknown> {
+  return isPlainObject(value) && value["kind"] === "sensitive" && "value" in value;
+}
+
+function redactValue(value: unknown, stats: RedactionStats): unknown {
+  if (isSensitive(value)) {
+    stats.redactedNodes += 1;
+    return REDACTED;
+  }
+  if (value === null) return null;
+  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") return value;
+  if (Array.isArray(value)) return value.map((v) => redactValue(v, stats));
+  if (isPlainObject(value)) {
+    const out: Record<string, unknown> = {};
+    for (const [k, v] of Object.entries(value)) out[k] = redactValue(v, stats);
+    return out;
+  }
+  return value;
+}
+
+export function redactTranscriptEvent(event: TranscriptEventV1): { event: TranscriptEventV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const redacted = redactValue(event, stats) as TranscriptEventV1;
+  return { event: redacted, stats };
+}
+
+export function redactTranscriptLog(log: TranscriptLogV1): { log: TranscriptLogV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const events = log.events.map((evt) => redactValue(evt, stats) as TranscriptEventV1);
+  return { log: { ...log, events }, stats };
+}
+
+function bytesToHex(bytes: Uint8Array): string {
+  let out = "";
+  for (const b of bytes) out += b.toString(16).padStart(2, "0");
+  return out;
+}
+
+export async function computeTranscriptSummary(
+  log: TranscriptLogV1,
+  crypto: HostCrypto
+): Promise<{ eventCount: number; sha256Hex: string; redactedNodes: number }> {
+  const { log: redacted, stats } = redactTranscriptLog(log);
+  const json = canonicalJsonStringify(redacted, { pretty: false });
+  const data = new TextEncoder().encode(json);
+  const digest = await crypto.digest("SHA-256", data);
+  return { eventCount: redacted.events.length, sha256Hex: bytesToHex(digest), redactedNodes: stats.redactedNodes };
+}
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+


[35m[3mthinking[0m[0m
**Adjusting snapshot functionality**

I‚Äôm looking at how the `restoreFromSnapshot` method directly accesses `snapshot.state`, which doesn‚Äôt incorporate crash recovery as `cmd/restore-from-snapshot` does. I think it‚Äôs better to modify `restoreFromSnapshot` to dispatch the command instead. Also, I see that `StateSnapshotV1` hasn‚Äôt been directly used in the store. I‚Äôll need to adjust the method to utilize `dispatchCommand({type: "cmd/restore-from-snapshot"...})` and clean up any unused imports, like `StateSnapshotV1`.
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
deleted file mode 100644
index a24169e79aeb5bebb6227585b7de8694bb92222c..0000000000000000000000000000000000000000
--- a/src/core/state/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
-
diff --git a/src/core/state/notifications.ts b/src/core/state/notifications.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f8dde458abe0ab190a09282b2445f708c11d9bc
--- /dev/null
+++ b/src/core/state/notifications.ts
@@ -0,0 +1,110 @@
+export type NotificationPriority = "immediate" | "high" | "medium" | "low";
+
+export type Notification = {
+  key: string;
+  text: string;
+  priority: NotificationPriority;
+  color?: string;
+  timeoutMs?: number;
+  invalidates?: string[];
+};
+
+export type NotificationState = {
+  current: Notification | null;
+  queue: Notification[];
+};
+
+export const DEFAULT_NOTIFICATION_TIMEOUT_MS = 8000;
+
+export type NotificationEffect =
+  | { type: "effect/notification-cancel-timeout" }
+  | { type: "effect/notification-schedule-timeout"; key: string; timeoutMs: number };
+
+const priorityOrder: Record<NotificationPriority, number> = {
+  immediate: 0,
+  high: 1,
+  medium: 2,
+  low: 3
+};
+
+function sortByPriority(queue: Notification[]): Notification[] {
+  return queue
+    .slice()
+    .sort((a, b) => (priorityOrder[a.priority] < priorityOrder[b.priority] ? -1 : priorityOrder[a.priority] > priorityOrder[b.priority] ? 1 : 0));
+}
+
+function removeInvalidated(queue: Notification[], invalidates: readonly string[] | undefined): Notification[] {
+  if (!invalidates || invalidates.length === 0) return queue;
+  const invalidated = new Set(invalidates);
+  return queue.filter((n) => !invalidated.has(n.key));
+}
+
+function dedupeByKey(queue: Notification[], key: string): Notification[] {
+  return queue.filter((n) => n.key !== key);
+}
+
+export function drainNotifications(state: NotificationState): { state: NotificationState; effects: NotificationEffect[] } {
+  if (state.current) return { state, effects: [] };
+  if (state.queue.length === 0) return { state, effects: [] };
+
+  const sorted = sortByPriority(state.queue);
+  const next = sorted[0];
+  const remaining = sorted.slice(1);
+  const timeoutMs = next.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+  return {
+    state: { current: next, queue: remaining },
+    effects: [{ type: "effect/notification-schedule-timeout", key: next.key, timeoutMs }]
+  };
+}
+
+export function addNotification(state: NotificationState, notification: Notification): { state: NotificationState; effects: NotificationEffect[] } {
+  const invalidates = notification.invalidates ?? [];
+
+  if (notification.priority === "immediate") {
+    const prevCurrent = state.current;
+    const merged = [...(prevCurrent ? [prevCurrent] : []), ...state.queue];
+    const filtered = removeInvalidated(
+      merged.filter((n) => n.priority !== "immediate"),
+      invalidates
+    );
+
+    const nextState: NotificationState = {
+      current: notification,
+      queue: dedupeByKey(filtered, notification.key)
+    };
+
+    const timeoutMs = notification.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+    return {
+      state: nextState,
+      effects: [
+        { type: "effect/notification-cancel-timeout" },
+        { type: "effect/notification-schedule-timeout", key: notification.key, timeoutMs }
+      ]
+    };
+  }
+
+  const currentKey = state.current?.key ?? null;
+  const alreadyQueued = state.queue.some((n) => n.key === notification.key);
+  if (currentKey === notification.key || alreadyQueued) {
+    const pruned = removeInvalidated(state.queue, invalidates);
+    const drained = drainNotifications({ current: state.current, queue: pruned });
+    return drained;
+  }
+
+  const pruned = removeInvalidated(state.queue, invalidates);
+  const next = { current: state.current, queue: [...pruned, notification] };
+  return drainNotifications(next);
+}
+
+export function expireCurrentNotification(
+  state: NotificationState,
+  key: string
+): { state: NotificationState; effects: NotificationEffect[] } {
+  if (!state.current || state.current.key !== key) return { state, effects: [] };
+
+  const invalidates = state.current.invalidates ?? [];
+  const pruned = removeInvalidated(state.queue.filter((n) => n.priority !== "immediate"), invalidates);
+  const cleared: NotificationState = { current: null, queue: pruned };
+  return drainNotifications(cleared);
+}
+
diff --git a/src/core/state/overlays.ts b/src/core/state/overlays.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a352707c5371f79c9647ad52dbc67193bd99cc40
--- /dev/null
+++ b/src/core/state/overlays.ts
@@ -0,0 +1,55 @@
+export type OverlayKind =
+  | "message-selector"
+  | "sandbox-permission"
+  | "tool-permission"
+  | "worker-permission"
+  | "worker-sandbox-permission"
+  | "elicitation"
+  | "cost"
+  | "ide-onboarding";
+
+export const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [
+  "message-selector",
+  "sandbox-permission",
+  "tool-permission",
+  "worker-permission",
+  "worker-sandbox-permission",
+  "elicitation",
+  "cost",
+  "ide-onboarding"
+] as const;
+
+export type OverlaySelectionInputs = {
+  exiting?: boolean;
+  exitMessageActive?: boolean;
+  messageSelectorOpen?: boolean;
+  sandboxPermissionQueueLength?: number;
+  pendingSandboxRequestActive?: boolean;
+  toolPermissionActive?: boolean;
+  workerPermissionQueueLength?: number;
+  pendingWorkerRequestActive?: boolean;
+  workerSandboxPermissionQueueLength?: number;
+  elicitationQueueLength?: number;
+  costNoticeActive?: boolean;
+  ideOnboardingActive?: boolean;
+};
+
+export function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {
+  if (inputs.exiting || inputs.exitMessageActive) return null;
+  if (inputs.messageSelectorOpen) return "message-selector";
+
+  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;
+  if (hasSandboxPrompt) return "sandbox-permission";
+
+  if (inputs.toolPermissionActive) return "tool-permission";
+
+  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
+  if (hasWorkerPermission) return "worker-permission";
+
+  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
+  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";
+  if (inputs.costNoticeActive) return "cost";
+  if (inputs.ideOnboardingActive) return "ide-onboarding";
+  return null;
+}
+
diff --git a/src/core/state/persistence.ts b/src/core/state/persistence.ts
new file mode 100644
index 0000000000000000000000000000000000000000..504af5f7dce298785ae86601827c122322a0cdd4
--- /dev/null
+++ b/src/core/state/persistence.ts
@@ -0,0 +1,82 @@
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import type { PersistedAppStateV1, StateSnapshotV1 } from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+
+export const STATE_SNAPSHOT_STORAGE_KEY = "state/state_snapshot";
+
+export type StateMigrationNote = {
+  fromVersion: number;
+  toVersion: number;
+  note: string;
+};
+
+export type HydrationRecoveryNote = {
+  kind: "tool_run_cancelled" | "hook_run_cancelled" | "other";
+  sessionId: string;
+  entityId: string;
+  message: string;
+};
+
+export type HydrationResult = {
+  persisted: PersistedAppStateV1;
+  migrations: StateMigrationNote[];
+  recovery: HydrationRecoveryNote[];
+};
+
+export class InvalidStateSnapshotError extends Error {
+  readonly name = "InvalidStateSnapshotError";
+  constructor(message: string) {
+    super(message);
+  }
+}
+
+export function encodeStateSnapshot(snapshot: StateSnapshotV1): string {
+  return canonicalJsonStringify(snapshot);
+}
+
+export function decodeStateSnapshot(text: string): StateSnapshotV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new InvalidStateSnapshotError("Snapshot is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["kind"] !== "state_snapshot") throw new InvalidStateSnapshotError("Snapshot kind mismatch");
+  if (obj["schemaVersion"] !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot version: ${String(obj["schemaVersion"])}`);
+  }
+  if (!("state" in obj)) throw new InvalidStateSnapshotError("Snapshot missing state");
+  return parsed as StateSnapshotV1;
+}
+
+export function migrateStateSnapshot(snapshot: StateSnapshotV1): HydrationResult {
+  const migrations: StateMigrationNote[] = [];
+  const recovery: HydrationRecoveryNote[] = [];
+
+  if (snapshot.schemaVersion !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot schemaVersion: ${snapshot.schemaVersion}`);
+  }
+
+  return { persisted: snapshot.state, migrations, recovery };
+}
+
+export async function loadStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY
+): Promise<StateSnapshotV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeStateSnapshot(found.value);
+}
+
+export async function saveStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  snapshot: StateSnapshotV1,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeStateSnapshot(snapshot);
+  const res = await storage.set(namespace, key, encoded, options);
+  return res;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..809c20a9646f83664161d132ecd72d2df942adbf
--- /dev/null
+++ b/src/core/state/state.ts
@@ -0,0 +1,264 @@
+import type { IdSource } from "../runtime/ids.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import {
+  asAppId,
+  asSessionId,
+  type PersistedAppStateV1,
+  type PersistedSessionStateV1,
+  type SessionId,
+  type SessionLifecycleState,
+  type StateSnapshotV1,
+  type TranscriptLogV1
+} from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { Notification, NotificationEffect, NotificationState } from "./notifications.js";
+import { addNotification, expireCurrentNotification } from "./notifications.js";
+
+export type SandboxHostPattern = { host: string; port?: number };
+
+export type SandboxPermissionRequest = {
+  requestId: string;
+  hostPattern: SandboxHostPattern;
+  createdAtMonoMs: number;
+  origin: "local" | "worker" | "leader";
+};
+
+export type ToolPermissionRequest = {
+  requestId: string;
+  toolName: string;
+  createdAtMonoMs: number;
+  message?: string;
+};
+
+export type ElicitationRequest = {
+  requestId: string;
+  createdAtMonoMs: number;
+  prompt: string;
+  source: "mcp";
+  concurrency: "serial" | "parallel";
+};
+
+export type WorkerPermissionQueueState = {
+  queue: Array<{ requestId: string; createdAtMonoMs: number; message?: string }>;
+  selectedIndex: number;
+};
+
+export type UiState = {
+  notifications: NotificationState;
+  sandboxPermissions: { queue: SandboxPermissionRequest[]; pendingLeaderRequest: { requestId: string; host: string } | null };
+  toolPermission: { active: ToolPermissionRequest | null };
+  workerPermissions: WorkerPermissionQueueState;
+  workerSandboxPermissions: WorkerPermissionQueueState;
+  elicitation: { queue: ElicitationRequest[] };
+  messageSelectorOpen: boolean;
+  costNoticeActive: boolean;
+  ideOnboardingActive: boolean;
+  exiting: boolean;
+  exitMessageActive: boolean;
+};
+
+export type AppState = {
+  persisted: PersistedAppStateV1;
+  ui: UiState;
+};
+
+export type StateEffect = NotificationEffect;
+
+export type StateUiEvent = { type: "ui/state-changed"; actionType: StateAction["type"] };
+
+export type StateAction =
+  | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
+  | { type: "app/session-created"; session: PersistedSessionStateV1 }
+  | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "ui/notification/add"; notification: Notification }
+  | { type: "ui/notification/expired"; key: string }
+  | { type: "ui/message-selector/set-open"; open: boolean }
+  | { type: "ui/exit/set"; exiting: boolean; exitMessageActive?: boolean };
+
+export type StateCommand =
+  | { type: "cmd/create-session"; sessionId?: SessionId; activate?: boolean; nowMonoMs?: number }
+  | { type: "cmd/restore-from-snapshot"; snapshot: StateSnapshotV1 };
+
+export function createEmptyTranscriptLog(nowMonoMs: number): TranscriptLogV1 {
+  return { schemaVersion: 1, events: [], bounded: undefined };
+}
+
+export function createEmptyUiState(): UiState {
+  return {
+    notifications: { current: null, queue: [] },
+    sandboxPermissions: { queue: [], pendingLeaderRequest: null },
+    toolPermission: { active: null },
+    workerPermissions: { queue: [], selectedIndex: 0 },
+    workerSandboxPermissions: { queue: [], selectedIndex: 0 },
+    elicitation: { queue: [] },
+    messageSelectorOpen: false,
+    costNoticeActive: false,
+    ideOnboardingActive: false,
+    exiting: false,
+    exitMessageActive: false
+  };
+}
+
+export function createEmptyPersistedAppState(options: { idSource: IdSource; clock: MonotonicClock }): PersistedAppStateV1 {
+  const now = options.clock.nowMs();
+  return {
+    schemaVersion: 1,
+    appId: asAppId(options.idSource.nextId("app")),
+    createdAtMonoMs: now,
+    updatedAtMonoMs: now,
+    sessions: {}
+  };
+}
+
+export function createAppState(options: { idSource: IdSource; clock: MonotonicClock }): AppState {
+  return { persisted: createEmptyPersistedAppState(options), ui: createEmptyUiState() };
+}
+
+export function createStateSnapshot(persisted: PersistedAppStateV1): StateSnapshotV1 {
+  return { kind: "state_snapshot", schemaVersion: SCHEMA_VERSION.stateSnapshot, state: persisted };
+}
+
+export type CrashRecoveryReport = {
+  cancelledToolRuns: Array<{ sessionId: SessionId; toolRunId: string }>;
+  cancelledHookRuns: Array<{ sessionId: SessionId; hookRunId: string }>;
+};
+
+export function recoverPersistedAppState(
+  persisted: PersistedAppStateV1,
+  nowMonoMs: number
+): { persisted: PersistedAppStateV1; report: CrashRecoveryReport } {
+  const report: CrashRecoveryReport = { cancelledToolRuns: [], cancelledHookRuns: [] };
+  const nextSessions: Record<string, PersistedSessionStateV1> = {};
+
+  const crashCancel: CancellationReason = { kind: "unknown", message: "Recovered from crash (tool/hook run left in-flight)" };
+
+  for (const [sessionKey, session] of Object.entries(persisted.sessions)) {
+    const nextToolRuns: typeof session.toolRuns = {};
+    for (const [id, run] of Object.entries(session.toolRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextToolRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledToolRuns.push({ sessionId: session.id, toolRunId: id });
+      } else {
+        nextToolRuns[id] = run;
+      }
+    }
+
+    const nextHookRuns: typeof session.hookRuns = {};
+    for (const [id, run] of Object.entries(session.hookRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextHookRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledHookRuns.push({ sessionId: session.id, hookRunId: id });
+      } else {
+        nextHookRuns[id] = run;
+      }
+    }
+
+    nextSessions[sessionKey] = {
+      ...session,
+      toolRuns: nextToolRuns,
+      hookRuns: nextHookRuns,
+      updatedAtMonoMs: nowMonoMs
+    };
+  }
+
+  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+}
+
+export function reduceAppState(state: AppState, action: StateAction): { state: AppState; effects: StateEffect[]; events: StateUiEvent[] } {
+  switch (action.type) {
+    case "app/restore-persisted": {
+      const next: AppState = { persisted: action.persisted, ui: createEmptyUiState() };
+      return { state: next, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-created": {
+      const sessions = { ...state.persisted.sessions, [action.session.id]: action.session };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions,
+        activeSessionId: state.persisted.activeSessionId ?? action.session.id,
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.session.updatedAtMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-lifecycle-set": {
+      const session = state.persisted.sessions[action.sessionId];
+      if (!session) return { state, effects: [], events: [] };
+      const nextSession: PersistedSessionStateV1 = {
+        ...session,
+        lifecycle: action.lifecycle,
+        updatedAtMonoMs: action.tsMonoMs,
+        ...(action.lifecycle === "ended" ? { endedAtMonoMs: action.tsMonoMs } : {}),
+        ...(action.lifecycle === "error" ? { error: action.error ?? session.error ?? "Session error" } : {})
+      };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions: { ...state.persisted.sessions, [action.sessionId]: nextSession },
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/add": {
+      const { state: nextNotif, effects } = addNotification(state.ui.notifications, action.notification);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/expired": {
+      const { state: nextNotif, effects } = expireCurrentNotification(state.ui.notifications, action.key);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/message-selector/set-open": {
+      return {
+        state: { ...state, ui: { ...state.ui, messageSelectorOpen: action.open } },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+    case "ui/exit/set": {
+      return {
+        state: {
+          ...state,
+          ui: {
+            ...state.ui,
+            exiting: action.exiting,
+            exitMessageActive: action.exitMessageActive ?? state.ui.exitMessageActive
+          }
+        },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+  }
+}
+
+export function commandToActions(
+  state: AppState,
+  command: StateCommand,
+  deps: { idSource: IdSource; clock: MonotonicClock }
+): StateAction[] {
+  switch (command.type) {
+    case "cmd/create-session": {
+      const sessionId = command.sessionId ?? asSessionId(deps.idSource.nextId("sess"));
+      const now = command.nowMonoMs ?? deps.clock.nowMs();
+      const session: PersistedSessionStateV1 = {
+        schemaVersion: 1,
+        id: sessionId,
+        lifecycle: "created",
+        createdAtMonoMs: now,
+        updatedAtMonoMs: now,
+        transcript: createEmptyTranscriptLog(now),
+        attachments: {},
+        toolRuns: {},
+        hookRuns: {},
+        mcpConnections: {}
+      };
+      const actions: StateAction[] = [{ type: "app/session-created", session }];
+      if (command.activate) actions.push({ type: "app/session-lifecycle-set", sessionId, lifecycle: "active", tsMonoMs: now });
+      return actions;
+    }
+    case "cmd/restore-from-snapshot": {
+      const recovered = recoverPersistedAppState(command.snapshot.state, deps.clock.nowMs());
+      return [{ type: "app/restore-persisted", persisted: recovered.persisted }];
+    }
+  }
+}
+
diff --git a/src/core/state/store.ts b/src/core/state/store.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f85b21e6ff7f0ec5be5a8dd9fd4cec4658e397f2
--- /dev/null
+++ b/src/core/state/store.ts
@@ -0,0 +1,89 @@
+import type { IdSource } from "../runtime/ids.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import { BoundedAsyncQueue } from "../runtime/queue.js";
+import type { StateSnapshotV1 } from "../types/state.js";
+import type { AppState, StateAction, StateCommand, StateEffect, StateUiEvent } from "./state.js";
+import { commandToActions, createAppState, createStateSnapshot, reduceAppState } from "./state.js";
+
+export type StateStoreOptions = {
+  idSource: IdSource;
+  clock: MonotonicClock;
+  eventBufferSize?: number;
+  effectBufferSize?: number;
+};
+
+export type Unsubscribe = () => void;
+
+export type Subscription<T> = AsyncIterable<T> & { unsubscribe: Unsubscribe };
+
+export type StateStore = {
+  getState: () => AppState;
+  dispatch: (action: StateAction) => Promise<void>;
+  dispatchCommand: (command: StateCommand) => Promise<void>;
+  snapshotPersisted: () => StateSnapshotV1;
+  restoreFromSnapshot: (snapshot: StateSnapshotV1) => Promise<void>;
+  subscribeUi: () => Subscription<StateUiEvent>;
+  subscribeEffects: () => Subscription<StateEffect>;
+};
+
+type Subscriber<T> = {
+  id: string;
+  queue: BoundedAsyncQueue<T>;
+};
+
+export function createStateStore(options: StateStoreOptions): StateStore {
+  const deps = { idSource: options.idSource, clock: options.clock };
+  let state = createAppState(deps);
+
+  const uiSubscribers = new Map<string, Subscriber<StateUiEvent>>();
+  const effectSubscribers = new Map<string, Subscriber<StateEffect>>();
+
+  const eventBufferSize = Math.max(0, options.eventBufferSize ?? 256);
+  const effectBufferSize = Math.max(0, options.effectBufferSize ?? 256);
+
+  async function fanOut<T>(subscribers: Map<string, Subscriber<T>>, value: T): Promise<void> {
+    const deliveries: Array<Promise<void>> = [];
+    for (const sub of subscribers.values()) deliveries.push(sub.queue.push(value));
+    await Promise.all(deliveries);
+  }
+
+  async function applyAction(action: StateAction): Promise<void> {
+    const reduced = reduceAppState(state, action);
+    state = reduced.state;
+    for (const evt of reduced.events) await fanOut(uiSubscribers, evt);
+    for (const eff of reduced.effects) await fanOut(effectSubscribers, eff);
+  }
+
+  function subscribe<T>(subscribers: Map<string, Subscriber<T>>, maxSize: number): Subscription<T> {
+    const id = options.idSource.nextId("store_sub");
+    const queue = new BoundedAsyncQueue<T>({ maxSize, dropPolicy: "drop_oldest" });
+    subscribers.set(id, { id, queue });
+    const iterator = (async function* (): AsyncGenerator<T> {
+      for await (const item of queue) yield item;
+    })();
+    return Object.assign(iterator, {
+      unsubscribe: () => {
+        subscribers.delete(id);
+        queue.close({ kind: "closed", message: "unsubscribed" });
+      }
+    });
+  }
+
+  return {
+    getState: () => state,
+    dispatch: async (action) => {
+      await applyAction(action);
+    },
+    dispatchCommand: async (command) => {
+      const actions = commandToActions(state, command, deps);
+      for (const action of actions) await applyAction(action);
+    },
+    snapshotPersisted: () => createStateSnapshot(state.persisted),
+    restoreFromSnapshot: async (snapshot) => {
+      await applyAction({ type: "app/restore-persisted", persisted: snapshot.state });
+    },
+    subscribeUi: () => subscribe(uiSubscribers, eventBufferSize),
+    subscribeEffects: () => subscribe(effectSubscribers, effectBufferSize)
+  };
+}
+
diff --git a/src/core/state/transcript.ts b/src/core/state/transcript.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f9b512d495cf977b0b62fbbe91b1247887087dab
--- /dev/null
+++ b/src/core/state/transcript.ts
@@ -0,0 +1,63 @@
+import type { HostCrypto } from "../types/host.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import { REDACTED, type Sensitive, type TranscriptEventV1, type TranscriptLogV1 } from "../types/state.js";
+
+export type RedactionStats = {
+  redactedNodes: number;
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  if (value === null || typeof value !== "object") return false;
+  const proto = Object.getPrototypeOf(value);
+  return proto === Object.prototype || proto === null;
+}
+
+function isSensitive(value: unknown): value is Sensitive<unknown> {
+  return isPlainObject(value) && value["kind"] === "sensitive" && "value" in value;
+}
+
+function redactValue(value: unknown, stats: RedactionStats): unknown {
+  if (isSensitive(value)) {
+    stats.redactedNodes += 1;
+    return REDACTED;
+  }
+  if (value === null) return null;
+  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") return value;
+  if (Array.isArray(value)) return value.map((v) => redactValue(v, stats));
+  if (isPlainObject(value)) {
+    const out: Record<string, unknown> = {};
+    for (const [k, v] of Object.entries(value)) out[k] = redactValue(v, stats);
+    return out;
+  }
+  return value;
+}
+
+export function redactTranscriptEvent(event: TranscriptEventV1): { event: TranscriptEventV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const redacted = redactValue(event, stats) as TranscriptEventV1;
+  return { event: redacted, stats };
+}
+
+export function redactTranscriptLog(log: TranscriptLogV1): { log: TranscriptLogV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const events = log.events.map((evt) => redactValue(evt, stats) as TranscriptEventV1);
+  return { log: { ...log, events }, stats };
+}
+
+function bytesToHex(bytes: Uint8Array): string {
+  let out = "";
+  for (const b of bytes) out += b.toString(16).padStart(2, "0");
+  return out;
+}
+
+export async function computeTranscriptSummary(
+  log: TranscriptLogV1,
+  crypto: HostCrypto
+): Promise<{ eventCount: number; sha256Hex: string; redactedNodes: number }> {
+  const { log: redacted, stats } = redactTranscriptLog(log);
+  const json = canonicalJsonStringify(redacted, { pretty: false });
+  const data = new TextEncoder().encode(json);
+  const digest = await crypto.digest("SHA-256", data);
+  return { eventCount: redacted.events.length, sha256Hex: bytesToHex(digest), redactedNodes: stats.redactedNodes };
+}
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+

[3m[35mfile update[0m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/state/index.ts[0m
[32mexport * from "./overlays.js";[0m
[32mexport * from "./notifications.js";[0m
[32mexport * from "./transcript.js";[0m
[32mexport * from "./persistence.js";[0m
[32mexport * from "./state.js";[0m
[32mexport * from "./store.js";[0m
[32m[0m
[32mapply_patch(auto_approved=true) exited 0 in 59ms:[0m
[2mSuccess. Updated the following files:[0m
[2mA src/core/state/index.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
index a24169e79aeb5bebb6227585b7de8694bb92222c..e1d816f843b43f78ace8124cc241e1c196362b50
--- a/src/core/state/index.ts
+++ b/src/core/state/index.ts
@@ -1,4 +1,7 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
+export * from "./overlays.js";
+export * from "./notifications.js";
+export * from "./transcript.js";
+export * from "./persistence.js";
+export * from "./state.js";
+export * from "./store.js";
 
diff --git a/src/core/state/notifications.ts b/src/core/state/notifications.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f8dde458abe0ab190a09282b2445f708c11d9bc
--- /dev/null
+++ b/src/core/state/notifications.ts
@@ -0,0 +1,110 @@
+export type NotificationPriority = "immediate" | "high" | "medium" | "low";
+
+export type Notification = {
+  key: string;
+  text: string;
+  priority: NotificationPriority;
+  color?: string;
+  timeoutMs?: number;
+  invalidates?: string[];
+};
+
+export type NotificationState = {
+  current: Notification | null;
+  queue: Notification[];
+};
+
+export const DEFAULT_NOTIFICATION_TIMEOUT_MS = 8000;
+
+export type NotificationEffect =
+  | { type: "effect/notification-cancel-timeout" }
+  | { type: "effect/notification-schedule-timeout"; key: string; timeoutMs: number };
+
+const priorityOrder: Record<NotificationPriority, number> = {
+  immediate: 0,
+  high: 1,
+  medium: 2,
+  low: 3
+};
+
+function sortByPriority(queue: Notification[]): Notification[] {
+  return queue
+    .slice()
+    .sort((a, b) => (priorityOrder[a.priority] < priorityOrder[b.priority] ? -1 : priorityOrder[a.priority] > priorityOrder[b.priority] ? 1 : 0));
+}
+
+function removeInvalidated(queue: Notification[], invalidates: readonly string[] | undefined): Notification[] {
+  if (!invalidates || invalidates.length === 0) return queue;
+  const invalidated = new Set(invalidates);
+  return queue.filter((n) => !invalidated.has(n.key));
+}
+
+function dedupeByKey(queue: Notification[], key: string): Notification[] {
+  return queue.filter((n) => n.key !== key);
+}
+
+export function drainNotifications(state: NotificationState): { state: NotificationState; effects: NotificationEffect[] } {
+  if (state.current) return { state, effects: [] };
+  if (state.queue.length === 0) return { state, effects: [] };
+
+  const sorted = sortByPriority(state.queue);
+  const next = sorted[0];
+  const remaining = sorted.slice(1);
+  const timeoutMs = next.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+  return {
+    state: { current: next, queue: remaining },
+    effects: [{ type: "effect/notification-schedule-timeout", key: next.key, timeoutMs }]
+  };
+}
+
+export function addNotification(state: NotificationState, notification: Notification): { state: NotificationState; effects: NotificationEffect[] } {
+  const invalidates = notification.invalidates ?? [];
+
+  if (notification.priority === "immediate") {
+    const prevCurrent = state.current;
+    const merged = [...(prevCurrent ? [prevCurrent] : []), ...state.queue];
+    const filtered = removeInvalidated(
+      merged.filter((n) => n.priority !== "immediate"),
+      invalidates
+    );
+
+    const nextState: NotificationState = {
+      current: notification,
+      queue: dedupeByKey(filtered, notification.key)
+    };
+
+    const timeoutMs = notification.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+    return {
+      state: nextState,
+      effects: [
+        { type: "effect/notification-cancel-timeout" },
+        { type: "effect/notification-schedule-timeout", key: notification.key, timeoutMs }
+      ]
+    };
+  }
+
+  const currentKey = state.current?.key ?? null;
+  const alreadyQueued = state.queue.some((n) => n.key === notification.key);
+  if (currentKey === notification.key || alreadyQueued) {
+    const pruned = removeInvalidated(state.queue, invalidates);
+    const drained = drainNotifications({ current: state.current, queue: pruned });
+    return drained;
+  }
+
+  const pruned = removeInvalidated(state.queue, invalidates);
+  const next = { current: state.current, queue: [...pruned, notification] };
+  return drainNotifications(next);
+}
+
+export function expireCurrentNotification(
+  state: NotificationState,
+  key: string
+): { state: NotificationState; effects: NotificationEffect[] } {
+  if (!state.current || state.current.key !== key) return { state, effects: [] };
+
+  const invalidates = state.current.invalidates ?? [];
+  const pruned = removeInvalidated(state.queue.filter((n) => n.priority !== "immediate"), invalidates);
+  const cleared: NotificationState = { current: null, queue: pruned };
+  return drainNotifications(cleared);
+}
+
diff --git a/src/core/state/overlays.ts b/src/core/state/overlays.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a352707c5371f79c9647ad52dbc67193bd99cc40
--- /dev/null
+++ b/src/core/state/overlays.ts
@@ -0,0 +1,55 @@
+export type OverlayKind =
+  | "message-selector"
+  | "sandbox-permission"
+  | "tool-permission"
+  | "worker-permission"
+  | "worker-sandbox-permission"
+  | "elicitation"
+  | "cost"
+  | "ide-onboarding";
+
+export const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [
+  "message-selector",
+  "sandbox-permission",
+  "tool-permission",
+  "worker-permission",
+  "worker-sandbox-permission",
+  "elicitation",
+  "cost",
+  "ide-onboarding"
+] as const;
+
+export type OverlaySelectionInputs = {
+  exiting?: boolean;
+  exitMessageActive?: boolean;
+  messageSelectorOpen?: boolean;
+  sandboxPermissionQueueLength?: number;
+  pendingSandboxRequestActive?: boolean;
+  toolPermissionActive?: boolean;
+  workerPermissionQueueLength?: number;
+  pendingWorkerRequestActive?: boolean;
+  workerSandboxPermissionQueueLength?: number;
+  elicitationQueueLength?: number;
+  costNoticeActive?: boolean;
+  ideOnboardingActive?: boolean;
+};
+
+export function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {
+  if (inputs.exiting || inputs.exitMessageActive) return null;
+  if (inputs.messageSelectorOpen) return "message-selector";
+
+  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;
+  if (hasSandboxPrompt) return "sandbox-permission";
+
+  if (inputs.toolPermissionActive) return "tool-permission";
+
+  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
+  if (hasWorkerPermission) return "worker-permission";
+
+  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
+  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";
+  if (inputs.costNoticeActive) return "cost";
+  if (inputs.ideOnboardingActive) return "ide-onboarding";
+  return null;
+}
+
diff --git a/src/core/state/persistence.ts b/src/core/state/persistence.ts
new file mode 100644
index 0000000000000000000000000000000000000000..504af5f7dce298785ae86601827c122322a0cdd4
--- /dev/null
+++ b/src/core/state/persistence.ts
@@ -0,0 +1,82 @@
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import type { PersistedAppStateV1, StateSnapshotV1 } from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+
+export const STATE_SNAPSHOT_STORAGE_KEY = "state/state_snapshot";
+
+export type StateMigrationNote = {
+  fromVersion: number;
+  toVersion: number;
+  note: string;
+};
+
+export type HydrationRecoveryNote = {
+  kind: "tool_run_cancelled" | "hook_run_cancelled" | "other";
+  sessionId: string;
+  entityId: string;
+  message: string;
+};
+
+export type HydrationResult = {
+  persisted: PersistedAppStateV1;
+  migrations: StateMigrationNote[];
+  recovery: HydrationRecoveryNote[];
+};
+
+export class InvalidStateSnapshotError extends Error {
+  readonly name = "InvalidStateSnapshotError";
+  constructor(message: string) {
+    super(message);
+  }
+}
+
+export function encodeStateSnapshot(snapshot: StateSnapshotV1): string {
+  return canonicalJsonStringify(snapshot);
+}
+
+export function decodeStateSnapshot(text: string): StateSnapshotV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new InvalidStateSnapshotError("Snapshot is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["kind"] !== "state_snapshot") throw new InvalidStateSnapshotError("Snapshot kind mismatch");
+  if (obj["schemaVersion"] !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot version: ${String(obj["schemaVersion"])}`);
+  }
+  if (!("state" in obj)) throw new InvalidStateSnapshotError("Snapshot missing state");
+  return parsed as StateSnapshotV1;
+}
+
+export function migrateStateSnapshot(snapshot: StateSnapshotV1): HydrationResult {
+  const migrations: StateMigrationNote[] = [];
+  const recovery: HydrationRecoveryNote[] = [];
+
+  if (snapshot.schemaVersion !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot schemaVersion: ${snapshot.schemaVersion}`);
+  }
+
+  return { persisted: snapshot.state, migrations, recovery };
+}
+
+export async function loadStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY
+): Promise<StateSnapshotV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeStateSnapshot(found.value);
+}
+
+export async function saveStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  snapshot: StateSnapshotV1,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeStateSnapshot(snapshot);
+  const res = await storage.set(namespace, key, encoded, options);
+  return res;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..809c20a9646f83664161d132ecd72d2df942adbf
--- /dev/null
+++ b/src/core/state/state.ts
@@ -0,0 +1,264 @@
+import type { IdSource } from "../runtime/ids.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import {
+  asAppId,
+  asSessionId,
+  type PersistedAppStateV1,
+  type PersistedSessionStateV1,
+  type SessionId,
+  type SessionLifecycleState,
+  type StateSnapshotV1,
+  type TranscriptLogV1
+} from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { Notification, NotificationEffect, NotificationState } from "./notifications.js";
+import { addNotification, expireCurrentNotification } from "./notifications.js";
+
+export type SandboxHostPattern = { host: string; port?: number };
+
+export type SandboxPermissionRequest = {
+  requestId: string;
+  hostPattern: SandboxHostPattern;
+  createdAtMonoMs: number;
+  origin: "local" | "worker" | "leader";
+};
+
+export type ToolPermissionRequest = {
+  requestId: string;
+  toolName: string;
+  createdAtMonoMs: number;
+  message?: string;
+};
+
+export type ElicitationRequest = {
+  requestId: string;
+  createdAtMonoMs: number;
+  prompt: string;
+  source: "mcp";
+  concurrency: "serial" | "parallel";
+};
+
+export type WorkerPermissionQueueState = {
+  queue: Array<{ requestId: string; createdAtMonoMs: number; message?: string }>;
+  selectedIndex: number;
+};
+
+export type UiState = {
+  notifications: NotificationState;
+  sandboxPermissions: { queue: SandboxPermissionRequest[]; pendingLeaderRequest: { requestId: string; host: string } | null };
+  toolPermission: { active: ToolPermissionRequest | null };
+  workerPermissions: WorkerPermissionQueueState;
+  workerSandboxPermissions: WorkerPermissionQueueState;
+  elicitation: { queue: ElicitationRequest[] };
+  messageSelectorOpen: boolean;
+  costNoticeActive: boolean;
+  ideOnboardingActive: boolean;
+  exiting: boolean;
+  exitMessageActive: boolean;
+};
+
+export type AppState = {
+  persisted: PersistedAppStateV1;
+  ui: UiState;
+};
+
+export type StateEffect = NotificationEffect;
+
+export type StateUiEvent = { type: "ui/state-changed"; actionType: StateAction["type"] };
+
+export type StateAction =
+  | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
+  | { type: "app/session-created"; session: PersistedSessionStateV1 }
+  | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "ui/notification/add"; notification: Notification }
+  | { type: "ui/notification/expired"; key: string }
+  | { type: "ui/message-selector/set-open"; open: boolean }
+  | { type: "ui/exit/set"; exiting: boolean; exitMessageActive?: boolean };
+
+export type StateCommand =
+  | { type: "cmd/create-session"; sessionId?: SessionId; activate?: boolean; nowMonoMs?: number }
+  | { type: "cmd/restore-from-snapshot"; snapshot: StateSnapshotV1 };
+
+export function createEmptyTranscriptLog(nowMonoMs: number): TranscriptLogV1 {
+  return { schemaVersion: 1, events: [], bounded: undefined };
+}
+
+export function createEmptyUiState(): UiState {
+  return {
+    notifications: { current: null, queue: [] },
+    sandboxPermissions: { queue: [], pendingLeaderRequest: null },
+    toolPermission: { active: null },
+    workerPermissions: { queue: [], selectedIndex: 0 },
+    workerSandboxPermissions: { queue: [], selectedIndex: 0 },
+    elicitation: { queue: [] },
+    messageSelectorOpen: false,
+    costNoticeActive: false,
+    ideOnboardingActive: false,
+    exiting: false,
+    exitMessageActive: false
+  };
+}
+
+export function createEmptyPersistedAppState(options: { idSource: IdSource; clock: MonotonicClock }): PersistedAppStateV1 {
+  const now = options.clock.nowMs();
+  return {
+    schemaVersion: 1,
+    appId: asAppId(options.idSource.nextId("app")),
+    createdAtMonoMs: now,
+    updatedAtMonoMs: now,
+    sessions: {}
+  };
+}
+
+export function createAppState(options: { idSource: IdSource; clock: MonotonicClock }): AppState {
+  return { persisted: createEmptyPersistedAppState(options), ui: createEmptyUiState() };
+}
+
+export function createStateSnapshot(persisted: PersistedAppStateV1): StateSnapshotV1 {
+  return { kind: "state_snapshot", schemaVersion: SCHEMA_VERSION.stateSnapshot, state: persisted };
+}
+
+export type CrashRecoveryReport = {
+  cancelledToolRuns: Array<{ sessionId: SessionId; toolRunId: string }>;
+  cancelledHookRuns: Array<{ sessionId: SessionId; hookRunId: string }>;
+};
+
+export function recoverPersistedAppState(
+  persisted: PersistedAppStateV1,
+  nowMonoMs: number
+): { persisted: PersistedAppStateV1; report: CrashRecoveryReport } {
+  const report: CrashRecoveryReport = { cancelledToolRuns: [], cancelledHookRuns: [] };
+  const nextSessions: Record<string, PersistedSessionStateV1> = {};
+
+  const crashCancel: CancellationReason = { kind: "unknown", message: "Recovered from crash (tool/hook run left in-flight)" };
+
+  for (const [sessionKey, session] of Object.entries(persisted.sessions)) {
+    const nextToolRuns: typeof session.toolRuns = {};
+    for (const [id, run] of Object.entries(session.toolRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextToolRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledToolRuns.push({ sessionId: session.id, toolRunId: id });
+      } else {
+        nextToolRuns[id] = run;
+      }
+    }
+
+    const nextHookRuns: typeof session.hookRuns = {};
+    for (const [id, run] of Object.entries(session.hookRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextHookRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledHookRuns.push({ sessionId: session.id, hookRunId: id });
+      } else {
+        nextHookRuns[id] = run;
+      }
+    }
+
+    nextSessions[sessionKey] = {
+      ...session,
+      toolRuns: nextToolRuns,
+      hookRuns: nextHookRuns,
+      updatedAtMonoMs: nowMonoMs
+    };
+  }
+
+  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+}
+
+export function reduceAppState(state: AppState, action: StateAction): { state: AppState; effects: StateEffect[]; events: StateUiEvent[] } {
+  switch (action.type) {
+    case "app/restore-persisted": {
+      const next: AppState = { persisted: action.persisted, ui: createEmptyUiState() };
+      return { state: next, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-created": {
+      const sessions = { ...state.persisted.sessions, [action.session.id]: action.session };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions,
+        activeSessionId: state.persisted.activeSessionId ?? action.session.id,
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.session.updatedAtMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-lifecycle-set": {
+      const session = state.persisted.sessions[action.sessionId];
+      if (!session) return { state, effects: [], events: [] };
+      const nextSession: PersistedSessionStateV1 = {
+        ...session,
+        lifecycle: action.lifecycle,
+        updatedAtMonoMs: action.tsMonoMs,
+        ...(action.lifecycle === "ended" ? { endedAtMonoMs: action.tsMonoMs } : {}),
+        ...(action.lifecycle === "error" ? { error: action.error ?? session.error ?? "Session error" } : {})
+      };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions: { ...state.persisted.sessions, [action.sessionId]: nextSession },
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/add": {
+      const { state: nextNotif, effects } = addNotification(state.ui.notifications, action.notification);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/expired": {
+      const { state: nextNotif, effects } = expireCurrentNotification(state.ui.notifications, action.key);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/message-selector/set-open": {
+      return {
+        state: { ...state, ui: { ...state.ui, messageSelectorOpen: action.open } },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+    case "ui/exit/set": {
+      return {
+        state: {
+          ...state,
+          ui: {
+            ...state.ui,
+            exiting: action.exiting,
+            exitMessageActive: action.exitMessageActive ?? state.ui.exitMessageActive
+          }
+        },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+  }
+}
+
+export function commandToActions(
+  state: AppState,
+  command: StateCommand,
+  deps: { idSource: IdSource; clock: MonotonicClock }
+): StateAction[] {
+  switch (command.type) {
+    case "cmd/create-session": {
+      const sessionId = command.sessionId ?? asSessionId(deps.idSource.nextId("sess"));
+      const now = command.nowMonoMs ?? deps.clock.nowMs();
+      const session: PersistedSessionStateV1 = {
+        schemaVersion: 1,
+        id: sessionId,
+        lifecycle: "created",
+        createdAtMonoMs: now,
+        updatedAtMonoMs: now,
+        transcript: createEmptyTranscriptLog(now),
+        attachments: {},
+        toolRuns: {},
+        hookRuns: {},
+        mcpConnections: {}
+      };
+      const actions: StateAction[] = [{ type: "app/session-created", session }];
+      if (command.activate) actions.push({ type: "app/session-lifecycle-set", sessionId, lifecycle: "active", tsMonoMs: now });
+      return actions;
+    }
+    case "cmd/restore-from-snapshot": {
+      const recovered = recoverPersistedAppState(command.snapshot.state, deps.clock.nowMs());
+      return [{ type: "app/restore-persisted", persisted: recovered.persisted }];
+    }
+  }
+}
+
diff --git a/src/core/state/store.ts b/src/core/state/store.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f85b21e6ff7f0ec5be5a8dd9fd4cec4658e397f2
--- /dev/null
+++ b/src/core/state/store.ts
@@ -0,0 +1,89 @@
+import type { IdSource } from "../runtime/ids.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import { BoundedAsyncQueue } from "../runtime/queue.js";
+import type { StateSnapshotV1 } from "../types/state.js";
+import type { AppState, StateAction, StateCommand, StateEffect, StateUiEvent } from "./state.js";
+import { commandToActions, createAppState, createStateSnapshot, reduceAppState } from "./state.js";
+
+export type StateStoreOptions = {
+  idSource: IdSource;
+  clock: MonotonicClock;
+  eventBufferSize?: number;
+  effectBufferSize?: number;
+};
+
+export type Unsubscribe = () => void;
+
+export type Subscription<T> = AsyncIterable<T> & { unsubscribe: Unsubscribe };
+
+export type StateStore = {
+  getState: () => AppState;
+  dispatch: (action: StateAction) => Promise<void>;
+  dispatchCommand: (command: StateCommand) => Promise<void>;
+  snapshotPersisted: () => StateSnapshotV1;
+  restoreFromSnapshot: (snapshot: StateSnapshotV1) => Promise<void>;
+  subscribeUi: () => Subscription<StateUiEvent>;
+  subscribeEffects: () => Subscription<StateEffect>;
+};
+
+type Subscriber<T> = {
+  id: string;
+  queue: BoundedAsyncQueue<T>;
+};
+
+export function createStateStore(options: StateStoreOptions): StateStore {
+  const deps = { idSource: options.idSource, clock: options.clock };
+  let state = createAppState(deps);
+
+  const uiSubscribers = new Map<string, Subscriber<StateUiEvent>>();
+  const effectSubscribers = new Map<string, Subscriber<StateEffect>>();
+
+  const eventBufferSize = Math.max(0, options.eventBufferSize ?? 256);
+  const effectBufferSize = Math.max(0, options.effectBufferSize ?? 256);
+
+  async function fanOut<T>(subscribers: Map<string, Subscriber<T>>, value: T): Promise<void> {
+    const deliveries: Array<Promise<void>> = [];
+    for (const sub of subscribers.values()) deliveries.push(sub.queue.push(value));
+    await Promise.all(deliveries);
+  }
+
+  async function applyAction(action: StateAction): Promise<void> {
+    const reduced = reduceAppState(state, action);
+    state = reduced.state;
+    for (const evt of reduced.events) await fanOut(uiSubscribers, evt);
+    for (const eff of reduced.effects) await fanOut(effectSubscribers, eff);
+  }
+
+  function subscribe<T>(subscribers: Map<string, Subscriber<T>>, maxSize: number): Subscription<T> {
+    const id = options.idSource.nextId("store_sub");
+    const queue = new BoundedAsyncQueue<T>({ maxSize, dropPolicy: "drop_oldest" });
+    subscribers.set(id, { id, queue });
+    const iterator = (async function* (): AsyncGenerator<T> {
+      for await (const item of queue) yield item;
+    })();
+    return Object.assign(iterator, {
+      unsubscribe: () => {
+        subscribers.delete(id);
+        queue.close({ kind: "closed", message: "unsubscribed" });
+      }
+    });
+  }
+
+  return {
+    getState: () => state,
+    dispatch: async (action) => {
+      await applyAction(action);
+    },
+    dispatchCommand: async (command) => {
+      const actions = commandToActions(state, command, deps);
+      for (const action of actions) await applyAction(action);
+    },
+    snapshotPersisted: () => createStateSnapshot(state.persisted),
+    restoreFromSnapshot: async (snapshot) => {
+      await applyAction({ type: "app/restore-persisted", persisted: snapshot.state });
+    },
+    subscribeUi: () => subscribe(uiSubscribers, eventBufferSize),
+    subscribeEffects: () => subscribe(effectSubscribers, effectBufferSize)
+  };
+}
+
diff --git a/src/core/state/transcript.ts b/src/core/state/transcript.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f9b512d495cf977b0b62fbbe91b1247887087dab
--- /dev/null
+++ b/src/core/state/transcript.ts
@@ -0,0 +1,63 @@
+import type { HostCrypto } from "../types/host.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import { REDACTED, type Sensitive, type TranscriptEventV1, type TranscriptLogV1 } from "../types/state.js";
+
+export type RedactionStats = {
+  redactedNodes: number;
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  if (value === null || typeof value !== "object") return false;
+  const proto = Object.getPrototypeOf(value);
+  return proto === Object.prototype || proto === null;
+}
+
+function isSensitive(value: unknown): value is Sensitive<unknown> {
+  return isPlainObject(value) && value["kind"] === "sensitive" && "value" in value;
+}
+
+function redactValue(value: unknown, stats: RedactionStats): unknown {
+  if (isSensitive(value)) {
+    stats.redactedNodes += 1;
+    return REDACTED;
+  }
+  if (value === null) return null;
+  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") return value;
+  if (Array.isArray(value)) return value.map((v) => redactValue(v, stats));
+  if (isPlainObject(value)) {
+    const out: Record<string, unknown> = {};
+    for (const [k, v] of Object.entries(value)) out[k] = redactValue(v, stats);
+    return out;
+  }
+  return value;
+}
+
+export function redactTranscriptEvent(event: TranscriptEventV1): { event: TranscriptEventV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const redacted = redactValue(event, stats) as TranscriptEventV1;
+  return { event: redacted, stats };
+}
+
+export function redactTranscriptLog(log: TranscriptLogV1): { log: TranscriptLogV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const events = log.events.map((evt) => redactValue(evt, stats) as TranscriptEventV1);
+  return { log: { ...log, events }, stats };
+}
+
+function bytesToHex(bytes: Uint8Array): string {
+  let out = "";
+  for (const b of bytes) out += b.toString(16).padStart(2, "0");
+  return out;
+}
+
+export async function computeTranscriptSummary(
+  log: TranscriptLogV1,
+  crypto: HostCrypto
+): Promise<{ eventCount: number; sha256Hex: string; redactedNodes: number }> {
+  const { log: redacted, stats } = redactTranscriptLog(log);
+  const json = canonicalJsonStringify(redacted, { pretty: false });
+  const data = new TextEncoder().encode(json);
+  const digest = await crypto.digest("SHA-256", data);
+  return { eventCount: redacted.events.length, sha256Hex: bytesToHex(digest), redactedNodes: stats.redactedNodes };
+}
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+


[35m[3mthinking[0m[0m
**Considering app state recovery**

I‚Äôm thinking about using `recoverPersistedAppState` to convert the report into notes, and I‚Äôll implement a schema migration hook. If there's a version mismatch, I‚Äôll throw an error. Safety is key, so I‚Äôll ensure a safe startup, especially if the snapshot is partial. I‚Äôm leaning toward validating that `snapshot.state.schemaVersion==1` to keep things in check. This feels like a good approach, so I‚Äôll proceed with minimal adjustments. Let‚Äôs patch this up!
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
index a24169e79aeb5bebb6227585b7de8694bb92222c..e1d816f843b43f78ace8124cc241e1c196362b50
--- a/src/core/state/index.ts
+++ b/src/core/state/index.ts
@@ -1,4 +1,7 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
+export * from "./overlays.js";
+export * from "./notifications.js";
+export * from "./transcript.js";
+export * from "./persistence.js";
+export * from "./state.js";
+export * from "./store.js";
 
diff --git a/src/core/state/notifications.ts b/src/core/state/notifications.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f8dde458abe0ab190a09282b2445f708c11d9bc
--- /dev/null
+++ b/src/core/state/notifications.ts
@@ -0,0 +1,110 @@
+export type NotificationPriority = "immediate" | "high" | "medium" | "low";
+
+export type Notification = {
+  key: string;
+  text: string;
+  priority: NotificationPriority;
+  color?: string;
+  timeoutMs?: number;
+  invalidates?: string[];
+};
+
+export type NotificationState = {
+  current: Notification | null;
+  queue: Notification[];
+};
+
+export const DEFAULT_NOTIFICATION_TIMEOUT_MS = 8000;
+
+export type NotificationEffect =
+  | { type: "effect/notification-cancel-timeout" }
+  | { type: "effect/notification-schedule-timeout"; key: string; timeoutMs: number };
+
+const priorityOrder: Record<NotificationPriority, number> = {
+  immediate: 0,
+  high: 1,
+  medium: 2,
+  low: 3
+};
+
+function sortByPriority(queue: Notification[]): Notification[] {
+  return queue
+    .slice()
+    .sort((a, b) => (priorityOrder[a.priority] < priorityOrder[b.priority] ? -1 : priorityOrder[a.priority] > priorityOrder[b.priority] ? 1 : 0));
+}
+
+function removeInvalidated(queue: Notification[], invalidates: readonly string[] | undefined): Notification[] {
+  if (!invalidates || invalidates.length === 0) return queue;
+  const invalidated = new Set(invalidates);
+  return queue.filter((n) => !invalidated.has(n.key));
+}
+
+function dedupeByKey(queue: Notification[], key: string): Notification[] {
+  return queue.filter((n) => n.key !== key);
+}
+
+export function drainNotifications(state: NotificationState): { state: NotificationState; effects: NotificationEffect[] } {
+  if (state.current) return { state, effects: [] };
+  if (state.queue.length === 0) return { state, effects: [] };
+
+  const sorted = sortByPriority(state.queue);
+  const next = sorted[0];
+  const remaining = sorted.slice(1);
+  const timeoutMs = next.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+  return {
+    state: { current: next, queue: remaining },
+    effects: [{ type: "effect/notification-schedule-timeout", key: next.key, timeoutMs }]
+  };
+}
+
+export function addNotification(state: NotificationState, notification: Notification): { state: NotificationState; effects: NotificationEffect[] } {
+  const invalidates = notification.invalidates ?? [];
+
+  if (notification.priority === "immediate") {
+    const prevCurrent = state.current;
+    const merged = [...(prevCurrent ? [prevCurrent] : []), ...state.queue];
+    const filtered = removeInvalidated(
+      merged.filter((n) => n.priority !== "immediate"),
+      invalidates
+    );
+
+    const nextState: NotificationState = {
+      current: notification,
+      queue: dedupeByKey(filtered, notification.key)
+    };
+
+    const timeoutMs = notification.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+    return {
+      state: nextState,
+      effects: [
+        { type: "effect/notification-cancel-timeout" },
+        { type: "effect/notification-schedule-timeout", key: notification.key, timeoutMs }
+      ]
+    };
+  }
+
+  const currentKey = state.current?.key ?? null;
+  const alreadyQueued = state.queue.some((n) => n.key === notification.key);
+  if (currentKey === notification.key || alreadyQueued) {
+    const pruned = removeInvalidated(state.queue, invalidates);
+    const drained = drainNotifications({ current: state.current, queue: pruned });
+    return drained;
+  }
+
+  const pruned = removeInvalidated(state.queue, invalidates);
+  const next = { current: state.current, queue: [...pruned, notification] };
+  return drainNotifications(next);
+}
+
+export function expireCurrentNotification(
+  state: NotificationState,
+  key: string
+): { state: NotificationState; effects: NotificationEffect[] } {
+  if (!state.current || state.current.key !== key) return { state, effects: [] };
+
+  const invalidates = state.current.invalidates ?? [];
+  const pruned = removeInvalidated(state.queue.filter((n) => n.priority !== "immediate"), invalidates);
+  const cleared: NotificationState = { current: null, queue: pruned };
+  return drainNotifications(cleared);
+}
+
diff --git a/src/core/state/overlays.ts b/src/core/state/overlays.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a352707c5371f79c9647ad52dbc67193bd99cc40
--- /dev/null
+++ b/src/core/state/overlays.ts
@@ -0,0 +1,55 @@
+export type OverlayKind =
+  | "message-selector"
+  | "sandbox-permission"
+  | "tool-permission"
+  | "worker-permission"
+  | "worker-sandbox-permission"
+  | "elicitation"
+  | "cost"
+  | "ide-onboarding";
+
+export const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [
+  "message-selector",
+  "sandbox-permission",
+  "tool-permission",
+  "worker-permission",
+  "worker-sandbox-permission",
+  "elicitation",
+  "cost",
+  "ide-onboarding"
+] as const;
+
+export type OverlaySelectionInputs = {
+  exiting?: boolean;
+  exitMessageActive?: boolean;
+  messageSelectorOpen?: boolean;
+  sandboxPermissionQueueLength?: number;
+  pendingSandboxRequestActive?: boolean;
+  toolPermissionActive?: boolean;
+  workerPermissionQueueLength?: number;
+  pendingWorkerRequestActive?: boolean;
+  workerSandboxPermissionQueueLength?: number;
+  elicitationQueueLength?: number;
+  costNoticeActive?: boolean;
+  ideOnboardingActive?: boolean;
+};
+
+export function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {
+  if (inputs.exiting || inputs.exitMessageActive) return null;
+  if (inputs.messageSelectorOpen) return "message-selector";
+
+  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;
+  if (hasSandboxPrompt) return "sandbox-permission";
+
+  if (inputs.toolPermissionActive) return "tool-permission";
+
+  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
+  if (hasWorkerPermission) return "worker-permission";
+
+  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
+  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";
+  if (inputs.costNoticeActive) return "cost";
+  if (inputs.ideOnboardingActive) return "ide-onboarding";
+  return null;
+}
+
diff --git a/src/core/state/persistence.ts b/src/core/state/persistence.ts
new file mode 100644
index 0000000000000000000000000000000000000000..504af5f7dce298785ae86601827c122322a0cdd4
--- /dev/null
+++ b/src/core/state/persistence.ts
@@ -0,0 +1,82 @@
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import type { PersistedAppStateV1, StateSnapshotV1 } from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+
+export const STATE_SNAPSHOT_STORAGE_KEY = "state/state_snapshot";
+
+export type StateMigrationNote = {
+  fromVersion: number;
+  toVersion: number;
+  note: string;
+};
+
+export type HydrationRecoveryNote = {
+  kind: "tool_run_cancelled" | "hook_run_cancelled" | "other";
+  sessionId: string;
+  entityId: string;
+  message: string;
+};
+
+export type HydrationResult = {
+  persisted: PersistedAppStateV1;
+  migrations: StateMigrationNote[];
+  recovery: HydrationRecoveryNote[];
+};
+
+export class InvalidStateSnapshotError extends Error {
+  readonly name = "InvalidStateSnapshotError";
+  constructor(message: string) {
+    super(message);
+  }
+}
+
+export function encodeStateSnapshot(snapshot: StateSnapshotV1): string {
+  return canonicalJsonStringify(snapshot);
+}
+
+export function decodeStateSnapshot(text: string): StateSnapshotV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new InvalidStateSnapshotError("Snapshot is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["kind"] !== "state_snapshot") throw new InvalidStateSnapshotError("Snapshot kind mismatch");
+  if (obj["schemaVersion"] !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot version: ${String(obj["schemaVersion"])}`);
+  }
+  if (!("state" in obj)) throw new InvalidStateSnapshotError("Snapshot missing state");
+  return parsed as StateSnapshotV1;
+}
+
+export function migrateStateSnapshot(snapshot: StateSnapshotV1): HydrationResult {
+  const migrations: StateMigrationNote[] = [];
+  const recovery: HydrationRecoveryNote[] = [];
+
+  if (snapshot.schemaVersion !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot schemaVersion: ${snapshot.schemaVersion}`);
+  }
+
+  return { persisted: snapshot.state, migrations, recovery };
+}
+
+export async function loadStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY
+): Promise<StateSnapshotV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeStateSnapshot(found.value);
+}
+
+export async function saveStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  snapshot: StateSnapshotV1,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeStateSnapshot(snapshot);
+  const res = await storage.set(namespace, key, encoded, options);
+  return res;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..809c20a9646f83664161d132ecd72d2df942adbf
--- /dev/null
+++ b/src/core/state/state.ts
@@ -0,0 +1,264 @@
+import type { IdSource } from "../runtime/ids.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import {
+  asAppId,
+  asSessionId,
+  type PersistedAppStateV1,
+  type PersistedSessionStateV1,
+  type SessionId,
+  type SessionLifecycleState,
+  type StateSnapshotV1,
+  type TranscriptLogV1
+} from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { Notification, NotificationEffect, NotificationState } from "./notifications.js";
+import { addNotification, expireCurrentNotification } from "./notifications.js";
+
+export type SandboxHostPattern = { host: string; port?: number };
+
+export type SandboxPermissionRequest = {
+  requestId: string;
+  hostPattern: SandboxHostPattern;
+  createdAtMonoMs: number;
+  origin: "local" | "worker" | "leader";
+};
+
+export type ToolPermissionRequest = {
+  requestId: string;
+  toolName: string;
+  createdAtMonoMs: number;
+  message?: string;
+};
+
+export type ElicitationRequest = {
+  requestId: string;
+  createdAtMonoMs: number;
+  prompt: string;
+  source: "mcp";
+  concurrency: "serial" | "parallel";
+};
+
+export type WorkerPermissionQueueState = {
+  queue: Array<{ requestId: string; createdAtMonoMs: number; message?: string }>;
+  selectedIndex: number;
+};
+
+export type UiState = {
+  notifications: NotificationState;
+  sandboxPermissions: { queue: SandboxPermissionRequest[]; pendingLeaderRequest: { requestId: string; host: string } | null };
+  toolPermission: { active: ToolPermissionRequest | null };
+  workerPermissions: WorkerPermissionQueueState;
+  workerSandboxPermissions: WorkerPermissionQueueState;
+  elicitation: { queue: ElicitationRequest[] };
+  messageSelectorOpen: boolean;
+  costNoticeActive: boolean;
+  ideOnboardingActive: boolean;
+  exiting: boolean;
+  exitMessageActive: boolean;
+};
+
+export type AppState = {
+  persisted: PersistedAppStateV1;
+  ui: UiState;
+};
+
+export type StateEffect = NotificationEffect;
+
+export type StateUiEvent = { type: "ui/state-changed"; actionType: StateAction["type"] };
+
+export type StateAction =
+  | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
+  | { type: "app/session-created"; session: PersistedSessionStateV1 }
+  | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "ui/notification/add"; notification: Notification }
+  | { type: "ui/notification/expired"; key: string }
+  | { type: "ui/message-selector/set-open"; open: boolean }
+  | { type: "ui/exit/set"; exiting: boolean; exitMessageActive?: boolean };
+
+export type StateCommand =
+  | { type: "cmd/create-session"; sessionId?: SessionId; activate?: boolean; nowMonoMs?: number }
+  | { type: "cmd/restore-from-snapshot"; snapshot: StateSnapshotV1 };
+
+export function createEmptyTranscriptLog(nowMonoMs: number): TranscriptLogV1 {
+  return { schemaVersion: 1, events: [], bounded: undefined };
+}
+
+export function createEmptyUiState(): UiState {
+  return {
+    notifications: { current: null, queue: [] },
+    sandboxPermissions: { queue: [], pendingLeaderRequest: null },
+    toolPermission: { active: null },
+    workerPermissions: { queue: [], selectedIndex: 0 },
+    workerSandboxPermissions: { queue: [], selectedIndex: 0 },
+    elicitation: { queue: [] },
+    messageSelectorOpen: false,
+    costNoticeActive: false,
+    ideOnboardingActive: false,
+    exiting: false,
+    exitMessageActive: false
+  };
+}
+
+export function createEmptyPersistedAppState(options: { idSource: IdSource; clock: MonotonicClock }): PersistedAppStateV1 {
+  const now = options.clock.nowMs();
+  return {
+    schemaVersion: 1,
+    appId: asAppId(options.idSource.nextId("app")),
+    createdAtMonoMs: now,
+    updatedAtMonoMs: now,
+    sessions: {}
+  };
+}
+
+export function createAppState(options: { idSource: IdSource; clock: MonotonicClock }): AppState {
+  return { persisted: createEmptyPersistedAppState(options), ui: createEmptyUiState() };
+}
+
+export function createStateSnapshot(persisted: PersistedAppStateV1): StateSnapshotV1 {
+  return { kind: "state_snapshot", schemaVersion: SCHEMA_VERSION.stateSnapshot, state: persisted };
+}
+
+export type CrashRecoveryReport = {
+  cancelledToolRuns: Array<{ sessionId: SessionId; toolRunId: string }>;
+  cancelledHookRuns: Array<{ sessionId: SessionId; hookRunId: string }>;
+};
+
+export function recoverPersistedAppState(
+  persisted: PersistedAppStateV1,
+  nowMonoMs: number
+): { persisted: PersistedAppStateV1; report: CrashRecoveryReport } {
+  const report: CrashRecoveryReport = { cancelledToolRuns: [], cancelledHookRuns: [] };
+  const nextSessions: Record<string, PersistedSessionStateV1> = {};
+
+  const crashCancel: CancellationReason = { kind: "unknown", message: "Recovered from crash (tool/hook run left in-flight)" };
+
+  for (const [sessionKey, session] of Object.entries(persisted.sessions)) {
+    const nextToolRuns: typeof session.toolRuns = {};
+    for (const [id, run] of Object.entries(session.toolRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextToolRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledToolRuns.push({ sessionId: session.id, toolRunId: id });
+      } else {
+        nextToolRuns[id] = run;
+      }
+    }
+
+    const nextHookRuns: typeof session.hookRuns = {};
+    for (const [id, run] of Object.entries(session.hookRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextHookRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledHookRuns.push({ sessionId: session.id, hookRunId: id });
+      } else {
+        nextHookRuns[id] = run;
+      }
+    }
+
+    nextSessions[sessionKey] = {
+      ...session,
+      toolRuns: nextToolRuns,
+      hookRuns: nextHookRuns,
+      updatedAtMonoMs: nowMonoMs
+    };
+  }
+
+  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+}
+
+export function reduceAppState(state: AppState, action: StateAction): { state: AppState; effects: StateEffect[]; events: StateUiEvent[] } {
+  switch (action.type) {
+    case "app/restore-persisted": {
+      const next: AppState = { persisted: action.persisted, ui: createEmptyUiState() };
+      return { state: next, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-created": {
+      const sessions = { ...state.persisted.sessions, [action.session.id]: action.session };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions,
+        activeSessionId: state.persisted.activeSessionId ?? action.session.id,
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.session.updatedAtMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-lifecycle-set": {
+      const session = state.persisted.sessions[action.sessionId];
+      if (!session) return { state, effects: [], events: [] };
+      const nextSession: PersistedSessionStateV1 = {
+        ...session,
+        lifecycle: action.lifecycle,
+        updatedAtMonoMs: action.tsMonoMs,
+        ...(action.lifecycle === "ended" ? { endedAtMonoMs: action.tsMonoMs } : {}),
+        ...(action.lifecycle === "error" ? { error: action.error ?? session.error ?? "Session error" } : {})
+      };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions: { ...state.persisted.sessions, [action.sessionId]: nextSession },
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/add": {
+      const { state: nextNotif, effects } = addNotification(state.ui.notifications, action.notification);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/expired": {
+      const { state: nextNotif, effects } = expireCurrentNotification(state.ui.notifications, action.key);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/message-selector/set-open": {
+      return {
+        state: { ...state, ui: { ...state.ui, messageSelectorOpen: action.open } },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+    case "ui/exit/set": {
+      return {
+        state: {
+          ...state,
+          ui: {
+            ...state.ui,
+            exiting: action.exiting,
+            exitMessageActive: action.exitMessageActive ?? state.ui.exitMessageActive
+          }
+        },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+  }
+}
+
+export function commandToActions(
+  state: AppState,
+  command: StateCommand,
+  deps: { idSource: IdSource; clock: MonotonicClock }
+): StateAction[] {
+  switch (command.type) {
+    case "cmd/create-session": {
+      const sessionId = command.sessionId ?? asSessionId(deps.idSource.nextId("sess"));
+      const now = command.nowMonoMs ?? deps.clock.nowMs();
+      const session: PersistedSessionStateV1 = {
+        schemaVersion: 1,
+        id: sessionId,
+        lifecycle: "created",
+        createdAtMonoMs: now,
+        updatedAtMonoMs: now,
+        transcript: createEmptyTranscriptLog(now),
+        attachments: {},
+        toolRuns: {},
+        hookRuns: {},
+        mcpConnections: {}
+      };
+      const actions: StateAction[] = [{ type: "app/session-created", session }];
+      if (command.activate) actions.push({ type: "app/session-lifecycle-set", sessionId, lifecycle: "active", tsMonoMs: now });
+      return actions;
+    }
+    case "cmd/restore-from-snapshot": {
+      const recovered = recoverPersistedAppState(command.snapshot.state, deps.clock.nowMs());
+      return [{ type: "app/restore-persisted", persisted: recovered.persisted }];
+    }
+  }
+}
+
diff --git a/src/core/state/store.ts b/src/core/state/store.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f85b21e6ff7f0ec5be5a8dd9fd4cec4658e397f2
--- /dev/null
+++ b/src/core/state/store.ts
@@ -0,0 +1,89 @@
+import type { IdSource } from "../runtime/ids.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import { BoundedAsyncQueue } from "../runtime/queue.js";
+import type { StateSnapshotV1 } from "../types/state.js";
+import type { AppState, StateAction, StateCommand, StateEffect, StateUiEvent } from "./state.js";
+import { commandToActions, createAppState, createStateSnapshot, reduceAppState } from "./state.js";
+
+export type StateStoreOptions = {
+  idSource: IdSource;
+  clock: MonotonicClock;
+  eventBufferSize?: number;
+  effectBufferSize?: number;
+};
+
+export type Unsubscribe = () => void;
+
+export type Subscription<T> = AsyncIterable<T> & { unsubscribe: Unsubscribe };
+
+export type StateStore = {
+  getState: () => AppState;
+  dispatch: (action: StateAction) => Promise<void>;
+  dispatchCommand: (command: StateCommand) => Promise<void>;
+  snapshotPersisted: () => StateSnapshotV1;
+  restoreFromSnapshot: (snapshot: StateSnapshotV1) => Promise<void>;
+  subscribeUi: () => Subscription<StateUiEvent>;
+  subscribeEffects: () => Subscription<StateEffect>;
+};
+
+type Subscriber<T> = {
+  id: string;
+  queue: BoundedAsyncQueue<T>;
+};
+
+export function createStateStore(options: StateStoreOptions): StateStore {
+  const deps = { idSource: options.idSource, clock: options.clock };
+  let state = createAppState(deps);
+
+  const uiSubscribers = new Map<string, Subscriber<StateUiEvent>>();
+  const effectSubscribers = new Map<string, Subscriber<StateEffect>>();
+
+  const eventBufferSize = Math.max(0, options.eventBufferSize ?? 256);
+  const effectBufferSize = Math.max(0, options.effectBufferSize ?? 256);
+
+  async function fanOut<T>(subscribers: Map<string, Subscriber<T>>, value: T): Promise<void> {
+    const deliveries: Array<Promise<void>> = [];
+    for (const sub of subscribers.values()) deliveries.push(sub.queue.push(value));
+    await Promise.all(deliveries);
+  }
+
+  async function applyAction(action: StateAction): Promise<void> {
+    const reduced = reduceAppState(state, action);
+    state = reduced.state;
+    for (const evt of reduced.events) await fanOut(uiSubscribers, evt);
+    for (const eff of reduced.effects) await fanOut(effectSubscribers, eff);
+  }
+
+  function subscribe<T>(subscribers: Map<string, Subscriber<T>>, maxSize: number): Subscription<T> {
+    const id = options.idSource.nextId("store_sub");
+    const queue = new BoundedAsyncQueue<T>({ maxSize, dropPolicy: "drop_oldest" });
+    subscribers.set(id, { id, queue });
+    const iterator = (async function* (): AsyncGenerator<T> {
+      for await (const item of queue) yield item;
+    })();
+    return Object.assign(iterator, {
+      unsubscribe: () => {
+        subscribers.delete(id);
+        queue.close({ kind: "closed", message: "unsubscribed" });
+      }
+    });
+  }
+
+  return {
+    getState: () => state,
+    dispatch: async (action) => {
+      await applyAction(action);
+    },
+    dispatchCommand: async (command) => {
+      const actions = commandToActions(state, command, deps);
+      for (const action of actions) await applyAction(action);
+    },
+    snapshotPersisted: () => createStateSnapshot(state.persisted),
+    restoreFromSnapshot: async (snapshot) => {
+      await applyAction({ type: "app/restore-persisted", persisted: snapshot.state });
+    },
+    subscribeUi: () => subscribe(uiSubscribers, eventBufferSize),
+    subscribeEffects: () => subscribe(effectSubscribers, effectBufferSize)
+  };
+}
+
diff --git a/src/core/state/transcript.ts b/src/core/state/transcript.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f9b512d495cf977b0b62fbbe91b1247887087dab
--- /dev/null
+++ b/src/core/state/transcript.ts
@@ -0,0 +1,63 @@
+import type { HostCrypto } from "../types/host.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import { REDACTED, type Sensitive, type TranscriptEventV1, type TranscriptLogV1 } from "../types/state.js";
+
+export type RedactionStats = {
+  redactedNodes: number;
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  if (value === null || typeof value !== "object") return false;
+  const proto = Object.getPrototypeOf(value);
+  return proto === Object.prototype || proto === null;
+}
+
+function isSensitive(value: unknown): value is Sensitive<unknown> {
+  return isPlainObject(value) && value["kind"] === "sensitive" && "value" in value;
+}
+
+function redactValue(value: unknown, stats: RedactionStats): unknown {
+  if (isSensitive(value)) {
+    stats.redactedNodes += 1;
+    return REDACTED;
+  }
+  if (value === null) return null;
+  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") return value;
+  if (Array.isArray(value)) return value.map((v) => redactValue(v, stats));
+  if (isPlainObject(value)) {
+    const out: Record<string, unknown> = {};
+    for (const [k, v] of Object.entries(value)) out[k] = redactValue(v, stats);
+    return out;
+  }
+  return value;
+}
+
+export function redactTranscriptEvent(event: TranscriptEventV1): { event: TranscriptEventV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const redacted = redactValue(event, stats) as TranscriptEventV1;
+  return { event: redacted, stats };
+}
+
+export function redactTranscriptLog(log: TranscriptLogV1): { log: TranscriptLogV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const events = log.events.map((evt) => redactValue(evt, stats) as TranscriptEventV1);
+  return { log: { ...log, events }, stats };
+}
+
+function bytesToHex(bytes: Uint8Array): string {
+  let out = "";
+  for (const b of bytes) out += b.toString(16).padStart(2, "0");
+  return out;
+}
+
+export async function computeTranscriptSummary(
+  log: TranscriptLogV1,
+  crypto: HostCrypto
+): Promise<{ eventCount: number; sha256Hex: string; redactedNodes: number }> {
+  const { log: redacted, stats } = redactTranscriptLog(log);
+  const json = canonicalJsonStringify(redacted, { pretty: false });
+  const data = new TextEncoder().encode(json);
+  const digest = await crypto.digest("SHA-256", data);
+  return { eventCount: redacted.events.length, sha256Hex: bytesToHex(digest), redactedNodes: stats.redactedNodes };
+}
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/state/persistence.ts[0m
@@ -4,2 +4,3 @@
 import { canonicalJsonStringify } from "../types/canonicalJson.js";
[32m+import { recoverPersistedAppState } from "./state.js";[0m
 
@@ -49,3 +50,3 @@
 
[31m-export function migrateStateSnapshot(snapshot: StateSnapshotV1): HydrationResult {[0m
[32m+export function migrateStateSnapshot(snapshot: StateSnapshotV1, nowMonoMs: number = Date.now()): HydrationResult {[0m
   const migrations: StateMigrationNote[] = [];
@@ -57,3 +58,25 @@
 
[31m-  return { persisted: snapshot.state, migrations, recovery };[0m
[32m+  if (snapshot.state.schemaVersion !== 1) {[0m
[32m+    throw new InvalidStateSnapshotError(`Unsupported persisted app state version: ${snapshot.state.schemaVersion}`);[0m
[32m+  }[0m
[32m+[0m
[32m+  const recovered = recoverPersistedAppState(snapshot.state, nowMonoMs);[0m
[32m+  for (const { sessionId, toolRunId } of recovered.report.cancelledToolRuns) {[0m
[32m+    recovery.push({[0m
[32m+      kind: "tool_run_cancelled",[0m
[32m+      sessionId,[0m
[32m+      entityId: toolRunId,[0m
[32m+      message: "Cancelled in-flight tool run during crash recovery"[0m
[32m+    });[0m
[32m+  }[0m
[32m+  for (const { sessionId, hookRunId } of recovered.report.cancelledHookRuns) {[0m
[32m+    recovery.push({[0m
[32m+      kind: "hook_run_cancelled",[0m
[32m+      sessionId,[0m
[32m+      entityId: hookRunId,[0m
[32m+      message: "Cancelled in-flight hook run during crash recovery"[0m
[32m+    });[0m
[32m+  }[0m
[32m+[0m
[32m+  return { persisted: recovered.persisted, migrations, recovery };[0m
 }
@@ -81,2 +104 @@
 }
[31m-[0m
[32mapply_patch(auto_approved=true) exited 0 in 65ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/state/persistence.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
index a24169e79aeb5bebb6227585b7de8694bb92222c..e1d816f843b43f78ace8124cc241e1c196362b50
--- a/src/core/state/index.ts
+++ b/src/core/state/index.ts
@@ -1,4 +1,7 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
+export * from "./overlays.js";
+export * from "./notifications.js";
+export * from "./transcript.js";
+export * from "./persistence.js";
+export * from "./state.js";
+export * from "./store.js";
 
diff --git a/src/core/state/notifications.ts b/src/core/state/notifications.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f8dde458abe0ab190a09282b2445f708c11d9bc
--- /dev/null
+++ b/src/core/state/notifications.ts
@@ -0,0 +1,110 @@
+export type NotificationPriority = "immediate" | "high" | "medium" | "low";
+
+export type Notification = {
+  key: string;
+  text: string;
+  priority: NotificationPriority;
+  color?: string;
+  timeoutMs?: number;
+  invalidates?: string[];
+};
+
+export type NotificationState = {
+  current: Notification | null;
+  queue: Notification[];
+};
+
+export const DEFAULT_NOTIFICATION_TIMEOUT_MS = 8000;
+
+export type NotificationEffect =
+  | { type: "effect/notification-cancel-timeout" }
+  | { type: "effect/notification-schedule-timeout"; key: string; timeoutMs: number };
+
+const priorityOrder: Record<NotificationPriority, number> = {
+  immediate: 0,
+  high: 1,
+  medium: 2,
+  low: 3
+};
+
+function sortByPriority(queue: Notification[]): Notification[] {
+  return queue
+    .slice()
+    .sort((a, b) => (priorityOrder[a.priority] < priorityOrder[b.priority] ? -1 : priorityOrder[a.priority] > priorityOrder[b.priority] ? 1 : 0));
+}
+
+function removeInvalidated(queue: Notification[], invalidates: readonly string[] | undefined): Notification[] {
+  if (!invalidates || invalidates.length === 0) return queue;
+  const invalidated = new Set(invalidates);
+  return queue.filter((n) => !invalidated.has(n.key));
+}
+
+function dedupeByKey(queue: Notification[], key: string): Notification[] {
+  return queue.filter((n) => n.key !== key);
+}
+
+export function drainNotifications(state: NotificationState): { state: NotificationState; effects: NotificationEffect[] } {
+  if (state.current) return { state, effects: [] };
+  if (state.queue.length === 0) return { state, effects: [] };
+
+  const sorted = sortByPriority(state.queue);
+  const next = sorted[0];
+  const remaining = sorted.slice(1);
+  const timeoutMs = next.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+  return {
+    state: { current: next, queue: remaining },
+    effects: [{ type: "effect/notification-schedule-timeout", key: next.key, timeoutMs }]
+  };
+}
+
+export function addNotification(state: NotificationState, notification: Notification): { state: NotificationState; effects: NotificationEffect[] } {
+  const invalidates = notification.invalidates ?? [];
+
+  if (notification.priority === "immediate") {
+    const prevCurrent = state.current;
+    const merged = [...(prevCurrent ? [prevCurrent] : []), ...state.queue];
+    const filtered = removeInvalidated(
+      merged.filter((n) => n.priority !== "immediate"),
+      invalidates
+    );
+
+    const nextState: NotificationState = {
+      current: notification,
+      queue: dedupeByKey(filtered, notification.key)
+    };
+
+    const timeoutMs = notification.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+    return {
+      state: nextState,
+      effects: [
+        { type: "effect/notification-cancel-timeout" },
+        { type: "effect/notification-schedule-timeout", key: notification.key, timeoutMs }
+      ]
+    };
+  }
+
+  const currentKey = state.current?.key ?? null;
+  const alreadyQueued = state.queue.some((n) => n.key === notification.key);
+  if (currentKey === notification.key || alreadyQueued) {
+    const pruned = removeInvalidated(state.queue, invalidates);
+    const drained = drainNotifications({ current: state.current, queue: pruned });
+    return drained;
+  }
+
+  const pruned = removeInvalidated(state.queue, invalidates);
+  const next = { current: state.current, queue: [...pruned, notification] };
+  return drainNotifications(next);
+}
+
+export function expireCurrentNotification(
+  state: NotificationState,
+  key: string
+): { state: NotificationState; effects: NotificationEffect[] } {
+  if (!state.current || state.current.key !== key) return { state, effects: [] };
+
+  const invalidates = state.current.invalidates ?? [];
+  const pruned = removeInvalidated(state.queue.filter((n) => n.priority !== "immediate"), invalidates);
+  const cleared: NotificationState = { current: null, queue: pruned };
+  return drainNotifications(cleared);
+}
+
diff --git a/src/core/state/overlays.ts b/src/core/state/overlays.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a352707c5371f79c9647ad52dbc67193bd99cc40
--- /dev/null
+++ b/src/core/state/overlays.ts
@@ -0,0 +1,55 @@
+export type OverlayKind =
+  | "message-selector"
+  | "sandbox-permission"
+  | "tool-permission"
+  | "worker-permission"
+  | "worker-sandbox-permission"
+  | "elicitation"
+  | "cost"
+  | "ide-onboarding";
+
+export const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [
+  "message-selector",
+  "sandbox-permission",
+  "tool-permission",
+  "worker-permission",
+  "worker-sandbox-permission",
+  "elicitation",
+  "cost",
+  "ide-onboarding"
+] as const;
+
+export type OverlaySelectionInputs = {
+  exiting?: boolean;
+  exitMessageActive?: boolean;
+  messageSelectorOpen?: boolean;
+  sandboxPermissionQueueLength?: number;
+  pendingSandboxRequestActive?: boolean;
+  toolPermissionActive?: boolean;
+  workerPermissionQueueLength?: number;
+  pendingWorkerRequestActive?: boolean;
+  workerSandboxPermissionQueueLength?: number;
+  elicitationQueueLength?: number;
+  costNoticeActive?: boolean;
+  ideOnboardingActive?: boolean;
+};
+
+export function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {
+  if (inputs.exiting || inputs.exitMessageActive) return null;
+  if (inputs.messageSelectorOpen) return "message-selector";
+
+  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;
+  if (hasSandboxPrompt) return "sandbox-permission";
+
+  if (inputs.toolPermissionActive) return "tool-permission";
+
+  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
+  if (hasWorkerPermission) return "worker-permission";
+
+  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
+  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";
+  if (inputs.costNoticeActive) return "cost";
+  if (inputs.ideOnboardingActive) return "ide-onboarding";
+  return null;
+}
+
diff --git a/src/core/state/persistence.ts b/src/core/state/persistence.ts
new file mode 100644
index 0000000000000000000000000000000000000000..090d11bf97d5a15ec1c27cbdb4e54fef599c26da
--- /dev/null
+++ b/src/core/state/persistence.ts
@@ -0,0 +1,104 @@
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import type { PersistedAppStateV1, StateSnapshotV1 } from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import { recoverPersistedAppState } from "./state.js";
+
+export const STATE_SNAPSHOT_STORAGE_KEY = "state/state_snapshot";
+
+export type StateMigrationNote = {
+  fromVersion: number;
+  toVersion: number;
+  note: string;
+};
+
+export type HydrationRecoveryNote = {
+  kind: "tool_run_cancelled" | "hook_run_cancelled" | "other";
+  sessionId: string;
+  entityId: string;
+  message: string;
+};
+
+export type HydrationResult = {
+  persisted: PersistedAppStateV1;
+  migrations: StateMigrationNote[];
+  recovery: HydrationRecoveryNote[];
+};
+
+export class InvalidStateSnapshotError extends Error {
+  readonly name = "InvalidStateSnapshotError";
+  constructor(message: string) {
+    super(message);
+  }
+}
+
+export function encodeStateSnapshot(snapshot: StateSnapshotV1): string {
+  return canonicalJsonStringify(snapshot);
+}
+
+export function decodeStateSnapshot(text: string): StateSnapshotV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new InvalidStateSnapshotError("Snapshot is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["kind"] !== "state_snapshot") throw new InvalidStateSnapshotError("Snapshot kind mismatch");
+  if (obj["schemaVersion"] !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot version: ${String(obj["schemaVersion"])}`);
+  }
+  if (!("state" in obj)) throw new InvalidStateSnapshotError("Snapshot missing state");
+  return parsed as StateSnapshotV1;
+}
+
+export function migrateStateSnapshot(snapshot: StateSnapshotV1, nowMonoMs: number = Date.now()): HydrationResult {
+  const migrations: StateMigrationNote[] = [];
+  const recovery: HydrationRecoveryNote[] = [];
+
+  if (snapshot.schemaVersion !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot schemaVersion: ${snapshot.schemaVersion}`);
+  }
+
+  if (snapshot.state.schemaVersion !== 1) {
+    throw new InvalidStateSnapshotError(`Unsupported persisted app state version: ${snapshot.state.schemaVersion}`);
+  }
+
+  const recovered = recoverPersistedAppState(snapshot.state, nowMonoMs);
+  for (const { sessionId, toolRunId } of recovered.report.cancelledToolRuns) {
+    recovery.push({
+      kind: "tool_run_cancelled",
+      sessionId,
+      entityId: toolRunId,
+      message: "Cancelled in-flight tool run during crash recovery"
+    });
+  }
+  for (const { sessionId, hookRunId } of recovered.report.cancelledHookRuns) {
+    recovery.push({
+      kind: "hook_run_cancelled",
+      sessionId,
+      entityId: hookRunId,
+      message: "Cancelled in-flight hook run during crash recovery"
+    });
+  }
+
+  return { persisted: recovered.persisted, migrations, recovery };
+}
+
+export async function loadStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY
+): Promise<StateSnapshotV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeStateSnapshot(found.value);
+}
+
+export async function saveStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  snapshot: StateSnapshotV1,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeStateSnapshot(snapshot);
+  const res = await storage.set(namespace, key, encoded, options);
+  return res;
+}
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..809c20a9646f83664161d132ecd72d2df942adbf
--- /dev/null
+++ b/src/core/state/state.ts
@@ -0,0 +1,264 @@
+import type { IdSource } from "../runtime/ids.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import {
+  asAppId,
+  asSessionId,
+  type PersistedAppStateV1,
+  type PersistedSessionStateV1,
+  type SessionId,
+  type SessionLifecycleState,
+  type StateSnapshotV1,
+  type TranscriptLogV1
+} from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { Notification, NotificationEffect, NotificationState } from "./notifications.js";
+import { addNotification, expireCurrentNotification } from "./notifications.js";
+
+export type SandboxHostPattern = { host: string; port?: number };
+
+export type SandboxPermissionRequest = {
+  requestId: string;
+  hostPattern: SandboxHostPattern;
+  createdAtMonoMs: number;
+  origin: "local" | "worker" | "leader";
+};
+
+export type ToolPermissionRequest = {
+  requestId: string;
+  toolName: string;
+  createdAtMonoMs: number;
+  message?: string;
+};
+
+export type ElicitationRequest = {
+  requestId: string;
+  createdAtMonoMs: number;
+  prompt: string;
+  source: "mcp";
+  concurrency: "serial" | "parallel";
+};
+
+export type WorkerPermissionQueueState = {
+  queue: Array<{ requestId: string; createdAtMonoMs: number; message?: string }>;
+  selectedIndex: number;
+};
+
+export type UiState = {
+  notifications: NotificationState;
+  sandboxPermissions: { queue: SandboxPermissionRequest[]; pendingLeaderRequest: { requestId: string; host: string } | null };
+  toolPermission: { active: ToolPermissionRequest | null };
+  workerPermissions: WorkerPermissionQueueState;
+  workerSandboxPermissions: WorkerPermissionQueueState;
+  elicitation: { queue: ElicitationRequest[] };
+  messageSelectorOpen: boolean;
+  costNoticeActive: boolean;
+  ideOnboardingActive: boolean;
+  exiting: boolean;
+  exitMessageActive: boolean;
+};
+
+export type AppState = {
+  persisted: PersistedAppStateV1;
+  ui: UiState;
+};
+
+export type StateEffect = NotificationEffect;
+
+export type StateUiEvent = { type: "ui/state-changed"; actionType: StateAction["type"] };
+
+export type StateAction =
+  | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
+  | { type: "app/session-created"; session: PersistedSessionStateV1 }
+  | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "ui/notification/add"; notification: Notification }
+  | { type: "ui/notification/expired"; key: string }
+  | { type: "ui/message-selector/set-open"; open: boolean }
+  | { type: "ui/exit/set"; exiting: boolean; exitMessageActive?: boolean };
+
+export type StateCommand =
+  | { type: "cmd/create-session"; sessionId?: SessionId; activate?: boolean; nowMonoMs?: number }
+  | { type: "cmd/restore-from-snapshot"; snapshot: StateSnapshotV1 };
+
+export function createEmptyTranscriptLog(nowMonoMs: number): TranscriptLogV1 {
+  return { schemaVersion: 1, events: [], bounded: undefined };
+}
+
+export function createEmptyUiState(): UiState {
+  return {
+    notifications: { current: null, queue: [] },
+    sandboxPermissions: { queue: [], pendingLeaderRequest: null },
+    toolPermission: { active: null },
+    workerPermissions: { queue: [], selectedIndex: 0 },
+    workerSandboxPermissions: { queue: [], selectedIndex: 0 },
+    elicitation: { queue: [] },
+    messageSelectorOpen: false,
+    costNoticeActive: false,
+    ideOnboardingActive: false,
+    exiting: false,
+    exitMessageActive: false
+  };
+}
+
+export function createEmptyPersistedAppState(options: { idSource: IdSource; clock: MonotonicClock }): PersistedAppStateV1 {
+  const now = options.clock.nowMs();
+  return {
+    schemaVersion: 1,
+    appId: asAppId(options.idSource.nextId("app")),
+    createdAtMonoMs: now,
+    updatedAtMonoMs: now,
+    sessions: {}
+  };
+}
+
+export function createAppState(options: { idSource: IdSource; clock: MonotonicClock }): AppState {
+  return { persisted: createEmptyPersistedAppState(options), ui: createEmptyUiState() };
+}
+
+export function createStateSnapshot(persisted: PersistedAppStateV1): StateSnapshotV1 {
+  return { kind: "state_snapshot", schemaVersion: SCHEMA_VERSION.stateSnapshot, state: persisted };
+}
+
+export type CrashRecoveryReport = {
+  cancelledToolRuns: Array<{ sessionId: SessionId; toolRunId: string }>;
+  cancelledHookRuns: Array<{ sessionId: SessionId; hookRunId: string }>;
+};
+
+export function recoverPersistedAppState(
+  persisted: PersistedAppStateV1,
+  nowMonoMs: number
+): { persisted: PersistedAppStateV1; report: CrashRecoveryReport } {
+  const report: CrashRecoveryReport = { cancelledToolRuns: [], cancelledHookRuns: [] };
+  const nextSessions: Record<string, PersistedSessionStateV1> = {};
+
+  const crashCancel: CancellationReason = { kind: "unknown", message: "Recovered from crash (tool/hook run left in-flight)" };
+
+  for (const [sessionKey, session] of Object.entries(persisted.sessions)) {
+    const nextToolRuns: typeof session.toolRuns = {};
+    for (const [id, run] of Object.entries(session.toolRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextToolRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledToolRuns.push({ sessionId: session.id, toolRunId: id });
+      } else {
+        nextToolRuns[id] = run;
+      }
+    }
+
+    const nextHookRuns: typeof session.hookRuns = {};
+    for (const [id, run] of Object.entries(session.hookRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextHookRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledHookRuns.push({ sessionId: session.id, hookRunId: id });
+      } else {
+        nextHookRuns[id] = run;
+      }
+    }
+
+    nextSessions[sessionKey] = {
+      ...session,
+      toolRuns: nextToolRuns,
+      hookRuns: nextHookRuns,
+      updatedAtMonoMs: nowMonoMs
+    };
+  }
+
+  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+}
+
+export function reduceAppState(state: AppState, action: StateAction): { state: AppState; effects: StateEffect[]; events: StateUiEvent[] } {
+  switch (action.type) {
+    case "app/restore-persisted": {
+      const next: AppState = { persisted: action.persisted, ui: createEmptyUiState() };
+      return { state: next, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-created": {
+      const sessions = { ...state.persisted.sessions, [action.session.id]: action.session };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions,
+        activeSessionId: state.persisted.activeSessionId ?? action.session.id,
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.session.updatedAtMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-lifecycle-set": {
+      const session = state.persisted.sessions[action.sessionId];
+      if (!session) return { state, effects: [], events: [] };
+      const nextSession: PersistedSessionStateV1 = {
+        ...session,
+        lifecycle: action.lifecycle,
+        updatedAtMonoMs: action.tsMonoMs,
+        ...(action.lifecycle === "ended" ? { endedAtMonoMs: action.tsMonoMs } : {}),
+        ...(action.lifecycle === "error" ? { error: action.error ?? session.error ?? "Session error" } : {})
+      };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions: { ...state.persisted.sessions, [action.sessionId]: nextSession },
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/add": {
+      const { state: nextNotif, effects } = addNotification(state.ui.notifications, action.notification);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/expired": {
+      const { state: nextNotif, effects } = expireCurrentNotification(state.ui.notifications, action.key);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/message-selector/set-open": {
+      return {
+        state: { ...state, ui: { ...state.ui, messageSelectorOpen: action.open } },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+    case "ui/exit/set": {
+      return {
+        state: {
+          ...state,
+          ui: {
+            ...state.ui,
+            exiting: action.exiting,
+            exitMessageActive: action.exitMessageActive ?? state.ui.exitMessageActive
+          }
+        },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+  }
+}
+
+export function commandToActions(
+  state: AppState,
+  command: StateCommand,
+  deps: { idSource: IdSource; clock: MonotonicClock }
+): StateAction[] {
+  switch (command.type) {
+    case "cmd/create-session": {
+      const sessionId = command.sessionId ?? asSessionId(deps.idSource.nextId("sess"));
+      const now = command.nowMonoMs ?? deps.clock.nowMs();
+      const session: PersistedSessionStateV1 = {
+        schemaVersion: 1,
+        id: sessionId,
+        lifecycle: "created",
+        createdAtMonoMs: now,
+        updatedAtMonoMs: now,
+        transcript: createEmptyTranscriptLog(now),
+        attachments: {},
+        toolRuns: {},
+        hookRuns: {},
+        mcpConnections: {}
+      };
+      const actions: StateAction[] = [{ type: "app/session-created", session }];
+      if (command.activate) actions.push({ type: "app/session-lifecycle-set", sessionId, lifecycle: "active", tsMonoMs: now });
+      return actions;
+    }
+    case "cmd/restore-from-snapshot": {
+      const recovered = recoverPersistedAppState(command.snapshot.state, deps.clock.nowMs());
+      return [{ type: "app/restore-persisted", persisted: recovered.persisted }];
+    }
+  }
+}
+
diff --git a/src/core/state/store.ts b/src/core/state/store.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f85b21e6ff7f0ec5be5a8dd9fd4cec4658e397f2
--- /dev/null
+++ b/src/core/state/store.ts
@@ -0,0 +1,89 @@
+import type { IdSource } from "../runtime/ids.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import { BoundedAsyncQueue } from "../runtime/queue.js";
+import type { StateSnapshotV1 } from "../types/state.js";
+import type { AppState, StateAction, StateCommand, StateEffect, StateUiEvent } from "./state.js";
+import { commandToActions, createAppState, createStateSnapshot, reduceAppState } from "./state.js";
+
+export type StateStoreOptions = {
+  idSource: IdSource;
+  clock: MonotonicClock;
+  eventBufferSize?: number;
+  effectBufferSize?: number;
+};
+
+export type Unsubscribe = () => void;
+
+export type Subscription<T> = AsyncIterable<T> & { unsubscribe: Unsubscribe };
+
+export type StateStore = {
+  getState: () => AppState;
+  dispatch: (action: StateAction) => Promise<void>;
+  dispatchCommand: (command: StateCommand) => Promise<void>;
+  snapshotPersisted: () => StateSnapshotV1;
+  restoreFromSnapshot: (snapshot: StateSnapshotV1) => Promise<void>;
+  subscribeUi: () => Subscription<StateUiEvent>;
+  subscribeEffects: () => Subscription<StateEffect>;
+};
+
+type Subscriber<T> = {
+  id: string;
+  queue: BoundedAsyncQueue<T>;
+};
+
+export function createStateStore(options: StateStoreOptions): StateStore {
+  const deps = { idSource: options.idSource, clock: options.clock };
+  let state = createAppState(deps);
+
+  const uiSubscribers = new Map<string, Subscriber<StateUiEvent>>();
+  const effectSubscribers = new Map<string, Subscriber<StateEffect>>();
+
+  const eventBufferSize = Math.max(0, options.eventBufferSize ?? 256);
+  const effectBufferSize = Math.max(0, options.effectBufferSize ?? 256);
+
+  async function fanOut<T>(subscribers: Map<string, Subscriber<T>>, value: T): Promise<void> {
+    const deliveries: Array<Promise<void>> = [];
+    for (const sub of subscribers.values()) deliveries.push(sub.queue.push(value));
+    await Promise.all(deliveries);
+  }
+
+  async function applyAction(action: StateAction): Promise<void> {
+    const reduced = reduceAppState(state, action);
+    state = reduced.state;
+    for (const evt of reduced.events) await fanOut(uiSubscribers, evt);
+    for (const eff of reduced.effects) await fanOut(effectSubscribers, eff);
+  }
+
+  function subscribe<T>(subscribers: Map<string, Subscriber<T>>, maxSize: number): Subscription<T> {
+    const id = options.idSource.nextId("store_sub");
+    const queue = new BoundedAsyncQueue<T>({ maxSize, dropPolicy: "drop_oldest" });
+    subscribers.set(id, { id, queue });
+    const iterator = (async function* (): AsyncGenerator<T> {
+      for await (const item of queue) yield item;
+    })();
+    return Object.assign(iterator, {
+      unsubscribe: () => {
+        subscribers.delete(id);
+        queue.close({ kind: "closed", message: "unsubscribed" });
+      }
+    });
+  }
+
+  return {
+    getState: () => state,
+    dispatch: async (action) => {
+      await applyAction(action);
+    },
+    dispatchCommand: async (command) => {
+      const actions = commandToActions(state, command, deps);
+      for (const action of actions) await applyAction(action);
+    },
+    snapshotPersisted: () => createStateSnapshot(state.persisted),
+    restoreFromSnapshot: async (snapshot) => {
+      await applyAction({ type: "app/restore-persisted", persisted: snapshot.state });
+    },
+    subscribeUi: () => subscribe(uiSubscribers, eventBufferSize),
+    subscribeEffects: () => subscribe(effectSubscribers, effectBufferSize)
+  };
+}
+
diff --git a/src/core/state/transcript.ts b/src/core/state/transcript.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f9b512d495cf977b0b62fbbe91b1247887087dab
--- /dev/null
+++ b/src/core/state/transcript.ts
@@ -0,0 +1,63 @@
+import type { HostCrypto } from "../types/host.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import { REDACTED, type Sensitive, type TranscriptEventV1, type TranscriptLogV1 } from "../types/state.js";
+
+export type RedactionStats = {
+  redactedNodes: number;
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  if (value === null || typeof value !== "object") return false;
+  const proto = Object.getPrototypeOf(value);
+  return proto === Object.prototype || proto === null;
+}
+
+function isSensitive(value: unknown): value is Sensitive<unknown> {
+  return isPlainObject(value) && value["kind"] === "sensitive" && "value" in value;
+}
+
+function redactValue(value: unknown, stats: RedactionStats): unknown {
+  if (isSensitive(value)) {
+    stats.redactedNodes += 1;
+    return REDACTED;
+  }
+  if (value === null) return null;
+  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") return value;
+  if (Array.isArray(value)) return value.map((v) => redactValue(v, stats));
+  if (isPlainObject(value)) {
+    const out: Record<string, unknown> = {};
+    for (const [k, v] of Object.entries(value)) out[k] = redactValue(v, stats);
+    return out;
+  }
+  return value;
+}
+
+export function redactTranscriptEvent(event: TranscriptEventV1): { event: TranscriptEventV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const redacted = redactValue(event, stats) as TranscriptEventV1;
+  return { event: redacted, stats };
+}
+
+export function redactTranscriptLog(log: TranscriptLogV1): { log: TranscriptLogV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const events = log.events.map((evt) => redactValue(evt, stats) as TranscriptEventV1);
+  return { log: { ...log, events }, stats };
+}
+
+function bytesToHex(bytes: Uint8Array): string {
+  let out = "";
+  for (const b of bytes) out += b.toString(16).padStart(2, "0");
+  return out;
+}
+
+export async function computeTranscriptSummary(
+  log: TranscriptLogV1,
+  crypto: HostCrypto
+): Promise<{ eventCount: number; sha256Hex: string; redactedNodes: number }> {
+  const { log: redacted, stats } = redactTranscriptLog(log);
+  const json = canonicalJsonStringify(redacted, { pretty: false });
+  const data = new TextEncoder().encode(json);
+  const digest = await crypto.digest("SHA-256", data);
+  return { eventCount: redacted.events.length, sha256Hex: bytesToHex(digest), redactedNodes: stats.redactedNodes };
+}
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+



[35m[3mthinking[0m[0m
**Evaluating time function implementation**

I‚Äôm realizing that the default nowMonoMs uses Date.now, which is wall time instead of monotonic. That‚Äôs acceptable, but maybe not optimal? I think it would be better to use a monotonic clock from the host. Since migrate is pure and has no host in core, we might want to remove the default and require a parameter instead. But it feels like it could be wise to make `nowMonoMs` a required parameter while still allowing Date.now if nothing is provided. Let's ensure it works for tests and make adjustments as needed.
[35m[3mthinking[0m[0m
**Updating state management**

I see that the store currently imports `StateSnapshotV1`, but it's being used in a different way. I‚Äôll patch the `restoreFromSnapshot` method to call `dispatchCommand` with the right parameters for restoration. I think the code should look like this: `restoreFromSnapshot: async (snapshot) => { await dispatchCommand({type:"cmd/restore-from-snapshot", snapshot}) }`. Also, it seems like there's an unused import for `createStateSnapshot`. I should probably remove that too. Let's make these updates!
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
index a24169e79aeb5bebb6227585b7de8694bb92222c..e1d816f843b43f78ace8124cc241e1c196362b50
--- a/src/core/state/index.ts
+++ b/src/core/state/index.ts
@@ -1,4 +1,7 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
+export * from "./overlays.js";
+export * from "./notifications.js";
+export * from "./transcript.js";
+export * from "./persistence.js";
+export * from "./state.js";
+export * from "./store.js";
 
diff --git a/src/core/state/notifications.ts b/src/core/state/notifications.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f8dde458abe0ab190a09282b2445f708c11d9bc
--- /dev/null
+++ b/src/core/state/notifications.ts
@@ -0,0 +1,110 @@
+export type NotificationPriority = "immediate" | "high" | "medium" | "low";
+
+export type Notification = {
+  key: string;
+  text: string;
+  priority: NotificationPriority;
+  color?: string;
+  timeoutMs?: number;
+  invalidates?: string[];
+};
+
+export type NotificationState = {
+  current: Notification | null;
+  queue: Notification[];
+};
+
+export const DEFAULT_NOTIFICATION_TIMEOUT_MS = 8000;
+
+export type NotificationEffect =
+  | { type: "effect/notification-cancel-timeout" }
+  | { type: "effect/notification-schedule-timeout"; key: string; timeoutMs: number };
+
+const priorityOrder: Record<NotificationPriority, number> = {
+  immediate: 0,
+  high: 1,
+  medium: 2,
+  low: 3
+};
+
+function sortByPriority(queue: Notification[]): Notification[] {
+  return queue
+    .slice()
+    .sort((a, b) => (priorityOrder[a.priority] < priorityOrder[b.priority] ? -1 : priorityOrder[a.priority] > priorityOrder[b.priority] ? 1 : 0));
+}
+
+function removeInvalidated(queue: Notification[], invalidates: readonly string[] | undefined): Notification[] {
+  if (!invalidates || invalidates.length === 0) return queue;
+  const invalidated = new Set(invalidates);
+  return queue.filter((n) => !invalidated.has(n.key));
+}
+
+function dedupeByKey(queue: Notification[], key: string): Notification[] {
+  return queue.filter((n) => n.key !== key);
+}
+
+export function drainNotifications(state: NotificationState): { state: NotificationState; effects: NotificationEffect[] } {
+  if (state.current) return { state, effects: [] };
+  if (state.queue.length === 0) return { state, effects: [] };
+
+  const sorted = sortByPriority(state.queue);
+  const next = sorted[0];
+  const remaining = sorted.slice(1);
+  const timeoutMs = next.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+  return {
+    state: { current: next, queue: remaining },
+    effects: [{ type: "effect/notification-schedule-timeout", key: next.key, timeoutMs }]
+  };
+}
+
+export function addNotification(state: NotificationState, notification: Notification): { state: NotificationState; effects: NotificationEffect[] } {
+  const invalidates = notification.invalidates ?? [];
+
+  if (notification.priority === "immediate") {
+    const prevCurrent = state.current;
+    const merged = [...(prevCurrent ? [prevCurrent] : []), ...state.queue];
+    const filtered = removeInvalidated(
+      merged.filter((n) => n.priority !== "immediate"),
+      invalidates
+    );
+
+    const nextState: NotificationState = {
+      current: notification,
+      queue: dedupeByKey(filtered, notification.key)
+    };
+
+    const timeoutMs = notification.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+    return {
+      state: nextState,
+      effects: [
+        { type: "effect/notification-cancel-timeout" },
+        { type: "effect/notification-schedule-timeout", key: notification.key, timeoutMs }
+      ]
+    };
+  }
+
+  const currentKey = state.current?.key ?? null;
+  const alreadyQueued = state.queue.some((n) => n.key === notification.key);
+  if (currentKey === notification.key || alreadyQueued) {
+    const pruned = removeInvalidated(state.queue, invalidates);
+    const drained = drainNotifications({ current: state.current, queue: pruned });
+    return drained;
+  }
+
+  const pruned = removeInvalidated(state.queue, invalidates);
+  const next = { current: state.current, queue: [...pruned, notification] };
+  return drainNotifications(next);
+}
+
+export function expireCurrentNotification(
+  state: NotificationState,
+  key: string
+): { state: NotificationState; effects: NotificationEffect[] } {
+  if (!state.current || state.current.key !== key) return { state, effects: [] };
+
+  const invalidates = state.current.invalidates ?? [];
+  const pruned = removeInvalidated(state.queue.filter((n) => n.priority !== "immediate"), invalidates);
+  const cleared: NotificationState = { current: null, queue: pruned };
+  return drainNotifications(cleared);
+}
+
diff --git a/src/core/state/overlays.ts b/src/core/state/overlays.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a352707c5371f79c9647ad52dbc67193bd99cc40
--- /dev/null
+++ b/src/core/state/overlays.ts
@@ -0,0 +1,55 @@
+export type OverlayKind =
+  | "message-selector"
+  | "sandbox-permission"
+  | "tool-permission"
+  | "worker-permission"
+  | "worker-sandbox-permission"
+  | "elicitation"
+  | "cost"
+  | "ide-onboarding";
+
+export const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [
+  "message-selector",
+  "sandbox-permission",
+  "tool-permission",
+  "worker-permission",
+  "worker-sandbox-permission",
+  "elicitation",
+  "cost",
+  "ide-onboarding"
+] as const;
+
+export type OverlaySelectionInputs = {
+  exiting?: boolean;
+  exitMessageActive?: boolean;
+  messageSelectorOpen?: boolean;
+  sandboxPermissionQueueLength?: number;
+  pendingSandboxRequestActive?: boolean;
+  toolPermissionActive?: boolean;
+  workerPermissionQueueLength?: number;
+  pendingWorkerRequestActive?: boolean;
+  workerSandboxPermissionQueueLength?: number;
+  elicitationQueueLength?: number;
+  costNoticeActive?: boolean;
+  ideOnboardingActive?: boolean;
+};
+
+export function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {
+  if (inputs.exiting || inputs.exitMessageActive) return null;
+  if (inputs.messageSelectorOpen) return "message-selector";
+
+  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;
+  if (hasSandboxPrompt) return "sandbox-permission";
+
+  if (inputs.toolPermissionActive) return "tool-permission";
+
+  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
+  if (hasWorkerPermission) return "worker-permission";
+
+  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
+  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";
+  if (inputs.costNoticeActive) return "cost";
+  if (inputs.ideOnboardingActive) return "ide-onboarding";
+  return null;
+}
+
diff --git a/src/core/state/persistence.ts b/src/core/state/persistence.ts
new file mode 100644
index 0000000000000000000000000000000000000000..090d11bf97d5a15ec1c27cbdb4e54fef599c26da
--- /dev/null
+++ b/src/core/state/persistence.ts
@@ -0,0 +1,104 @@
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import type { PersistedAppStateV1, StateSnapshotV1 } from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import { recoverPersistedAppState } from "./state.js";
+
+export const STATE_SNAPSHOT_STORAGE_KEY = "state/state_snapshot";
+
+export type StateMigrationNote = {
+  fromVersion: number;
+  toVersion: number;
+  note: string;
+};
+
+export type HydrationRecoveryNote = {
+  kind: "tool_run_cancelled" | "hook_run_cancelled" | "other";
+  sessionId: string;
+  entityId: string;
+  message: string;
+};
+
+export type HydrationResult = {
+  persisted: PersistedAppStateV1;
+  migrations: StateMigrationNote[];
+  recovery: HydrationRecoveryNote[];
+};
+
+export class InvalidStateSnapshotError extends Error {
+  readonly name = "InvalidStateSnapshotError";
+  constructor(message: string) {
+    super(message);
+  }
+}
+
+export function encodeStateSnapshot(snapshot: StateSnapshotV1): string {
+  return canonicalJsonStringify(snapshot);
+}
+
+export function decodeStateSnapshot(text: string): StateSnapshotV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new InvalidStateSnapshotError("Snapshot is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["kind"] !== "state_snapshot") throw new InvalidStateSnapshotError("Snapshot kind mismatch");
+  if (obj["schemaVersion"] !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot version: ${String(obj["schemaVersion"])}`);
+  }
+  if (!("state" in obj)) throw new InvalidStateSnapshotError("Snapshot missing state");
+  return parsed as StateSnapshotV1;
+}
+
+export function migrateStateSnapshot(snapshot: StateSnapshotV1, nowMonoMs: number = Date.now()): HydrationResult {
+  const migrations: StateMigrationNote[] = [];
+  const recovery: HydrationRecoveryNote[] = [];
+
+  if (snapshot.schemaVersion !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot schemaVersion: ${snapshot.schemaVersion}`);
+  }
+
+  if (snapshot.state.schemaVersion !== 1) {
+    throw new InvalidStateSnapshotError(`Unsupported persisted app state version: ${snapshot.state.schemaVersion}`);
+  }
+
+  const recovered = recoverPersistedAppState(snapshot.state, nowMonoMs);
+  for (const { sessionId, toolRunId } of recovered.report.cancelledToolRuns) {
+    recovery.push({
+      kind: "tool_run_cancelled",
+      sessionId,
+      entityId: toolRunId,
+      message: "Cancelled in-flight tool run during crash recovery"
+    });
+  }
+  for (const { sessionId, hookRunId } of recovered.report.cancelledHookRuns) {
+    recovery.push({
+      kind: "hook_run_cancelled",
+      sessionId,
+      entityId: hookRunId,
+      message: "Cancelled in-flight hook run during crash recovery"
+    });
+  }
+
+  return { persisted: recovered.persisted, migrations, recovery };
+}
+
+export async function loadStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY
+): Promise<StateSnapshotV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeStateSnapshot(found.value);
+}
+
+export async function saveStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  snapshot: StateSnapshotV1,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeStateSnapshot(snapshot);
+  const res = await storage.set(namespace, key, encoded, options);
+  return res;
+}
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..809c20a9646f83664161d132ecd72d2df942adbf
--- /dev/null
+++ b/src/core/state/state.ts
@@ -0,0 +1,264 @@
+import type { IdSource } from "../runtime/ids.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import {
+  asAppId,
+  asSessionId,
+  type PersistedAppStateV1,
+  type PersistedSessionStateV1,
+  type SessionId,
+  type SessionLifecycleState,
+  type StateSnapshotV1,
+  type TranscriptLogV1
+} from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { Notification, NotificationEffect, NotificationState } from "./notifications.js";
+import { addNotification, expireCurrentNotification } from "./notifications.js";
+
+export type SandboxHostPattern = { host: string; port?: number };
+
+export type SandboxPermissionRequest = {
+  requestId: string;
+  hostPattern: SandboxHostPattern;
+  createdAtMonoMs: number;
+  origin: "local" | "worker" | "leader";
+};
+
+export type ToolPermissionRequest = {
+  requestId: string;
+  toolName: string;
+  createdAtMonoMs: number;
+  message?: string;
+};
+
+export type ElicitationRequest = {
+  requestId: string;
+  createdAtMonoMs: number;
+  prompt: string;
+  source: "mcp";
+  concurrency: "serial" | "parallel";
+};
+
+export type WorkerPermissionQueueState = {
+  queue: Array<{ requestId: string; createdAtMonoMs: number; message?: string }>;
+  selectedIndex: number;
+};
+
+export type UiState = {
+  notifications: NotificationState;
+  sandboxPermissions: { queue: SandboxPermissionRequest[]; pendingLeaderRequest: { requestId: string; host: string } | null };
+  toolPermission: { active: ToolPermissionRequest | null };
+  workerPermissions: WorkerPermissionQueueState;
+  workerSandboxPermissions: WorkerPermissionQueueState;
+  elicitation: { queue: ElicitationRequest[] };
+  messageSelectorOpen: boolean;
+  costNoticeActive: boolean;
+  ideOnboardingActive: boolean;
+  exiting: boolean;
+  exitMessageActive: boolean;
+};
+
+export type AppState = {
+  persisted: PersistedAppStateV1;
+  ui: UiState;
+};
+
+export type StateEffect = NotificationEffect;
+
+export type StateUiEvent = { type: "ui/state-changed"; actionType: StateAction["type"] };
+
+export type StateAction =
+  | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
+  | { type: "app/session-created"; session: PersistedSessionStateV1 }
+  | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "ui/notification/add"; notification: Notification }
+  | { type: "ui/notification/expired"; key: string }
+  | { type: "ui/message-selector/set-open"; open: boolean }
+  | { type: "ui/exit/set"; exiting: boolean; exitMessageActive?: boolean };
+
+export type StateCommand =
+  | { type: "cmd/create-session"; sessionId?: SessionId; activate?: boolean; nowMonoMs?: number }
+  | { type: "cmd/restore-from-snapshot"; snapshot: StateSnapshotV1 };
+
+export function createEmptyTranscriptLog(nowMonoMs: number): TranscriptLogV1 {
+  return { schemaVersion: 1, events: [], bounded: undefined };
+}
+
+export function createEmptyUiState(): UiState {
+  return {
+    notifications: { current: null, queue: [] },
+    sandboxPermissions: { queue: [], pendingLeaderRequest: null },
+    toolPermission: { active: null },
+    workerPermissions: { queue: [], selectedIndex: 0 },
+    workerSandboxPermissions: { queue: [], selectedIndex: 0 },
+    elicitation: { queue: [] },
+    messageSelectorOpen: false,
+    costNoticeActive: false,
+    ideOnboardingActive: false,
+    exiting: false,
+    exitMessageActive: false
+  };
+}
+
+export function createEmptyPersistedAppState(options: { idSource: IdSource; clock: MonotonicClock }): PersistedAppStateV1 {
+  const now = options.clock.nowMs();
+  return {
+    schemaVersion: 1,
+    appId: asAppId(options.idSource.nextId("app")),
+    createdAtMonoMs: now,
+    updatedAtMonoMs: now,
+    sessions: {}
+  };
+}
+
+export function createAppState(options: { idSource: IdSource; clock: MonotonicClock }): AppState {
+  return { persisted: createEmptyPersistedAppState(options), ui: createEmptyUiState() };
+}
+
+export function createStateSnapshot(persisted: PersistedAppStateV1): StateSnapshotV1 {
+  return { kind: "state_snapshot", schemaVersion: SCHEMA_VERSION.stateSnapshot, state: persisted };
+}
+
+export type CrashRecoveryReport = {
+  cancelledToolRuns: Array<{ sessionId: SessionId; toolRunId: string }>;
+  cancelledHookRuns: Array<{ sessionId: SessionId; hookRunId: string }>;
+};
+
+export function recoverPersistedAppState(
+  persisted: PersistedAppStateV1,
+  nowMonoMs: number
+): { persisted: PersistedAppStateV1; report: CrashRecoveryReport } {
+  const report: CrashRecoveryReport = { cancelledToolRuns: [], cancelledHookRuns: [] };
+  const nextSessions: Record<string, PersistedSessionStateV1> = {};
+
+  const crashCancel: CancellationReason = { kind: "unknown", message: "Recovered from crash (tool/hook run left in-flight)" };
+
+  for (const [sessionKey, session] of Object.entries(persisted.sessions)) {
+    const nextToolRuns: typeof session.toolRuns = {};
+    for (const [id, run] of Object.entries(session.toolRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextToolRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledToolRuns.push({ sessionId: session.id, toolRunId: id });
+      } else {
+        nextToolRuns[id] = run;
+      }
+    }
+
+    const nextHookRuns: typeof session.hookRuns = {};
+    for (const [id, run] of Object.entries(session.hookRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextHookRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledHookRuns.push({ sessionId: session.id, hookRunId: id });
+      } else {
+        nextHookRuns[id] = run;
+      }
+    }
+
+    nextSessions[sessionKey] = {
+      ...session,
+      toolRuns: nextToolRuns,
+      hookRuns: nextHookRuns,
+      updatedAtMonoMs: nowMonoMs
+    };
+  }
+
+  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+}
+
+export function reduceAppState(state: AppState, action: StateAction): { state: AppState; effects: StateEffect[]; events: StateUiEvent[] } {
+  switch (action.type) {
+    case "app/restore-persisted": {
+      const next: AppState = { persisted: action.persisted, ui: createEmptyUiState() };
+      return { state: next, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-created": {
+      const sessions = { ...state.persisted.sessions, [action.session.id]: action.session };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions,
+        activeSessionId: state.persisted.activeSessionId ?? action.session.id,
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.session.updatedAtMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-lifecycle-set": {
+      const session = state.persisted.sessions[action.sessionId];
+      if (!session) return { state, effects: [], events: [] };
+      const nextSession: PersistedSessionStateV1 = {
+        ...session,
+        lifecycle: action.lifecycle,
+        updatedAtMonoMs: action.tsMonoMs,
+        ...(action.lifecycle === "ended" ? { endedAtMonoMs: action.tsMonoMs } : {}),
+        ...(action.lifecycle === "error" ? { error: action.error ?? session.error ?? "Session error" } : {})
+      };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions: { ...state.persisted.sessions, [action.sessionId]: nextSession },
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/add": {
+      const { state: nextNotif, effects } = addNotification(state.ui.notifications, action.notification);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/expired": {
+      const { state: nextNotif, effects } = expireCurrentNotification(state.ui.notifications, action.key);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/message-selector/set-open": {
+      return {
+        state: { ...state, ui: { ...state.ui, messageSelectorOpen: action.open } },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+    case "ui/exit/set": {
+      return {
+        state: {
+          ...state,
+          ui: {
+            ...state.ui,
+            exiting: action.exiting,
+            exitMessageActive: action.exitMessageActive ?? state.ui.exitMessageActive
+          }
+        },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+  }
+}
+
+export function commandToActions(
+  state: AppState,
+  command: StateCommand,
+  deps: { idSource: IdSource; clock: MonotonicClock }
+): StateAction[] {
+  switch (command.type) {
+    case "cmd/create-session": {
+      const sessionId = command.sessionId ?? asSessionId(deps.idSource.nextId("sess"));
+      const now = command.nowMonoMs ?? deps.clock.nowMs();
+      const session: PersistedSessionStateV1 = {
+        schemaVersion: 1,
+        id: sessionId,
+        lifecycle: "created",
+        createdAtMonoMs: now,
+        updatedAtMonoMs: now,
+        transcript: createEmptyTranscriptLog(now),
+        attachments: {},
+        toolRuns: {},
+        hookRuns: {},
+        mcpConnections: {}
+      };
+      const actions: StateAction[] = [{ type: "app/session-created", session }];
+      if (command.activate) actions.push({ type: "app/session-lifecycle-set", sessionId, lifecycle: "active", tsMonoMs: now });
+      return actions;
+    }
+    case "cmd/restore-from-snapshot": {
+      const recovered = recoverPersistedAppState(command.snapshot.state, deps.clock.nowMs());
+      return [{ type: "app/restore-persisted", persisted: recovered.persisted }];
+    }
+  }
+}
+
diff --git a/src/core/state/store.ts b/src/core/state/store.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f85b21e6ff7f0ec5be5a8dd9fd4cec4658e397f2
--- /dev/null
+++ b/src/core/state/store.ts
@@ -0,0 +1,89 @@
+import type { IdSource } from "../runtime/ids.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import { BoundedAsyncQueue } from "../runtime/queue.js";
+import type { StateSnapshotV1 } from "../types/state.js";
+import type { AppState, StateAction, StateCommand, StateEffect, StateUiEvent } from "./state.js";
+import { commandToActions, createAppState, createStateSnapshot, reduceAppState } from "./state.js";
+
+export type StateStoreOptions = {
+  idSource: IdSource;
+  clock: MonotonicClock;
+  eventBufferSize?: number;
+  effectBufferSize?: number;
+};
+
+export type Unsubscribe = () => void;
+
+export type Subscription<T> = AsyncIterable<T> & { unsubscribe: Unsubscribe };
+
+export type StateStore = {
+  getState: () => AppState;
+  dispatch: (action: StateAction) => Promise<void>;
+  dispatchCommand: (command: StateCommand) => Promise<void>;
+  snapshotPersisted: () => StateSnapshotV1;
+  restoreFromSnapshot: (snapshot: StateSnapshotV1) => Promise<void>;
+  subscribeUi: () => Subscription<StateUiEvent>;
+  subscribeEffects: () => Subscription<StateEffect>;
+};
+
+type Subscriber<T> = {
+  id: string;
+  queue: BoundedAsyncQueue<T>;
+};
+
+export function createStateStore(options: StateStoreOptions): StateStore {
+  const deps = { idSource: options.idSource, clock: options.clock };
+  let state = createAppState(deps);
+
+  const uiSubscribers = new Map<string, Subscriber<StateUiEvent>>();
+  const effectSubscribers = new Map<string, Subscriber<StateEffect>>();
+
+  const eventBufferSize = Math.max(0, options.eventBufferSize ?? 256);
+  const effectBufferSize = Math.max(0, options.effectBufferSize ?? 256);
+
+  async function fanOut<T>(subscribers: Map<string, Subscriber<T>>, value: T): Promise<void> {
+    const deliveries: Array<Promise<void>> = [];
+    for (const sub of subscribers.values()) deliveries.push(sub.queue.push(value));
+    await Promise.all(deliveries);
+  }
+
+  async function applyAction(action: StateAction): Promise<void> {
+    const reduced = reduceAppState(state, action);
+    state = reduced.state;
+    for (const evt of reduced.events) await fanOut(uiSubscribers, evt);
+    for (const eff of reduced.effects) await fanOut(effectSubscribers, eff);
+  }
+
+  function subscribe<T>(subscribers: Map<string, Subscriber<T>>, maxSize: number): Subscription<T> {
+    const id = options.idSource.nextId("store_sub");
+    const queue = new BoundedAsyncQueue<T>({ maxSize, dropPolicy: "drop_oldest" });
+    subscribers.set(id, { id, queue });
+    const iterator = (async function* (): AsyncGenerator<T> {
+      for await (const item of queue) yield item;
+    })();
+    return Object.assign(iterator, {
+      unsubscribe: () => {
+        subscribers.delete(id);
+        queue.close({ kind: "closed", message: "unsubscribed" });
+      }
+    });
+  }
+
+  return {
+    getState: () => state,
+    dispatch: async (action) => {
+      await applyAction(action);
+    },
+    dispatchCommand: async (command) => {
+      const actions = commandToActions(state, command, deps);
+      for (const action of actions) await applyAction(action);
+    },
+    snapshotPersisted: () => createStateSnapshot(state.persisted),
+    restoreFromSnapshot: async (snapshot) => {
+      await applyAction({ type: "app/restore-persisted", persisted: snapshot.state });
+    },
+    subscribeUi: () => subscribe(uiSubscribers, eventBufferSize),
+    subscribeEffects: () => subscribe(effectSubscribers, effectBufferSize)
+  };
+}
+
diff --git a/src/core/state/transcript.ts b/src/core/state/transcript.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f9b512d495cf977b0b62fbbe91b1247887087dab
--- /dev/null
+++ b/src/core/state/transcript.ts
@@ -0,0 +1,63 @@
+import type { HostCrypto } from "../types/host.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import { REDACTED, type Sensitive, type TranscriptEventV1, type TranscriptLogV1 } from "../types/state.js";
+
+export type RedactionStats = {
+  redactedNodes: number;
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  if (value === null || typeof value !== "object") return false;
+  const proto = Object.getPrototypeOf(value);
+  return proto === Object.prototype || proto === null;
+}
+
+function isSensitive(value: unknown): value is Sensitive<unknown> {
+  return isPlainObject(value) && value["kind"] === "sensitive" && "value" in value;
+}
+
+function redactValue(value: unknown, stats: RedactionStats): unknown {
+  if (isSensitive(value)) {
+    stats.redactedNodes += 1;
+    return REDACTED;
+  }
+  if (value === null) return null;
+  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") return value;
+  if (Array.isArray(value)) return value.map((v) => redactValue(v, stats));
+  if (isPlainObject(value)) {
+    const out: Record<string, unknown> = {};
+    for (const [k, v] of Object.entries(value)) out[k] = redactValue(v, stats);
+    return out;
+  }
+  return value;
+}
+
+export function redactTranscriptEvent(event: TranscriptEventV1): { event: TranscriptEventV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const redacted = redactValue(event, stats) as TranscriptEventV1;
+  return { event: redacted, stats };
+}
+
+export function redactTranscriptLog(log: TranscriptLogV1): { log: TranscriptLogV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const events = log.events.map((evt) => redactValue(evt, stats) as TranscriptEventV1);
+  return { log: { ...log, events }, stats };
+}
+
+function bytesToHex(bytes: Uint8Array): string {
+  let out = "";
+  for (const b of bytes) out += b.toString(16).padStart(2, "0");
+  return out;
+}
+
+export async function computeTranscriptSummary(
+  log: TranscriptLogV1,
+  crypto: HostCrypto
+): Promise<{ eventCount: number; sha256Hex: string; redactedNodes: number }> {
+  const { log: redacted, stats } = redactTranscriptLog(log);
+  const json = canonicalJsonStringify(redacted, { pretty: false });
+  const data = new TextEncoder().encode(json);
+  const digest = await crypto.digest("SHA-256", data);
+  return { eventCount: redacted.events.length, sha256Hex: bytesToHex(digest), redactedNodes: stats.redactedNodes };
+}
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/state/store.ts[0m
@@ -82,3 +82,5 @@
     restoreFromSnapshot: async (snapshot) => {
[31m-      await applyAction({ type: "app/restore-persisted", persisted: snapshot.state });[0m
[32m+      await fanOut(uiSubscribers, { type: "ui/state-changed", actionType: "app/restore-persisted" });[0m
[32m+      const actions = commandToActions(state, { type: "cmd/restore-from-snapshot", snapshot }, deps);[0m
[32m+      for (const action of actions) await applyAction(action);[0m
     },
@@ -88,2 +90 @@
 }
[31m-[0m
[32mapply_patch(auto_approved=true) exited 0 in 61ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/state/store.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/state/index.ts b/src/core/state/index.ts
index a24169e79aeb5bebb6227585b7de8694bb92222c..e1d816f843b43f78ace8124cc241e1c196362b50
--- a/src/core/state/index.ts
+++ b/src/core/state/index.ts
@@ -1,4 +1,7 @@
-export type StatePlaceholder = {
-  phase: "2";
-};
+export * from "./overlays.js";
+export * from "./notifications.js";
+export * from "./transcript.js";
+export * from "./persistence.js";
+export * from "./state.js";
+export * from "./store.js";
 
diff --git a/src/core/state/notifications.ts b/src/core/state/notifications.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f8dde458abe0ab190a09282b2445f708c11d9bc
--- /dev/null
+++ b/src/core/state/notifications.ts
@@ -0,0 +1,110 @@
+export type NotificationPriority = "immediate" | "high" | "medium" | "low";
+
+export type Notification = {
+  key: string;
+  text: string;
+  priority: NotificationPriority;
+  color?: string;
+  timeoutMs?: number;
+  invalidates?: string[];
+};
+
+export type NotificationState = {
+  current: Notification | null;
+  queue: Notification[];
+};
+
+export const DEFAULT_NOTIFICATION_TIMEOUT_MS = 8000;
+
+export type NotificationEffect =
+  | { type: "effect/notification-cancel-timeout" }
+  | { type: "effect/notification-schedule-timeout"; key: string; timeoutMs: number };
+
+const priorityOrder: Record<NotificationPriority, number> = {
+  immediate: 0,
+  high: 1,
+  medium: 2,
+  low: 3
+};
+
+function sortByPriority(queue: Notification[]): Notification[] {
+  return queue
+    .slice()
+    .sort((a, b) => (priorityOrder[a.priority] < priorityOrder[b.priority] ? -1 : priorityOrder[a.priority] > priorityOrder[b.priority] ? 1 : 0));
+}
+
+function removeInvalidated(queue: Notification[], invalidates: readonly string[] | undefined): Notification[] {
+  if (!invalidates || invalidates.length === 0) return queue;
+  const invalidated = new Set(invalidates);
+  return queue.filter((n) => !invalidated.has(n.key));
+}
+
+function dedupeByKey(queue: Notification[], key: string): Notification[] {
+  return queue.filter((n) => n.key !== key);
+}
+
+export function drainNotifications(state: NotificationState): { state: NotificationState; effects: NotificationEffect[] } {
+  if (state.current) return { state, effects: [] };
+  if (state.queue.length === 0) return { state, effects: [] };
+
+  const sorted = sortByPriority(state.queue);
+  const next = sorted[0];
+  const remaining = sorted.slice(1);
+  const timeoutMs = next.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+  return {
+    state: { current: next, queue: remaining },
+    effects: [{ type: "effect/notification-schedule-timeout", key: next.key, timeoutMs }]
+  };
+}
+
+export function addNotification(state: NotificationState, notification: Notification): { state: NotificationState; effects: NotificationEffect[] } {
+  const invalidates = notification.invalidates ?? [];
+
+  if (notification.priority === "immediate") {
+    const prevCurrent = state.current;
+    const merged = [...(prevCurrent ? [prevCurrent] : []), ...state.queue];
+    const filtered = removeInvalidated(
+      merged.filter((n) => n.priority !== "immediate"),
+      invalidates
+    );
+
+    const nextState: NotificationState = {
+      current: notification,
+      queue: dedupeByKey(filtered, notification.key)
+    };
+
+    const timeoutMs = notification.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;
+    return {
+      state: nextState,
+      effects: [
+        { type: "effect/notification-cancel-timeout" },
+        { type: "effect/notification-schedule-timeout", key: notification.key, timeoutMs }
+      ]
+    };
+  }
+
+  const currentKey = state.current?.key ?? null;
+  const alreadyQueued = state.queue.some((n) => n.key === notification.key);
+  if (currentKey === notification.key || alreadyQueued) {
+    const pruned = removeInvalidated(state.queue, invalidates);
+    const drained = drainNotifications({ current: state.current, queue: pruned });
+    return drained;
+  }
+
+  const pruned = removeInvalidated(state.queue, invalidates);
+  const next = { current: state.current, queue: [...pruned, notification] };
+  return drainNotifications(next);
+}
+
+export function expireCurrentNotification(
+  state: NotificationState,
+  key: string
+): { state: NotificationState; effects: NotificationEffect[] } {
+  if (!state.current || state.current.key !== key) return { state, effects: [] };
+
+  const invalidates = state.current.invalidates ?? [];
+  const pruned = removeInvalidated(state.queue.filter((n) => n.priority !== "immediate"), invalidates);
+  const cleared: NotificationState = { current: null, queue: pruned };
+  return drainNotifications(cleared);
+}
+
diff --git a/src/core/state/overlays.ts b/src/core/state/overlays.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a352707c5371f79c9647ad52dbc67193bd99cc40
--- /dev/null
+++ b/src/core/state/overlays.ts
@@ -0,0 +1,55 @@
+export type OverlayKind =
+  | "message-selector"
+  | "sandbox-permission"
+  | "tool-permission"
+  | "worker-permission"
+  | "worker-sandbox-permission"
+  | "elicitation"
+  | "cost"
+  | "ide-onboarding";
+
+export const OVERLAY_PRECEDENCE: readonly OverlayKind[] = [
+  "message-selector",
+  "sandbox-permission",
+  "tool-permission",
+  "worker-permission",
+  "worker-sandbox-permission",
+  "elicitation",
+  "cost",
+  "ide-onboarding"
+] as const;
+
+export type OverlaySelectionInputs = {
+  exiting?: boolean;
+  exitMessageActive?: boolean;
+  messageSelectorOpen?: boolean;
+  sandboxPermissionQueueLength?: number;
+  pendingSandboxRequestActive?: boolean;
+  toolPermissionActive?: boolean;
+  workerPermissionQueueLength?: number;
+  pendingWorkerRequestActive?: boolean;
+  workerSandboxPermissionQueueLength?: number;
+  elicitationQueueLength?: number;
+  costNoticeActive?: boolean;
+  ideOnboardingActive?: boolean;
+};
+
+export function selectActiveOverlay(inputs: OverlaySelectionInputs): OverlayKind | null {
+  if (inputs.exiting || inputs.exitMessageActive) return null;
+  if (inputs.messageSelectorOpen) return "message-selector";
+
+  const hasSandboxPrompt = (inputs.sandboxPermissionQueueLength ?? 0) > 0 || inputs.pendingSandboxRequestActive === true;
+  if (hasSandboxPrompt) return "sandbox-permission";
+
+  if (inputs.toolPermissionActive) return "tool-permission";
+
+  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
+  if (hasWorkerPermission) return "worker-permission";
+
+  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
+  if ((inputs.elicitationQueueLength ?? 0) > 0) return "elicitation";
+  if (inputs.costNoticeActive) return "cost";
+  if (inputs.ideOnboardingActive) return "ide-onboarding";
+  return null;
+}
+
diff --git a/src/core/state/persistence.ts b/src/core/state/persistence.ts
new file mode 100644
index 0000000000000000000000000000000000000000..090d11bf97d5a15ec1c27cbdb4e54fef599c26da
--- /dev/null
+++ b/src/core/state/persistence.ts
@@ -0,0 +1,104 @@
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+import type { PersistedAppStateV1, StateSnapshotV1 } from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import { recoverPersistedAppState } from "./state.js";
+
+export const STATE_SNAPSHOT_STORAGE_KEY = "state/state_snapshot";
+
+export type StateMigrationNote = {
+  fromVersion: number;
+  toVersion: number;
+  note: string;
+};
+
+export type HydrationRecoveryNote = {
+  kind: "tool_run_cancelled" | "hook_run_cancelled" | "other";
+  sessionId: string;
+  entityId: string;
+  message: string;
+};
+
+export type HydrationResult = {
+  persisted: PersistedAppStateV1;
+  migrations: StateMigrationNote[];
+  recovery: HydrationRecoveryNote[];
+};
+
+export class InvalidStateSnapshotError extends Error {
+  readonly name = "InvalidStateSnapshotError";
+  constructor(message: string) {
+    super(message);
+  }
+}
+
+export function encodeStateSnapshot(snapshot: StateSnapshotV1): string {
+  return canonicalJsonStringify(snapshot);
+}
+
+export function decodeStateSnapshot(text: string): StateSnapshotV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new InvalidStateSnapshotError("Snapshot is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["kind"] !== "state_snapshot") throw new InvalidStateSnapshotError("Snapshot kind mismatch");
+  if (obj["schemaVersion"] !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot version: ${String(obj["schemaVersion"])}`);
+  }
+  if (!("state" in obj)) throw new InvalidStateSnapshotError("Snapshot missing state");
+  return parsed as StateSnapshotV1;
+}
+
+export function migrateStateSnapshot(snapshot: StateSnapshotV1, nowMonoMs: number = Date.now()): HydrationResult {
+  const migrations: StateMigrationNote[] = [];
+  const recovery: HydrationRecoveryNote[] = [];
+
+  if (snapshot.schemaVersion !== SCHEMA_VERSION.stateSnapshot) {
+    throw new InvalidStateSnapshotError(`Unsupported state snapshot schemaVersion: ${snapshot.schemaVersion}`);
+  }
+
+  if (snapshot.state.schemaVersion !== 1) {
+    throw new InvalidStateSnapshotError(`Unsupported persisted app state version: ${snapshot.state.schemaVersion}`);
+  }
+
+  const recovered = recoverPersistedAppState(snapshot.state, nowMonoMs);
+  for (const { sessionId, toolRunId } of recovered.report.cancelledToolRuns) {
+    recovery.push({
+      kind: "tool_run_cancelled",
+      sessionId,
+      entityId: toolRunId,
+      message: "Cancelled in-flight tool run during crash recovery"
+    });
+  }
+  for (const { sessionId, hookRunId } of recovered.report.cancelledHookRuns) {
+    recovery.push({
+      kind: "hook_run_cancelled",
+      sessionId,
+      entityId: hookRunId,
+      message: "Cancelled in-flight hook run during crash recovery"
+    });
+  }
+
+  return { persisted: recovered.persisted, migrations, recovery };
+}
+
+export async function loadStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY
+): Promise<StateSnapshotV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeStateSnapshot(found.value);
+}
+
+export async function saveStateSnapshot(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  snapshot: StateSnapshotV1,
+  key: string = STATE_SNAPSHOT_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeStateSnapshot(snapshot);
+  const res = await storage.set(namespace, key, encoded, options);
+  return res;
+}
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..809c20a9646f83664161d132ecd72d2df942adbf
--- /dev/null
+++ b/src/core/state/state.ts
@@ -0,0 +1,264 @@
+import type { IdSource } from "../runtime/ids.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import {
+  asAppId,
+  asSessionId,
+  type PersistedAppStateV1,
+  type PersistedSessionStateV1,
+  type SessionId,
+  type SessionLifecycleState,
+  type StateSnapshotV1,
+  type TranscriptLogV1
+} from "../types/state.js";
+import { SCHEMA_VERSION } from "../types/schema.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { Notification, NotificationEffect, NotificationState } from "./notifications.js";
+import { addNotification, expireCurrentNotification } from "./notifications.js";
+
+export type SandboxHostPattern = { host: string; port?: number };
+
+export type SandboxPermissionRequest = {
+  requestId: string;
+  hostPattern: SandboxHostPattern;
+  createdAtMonoMs: number;
+  origin: "local" | "worker" | "leader";
+};
+
+export type ToolPermissionRequest = {
+  requestId: string;
+  toolName: string;
+  createdAtMonoMs: number;
+  message?: string;
+};
+
+export type ElicitationRequest = {
+  requestId: string;
+  createdAtMonoMs: number;
+  prompt: string;
+  source: "mcp";
+  concurrency: "serial" | "parallel";
+};
+
+export type WorkerPermissionQueueState = {
+  queue: Array<{ requestId: string; createdAtMonoMs: number; message?: string }>;
+  selectedIndex: number;
+};
+
+export type UiState = {
+  notifications: NotificationState;
+  sandboxPermissions: { queue: SandboxPermissionRequest[]; pendingLeaderRequest: { requestId: string; host: string } | null };
+  toolPermission: { active: ToolPermissionRequest | null };
+  workerPermissions: WorkerPermissionQueueState;
+  workerSandboxPermissions: WorkerPermissionQueueState;
+  elicitation: { queue: ElicitationRequest[] };
+  messageSelectorOpen: boolean;
+  costNoticeActive: boolean;
+  ideOnboardingActive: boolean;
+  exiting: boolean;
+  exitMessageActive: boolean;
+};
+
+export type AppState = {
+  persisted: PersistedAppStateV1;
+  ui: UiState;
+};
+
+export type StateEffect = NotificationEffect;
+
+export type StateUiEvent = { type: "ui/state-changed"; actionType: StateAction["type"] };
+
+export type StateAction =
+  | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
+  | { type: "app/session-created"; session: PersistedSessionStateV1 }
+  | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "ui/notification/add"; notification: Notification }
+  | { type: "ui/notification/expired"; key: string }
+  | { type: "ui/message-selector/set-open"; open: boolean }
+  | { type: "ui/exit/set"; exiting: boolean; exitMessageActive?: boolean };
+
+export type StateCommand =
+  | { type: "cmd/create-session"; sessionId?: SessionId; activate?: boolean; nowMonoMs?: number }
+  | { type: "cmd/restore-from-snapshot"; snapshot: StateSnapshotV1 };
+
+export function createEmptyTranscriptLog(nowMonoMs: number): TranscriptLogV1 {
+  return { schemaVersion: 1, events: [], bounded: undefined };
+}
+
+export function createEmptyUiState(): UiState {
+  return {
+    notifications: { current: null, queue: [] },
+    sandboxPermissions: { queue: [], pendingLeaderRequest: null },
+    toolPermission: { active: null },
+    workerPermissions: { queue: [], selectedIndex: 0 },
+    workerSandboxPermissions: { queue: [], selectedIndex: 0 },
+    elicitation: { queue: [] },
+    messageSelectorOpen: false,
+    costNoticeActive: false,
+    ideOnboardingActive: false,
+    exiting: false,
+    exitMessageActive: false
+  };
+}
+
+export function createEmptyPersistedAppState(options: { idSource: IdSource; clock: MonotonicClock }): PersistedAppStateV1 {
+  const now = options.clock.nowMs();
+  return {
+    schemaVersion: 1,
+    appId: asAppId(options.idSource.nextId("app")),
+    createdAtMonoMs: now,
+    updatedAtMonoMs: now,
+    sessions: {}
+  };
+}
+
+export function createAppState(options: { idSource: IdSource; clock: MonotonicClock }): AppState {
+  return { persisted: createEmptyPersistedAppState(options), ui: createEmptyUiState() };
+}
+
+export function createStateSnapshot(persisted: PersistedAppStateV1): StateSnapshotV1 {
+  return { kind: "state_snapshot", schemaVersion: SCHEMA_VERSION.stateSnapshot, state: persisted };
+}
+
+export type CrashRecoveryReport = {
+  cancelledToolRuns: Array<{ sessionId: SessionId; toolRunId: string }>;
+  cancelledHookRuns: Array<{ sessionId: SessionId; hookRunId: string }>;
+};
+
+export function recoverPersistedAppState(
+  persisted: PersistedAppStateV1,
+  nowMonoMs: number
+): { persisted: PersistedAppStateV1; report: CrashRecoveryReport } {
+  const report: CrashRecoveryReport = { cancelledToolRuns: [], cancelledHookRuns: [] };
+  const nextSessions: Record<string, PersistedSessionStateV1> = {};
+
+  const crashCancel: CancellationReason = { kind: "unknown", message: "Recovered from crash (tool/hook run left in-flight)" };
+
+  for (const [sessionKey, session] of Object.entries(persisted.sessions)) {
+    const nextToolRuns: typeof session.toolRuns = {};
+    for (const [id, run] of Object.entries(session.toolRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextToolRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledToolRuns.push({ sessionId: session.id, toolRunId: id });
+      } else {
+        nextToolRuns[id] = run;
+      }
+    }
+
+    const nextHookRuns: typeof session.hookRuns = {};
+    for (const [id, run] of Object.entries(session.hookRuns)) {
+      if (run.status === "running" || run.status === "created") {
+        nextHookRuns[id] = { ...run, status: "cancelled", cancelled: crashCancel, endedAtMonoMs: nowMonoMs };
+        report.cancelledHookRuns.push({ sessionId: session.id, hookRunId: id });
+      } else {
+        nextHookRuns[id] = run;
+      }
+    }
+
+    nextSessions[sessionKey] = {
+      ...session,
+      toolRuns: nextToolRuns,
+      hookRuns: nextHookRuns,
+      updatedAtMonoMs: nowMonoMs
+    };
+  }
+
+  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+}
+
+export function reduceAppState(state: AppState, action: StateAction): { state: AppState; effects: StateEffect[]; events: StateUiEvent[] } {
+  switch (action.type) {
+    case "app/restore-persisted": {
+      const next: AppState = { persisted: action.persisted, ui: createEmptyUiState() };
+      return { state: next, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-created": {
+      const sessions = { ...state.persisted.sessions, [action.session.id]: action.session };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions,
+        activeSessionId: state.persisted.activeSessionId ?? action.session.id,
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.session.updatedAtMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/session-lifecycle-set": {
+      const session = state.persisted.sessions[action.sessionId];
+      if (!session) return { state, effects: [], events: [] };
+      const nextSession: PersistedSessionStateV1 = {
+        ...session,
+        lifecycle: action.lifecycle,
+        updatedAtMonoMs: action.tsMonoMs,
+        ...(action.lifecycle === "ended" ? { endedAtMonoMs: action.tsMonoMs } : {}),
+        ...(action.lifecycle === "error" ? { error: action.error ?? session.error ?? "Session error" } : {})
+      };
+      const nextPersisted: PersistedAppStateV1 = {
+        ...state.persisted,
+        sessions: { ...state.persisted.sessions, [action.sessionId]: nextSession },
+        updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs)
+      };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/add": {
+      const { state: nextNotif, effects } = addNotification(state.ui.notifications, action.notification);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/notification/expired": {
+      const { state: nextNotif, effects } = expireCurrentNotification(state.ui.notifications, action.key);
+      return { state: { ...state, ui: { ...state.ui, notifications: nextNotif } }, effects, events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "ui/message-selector/set-open": {
+      return {
+        state: { ...state, ui: { ...state.ui, messageSelectorOpen: action.open } },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+    case "ui/exit/set": {
+      return {
+        state: {
+          ...state,
+          ui: {
+            ...state.ui,
+            exiting: action.exiting,
+            exitMessageActive: action.exitMessageActive ?? state.ui.exitMessageActive
+          }
+        },
+        effects: [],
+        events: [{ type: "ui/state-changed", actionType: action.type }]
+      };
+    }
+  }
+}
+
+export function commandToActions(
+  state: AppState,
+  command: StateCommand,
+  deps: { idSource: IdSource; clock: MonotonicClock }
+): StateAction[] {
+  switch (command.type) {
+    case "cmd/create-session": {
+      const sessionId = command.sessionId ?? asSessionId(deps.idSource.nextId("sess"));
+      const now = command.nowMonoMs ?? deps.clock.nowMs();
+      const session: PersistedSessionStateV1 = {
+        schemaVersion: 1,
+        id: sessionId,
+        lifecycle: "created",
+        createdAtMonoMs: now,
+        updatedAtMonoMs: now,
+        transcript: createEmptyTranscriptLog(now),
+        attachments: {},
+        toolRuns: {},
+        hookRuns: {},
+        mcpConnections: {}
+      };
+      const actions: StateAction[] = [{ type: "app/session-created", session }];
+      if (command.activate) actions.push({ type: "app/session-lifecycle-set", sessionId, lifecycle: "active", tsMonoMs: now });
+      return actions;
+    }
+    case "cmd/restore-from-snapshot": {
+      const recovered = recoverPersistedAppState(command.snapshot.state, deps.clock.nowMs());
+      return [{ type: "app/restore-persisted", persisted: recovered.persisted }];
+    }
+  }
+}
+
diff --git a/src/core/state/store.ts b/src/core/state/store.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5fcd825ef7e229cf55d4dc4a970ab9b5a6d45bb2
--- /dev/null
+++ b/src/core/state/store.ts
@@ -0,0 +1,90 @@
+import type { IdSource } from "../runtime/ids.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import { BoundedAsyncQueue } from "../runtime/queue.js";
+import type { StateSnapshotV1 } from "../types/state.js";
+import type { AppState, StateAction, StateCommand, StateEffect, StateUiEvent } from "./state.js";
+import { commandToActions, createAppState, createStateSnapshot, reduceAppState } from "./state.js";
+
+export type StateStoreOptions = {
+  idSource: IdSource;
+  clock: MonotonicClock;
+  eventBufferSize?: number;
+  effectBufferSize?: number;
+};
+
+export type Unsubscribe = () => void;
+
+export type Subscription<T> = AsyncIterable<T> & { unsubscribe: Unsubscribe };
+
+export type StateStore = {
+  getState: () => AppState;
+  dispatch: (action: StateAction) => Promise<void>;
+  dispatchCommand: (command: StateCommand) => Promise<void>;
+  snapshotPersisted: () => StateSnapshotV1;
+  restoreFromSnapshot: (snapshot: StateSnapshotV1) => Promise<void>;
+  subscribeUi: () => Subscription<StateUiEvent>;
+  subscribeEffects: () => Subscription<StateEffect>;
+};
+
+type Subscriber<T> = {
+  id: string;
+  queue: BoundedAsyncQueue<T>;
+};
+
+export function createStateStore(options: StateStoreOptions): StateStore {
+  const deps = { idSource: options.idSource, clock: options.clock };
+  let state = createAppState(deps);
+
+  const uiSubscribers = new Map<string, Subscriber<StateUiEvent>>();
+  const effectSubscribers = new Map<string, Subscriber<StateEffect>>();
+
+  const eventBufferSize = Math.max(0, options.eventBufferSize ?? 256);
+  const effectBufferSize = Math.max(0, options.effectBufferSize ?? 256);
+
+  async function fanOut<T>(subscribers: Map<string, Subscriber<T>>, value: T): Promise<void> {
+    const deliveries: Array<Promise<void>> = [];
+    for (const sub of subscribers.values()) deliveries.push(sub.queue.push(value));
+    await Promise.all(deliveries);
+  }
+
+  async function applyAction(action: StateAction): Promise<void> {
+    const reduced = reduceAppState(state, action);
+    state = reduced.state;
+    for (const evt of reduced.events) await fanOut(uiSubscribers, evt);
+    for (const eff of reduced.effects) await fanOut(effectSubscribers, eff);
+  }
+
+  function subscribe<T>(subscribers: Map<string, Subscriber<T>>, maxSize: number): Subscription<T> {
+    const id = options.idSource.nextId("store_sub");
+    const queue = new BoundedAsyncQueue<T>({ maxSize, dropPolicy: "drop_oldest" });
+    subscribers.set(id, { id, queue });
+    const iterator = (async function* (): AsyncGenerator<T> {
+      for await (const item of queue) yield item;
+    })();
+    return Object.assign(iterator, {
+      unsubscribe: () => {
+        subscribers.delete(id);
+        queue.close({ kind: "closed", message: "unsubscribed" });
+      }
+    });
+  }
+
+  return {
+    getState: () => state,
+    dispatch: async (action) => {
+      await applyAction(action);
+    },
+    dispatchCommand: async (command) => {
+      const actions = commandToActions(state, command, deps);
+      for (const action of actions) await applyAction(action);
+    },
+    snapshotPersisted: () => createStateSnapshot(state.persisted),
+    restoreFromSnapshot: async (snapshot) => {
+      await fanOut(uiSubscribers, { type: "ui/state-changed", actionType: "app/restore-persisted" });
+      const actions = commandToActions(state, { type: "cmd/restore-from-snapshot", snapshot }, deps);
+      for (const action of actions) await applyAction(action);
+    },
+    subscribeUi: () => subscribe(uiSubscribers, eventBufferSize),
+    subscribeEffects: () => subscribe(effectSubscribers, effectBufferSize)
+  };
+}
diff --git a/src/core/state/transcript.ts b/src/core/state/transcript.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f9b512d495cf977b0b62fbbe91b1247887087dab
--- /dev/null
+++ b/src/core/state/transcript.ts
@@ -0,0 +1,63 @@
+import type { HostCrypto } from "../types/host.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import { REDACTED, type Sensitive, type TranscriptEventV1, type TranscriptLogV1 } from "../types/state.js";
+
+export type RedactionStats = {
+  redactedNodes: number;
+};
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+  if (value === null || typeof value !== "object") return false;
+  const proto = Object.getPrototypeOf(value);
+  return proto === Object.prototype || proto === null;
+}
+
+function isSensitive(value: unknown): value is Sensitive<unknown> {
+  return isPlainObject(value) && value["kind"] === "sensitive" && "value" in value;
+}
+
+function redactValue(value: unknown, stats: RedactionStats): unknown {
+  if (isSensitive(value)) {
+    stats.redactedNodes += 1;
+    return REDACTED;
+  }
+  if (value === null) return null;
+  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") return value;
+  if (Array.isArray(value)) return value.map((v) => redactValue(v, stats));
+  if (isPlainObject(value)) {
+    const out: Record<string, unknown> = {};
+    for (const [k, v] of Object.entries(value)) out[k] = redactValue(v, stats);
+    return out;
+  }
+  return value;
+}
+
+export function redactTranscriptEvent(event: TranscriptEventV1): { event: TranscriptEventV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const redacted = redactValue(event, stats) as TranscriptEventV1;
+  return { event: redacted, stats };
+}
+
+export function redactTranscriptLog(log: TranscriptLogV1): { log: TranscriptLogV1; stats: RedactionStats } {
+  const stats: RedactionStats = { redactedNodes: 0 };
+  const events = log.events.map((evt) => redactValue(evt, stats) as TranscriptEventV1);
+  return { log: { ...log, events }, stats };
+}
+
+function bytesToHex(bytes: Uint8Array): string {
+  let out = "";
+  for (const b of bytes) out += b.toString(16).padStart(2, "0");
+  return out;
+}
+
+export async function computeTranscriptSummary(
+  log: TranscriptLogV1,
+  crypto: HostCrypto
+): Promise<{ eventCount: number; sha256Hex: string; redactedNodes: number }> {
+  const { log: redacted, stats } = redactTranscriptLog(log);
+  const json = canonicalJsonStringify(redacted, { pretty: false });
+  const data = new TextEncoder().encode(json);
+  const digest = await crypto.digest("SHA-256", data);
+  return { eventCount: redacted.events.length, sha256Hex: bytesToHex(digest), redactedNodes: stats.redactedNodes };
+}
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index c1e064591f57c8ca5d858528258a098d2fc5fd5d..3d7ec98c7ee02a8c78f42b14a4e226100ce98185
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -1,6 +1,7 @@
 import type { EngineError } from "./errors.js";
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeSnapshot, TaskId } from "./runtime.js";
+import type { StateSnapshotV1 } from "./state.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -26,7 +27,7 @@
   | { type: "diag/log"; level: EngineEventSeverity; message: string; fields?: unknown }
   | { type: "runtime/snapshot"; snapshot: RuntimeSnapshot }
   | { type: "runtime/hang-detected"; snapshot: RuntimeSnapshot; summary: string }
-  | { type: "state/snapshot"; snapshot: unknown }
+  | { type: "state/snapshot"; snapshot: StateSnapshotV1 }
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 61fe8e84b6cec9d1ffa71e0fccc47b0dcac2341e..5e76720643cda173a645ca4d6a363fa82d3ff9d7
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,3 +7,4 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./state.js";
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
new file mode 100644
index 0000000000000000000000000000000000000000..755c9324eaa2e825ed8e290c7d44727ebeda39d2
--- /dev/null
+++ b/src/core/types/state.ts
@@ -0,0 +1,175 @@
+import type { VersionedEnvelopeBase } from "./schema.js";
+import { SCHEMA_VERSION } from "./schema.js";
+import type { CancellationReason } from "./runtime.js";
+
+export type AppId = string & { readonly __brand: "AppId" };
+export type SessionId = string & { readonly __brand: "SessionId" };
+export type AttachmentId = string & { readonly __brand: "AttachmentId" };
+export type ToolRunId = string & { readonly __brand: "ToolRunId" };
+export type HookRunId = string & { readonly __brand: "HookRunId" };
+export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };
+
+export function asAppId(value: string): AppId {
+  return value as AppId;
+}
+export function asSessionId(value: string): SessionId {
+  return value as SessionId;
+}
+export function asAttachmentId(value: string): AttachmentId {
+  return value as AttachmentId;
+}
+export function asToolRunId(value: string): ToolRunId {
+  return value as ToolRunId;
+}
+export function asHookRunId(value: string): HookRunId {
+  return value as HookRunId;
+}
+export function asMcpConnectionId(value: string): McpConnectionId {
+  return value as McpConnectionId;
+}
+
+export type SessionLifecycleState = "created" | "active" | "paused" | "ended" | "error";
+
+export type Sensitive<T> = { kind: "sensitive"; value: T };
+export type Redacted = { kind: "redacted" };
+export function sensitive<T>(value: T): Sensitive<T> {
+  return { kind: "sensitive", value };
+}
+export const REDACTED: Redacted = { kind: "redacted" };
+
+export type AttachmentRefV1 = {
+  id: AttachmentId;
+  createdAtMonoMs: number;
+  kind: "text" | "json" | "binary";
+  mediaType?: string;
+  byteLength?: number;
+  sha256Hex?: string;
+  storageKey?: string;
+  inlineText?: string;
+  inlineJson?: unknown;
+};
+
+export type TranscriptEventBaseV1 = {
+  id: string;
+  tsMonoMs: number;
+  tsWallMs?: number;
+  sensitivity?: "public" | "internal" | "pii" | "secret";
+};
+
+export type TranscriptMessageEventV1 = TranscriptEventBaseV1 & {
+  type: "message";
+  role: "user" | "assistant" | "system";
+  content: string | Array<{ type: "text"; text: string } | { type: "attachment"; ref: AttachmentId }>;
+};
+
+export type TranscriptToolEventV1 = TranscriptEventBaseV1 & {
+  type: "tool";
+  toolRunId: ToolRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  toolName: string;
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+};
+
+export type TranscriptHookEventV1 = TranscriptEventBaseV1 & {
+  type: "hook";
+  hookRunId: HookRunId;
+  stage: "start" | "stream" | "result" | "error" | "cancelled";
+  eventName: string;
+  selectedHooks?: string[];
+  message?: string;
+  result?: unknown;
+  error?: string;
+};
+
+export type TranscriptMcpEventV1 = TranscriptEventBaseV1 & {
+  type: "mcp";
+  connectionId: McpConnectionId;
+  stage: "connected" | "disconnected" | "tools-snapshot" | "resources-snapshot" | "error";
+  serverName?: string;
+  payload?: unknown;
+  error?: string;
+};
+
+export type TranscriptEventV1 =
+  | TranscriptMessageEventV1
+  | TranscriptToolEventV1
+  | TranscriptHookEventV1
+  | TranscriptMcpEventV1;
+
+export type TranscriptLogV1 = {
+  schemaVersion: 1;
+  events: TranscriptEventV1[];
+  bounded?: { truncatedBeforeEventId?: string; truncatedAtMonoMs?: number; reason?: string };
+};
+
+export type ToolRunEntityV1 = {
+  id: ToolRunId;
+  toolName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  permission?: { decision: "allow" | "deny" | "ask"; persistedKey?: string; decidedAtMonoMs?: number };
+  input?: unknown;
+  output?: unknown;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type HookRunEntityV1 = {
+  id: HookRunId;
+  eventName: string;
+  createdAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  status: "created" | "running" | "completed" | "error" | "cancelled";
+  selectedHooks?: string[];
+  outcomes?: Array<{ hookId: string; status: "completed" | "error" | "cancelled"; error?: string }>;
+  error?: string;
+  cancelled?: CancellationReason;
+};
+
+export type McpConnectionEntityV1 = {
+  id: McpConnectionId;
+  serverName: string;
+  mode: "direct" | "endpoint";
+  status: "disconnected" | "connecting" | "connected" | "error";
+  connectedAtMonoMs?: number;
+  disconnectedAtMonoMs?: number;
+  toolsSnapshot?: unknown;
+  resourcesSnapshot?: unknown;
+  error?: string;
+};
+
+export type PersistedSessionStateV1 = {
+  schemaVersion: 1;
+  id: SessionId;
+  lifecycle: SessionLifecycleState;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  endedAtMonoMs?: number;
+  error?: string;
+  transcript: TranscriptLogV1;
+  attachments: Record<string, AttachmentRefV1>;
+  toolRuns: Record<string, ToolRunEntityV1>;
+  hookRuns: Record<string, HookRunEntityV1>;
+  mcpConnections: Record<string, McpConnectionEntityV1>;
+};
+
+export type PersistedAppStateV1 = {
+  schemaVersion: 1;
+  appId: AppId;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  activeSessionId?: SessionId;
+  sessions: Record<string, PersistedSessionStateV1>;
+};
+
+export type StateSnapshotV1 = VersionedEnvelopeBase & {
+  kind: "state_snapshot";
+  schemaVersion: typeof SCHEMA_VERSION.stateSnapshot;
+  state: PersistedAppStateV1;
+};
+

[2m2025-12-16T18:48:20.820027Z[0m [31mERROR[0m [2mcodex_api::endpoint::responses[0m[2m:[0m [3merror[0m[2m=[0mhttp 400 Bad Request: Some("{\n  \"error\": {\n    \"message\": \"The encrypted content gAAA...Gqk7 could not be verified.\",\n    \"type\": \"invalid_request_error\",\n    \"param\": null,\n    \"code\": \"invalid_encrypted_content\"\n  }\n}")
[31mERROR:[0m {
  "error": {
    "message": "The encrypted content gAAA...Gqk7 could not be verified.",
    "type": "invalid_request_error",
    "param": null,
    "code": "invalid_encrypted_content"
  }
}
[3m[35mtokens used[0m[0m
120,690
