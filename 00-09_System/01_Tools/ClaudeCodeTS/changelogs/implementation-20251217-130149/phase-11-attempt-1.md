Reading prompt from stdin...
OpenAI Codex v0.73.0 (research preview)
--------
[1mworkdir:[0m /Users/ronaldeddings/ClaudeCodeTS
[1mmodel:[0m gpt-5.2
[1mprovider:[0m openai
[1mapproval:[0m never
[1msandbox:[0m danger-full-access
[1mreasoning effort:[0m high
[1mreasoning summaries:[0m auto
[1msession id:[0m 019b2dd1-1f12-7b60-94e7-5afecb31c16c
--------
[36muser[0m
You are implementing PHASE 11 of 19.

==============================================
MISSION: IMPLEMENT THE REWRITE PLAN (PHASE-BY-PHASE)
==============================================

AUTHORITATIVE INPUTS:
- Implementation Plan: @/Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md
- CLI Encyclopedia: @CLI_ENCYCLOPEDIA.md
- Bundles directory: @/Users/ronaldeddings/ClaudeCodeTS/bundles
- Target source directory: @src
- Local docs directory: @/Users/ronaldeddings/ClaudeCodeTS/docs

PREVIOUS PHASE CHANGELOG:
- @/Users/ronaldeddings/ClaudeCodeTS/changelogs/implementation-20251217-130149/phase-10-changelog.md

CRITICAL RULES:
1) Only implement PHASE 11 right now.
2) Do NOT jump ahead to future phases.
3) Read the relevant files thoroughly, especially the bundled/minified cli.js files @bundles/ClaudeCodeCode/cli.js and @bundles/ClaudeAgentSDKCode/cli.js.
4) You must treat third-party code as dependencies ‚Äî do not re-implement vendor internals.
5) You must build a clean TypeScript module graph in ./src that matches the plan and the encyclopedia and @/Users/ronaldeddings/ClaudeCodeTS/implementation/1-initial-rewrite-implementation-checklist.md
6) Prefer async-first JS/TS, no subprocess-centric control flow.

AUTHENTICATION REQUIREMENT (SAFE):
- Use keychain to extract secrets, search for Claude Code-credentials .... within it there is an accessToken.... Also reference CLAUDE_CODE_SESSION_ACCESS_TOKEN in our old cli.js files
- Assume that using the keychain secret will log you in and you do NOT need to run /login.
- If you're able to run 'claude --dangerously-skip-permissions -p sayhello' and if it works, then creds are good and your code is not good.

WHAT TO DO IN THIS PHASE:
- Locate the 'Phase 11' section in the implementation plan and implement it fully.
- Check off every completed item in that Phase in the plan.
- Add at least one test that proves the phase works (or explain why a test is not applicable).
- If something is ambiguous, make a reasonable best decision and record it in the changelog as a 'Decision'.

VALIDATION:
- Run [0m[1mbun test [0m[2mv1.3.4 (5eb2145b)[0m, , and Import boundary check passed..
- ALSO: YOU MUST RUN THE IDENTICAL COMMAANDS that are in the previous cli.js files....
- If you cannot run something, explain why and what command should be run by the user.

STDOUT CONTRACT:
- Output ONLY a PHASE Change Log.
- Include these sections:
  1) Summary (what you accomplished in Phase 11)
  2) Files changed (created/modified/deleted)
  3) Decisions made (with rationale)
  4) Tests/validation run + results
  5) Remaining work inside Phase 11 (if any)
  6) Handoff notes for next phase

DO NOT print source code to stdout.
Begin now.

[36mmcp:[0m context7 starting
[36mmcp:[0m chrome-devtools starting
[36mmcp:[0m context7 ready
[36mmcp:[0m chrome-devtools ready
[36mmcp startup:[0m ready: context7, chrome-devtools

[35m[3mthinking[0m[0m
**Implementing Phase 11 Tasks**

I need to implement Phase 11, so my first step is to read through the implementation plan, CLI encyclopedia, and bundles. I‚Äôm determining the specific tasks for Phase 11 and will implement them in the TypeScript source. I also need to update the checklist in markdown and add a changelog file with the current timestamp. Running tests and checking the previous cli.js for validation commands is essential. Finally, I‚Äôll only output the phase change log at the end without commentary. Let‚Äôs start with the implementation plan!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'ls changelogs | tail -n 20'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 110ms:[0m
[2m1-rewrite-plan-20251216-074742
implementation-20251216-112218
implementation-20251216-112501
implementation-20251216-125408
implementation-20251216-134333
implementation-20251217-052000
implementation-20251217-092658
implementation-20251217-093335
implementation-20251217-130149[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc ls[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 37ms:[0m
[2mbun.lock
bundles
changelogs
CLI_ENCYCLOPEDIA.md
CLI_FUNCTION_CLASS_MAP.md
docs
ignore
implementation
instruction.md
node_modules
package.json
runner-v2.sh
runner-v3
scripts
src
tests
tsconfig.json[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' CLI_ENCYCLOPEDIA.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 32ms:[0m
[2m# CLI Encyclopedia (WIP) ‚Äî Rebuilding `cli.js` into TypeScript

This is an **encyclopedia-style** guide to the two bundled/minified CLIs:

- `ClaudeAgentSDKCode/cli.js` (Claude Code 2.0.67 bundle)
- `ClaudeCodeCode/cli.js` (Claude Code 2.0.69 bundle)

Goal: document *what each top-level function/class does* (including minified symbol meanings) so we can **extract** it into a clean TypeScript module graph.

Important constraints:

1. These are **bundled + minified** with **no source maps** (no `sourceMappingURL`, no `*.map` files). That means:
   - Many identifiers are arbitrary (`uQ`, `coB`, `qV5`, ‚Ä¶) and not stable across builds.
   - A symbol name alone is not meaningful without its **definition site** and **call sites**.
2. The bundle contains **a large amount of third-party code** (e.g., lodash, commander, AWS SDK, XML parsing, etc.). Rewriting those internals is usually the wrong goal; instead, we should treat them as **dependencies** in the TS rewrite.
3. Therefore, this encyclopedia is organized by **subsystems** and focuses first on **first-party/product logic** that should become your TS modules.

---

## How to read minified symbols (practical decoding rules)[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,220p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 32ms:[0m
[2m# Claude Code v3 ‚Äî Rewrite Implementation Checklist (Iteration 5)

## Project Overview

This project is a ground-up rewrite of the current Claude Code CLI application (two bundled variants) into a single, TypeScript-first, **platform-agnostic engine** that can run inside iOS (React Native), web, and desktop hosts. The rewrite explicitly removes the current architecture‚Äôs reliance on spawning child processes as an orchestration/concurrency mechanism, replacing it with **async-first, event-driven execution** and explicit cooperative scheduling.

### Why this rewrite exists

- The current system is tightly coupled to Node + filesystem + subprocess execution, which blocks mobile/web support and makes correctness/testing nondeterministic.
- Multiple ‚Äúsystems‚Äù (hooks, permissions, background tasks) exist primarily to manage process boundaries instead of explicit async boundaries.
- The bundled codebase is difficult to reason about and evolve; the rewrite aims for a clean module graph with explicit ownership boundaries.

### High-level goals

- Core ‚Äúengine‚Äù is TypeScript, portable, and deterministic under test.
- UI layers (CLI, React Native, web) are thin adapters over the engine.
- Tool execution, hooks, and background agents are implemented as **async tasks** (no process-per-task model).
- Permissions and policy are explicit, enforceable, and testable across hosts.
- MCP works in endpoint mode and direct mode with **mobile-safe transports** and consistent streaming semantics.
[0m

[35m[3mthinking[0m[0m
**Locating Phase 11 section**

I‚Äôm aiming to find the "Phase 11" section in this big, truncated plan file. The plan is to use a command to search for "Phase 11" quickly and get it within context. I‚Äôll run a command to locate it and then use another tool to get the specific range around it. This should help me navigate through the document more efficiently. Let‚Äôs get started!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"\\*\\*\\*Phase 11|Phase 11\" implementation/1-initial-rewrite-implementation-checklist.md | head"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 53ms:[0m
[2m892:- [x] Define how to run constrained tools in a worker context when available (Phase 11.5), with a main-thread fallback.
1296:***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
1777:Dependencies: Phase 3 scheduler/budgets, Phase 8 tool tracks, Phase 11 background agents, Phase 13 tracing.[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1290,1535p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 41ms:[0m
[2m  - [x] buffered responses with bounded memory usage
  - [x] UI messaging that explains reduced fidelity
  - [x] test fixtures that assert identical behavior across hosts lacking fetch streaming

---

***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***

Why this phase exists: legacy includes multiple ‚Äúbackground-ish‚Äù agents (Magic Docs, classifier, session memory, prompt suggestion) and long-running operations. The rewrite must run them in the main runtime cooperatively and portably.

Risks mitigated: runaway resource usage, unpredictable concurrency, and mobile lifecycle breakage.

Dependencies: Phase 3 scheduler, Phase 5 state model, Phase 8 tool pipeline.

11.1 Agent/task model (portable, explicit)
- [ ] Define what qualifies as a ‚Äúbackground agent‚Äù vs a ‚Äúforeground tool run‚Äù.
- [ ] Define the agent lifecycle (scheduled, running, awaiting input, paused, completed, failed, cancelled).
- [ ] Define budgeting for agents (max turns, timeouts, token budgets, concurrency).
- [ ] Define how agents emit progress and results (typed events, not console output).
- [ ] Define how agent outputs are persisted (summary-only vs full trace) with privacy constraints.[0m

[35m[3mthinking[0m[0m
**Planning Phase 11 implementation**

All tasks for Phase 11 are currently unchecked, and I need to implement several components like background agents model and task coordination. This phase is crucial since it's part of a 19-phase project, building on previous phases' foundations. I wonder if I should focus on adding types and runtime scheduling without fully implementing things like Magic Docs just yet. I'll need to follow specifications, build the module graph, and check existing structures to avoid duplication. Let's take a look at the source files.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "find src -maxdepth 3 -type f | sort | sed -n '1,220p'"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 49ms:[0m
[2msrc/core/agents/index.ts
src/core/capabilities/audit.ts
src/core/capabilities/catalog.ts
src/core/capabilities/compliance.ts
src/core/capabilities/index.ts
src/core/capabilities/policy.ts
src/core/capabilities/view.ts
src/core/commands/index.ts
src/core/commands/registry.ts
src/core/commands/types.ts
src/core/engine/index.ts
src/core/events/bus.ts
src/core/events/index.ts
src/core/events/recording.ts
src/core/events/streamAdapters.ts
src/core/filesystem/index.ts
src/core/filesystem/path.ts
src/core/hooks/errors.ts
src/core/hooks/index.ts
src/core/hooks/interpreter.ts[0m

[35m[3mthinking[0m[0m
**Inspecting existing modules**

I need to take a look at src/core/agents/index.ts, as it might have useful information from previous phases. I'll check out the runtime tasks and related components as well. It‚Äôs important to carefully read through these existing modules, including any agents and runtime kernels. To manage this efficiently, I plan to use a parallel approach with the cat command for the relevant files.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,240p' src/core/agents/index.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 39ms:[0m
[2mexport type AgentsPlaceholder = {
  phase: "2";
};
[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/state/store.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 31ms:[0m
[2mimport type { IdSource } from "../runtime/ids.js";
import type { MonotonicClock } from "../runtime/clock.js";
import { BoundedAsyncQueue } from "../runtime/queue.js";
import type { StateSnapshotV1 } from "../types/state.js";
import type { AppState, StateAction, StateCommand, StateEffect, StateUiEvent } from "./state.js";
import { commandToActions, createAppState, createStateSnapshot, reduceAppState } from "./state.js";

export type StateStoreOptions = {
  idSource: IdSource;
  clock: MonotonicClock;
  eventBufferSize?: number;
  effectBufferSize?: number;
};

export type StoreUnsubscribe = () => void;

export type Subscription<T> = AsyncIterable<T> & { unsubscribe: StoreUnsubscribe };

export type StateStore = {
  getState: () => AppState;[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/runtime/scheduler.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 34ms:[0m
[2mimport type { CancellationReason, TaskId, TaskPriority } from "../types/runtime.js";
import { createDeferred, type Deferred } from "./deferred.js";
import type { MonotonicClock } from "./clock.js";

export type SchedulerInstrumentation = {
  onQueued?: (info: { taskId: TaskId; priority: TaskPriority; tick: number }) => void;
  onStarted?: (info: { taskId: TaskId; tick: number }) => void;
  onYielded?: (info: { taskId: TaskId; tick: number }) => void;
  onCompleted?: (info: { taskId: TaskId; tick: number }) => void;
};

export type SchedulerTickOptions = {
  maxRunnables?: number;
};

type Runnable = {
  taskId: TaskId;
  priority: TaskPriority;
  queuedAtTick: number;
  cancelled: boolean;[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/runtime/kernel.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 32ms:[0m
[2mimport { toEngineError } from "../types/errors.js";
import type {
  CancellationReason,
  ConcurrencyLimiterSnapshot,
  PendingTimerSnapshot,
  RuntimeSnapshot,
  RuntimeShutdownSummary,
  RuntimeStreamKind,
  RuntimeStreamSnapshot,
  SchedulerQueueDepths,
  TaskFailurePolicy,
  TaskId,
  TaskInfoSnapshot,
  TaskLifecycleState,
  TaskPriority,
  TaskResult,
  TaskScopeId,
  TaskScopeKind,
  TaskScopeSnapshot
} from "../types/runtime.js";[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/state/state.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 32ms:[0m
[2mimport type { IdSource } from "../runtime/ids.js";
import type { MonotonicClock } from "../runtime/clock.js";
import {
  asAppId,
  asSessionId,
  type AttachmentRefV1,
  type HookRunEntityV1,
  type McpConnectionEntityV1,
  type PersistedAppStateV1,
  type PersistedSessionStateV1,
  type SessionId,
  type SessionLifecycleState,
  type StateSnapshotV1,
  type ToolRunEntityV1,
  type TranscriptEventV1,
  type TranscriptLogV1
} from "../types/state.js";
import { SCHEMA_VERSION } from "../types/schema.js";
import type { CancellationReason } from "../types/runtime.js";
import type { HostEvent } from "../types/events.js";[0m

[35m[3mthinking[0m[0m
**Exploring agent modules**

I‚Äôm noticing that the agents' placeholder is currently quite basic. So, it seems like Phase 11 will likely bring in the actual agent module. I need to check the types used at runtime for the task model and other related elements. I think it will be helpful to inspect the `src/core/types/runtime.ts` file to get a better understanding of what‚Äôs going on there and how it all connects.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,320p' src/core/types/runtime.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 45ms:[0m
[2mimport type { EngineError } from "./errors.js";

export type TaskId = string;
export type TaskScopeId = string;
export type StreamId = string;

export type TaskPriority = "immediate" | "high" | "normal" | "low";
export type TaskFailurePolicy = "fail-fast" | "isolate" | "escalate";

export type TaskLifecycleState = "created" | "queued" | "running" | "waiting" | "completed";

export type CancellationReason =
  | { kind: "user_cancel"; message?: string }
  | { kind: "stop_request"; message?: string }
  | { kind: "timeout"; message?: string; deadlineMonoMs?: number }
  | { kind: "policy_denied"; message?: string }
  | { kind: "host_lifecycle"; message?: string; event?: string }
  | { kind: "unknown"; message?: string };

export type TaskResult<T = unknown> =[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/spec/legacy/appstate.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 39ms:[0m
[2mexport type LegacyNotificationPriority = "immediate" | "high" | "medium" | "low";

export type LegacyNotification = {
  key: string;
  text: string;
  priority: LegacyNotificationPriority;
  color?: string;
  timeoutMs?: number;
  invalidates?: string[];
};

export type LegacyOverlay =
  | "message-selector"
  | "sandbox-permission"
  | "tool-permission"
  | "worker-permission"
  | "worker-sandbox-permission"
  | "elicitation"
  | "cost"
  | "ide-onboarding";[0m

[35m[3mthinking[0m[0m
**Inspecting app tasks**

I‚Äôm noticing that the legacy app state is rather minimal, and it seems there are tasks related to transcript/hook runs that aren't covered. I think I'll need to check the CLI bundles for tasks. The plan mentions a "long-running tasks registry" that resembles the legacy tasks, so that‚Äôs a focus. Using `rg` in the bundles could help, but it looks like the files are large. Maybe I can refine my search to target relevant tasks, particularly in the CLI encyclopedia.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"\\btasks\\b|Background\" CLI_ENCYCLOPEDIA.md | head -n 50"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 50ms:[0m
[2m1840:- it stitches together: settings, tool permissions, plugins, MCP, tasks, file history, notifications, and more
1881:- `tasks`: task registry (`{}`)
2176:   - 2.0.67: `XJ8(B || Q || "Background task", signal)`
2177:   - 2.0.69: `DI8(B || Q || "Background task", signal)`
3594:#### 13.2.4 Background trigger and registry mechanics (WIP)
3735:#### 13.4.3 Background update agent (hook registration + execution)
3847:3. Teleport + remote sessions ‚Äî documented in Chapter 8; remaining: ‚Äúremote tasks‚Äù + any additional teleport-related agents[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1780,1945p' CLI_ENCYCLOPEDIA.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 41ms:[0m
[2m
The executor yields objects shaped like:

```ts
{ message: TranscriptMessage | ProgressMessage }
```

Where progress messages include:

- hook event name
- hook name (`<event>:<matchQuery>` when applicable)
- the specific hook command/prompt/agent being run
- optional status line (if the hook config includes it)

### 6.10 Non-streaming executor: `hY0` vs `XJ0`

Outside-REPL execution returns a simple array:

```ts
type HookRunResult = { command: string; succeeded: boolean; output: string };[0m

[35m[3mthinking[0m[0m
**Evaluating task registry integration**

I‚Äôm looking into the encyclopedia details about the tasks registry in the app state. Currently, our rewrite state model includes the persisted state and UI state, but not the tasks registry. It's in Phase 5, so I need to align with the plan and ensure that tasks are registered and surfaced properly. I should check where persisted types are defined, as src/core/types/state.ts outlines the persisted app and session state. Let's inspect it for tasks!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "task" src/core/types/state.ts | head -n 50'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 46ms:[0m
[2m[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/types/state.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 36ms:[0m
[2mimport type { VersionedEnvelopeBase } from "./schema.js";
import { SCHEMA_VERSION } from "./schema.js";
import type { CancellationReason } from "./runtime.js";

export type AppId = string & { readonly __brand: "AppId" };
export type SessionId = string & { readonly __brand: "SessionId" };
export type AttachmentId = string & { readonly __brand: "AttachmentId" };
export type ToolRunId = string & { readonly __brand: "ToolRunId" };
export type HookRunId = string & { readonly __brand: "HookRunId" };
export type McpConnectionId = string & { readonly __brand: "McpConnectionId" };

export function asAppId(value: string): AppId {
  return value as AppId;
}
export function asSessionId(value: string): SessionId {
  return value as SessionId;
}
export function asAttachmentId(value: string): AttachmentId {
  return value as AttachmentId;
}[0m

[35m[3mthinking[0m[0m
**Considering task records**

I see there are no tasks currently, so I need to add a TaskRecord state. I need to be cautious about this, as I might have to bump the persisted state schema version and include migration logic. There‚Äôs also a SCHEMA_VERSION mapping to consider here. I‚Äôll take a look at the schema file in src/core/types/schema.ts to understand what needs to be updated. It‚Äôs all about making sure things are aligned correctly!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,220p' src/core/types/schema.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 42ms:[0m
[2mexport type SchemaVersion = number;

export type SchemaKind =
  | "engine_event_envelope"
  | "settings_document"
  | "state_snapshot"
  | "session_export"
  | "hook_definition"
  | "hook_result"
  | "tool_invocation"
  | "tool_result"
  | "mcp_envelope";

export type VersionedEnvelopeBase = {
  kind: SchemaKind;
  schemaVersion: SchemaVersion;
};

export const SCHEMA_VERSION = {
  engineEventEnvelope: 1,[0m

[35m[3mthinking[0m[0m
**Evaluating schema versioning**

I‚Äôm considering the schema version constants and noticing the stateSnapshot schema version is at 1. I wonder if changing the state snapshot structure is feasible without a bump. But it seems necessary to bump it if the persisted state shape changes, even if the plan didn‚Äôt mention this. I think it‚Äôs likely more proper to bump it. I'll need to check where the state snapshot is used, probably in state/persistence. Let's inspect that file.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/state/persistence.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 44ms:[0m
[2mimport type { HostStorage, StorageNamespace } from "../types/host.js";
import type { PersistedAppStateV1, StateSnapshotV1 } from "../types/state.js";
import type { MonotonicClock } from "../runtime/clock.js";
import type { IdSource } from "../runtime/ids.js";
import { SCHEMA_VERSION } from "../types/schema.js";
import { canonicalJsonStringify } from "../types/canonicalJson.js";
import { createEmptyPersistedAppState, recoverPersistedAppState } from "./state.js";

export const STATE_SNAPSHOT_STORAGE_KEY = "state/state_snapshot";

export type StateMigrationNote = {
  fromVersion: number;
  toVersion: number;
  note: string;
};

export type HydrationRecoveryNote = {
  kind: "tool_run_cancelled" | "hook_run_cancelled" | "other";
  sessionId: string;
  entityId: string;[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/types/host.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 38ms:[0m
[2mimport type { HostEvent } from "./events.js";
import type { WorkspaceId } from "./workspace.js";

export type CapabilityUnavailableReason =
  | { kind: "not-provided"; message?: string }
  | { kind: "unsupported"; message?: string }
  | { kind: "disabled"; message?: string }
  | { kind: "policy-denied"; message?: string; policyId?: string };

export type Capability<T> =
  | { kind: "available"; value: T }
  | { kind: "unavailable"; reason: CapabilityUnavailableReason };

export function availableCapability<T>(value: T): Capability<T> {
  return { kind: "available", value };
}

export function unavailableCapability(reason: CapabilityUnavailableReason): Capability<never> {
  return { kind: "unavailable", reason };
}[0m

[35m[3mthinking[0m[0m
**Inspecting HostEvent Type**

I'm considering the HostLifecycle functionality and how it allows subscription to HostEvent. I think I should take a look at the file src/core/types/events.ts to really understand what HostEvent entails, particularly its elements like background and foreground. Diving into the source will help clarify the details and ensure I'm covering the right aspects. Let's see what we can find there!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"export type HostEvent\" -n src/core/types/events.ts && sed -n '1,260p' src/core/types/events.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 53ms:[0m
[2m58:export type HostEvent =
import type { EngineError } from "./errors.js";
import type { VersionedEnvelopeBase } from "./schema.js";
import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
import type { StateSnapshotV1 } from "./state.js";

export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
export type EngineEventSeverity = "debug" | "info" | "warn" | "error";

export type EngineEventSensitivity = "public" | "internal" | "pii" | "secret";

export type EngineEventCorrelationIds = {
  taskId?: TaskId;
  toolRunId?: string;
  hookRunId?: string;
  mcpRequestId?: string;
};

export type EngineEventCursor = {
  channel: EngineEventChannel;[0m

[35m[3mthinking[0m[0m
**Considering host events**

I'm thinking about the current HostEvent, which includes backgrounded and foregrounded states, but lacks details on network changes or memory pressure. Since Phase 11.4 requires those elements, I should consider extending the HostEvent union to incorporate network-state and memory-pressure events. However, do I want to change host events right now? Given that Phase 11 includes platform lifecycle integration, it seems necessary. I might need to check host adapters to ensure they emit these events correctly.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/platform/node/host.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 38ms:[0m
[2mimport { availableCapability, unavailableCapability } from "../../core/types/host.js";
import type {
  HostCapabilities,
  HostClock,
  HostCrypto,
  HostFilesystem,
  HostLifecycle,
  HostNetwork,
  HostProcess,
  HostRandom,
  HostSecrets,
  HostStorage,
  StorageNamespace
} from "../../core/types/host.js";
import { StorageConflictError, StorageCorruptionDetectedError } from "../../core/types/host.js";
import crypto from "node:crypto";
import { execFile as execFileCb } from "node:child_process";
import { watch as watchFs } from "node:fs";
import fs from "node:fs/promises";
import os from "node:os";[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "worker" src/core | head -n 80'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 57ms:[0m
[2msrc/core/permissions/types.ts:185:  origin: "local" | "worker" | "leader";
src/core/state/overlays.ts:5:  | "worker-permission"
src/core/state/overlays.ts:6:  | "worker-sandbox-permission"
src/core/state/overlays.ts:15:  "worker-permission",
src/core/state/overlays.ts:16:  "worker-sandbox-permission",
src/core/state/overlays.ts:29:  workerPermissionQueueLength?: number;
src/core/state/overlays.ts:31:  workerSandboxPermissionQueueLength?: number;
src/core/state/overlays.ts:46:  const hasWorkerPermission = (inputs.workerPermissionQueueLength ?? 0) > 0 || inputs.pendingWorkerRequestActive === true;
src/core/state/overlays.ts:47:  if (hasWorkerPermission) return "worker-permission";
src/core/state/overlays.ts:49:  if ((inputs.workerSandboxPermissionQueueLength ?? 0) > 0) return "worker-sandbox-permission";
src/core/state/selectors.ts:22:    workerPermissionQueueLength: ui.workerPermissions.queue.length,
src/core/state/selectors.ts:24:    workerSandboxPermissionQueueLength: ui.workerSandboxPermissions.queue.length,
src/core/state/state.ts:30:  origin: "local" | "worker" | "leader";
src/core/state/state.ts:59:  workerPermissions: WorkerPermissionQueueState;
src/core/state/state.ts:60:  workerSandboxPermissions: WorkerPermissionQueueState;
src/core/state/state.ts:76:  | { type: "effect/request-cancelled"; requestId: string; kind: "elicitation" | "tool-permission" | "sandbox-permission" | "worker-permission" | "worker-sandbox-permission"; reason: CancellationReason }
src/core/state/state.ts:93:  | { type: "effect/worker-permission-decided"; requestId: string; decision: "allow" | "deny"; remember?: boolean }
src/core/state/state.ts:94:  | { type: "effect/worker-sandbox-permission-decided"; requestId: string; decision: "allow" | "deny"; remember?: boolean };
src/core/state/state.ts:117:  | { type: "ui/worker-permissions/enqueue"; request: { requestId: string; createdAtMonoMs: number; message?: string } }
src/core/state/state.ts:118:  | { type: "ui/worker-permissions/dequeue"; requestId: string }[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '3500,3925p' CLI_ENCYCLOPEDIA.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 47ms:[0m
[2m
Primary entrypoints:

- 2.0.67: `ClaudeAgentSDKCode/cli.js:1774`
- 2.0.69: `ClaudeCodeCode/cli.js:1774`

| Concept | 2.0.67 symbol | 2.0.69 symbol |
|---|---:|---:|
| Init (feature flag + env override) | `r12()` | `h02()` |
| Run (attempt generation, then write to AppState) | `s12(ctx)` | `g02(ctx)` |
| Generate suggestion via forked query | `mD8(ctx)` | `nH8(ctx)` |
| Suppress heuristics (too long, formatting, etc.) | `dD8(text)` | `aH8(text)` |
| Suppression telemetry | `NQ0(reason, text)` | `cQ0(reason, text)` |
| Feature flag name | `uD8="tengu_prompt_suggestion"` | `lH8="tengu_prompt_suggestion"` |
| UI callsite | *(no callsite found)* | `g02(...)` called in the main UI loop (`ClaudeCodeCode/cli.js:2645`) |

### 13.2 Magic Docs agent (‚Äú# MAGIC DOC: ‚Ä¶‚Äù)

The Magic Docs system is built around a strict file marker:
[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' changelogs/implementation-20251217-130149/phase-10-changelog.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 70ms:[0m
[2m## Attempt 1

Reading prompt from stdin...
OpenAI Codex v0.73.0 (research preview)
--------
[1mworkdir:[0m /Users/ronaldeddings/ClaudeCodeTS
[1mmodel:[0m gpt-5.2
[1mprovider:[0m openai
[1mapproval:[0m never
[1msandbox:[0m danger-full-access
[1mreasoning effort:[0m high
[1mreasoning summaries:[0m auto
[1msession id:[0m 019b2db0-b8d4-72d0-92ac-c979c2fad05b
--------
[36muser[0m
You are implementing PHASE 10 of 19.

==============================================
MISSION: IMPLEMENT THE REWRITE PLAN (PHASE-BY-PHASE)
==============================================[0m


[35m[3mthinking[0m[0m
**Planning subsystem definitions**

I‚Äôm focusing on defining tasks for each subsystem, including writing new module documentation or types. It seems like the goal is to produce actual code reflecting those definitions. I plan to implement this in the src/core/agents and src/spec/legacy, or maybe in the docs. Each plan item will be considered complete once we have types and skeleton functions, along with at least one test verifying functionalities like agent lifecycle and background tasks. I'll also thoroughly review cli.js bundles for relevant sections.
[35m[3mthinking[0m[0m
**Inspecting task functions**

I see that the files are quite large and minified, which could make things tricky. Still, I can focus on specific line numbers to identify our background tasks. I need to locate references like `XJ8` or `DI8` and inspect those areas closely. I can utilize tools like `rg` and `sed` to help parse through those functions efficiently. Using shell commands will allow me to view the relevant sections more easily. It's all about narrowing down the search!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "tengu_prompt_suggestion|prompt_suggestion" bundles/ClaudeAgentSDKCode/cli.js bundles/ClaudeCodeCode/cli.js | head -n 20'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 68ms:[0m
[2mbundles/ClaudeCodeCode/cli.js:1774:`,isMeta:!0}),...A]}async function U02(A,Q){if(N02())return;let[{tools:B},G,Z,Y]=await Promise.all([PtA(A),UH(Q),_V(),nE()]),J=Y.gitStatus?.length??0,I=Z.claudeMd?.length??0,X=J+I,W=g9();setTimeout(()=>W.abort(),1000);let K=r1(),V=AZA(Q),E=eGA(V,K),D=await pSA(K,W.signal,E),H=0,F=0,C=0,U=0,O=0,q=G.filter((_)=>!_.isMcp);H=B.length,U=q.length;let M=new Set;for(let _ of B){let T=_.name.split("__");if(T.length>=3&&T[1])M.add(T[1])}F=M.size;try{if(B.length>0){let{mcpToolTokens:_}=await _MA(B,async()=>Q,null);C=_}if(q.length>0)O=await F02(G,async()=>Q,null)}catch{}r("tengu_context_size",{git_status_size:J,claude_md_size:I,total_context_size:X,project_file_count_rounded:D,mcp_tools_count:H,mcp_servers_count:F,mcp_tools_tokens:C,non_mcp_tools_count:U,non_mcp_tools_tokens:O})}function $02(A,Q,B){switch(A.name){case HMA:{let G=dF(B);if(G)return{...Q,plan:G};return Q}case Q4.name:{let G=Q4.inputSchema.parse(Q),{command:Z,timeout:Y,description:J,run_in_background:I}=G,X=Z.replace(`cd ${r1()} && `,"");if(X=X.replace(/\\\\;/g,"\\;"),/^echo\s+["']?[^|&;><]*["']?$/i.test(X.trim()))r("tengu_bash_tool_simple_echo",{});return{command:X,description:J,...Y?{timeout:Y}:{},...J?{description:J}:{},...I?{run_in_background:I}:{},..."dangerouslyDisableSandbox"in G&&G.dangerouslyDisableSandbox?{dangerouslyDisableSandbox:G.dangerouslyDisableSandbox}:{}}}case lE.name:{let G=lE.inputSchema.parse(Q),{file_path:Z,edits:Y}=__B({file_path:G.file_path,edits:[{old_string:G.old_string,new_string:G.new_string,replace_all:G.replace_all}]});return{replace_all:Y[0].replace_all,file_path:Z,old_string:Y[0].old_string,new_string:Y[0].new_string}}case XW.name:{let G=XW.inputSchema.parse(Q);return{file_path:G.file_path,content:Go1(G.content)}}case VH:{let G=Q,Z=G.task_id??G.agentId??G.bash_id,Y=G.timeout??(typeof G.wait_up_to==="number"?G.wait_up_to*1000:void 0);return{task_id:Z??"",block:G.block??!0,timeout:Y??30000}}default:return Q}}function w02(A,Q){switch(A.name){case HMA:{if(Q&&typeof Q==="object"&&"plan"in Q){let{plan:B,...G}=Q;return G}return Q}default:return Q}}var kH8;var Xh=L(()=>{T00();J4();T0();HB();xj();pB();cY();pE();rl();OAA();Rb();LZ();cF();Y0();GB1();fv();ayA();$_();dx();$H();kH8=o(W02(),1)});var q02=L(()=>{T0();HB();RG();Xh();LZ();l2()});var L02=L(()=>{ar();pE();Rb();rl();pYA();h1();q02()});async function M02(A){let Q;do Q=await A.next();while(!Q.done);return Q.value}async function*GJA(A,Q=1/0){let B=(Y)=>{let J=Y.next().then(({done:I,value:X})=>({done:I,value:X,generator:Y,promise:J}));return J},G=[...A],Z=new Set;while(Z.size<Q&&G.length>0){let Y=G.shift();Z.add(B(Y))}while(Z.size>0){let{done:Y,value:J,generator:I,promise:X}=await Promise.race(Z);if(Z.delete(X),!Y){if(Z.add(B(I)),J!==void 0)yield J}else if(G.length>0){let W=G.shift();Z.add(B(W))}}}async function YB1(A){let Q=[];for await(let B of A)Q.push(B);return Q}async function*SQ0(A){for(let Q of A)yield Q}var sOG;var Xi=L(()=>{sOG=Symbol("NO_VALUE")});function O02(A){let Q=A.toLowerCase();return/\b(wtf|wth|ffs|omfg|shit(ty|tiest)?|dumbass|horrible|awful|piss(ed|ing)? off|piece of (shit|crap|junk)|what the (fuck|hell)|fucking? (broken|useless|terrible|awful|horrible)|fuck you|screw (this|you)|so frustrating|this sucks|damn it)\b/.test(Q)}function R02(A){let Q=A.toLowerCase().trim();if(Q==="continue")return!0;return/\b(keep going|go on)\b/.test(Q)}function _02(A){let Q=A.toLowerCase();return/\b(you'?re absolutely right|you'?re right)\b/.test(Q)}function IB1(){if(!xQ0)xQ0=qA("perf_hooks").performance;return xQ0}function bH8(){let A=IB1(),Q=A.getEntriesByType("mark");for(let B of Q)if(B.name.startsWith(jMA))A.clearMarks(B.name)}function vQ0(){if(!D4())return;if(!yQ0)return;if(TMA++,bH8(),IB1().mark(`${jMA}turn_start`),JB1)f(`[headlessProfiler] Started turn ${TMA}`)}function z1A(A){if(!D4())return;if(!yQ0)return;let Q=IB1();if(Q.mark(`${jMA}${A}`),JB1)f(`[headlessProfiler] Checkpoint: ${A} at ${Q.now().toFixed(1)}ms`)}function kQ0(){if(!D4())return;if(!yQ0)return;let B=IB1().getEntriesByType("mark").filter((K)=>K.name.startsWith(jMA));if(B.length===0)return;let G=new Map;for(let K of B){let V=K.name.slice(jMA.length);G.set(V,K.startTime)}let Z=G.get("turn_start");if(Z===void 0)return;let Y={turn_number:TMA},J=G.get("system_message_yielded");if(J!==void 0&&TMA===0)Y.time_to_system_message_ms=Math.round(J);let I=G.get("query_started");if(I!==void 0)Y.time_to_query_start_ms=Math.round(I-Z);let X=G.get("first_chunk");if(X!==void 0)Y.time_to_first_response_ms=Math.round(X-Z);let W=G.get("api_request_sent");if(I!==void 0&&W!==void 0)Y.query_overhead_ms=Math.round(W-I);if(Y.checkpoint_count=B.length,process.env.CLAUDE_CODE_ENTRYPOINT)Y.entrypoint=process.env.CLAUDE_CODE_ENTRYPOINT;if(T02)r("tengu_headless_latency",Y);if(JB1)f(`[headlessProfiler] Turn ${TMA} metrics: ${JSON.stringify(Y)}`)}var JB1,fH8=0.05,T02,yQ0,xQ0=null,jMA="headless_",TMA=-1;var PMA=L(()=>{Y0();T0();g0();JB1=process.env.CLAUDE_CODE_PROFILE_STARTUP==="1",T02=Math.random()<fH8,yQ0=JB1||T02});function XB1(A){j02.push(A)}async function P02(A,Q,B,G,Z,Y){let J={messages:A,systemPrompt:Q,userContext:B,systemContext:G,toolUseContext:Z,querySource:Y};for(let I of j02)try{await I(J)}catch(X){s(X instanceof Error?X:Error(`Post-sampling hook failed: ${X}`))}}var j02;var SMA=L(()=>{h1();j02=[]});var xMA=L(()=>{XQ();g0();rQ()});class fQ0{toolDefinitions;canUseTool;tools=[];toolUseContext;hasErrored=!1;progressAvailableResolve;constructor(A,Q,B){this.toolDefinitions=A;this.canUseTool=Q;this.toolUseContext=B}addTool(A,Q){let B=this.toolDefinitions.find((Y)=>Y.name===A.name);if(!B){this.tools.push({id:A.id,block:A,assistantMessage:Q,status:"completed",isConcurrencySafe:!0,pendingProgress:[],results:[u0({content:[{type:"tool_result",content:`<tool_use_error>Error: No such tool available: ${A.name}</tool_use_error>`,is_error:!0,tool_use_id:A.id}],toolUseResult:`Error: No such tool available: ${A.name}`})]});return}let G=B.inputSchema.safeParse(A.input),Z=G?.success?B.isConcurrencySafe(G.data):!1;this.tools.push({id:A.id,block:A,assistantMessage:Q,status:"queued",isConcurrencySafe:Z,pendingProgress:[]}),this.processQueue()}canExecuteTool(A){let Q=this.tools.filter((B)=>B.status==="executing");return Q.length===0||A&&Q.every((B)=>B.isConcurrencySafe)}async processQueue(){for(let A of this.tools){if(A.status!=="queued")continue;if(this.canExecuteTool(A.isConcurrencySafe))await this.executeTool(A);else if(!A.isConcurrencySafe)break}}createSyntheticErrorMessage(A,Q){if(Q==="user_interrupted")return u0({content:[{type:"tool_result",content:U1A,is_error:!0,tool_use_id:A}],toolUseResult:"User rejected tool use"});return u0({content:[{type:"tool_result",content:"<tool_use_error>Sibling tool call errored</tool_use_error>",is_error:!0,tool_use_id:A}],toolUseResult:"Sibling tool call errored"})}getAbortReason(){if(this.hasErrored)return"sibling_error";if(this.toolUseContext.abortController.signal.aborted)return"user_interrupted";return null}async executeTool(A){A.status="executing",this.toolUseContext.setInProgressToolUseIDs((Y)=>new Set([...Y,A.id]));let Q=[],B=[],Z=(async()=>{let Y=this.getAbortReason();if(Y){Q.push(this.createSyntheticErrorMessage(A.id,Y)),A.results=Q,A.contextModifiers=B,A.status="completed";return}let J=WB1(A.block,A.assistantMessage,this.canUseTool,this.toolUseContext),I=!1;for await(let X of J){let W=this.getAbortReason();if(W&&!I){Q.push(this.createSyntheticErrorMessage(A.id,W));break}if(X.message.type==="user"&&Array.isArray(X.message.message.content)&&X.message.message.content.some((V)=>V.type==="tool_result"&&V.is_error===!0))this.hasErrored=!0,I=!0;if(X.message)if(X.message.type==="progress"){if(A.pendingProgress.push(X.message),this.progressAvailableResolve)this.progressAvailableResolve(),this.progressAvailableResolve=void 0}else Q.push(X.message);if(X.contextModifier)B.push(X.contextModifier.modifyContext)}if(A.results=Q,A.contextModifiers=B,A.status="completed",!A.isConcurrencySafe&&B.length>0)for(let X of B)this.toolUseContext=X(this.toolUseContext)})();A.promise=Z,Z.finally(()=>{this.processQueue()})}*getCompletedResults(){for(let A of this.tools){while(A.pendingProgress.length>0)yield{message:A.pendingProgress.shift()};if(A.status==="yielded")continue;if(A.status==="completed"&&A.results){A.status="yielded";for(let Q of A.results)yield{message:Q};hH8(this.toolUseContext,A.id)}else if(A.status==="executing"&&!A.isConcurrencySafe)break}}hasPendingProgress(){return this.tools.some((A)=>A.pendingProgress.length>0)}async*getRemainingResults(){while(this.hasUnfinishedTools()){await this.processQueue();for(let A of this.getCompletedResults())yield A;if(this.hasExecutingTools()&&!this.hasCompletedResults()&&!this.hasPendingProgress()){let A=this.tools.filter((B)=>B.status==="executing"&&B.promise).map((B)=>B.promise),Q=new Promise((B)=>{this.progressAvailableResolve=B});if(A.length>0)await Promise.race([...A,Q])}}for(let A of this.getCompletedResults())yield A}hasCompletedResults(){return this.tools.some((A)=>A.status==="completed")}hasExecutingTools(){return this.tools.some((A)=>A.status==="executing")}hasUnfinishedTools(){return this.tools.some((A)=>A.status!=="yielded")}getUpdatedContext(){return this.toolUseContext}}function hH8(A,Q){A.setInProgressToolUseIDs((B)=>new Set([...B].filter((G)=>G!==Q)))}var S02=L(()=>{Wi();HB()});import{randomUUID as gH8}from"crypto";function KB1(A){return async(Q)=>{try{if(!await A.shouldRun(Q))return;let G=gH8(),Z=A.buildMessages(Q);Q.queryMessageCount=Z.length;let Y=A.systemPrompt?[A.systemPrompt]:Q.systemPrompt,I=A.useTools??!0?Q.toolUseContext.options.tools:[],X=A.getModel(),W=await Wh({messages:Z,systemPrompt:Y,maxThinkingTokens:0,tools:I,signal:g9().signal,options:{getToolPermissionContext:async()=>{return(await Q.toolUseContext.getAppState()).toolPermissionContext},model:X,toolChoice:void 0,isNonInteractiveSession:Q.toolUseContext.options.isNonInteractiveSession,hasAppendSystemPrompt:Q.toolUseContext.options.hasAppendSystemPrompt,temperatureOverride:0,agents:Q.toolUseContext.options.agentDefinitions.activeAgents,querySource:A.name,mcpTools:[],agentIdOrSessionId:Q.toolUseContext.agentId}}),K=W.message.content.filter((V)=>V.type==="text").map((V)=>V.text).join("").trim();try{let V=A.parseResponse(K,Q);A.logResult({type:"success",queryName:A.name,result:V,messageId:W.message.id,model:X,uuid:G},Q)}catch(V){A.logResult({type:"error",queryName:A.name,error:V,uuid:G},Q)}}catch(B){s(B instanceof Error?B:Error(`API query hook ${A.name} failed`))}}}var bQ0=L(()=>{RG();LZ();h1()});async function x02(){return}async function y02(A){if(hQ0)await hQ0(A)}var hQ0=null;var gQ0=L(()=>{bQ0();HB();T0();J4();l2();Xh()});function uH8(A){if(A instanceof I9){let Q=A.error;if(Q?.error?.message)return Q.error.message}return A instanceof Error?A.message:String(A)}function uQ0(A){let Q=new Set;A.forEach((B,G)=>Q.add(G));for(let[B,G]of Object.entries(mH8))if(G.prefixes?.some((Z)=>Array.from(Q).some((Y)=>Y.startsWith(Z))))return B;return}function mQ0(){return{...process.env.ANTHROPIC_BASE_URL?{baseUrl:process.env.ANTHROPIC_BASE_URL}:{},...process.env.ANTHROPIC_MODEL?{envModel:process.env.ANTHROPIC_MODEL}:{},...process.env.ANTHROPIC_SMALL_FAST_MODEL?{envSmallFastModel:process.env.ANTHROPIC_SMALL_FAST_MODEL}:{}}}function v02(){if(!{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.69",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues",BUILD_TIME:"2025-12-13T00:32:01Z"}.BUILD_TIME)return;let A=new Date({ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.69",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues",BUILD_TIME:"2025-12-13T00:32:01Z"}.BUILD_TIME).getTime();if(isNaN(A))return;return Math.floor((Date.now()-A)/60000)}function k02({model:A,messagesLength:Q,temperature:B,betas:G,permissionMode:Z,querySource:Y,queryTracking:J}){r("tengu_api_query",{model:A,messagesLength:Q,temperature:B,provider:pO(),buildAgeMins:v02(),...G?.length?{betas:G.join(",")}:{},permissionMode:Z,querySource:Y,...J?{queryChainId:J.chainId,queryDepth:J.depth}:{},...mQ0()})}function f02({error:A,model:Q,messageCount:B,messageTokens:G,durationMs:Z,durationMsIncludingRetries:Y,attempt:J,requestId:I,didFallBackToNonStreaming:X,promptCategory:W,headers:K,queryTracking:V,llmSpan:E}){let D=void 0;if(A instanceof I9&&A.headers)D=uQ0(A.headers);else if(K)D=uQ0(K);let H=uH8(A),F=A instanceof I9?String(A.status):void 0,C=cRB(A),U=QqA(A);if(U){let O=U.isSSLError?" (SSL error)":"";f(`Connection error details: code=${U.code}${O}, message=${U.message}`,{level:"error"})}s(A),r("tengu_api_error",{model:Q,error:H,status:F,errorType:C,messageCount:B,messageTokens:G,durationMs:Z,durationMsIncludingRetries:Y,attempt:J,provider:pO(),requestId:I||void 0,didFallBackToNonStreaming:X,...W?{promptCategory:W}:{},...D?{gateway:D}:{},...V?{queryChainId:V.chainId,queryDepth:V.depth}:{},...mQ0()}),zU("api_error",{model:Q,error:H,status_code:String(F),duration_ms:String(Z),attempt:String(J)}),ee1(E,{success:!1,statusCode:F?parseInt(F):void 0,error:H,attempt:J})}function dH8({model:A,preNormalizedModel:Q,messageCount:B,messageTokens:G,usage:Z,durationMs:Y,durationMsIncludingRetries:J,attempt:I,ttftMs:X,requestId:W,stopReason:K,costUSD:V,didFallBackToNonStreaming:E,querySource:D,gateway:H,queryTracking:F,permissionMode:C}){let U=D4(),O=process.argv.includes("-p")||process.argv.includes("--print");r("tengu_api_success",{model:A,...Q!==A?{preNormalizedModel:Q}:{},messageCount:B,messageTokens:G,inputTokens:Z.input_tokens,outputTokens:Z.output_tokens,cachedInputTokens:Z.cache_read_input_tokens??0,uncachedInputTokens:Z.cache_creation_input_tokens??0,durationMs:Y,durationMsIncludingRetries:J,attempt:I,ttftMs:X??void 0,buildAgeMins:v02(),provider:pO(),requestId:W??void 0,stop_reason:K??void 0,costUSD:V,didFallBackToNonStreaming:E,isNonInteractiveSession:U,print:O,isTTY:process.stdout.isTTY??!1,querySource:D,...H?{gateway:H}:{},...F?{queryChainId:F.chainId,queryDepth:F.depth}:{},permissionMode:C,...mQ0()})}function b02({model:A,preNormalizedModel:Q,start:B,startIncludingRetries:G,ttftMs:Z,usage:Y,attempt:J,messageCount:I,messageTokens:X,requestId:W,stopReason:K,didFallBackToNonStreaming:V,querySource:E,headers:D,costUSD:H,queryTracking:F,permissionMode:C,newMessages:U,llmSpan:O}){let q=D?uQ0(D):void 0,M=Date.now()-B,_=Date.now()-G;ZK0(_,M),dH8({model:A,preNormalizedModel:Q,messageCount:I,messageTokens:X,usage:Y,durationMs:M,durationMsIncludingRetries:_,attempt:J,ttftMs:Z,requestId:W,stopReason:K,costUSD:H,didFallBackToNonStreaming:V,querySource:E,gateway:q,queryTracking:F,permissionMode:C}),zU("api_request",{model:A,input_tokens:String(Y.input_tokens),output_tokens:String(Y.output_tokens),cache_read_tokens:String(Y.cache_read_input_tokens),cache_creation_tokens:String(Y.cache_creation_input_tokens),cost_usd:String(H),duration_ms:String(M)});let T,y,h;ee1(O,{success:!0,inputTokens:Y.input_tokens,outputTokens:Y.output_tokens,cacheReadTokens:Y.cache_read_input_tokens,cacheCreationTokens:Y.cache_creation_input_tokens,attempt:J,modelOutput:T,thinkingOutput:y,hasToolCall:h})}var mH8,$M;var yMA=L(()=>{VS();h1();Y0();hX();T0();ml();dl();g0();JM();YZA();mH8={litellm:{prefixes:["x-litellm-"]},helicone:{prefixes:["helicone-"]},portkey:{prefixes:["x-portkey-"]},"cloudflare-ai-gateway":{prefixes:["cf-aig-"]}};$M={input_tokens:0,cache_creation_input_tokens:0,cache_read_input_tokens:0,output_tokens:0,server_tool_use:{web_search_requests:0,web_fetch_requests:0},service_tier:"standard",cache_creation:{ephemeral_1h_input_tokens:0,ephemeral_5m_input_tokens:0}}});import{randomUUID as cH8}from"crypto";function VB1(A){return{systemPrompt:A.systemPrompt,userContext:A.userContext,systemContext:A.systemContext,toolUseContext:A.toolUseContext,forkContextMessages:A.messages}}function vMA(A,Q){let B=Q?.abortController??(Q?.shareAbortController?A.abortController:uV0(A.abortController)),G=Q?.getAppState?Q.getAppState:Q?.shareAbortController?A.getAppState:async()=>{let Z=await A.getAppState();if(Z.toolPermissionContext.shouldAvoidPermissionPrompts)return Z;return{...Z,toolPermissionContext:{...Z.toolPermissionContext,shouldAvoidPermissionPrompts:!0}}};return{readFileState:UAA(Q?.readFileState??A.readFileState),nestedMemoryAttachmentTriggers:new Set,toolDecisions:void 0,pendingSteeringAttachments:void 0,abortController:B,getAppState:G,setAppState:Q?.shareSetAppState?A.setAppState:()=>{},setMessages:()=>{},setInProgressToolUseIDs:()=>{},setResponseLength:Q?.shareSetResponseLength?A.setResponseLength:()=>{},updateFileHistoryState:()=>{},addNotification:void 0,setToolJSX:void 0,setStreamMode:void 0,setSpinnerMessage:void 0,setSpinnerColor:void 0,setSpinnerShimmerColor:void 0,setSDKStatus:void 0,openMessageSelector:void 0,options:Q?.options??A.options,messages:Q?.messages??A.messages,agentId:Q?.agentId??QAA(),isSubAgent:!0,queryTracking:{chainId:cH8(),depth:(A.queryTracking?.depth??-1)+1},fileReadingLimits:A.fileReadingLimits,userModified:A.userModified,criticalSystemReminder_EXPERIMENTAL:Q?.criticalSystemReminder_EXPERIMENTAL}}async function EB1({promptMessages:A,cacheSafeParams:Q,canUseTool:B,querySource:G,forkLabel:Z,overrides:Y,maxOutputTokens:J}){let I=Date.now(),X=[],W={...$M},{systemPrompt:K,userContext:V,systemContext:E,toolUseContext:D,forkContextMessages:H}=Q,F=vMA(D,Y),C=[...dQ0(H),...A];for await(let O of LU({messages:C,systemPrompt:K,userContext:V,systemContext:E,canUseTool:B,toolUseContext:F,querySource:G,maxOutputTokensOverride:J})){if(O.type==="stream_event"||O.type==="stream_request_start")continue;if(O.type==="assistant"){let M=O.message.usage;if(M)W=FB1(W,{input_tokens:M.input_tokens??0,cache_creation_input_tokens:M.cache_creation_input_tokens??0,cache_read_input_tokens:M.cache_read_input_tokens??0,output_tokens:M.output_tokens??0,server_tool_use:{web_search_requests:M.server_tool_use?.web_search_requests??0,web_fetch_requests:M.server_tool_use?.web_fetch_requests??0},service_tier:M.service_tier??"standard",cache_creation:{ephemeral_1h_input_tokens:M.cache_creation?.ephemeral_1h_input_tokens??0,ephemeral_5m_input_tokens:M.cache_creation?.ephemeral_5m_input_tokens??0}})}X.push(O)}let U=Date.now()-I;return pH8({forkLabel:Z,querySource:G,durationMs:U,messageCount:X.length,totalUsage:W,queryTracking:D.queryTracking}),{messages:X,totalUsage:W}}function pH8({forkLabel:A,querySource:Q,durationMs:B,messageCount:G,totalUsage:Z,queryTracking:Y}){let J=Z.input_tokens+Z.cache_creation_input_tokens+Z.cache_read_input_tokens,I=J>0?Z.cache_read_input_tokens/J:0;r("tengu_fork_agent_query",{forkLabel:A,querySource:Q,durationMs:B,messageCount:G,inputTokens:Z.input_tokens,outputTokens:Z.output_tokens,cacheReadInputTokens:Z.cache_read_input_tokens,cacheCreationInputTokens:Z.cache_creation_input_tokens,serviceTier:Z.service_tier,cacheCreationEphemeral1hTokens:Z.cache_creation.ephemeral_1h_input_tokens,cacheCreationEphemeral5mTokens:Z.cache_creation.ephemeral_5m_input_tokens,cacheHitRate:I,...Y?{queryChainId:Y.chainId,queryDepth:Y.depth}:{}})}var DB1=L(()=>{Wi();RG();yMA();T0();HB1();_w();rS();LZ()});async function h02(){if(D4())return;let A=process.env.CLAUDE_CODE_ENABLE_PROMPT_SUGGESTION;if(A==="false"){CB1=!1;return}if(A==="1"){CB1=!0;return}CB1=await JZ(lH8)}async function g02(A){if(!CB1||A.querySource!=="repl_main_thread")return;try{let Q=await nH8(A);if(!Q)return;if(aH8(Q))return;A.toolUseContext.setAppState((B)=>({...B,promptSuggestion:{text:Q,shownAt:0,acceptedAt:0}}))}catch(Q){s(Q instanceof Error?Q:Error("Prompt suggestion generation failed"))}}async function nH8(A){let Q=VB1(A),B=async()=>({behavior:"deny",message:"No tools needed for suggestion",decisionReason:{type:"other",reason:"suggestion only"}}),G=await EB1({promptMessages:[u0({content:iH8})],cacheSafeParams:Q,maxOutputTokens:16000,canUseTool:B,querySource:"prompt_suggestion",forkLabel:"prompt_suggestion"});for(let Z of G.messages){if(Z.type!=="assistant")continue;let Y=Z.message.content.find((J)=>J.type==="text");if(Y?.type==="text"&&Y.text.trim())return Y.text.trim()}return null}function aH8(A){let Q=A.toLowerCase(),B=[["empty",()=>!A],["done",()=>Q==="done"],["too_long",()=>A.length>=100],["has_formatting",()=>/[\n*]|\*\*/.test(A)],["error_message",()=>/prompt is too long|context length|token limit/.test(Q)],["gratitude",()=>/thanks|thank you|looks good|that worked|that's all/.test(Q)]];for(let[G,Z]of B)if(Z())return cQ0(G,A),!0;return!1}function cQ0(A,Q){r("tengu_prompt_suggestion",{outcome:"suppressed",reason:A,...!1})}var lH8="tengu_prompt_suggestion",CB1=!1,iH8=`You are now a prompt suggestion generator. The conversation above is context - your job is to suggest what Claude could help with next.
bundles/ClaudeCodeCode/cli.js:2632:`)}function XN2(){let{columns:A}=kB(),[{inbox:Q}]=yQ(),B=Q.messages.filter((J)=>J.status==="pending");if(B.length===0)return null;let G=B.slice(0,o85),Z=B.length-G.length,Y=Math.max(20,A-4-2-4);return yT.createElement(j,{marginTop:1,paddingLeft:2,flexDirection:"column",width:A-4},yT.createElement(z,{dimColor:!0},"Queued teammate ",B.length===1?"message":"messages",":"),G.map((J,I)=>yT.createElement(z,{key:I,color:r85(J.color),wrap:"wrap"},"‚óè ",yT.createElement(z,{bold:!0},J.from,":")," ",s85(J.text,a85,Y))),Z>0&&yT.createElement(z,{dimColor:!0},"(...",Z," more)"))}var yT,n85="ansi:cyan",a85=3,o85=2;var WN2=L(()=>{fA();y6();u2();yT=o(WA(),1)});function KN2({hasStash:A}){if(!A)return null;return R_A.createElement(j,{paddingLeft:2},R_A.createElement(z,{dimColor:!0},X1.pointerSmall," Stashed (auto-restores after submit)"))}var R_A;var VN2=L(()=>{fA();g2();R_A=o(WA(),1)});function EN2(A,Q,B,G,Z,Y,J,I,X){let[W,K]=KN.useState(""),[V,E]=KN.useState(!1),[D,H]=KN.useState(""),[F,C]=KN.useState(0),[U,O]=KN.useState("prompt"),[q,M]=KN.useState(void 0),_=KN.useRef(void 0),T=KN.useRef(new Set),y=KN.useRef(null);function h(){if(_.current)_.current.return(void 0),_.current=void 0}function x(){X(!1),K(""),E(!1),H(""),C(0),O("prompt"),M(void 0),h(),T.current.clear()}async function m(g,t){if(!I)return;if(W.length===0){h(),T.current.clear(),M(void 0),E(!1),B(D),G(F),Y(U);return}if(!g)h(),_.current=vcA(),T.current.clear();if(!_.current)return;while(!0){if(t?.aborted)return;let p=await _.current.next();if(p.done){E(!0);return}let k=p.value.display,c=k.lastIndexOf(W);if(c!==-1&&!T.current.has(k)){T.current.add(k),M(p.value),E(!1);let e=rk(k);Y(e),B(k);let VA=Ls(k).lastIndexOf(W);G(VA!==-1?VA:c);return}}}return k1((g,t)=>{if(I){if(t.ctrl&&g==="r")m(!0);else if(t.escape||t.tab){if(q){let p=typeof q==="string"?q:q.display,k=rk(p),c=Ls(p);B(c),Y(k)}x()}else if(t.ctrl&&g==="c"||t.backspace&&W==="")B(D),G(F),x();else if(t.return){if(W.length===0)A({display:D,pastedContents:{}});else if(q){let p=typeof q==="string"?q:q.display,k=rk(p),c=Ls(p);Y(k),A({display:c,pastedContents:{}})}x()}}else if(t.ctrl&&g==="r")X(!0),H(Q),C(Z),O(J),_.current=vcA(),T.current.clear()},{isActive:!0}),KN.useEffect(()=>{y.current?.abort();let g=new AbortController;return y.current=g,m(!1,g.signal),()=>{g.abort()}},[W]),{historyQuery:W,setHistoryQuery:K,historyMatch:q,historyFailedMatch:V}}var KN;var DN2=L(()=>{fA();nd();KN=o(WA(),1)});function FN2({inputValue:A,isAssistantResponding:Q}){let[B,G]=yQ(),{text:Z,shownAt:Y,acceptedAt:J}=B.promptSuggestion,I=Q||A.length>0?null:Z,X=Z&&Y>0,W=__A.useCallback(()=>{G((D)=>({...D,promptSuggestion:{text:null,shownAt:0,acceptedAt:0}}))},[G]),K=__A.useCallback(()=>{if(!X)return;G((D)=>({...D,promptSuggestion:{...D.promptSuggestion,acceptedAt:Date.now()}}))},[X,G]),V=__A.useCallback(()=>{if(I&&Y===0)G((D)=>({...D,promptSuggestion:{...D.promptSuggestion,shownAt:Date.now()}}))},[I,Y,G]),E=__A.useCallback((D)=>{if(!X)return;let H=J>Y||D===Z,F=H?J||Date.now():Date.now();r("tengu_prompt_suggestion",{outcome:H?"accepted":"ignored",...H&&{timeToAcceptMs:F-Y},...!H&&{timeToIgnoreMs:F-Y},similarity:Math.round(D.length/(Z?.length||1)*100)/100,...!1}),W()},[X,J,Y,Z,W]);return{suggestion:I,markAccepted:K,markShown:V,logOutcomeAtSubmission:E}}var __A,HN2=" (tab to accept)";var CN2=L(()=>{u2();T0();__A=o(WA(),1)});function fIA({initial:A,sessionModel:Q,onSelect:B,onCancel:G,isStandaloneCommand:Z}){let Y=A===null?f50:A,J=10,I=_Q(),X=x31.useMemo(()=>wmA(),[]),W=x31.useMemo(()=>X.map((D)=>({...D,value:D.value===null?f50:D.value})),[X]),K=x31.useMemo(()=>W.some((D)=>D.value===Y)?Y:W[0]?.value??void 0,[W,Y]),V=Math.min(10,W.length),E=Math.max(0,W.length-V);return U3.createElement(j,{flexDirection:"column",width:"100%"},Z&&U3.createElement(p8,{dividerColor:"permission",dividerDimColor:!1}),U3.createElement(j,{flexDirection:"column",paddingX:Z?1:0},U3.createElement(j,{flexDirection:"column"},U3.createElement(j,{marginBottom:1,flexDirection:"column"},U3.createElement(z,{color:"remember",bold:!0},"Select model"),U3.createElement(z,{dimColor:!0},"Switch between Claude models. Applies to this session and future Claude Code sessions. For other/previous model names, specify with --model."),Q&&U3.createElement(z,{dimColor:!0},"Currently using ",eq(Q)," for this session (set by plan mode). Selecting a model will undo this.")),U3.createElement(j,{flexDirection:"column",marginBottom:1},U3.createElement(j,{flexDirection:"column"},U3.createElement(S0,{defaultValue:Y,defaultFocusValue:K,options:W,onChange:(D)=>B(D===f50?null:D),onCancel:G??(()=>{}),visibleOptionCount:V})),E>0&&U3.createElement(j,{paddingLeft:3},U3.createElement(z,{dimColor:!0},"and ",E," more‚Ä¶")))),Z&&U3.createElement(z,{dimColor:!0,italic:!0},I.pending?U3.createElement(U3.Fragment,null,"Press ",I.keyName," again to exit"):U3.createElement(LB,null,U3.createElement(R0,{shortcut:"Enter",action:"confirm"}),U3.createElement(R0,{shortcut:"Esc",action:"exit"})))))}var U3,x31,f50="__NO_PREFERENCE__";var y31=L(()=>{fA();l2();Y3();c9();AK();s4();l6();U3=o(WA(),1),x31=o(WA(),1)});import*as zN2 from"path";function t85({debug:A,ideSelection:Q,toolPermissionContext:B,setToolPermissionContext:G,apiKeyStatus:Z,commands:Y,agents:J,isLoading:I,verbose:X,messages:W,onAutoUpdaterResult:K,autoUpdaterResult:V,input:E,onInputChange:D,mode:H,onModeChange:F,stashedPrompt:C,setStashedPrompt:U,submitCount:O,onShowMessageSelector:q,mcpClients:M,pastedContents:_,setPastedContents:T,vimMode:y,setVimMode:h,showBashesDialog:x,setShowBashesDialog:m,showDiffDialog:g,setShowDiffDialog:t,tasksSelected:p,setTasksSelected:k,diffSelected:c,setDiffSelected:e,onExit:AA,getToolUseContext:VA,onSubmit:OA,isSearchingHistory:EA,setIsSearchingHistory:SA}){let yA=ai(),[ZA,GA]=BG.useState(!1),[zA,bA]=BG.useState({show:!1}),[TA,G1]=BG.useState(E.length),[YA,CA]=yQ(),{historyQuery:MA,setHistoryQuery:NA,historyMatch:UA,historyFailedMatch:LA}=EN2((t0)=>{let nQ=typeof t0==="string"?t0:t0.display;iA(nQ)},E,D,G1,TA,F,H,EA,SA),lA=BG.useMemo(()=>{let t0=Object.keys(_).map(Number);if(t0.length===0)return 1;return Math.max(...t0)+1},[_]),[gA,I1]=BG.useState(!1),[$1,RA]=BG.useState(!1),[B1,m1]=BG.useState(!1),[S1,H0]=BG.useState(!1),{suggestion:ZQ,markAccepted:o0,logOutcomeAtSubmission:EQ,markShown:WQ}=FN2({inputValue:E,isAssistantResponding:I}),w1=BG.useMemo(()=>EA&&UA?Ls(typeof UA==="string"?UA:UA.display):E,[EA,UA,E]),eA=BG.useMemo(()=>qB1(w1),[w1]),V1=BG.useMemo(()=>{let t0=[];if(EA&&UA&&!LA)t0.push({start:TA,end:TA+MA.length,style:{type:"solid",color:"warning"},priority:20});if(eA.length>0){let nQ=hMA(w1);if(nQ.level!=="none"){let xB=wB1[nQ.level],Y4=l02[nQ.level];for(let e4 of eA)t0.push({start:e4.start,end:e4.end,style:NB1(e4.word)?{type:"rainbow",useShimmer:!0}:{type:"shimmer",baseColor:xB,shimmerColor:Y4},priority:10})}}return t0},[EA,MA,UA,LA,TA,eA,w1]),{addNotification:R1}=xG();BG.useEffect(()=>{if(!eA.length)return;if(eA.length&&!YA.thinkingEnabled)R1({key:"thinking-toggled-via-keyword",jsx:a8.createElement(z,{color:"suggestion"},"Thinking on"),priority:"immediate",timeoutMs:3000})},[R1,YA.thinkingEnabled,CA,eA.length]);let[G0,U0]=BG.useState(!1),C0=xJA(G0?_61:0),HA=G0&&!C0,wA=BG.useRef(E.length);BG.useEffect(()=>{let t0=wA.current,nQ=E.length;if(t0>=20&&nQ<=5&&t0-nQ>=15){if(!d1().hasSeenStashHint)U0(!0),i0((e4)=>({...e4,hasSeenStashHint:!0}))}wA.current=nQ},[E.length]);let{pushToBuffer:tA,undo:N1,canUndo:C1,clearBuffer:D1}=YF2({maxBufferSize:50,debounceMs:1000});rw2({input:E,pastedContents:_,onInputChange:D,setCursorOffset:G1,setPastedContents:T});let X0=BN2({input:E,mode:H,submitCount:O}),p1=BG.useCallback((t0)=>{if(t0==="?"){r("tengu_help_toggled",{}),I1((kG)=>!kG);return}I1(!1);let nQ=t0.length===E.length+1,xB=TA===0,Y4=rk(t0);if(nQ&&xB&&Y4!=="prompt"){F(Y4);return}let e4=t0.replaceAll("\t","    ");if(E!==e4)tA(E,TA,_);D(e4)},[D,F,E,TA,tA,_]),{resetHistory:k0,onHistoryUp:KQ,onHistoryDown:bB,shouldShowSearchHint:IB,dismissSearchHint:W2,historyIndex:d0}=VD2((t0,nQ,xB)=>{p1(t0),F(nQ),T(xB)},E,_,G1);BG.useEffect(()=>{if(EA)W2()},[EA,W2]);function OQ(t0){k(t0==="tasks"),e(t0==="diff")}function fB(){if(F1.length>1)return;if(YA.queuedCommands.some((nQ)=>teA(nQ.mode))){T9();return}if(c){let nQ=Object.values(YA.tasks).filter((xB)=>xB.status==="running").length;OQ(nQ>0?"tasks":"none");return}if(p)OQ("none");else KQ()}function _9(){if(F1.length>1)return;let t0=Object.values(YA.tasks).filter((xB)=>xB.status==="running").length;if(p)return;if(c)return;if(bB()){if(t0>0){if(OQ("tasks"),!d1().hasSeenTasksHint)i0((Y4)=>{if(Y4.hasSeenTasksHint===!0)return Y4;return{...Y4,hasSeenTasksHint:!0}})}}}let[GB,K1]=BG.useState({suggestions:[],selectedSuggestion:-1,commandArgumentHint:void 0}),iA=BG.useCallback(async(t0,nQ=!1,xB)=>{if(p||c)return;if(t0.trim()==="")return;let Y4=GB.suggestions.length>0&&GB.suggestions.every((e4)=>e4.description==="directory");if(GB.suggestions.length>0&&!nQ&&!Y4)return;if(YA.promptSuggestion.text&&YA.promptSuggestion.shownAt>0)EQ(t0);await OA(t0,xB,{setCursorOffset:G1,clearBuffer:D1,resetHistory:k0})},[YA.promptSuggestion,p,c,GB.suggestions,OA,D1,k0,EQ]),{suggestions:F1,selectedSuggestion:A0,commandArgumentHint:D0}=CH2({commands:Y,onInputChange:D,onSubmit:iA,setCursorOffset:G1,input:E,cursorOffset:TA,mode:H,agents:J,setSuggestionsState:K1,suggestionsState:GB,suppressSuggestions:EA||d0>0,markAccepted:o0}),YQ=H==="prompt"&&F1.length===0&&ZQ?(()=>{return WQ(),ZQ+HN2})():X0;if(YA.promptSuggestion.text&&!ZQ&&YA.promptSuggestion.shownAt===0)cQ0("timing",YA.promptSuggestion.text),CA((t0)=>({...t0,promptSuggestion:{text:null,shownAt:0,acceptedAt:0}}));function Q2(t0,nQ,xB){r("tengu_paste_image",{}),F("prompt");let Y4={id:lA,type:"image",content:t0,mediaType:nQ||"image/png",dimensions:xB};T((e4)=>({...e4,[lA]:Y4})),b9(alQ(Y4.id))}function K9(t0){let nQ=oI(t0).replace(/\r/g,`
bundles/ClaudeAgentSDKCode/cli.js:1780:Reply with ONLY the suggestion text, no quotes, no explanation, no markdown.`})],cacheSafeParams:{...VB1(A),toolUseContext:{...A.toolUseContext,options:{...A.toolUseContext.options,maxThinkingTokens:0}}},canUseTool:async()=>({behavior:"deny",message:"No tools needed for suggestion",decisionReason:{type:"other",reason:"suggestion only"}}),querySource:"prompt_suggestion",forkLabel:"prompt_suggestion"}).then((B)=>{let Z=B.messages.find((J)=>J.type==="assistant")?.message?.content?.find((J)=>J.type==="text");return Z?.type==="text"?Z.text.trim():null})}function dD8(A){let Q=A.toLowerCase(),B=[["empty",()=>!A],["done",()=>Q==="done"],["too_long",()=>A.length>=100],["has_formatting",()=>/[\n*]|\*\*/.test(A)],["error_message",()=>/prompt is too long|context length|token limit/.test(Q)],["gratitude",()=>/thanks|thank you|looks good|that worked|that's all/.test(Q)]];for(let[G,Z]of B)if(Z())return NQ0(G,A),!0;return!1}function NQ0(A,Q){s("tengu_prompt_suggestion",{outcome:"suppressed",reason:A,...!1})}var uD8="tengu_prompt_suggestion",CB1=!1;var zB1=q(()=>{DB1();KB();w4();u0();_0();g1()});var gMA;var qQ0=q(()=>{gMA=class gMA{returned;queue=[];readResolve;readReject;isDone=!1;hasError;started=!1;constructor(A){this.returned=A}[Symbol.asyncIterator](){if(this.started)throw Error("Stream can only be iterated once");return this.started=!0,this}next(){if(this.queue.length>0)return Promise.resolve({done:!1,value:this.queue.shift()});if(this.isDone)return Promise.resolve({done:!0,value:void 0});if(this.hasError)return Promise.reject(this.hasError);return new Promise((A,Q)=>{this.readResolve=A,this.readReject=Q})}enqueue(A){if(this.readResolve){let Q=this.readResolve;this.readResolve=void 0,this.readReject=void 0,Q({done:!1,value:A})}else this.queue.push(A)}done(){if(this.isDone=!0,this.readResolve){let A=this.readResolve;this.readResolve=void 0,this.readReject=void 0,A({done:!0,value:void 0})}}error(A){if(this.hasError=A,this.readReject){let Q=this.readReject;this.readResolve=void 0,this.readReject=void 0,Q(A)}}return(){if(this.isDone=!0,this.returned)this.returned();return Promise.resolve({done:!0,value:void 0})}}});import{randomUUID as t12}from"crypto";function cD8(){return parseInt(process.env.CLAUDE_CODE_MAX_TOOL_USE_CONCURRENCY||"",10)||10}function*UB1(A,Q){for(let B of A){let G=B.message.content.filter((Z)=>Z.type==="tool_use");for(let Z of G)yield g0({content:[{type:"tool_result",content:Q,is_error:!0,tool_use_id:Z.id}],toolUseResult:Q})}}async function*kU({messages:A,systemPrompt:Q,userContext:B,systemContext:G,canUseTool:Z,toolUseContext:Y,autoCompactTracking:J,fallbackModel:I,stopHookActive:X,querySource:W}){let K=Y.options.sdkBetas;yield{type:"stream_request_start"},T1A("query_started");let V=Y.queryTracking?{chainId:Y.queryTracking.chainId,depth:Y.queryTracking.depth+1}:{chainId:t12(),depth:0},E=V.chainId;Y={...Y,queryTracking:V};let D=HT(A),H=J,F=await Ph(D,void 0,Y);if(D=F.messages,F.compactionInfo?.systemMessage)yield F.compactionInfo.systemMessage;let{compactionResult:C}=await xrB(D,Y,W);if(C){let{preCompactTokenCount:IA,postCompactTokenCount:PA,compactionUsage:kA}=C;if(s("tengu_auto_compact_succeeded",{originalMessageCount:A.length,compactedMessageCount:C.summaryMessages.length+C.attachments.length+C.hookResults.length,preCompactTokenCount:IA,postCompactTokenCount:PA,compactionInputTokens:kA?.input_tokens,compactionOutputTokens:kA?.output_tokens,compactionCacheReadTokens:kA?.cache_read_input_tokens??0,compactionCacheCreationTokens:kA?.cache_creation_input_tokens??0,compactionTotalTokens:kA?kA.input_tokens+(kA.cache_creation_input_tokens??0)+(kA.cache_read_input_tokens??0)+kA.output_tokens:0,queryChainId:E,queryDepth:V.depth}),!H?.compacted)H={compacted:!0,turnId:t12(),turnCounter:0};let YA=[C.boundaryMarker,...C.summaryMessages,...C.attachments,...C.hookResults,...C.messagesToKeep??[]];for(let ZA of YA)yield ZA;D=YA}Y={...Y,messages:D};let $=[],O=[],L=await JZ("tengu_streaming_tool_execution2")?new HQ0(Y.options.tools,Z,Y):null,_=await Y.getAppState(),T=_.toolPermissionContext.mode,x=Vs({permissionMode:T,mainLoopModel:Y.options.mainLoopModel,exceeds200kTokens:T==="plan"&&meA(D)}),b=j12(Q,G),v=void 0,m=!0;try{while(m){m=!1;try{let IA=!1;for await(let PA of cYA({messages:_1A(D,B),systemPrompt:b,maxThinkingTokens:Y.options.maxThinkingTokens,tools:Y.options.tools,signal:Y.abortController.signal,options:{async getToolPermissionContext(){return(await Y.getAppState()).toolPermissionContext},model:x,toolChoice:void 0,isNonInteractiveSession:Y.options.isNonInteractiveSession,fallbackModel:I,sdkBetas:K,onStreamingFallback:()=>{IA=!0},querySource:W,agents:Y.options.agentDefinitions.activeAgents,hasAppendSystemPrompt:Y.options.hasAppendSystemPrompt,fetchOverride:v,mcpTools:_.mcp.tools,queryTracking:V,taskIntensityOverride:F10(),agentIdOrSessionId:Y.agentId}})){if(IA){for(let kA of $)yield{type:"tombstone",message:kA};s("tengu_orphaned_messages_tombstoned",{orphanedMessageCount:$.length,queryChainId:E,queryDepth:V.depth}),yield*UB1($,"Streaming fallback triggered"),$.length=0}if(yield PA,PA.type==="assistant"){if($.push(PA),L){let kA=PA.message.content.filter((YA)=>YA.type==="tool_use");for(let YA of kA)L.addTool(YA,PA)}}if(L){for(let kA of L.getCompletedResults())if(kA.message)yield kA.message,O.push(...WY([kA.message]).filter((YA)=>YA.type==="user"))}}}catch(IA){if(IA instanceof beA&&I){x=I,m=!0,yield*UB1($,"Model fallback triggered"),$.length=0,Y.options.mainLoopModel=I,s("tengu_model_fallback_triggered",{original_model:IA.originalModel,fallback_model:I,entrypoint:"cli",queryChainId:E,queryDepth:V.depth}),yield ET(`Model fallback triggered: switching from ${IA.originalModel} to ${IA.fallbackModel}`,"info");continue}throw IA}}}catch(IA){r(IA instanceof Error?IA:Error(String(IA)));let PA=IA instanceof Error?IA.message:String(IA);s("tengu_query_error",{assistantMessages:$.length,toolUses:$.flatMap((kA)=>kA.message.content.filter((YA)=>YA.type==="tool_use")).length,queryChainId:E,queryDepth:V.depth}),yield*UB1($,PA),yield uMA({toolUse:!1}),Dq("Query error",IA);return}if($.length>0)d12([...D,...$],Q,B,G,Y,W);if($.some((IA)=>IA.message.content.some((PA)=>PA.type==="text"&&g12(PA.text))))s("tengu_model_response_keyword_detected",{is_overly_agreeable:!0,queryChainId:E,queryDepth:V.depth});if(Y.abortController.signal.aborted){if(!L)yield*UB1($,"Interrupted by user");yield uMA({toolUse:!1});return}let e=$.flatMap((IA)=>IA.message.content.filter((PA)=>PA.type==="tool_use"));if(!$.length||!e.length){yield*lD8(D,$,Q,B,G,Z,Y,W,H,I,X),yield*pD8(D,$,Q,B,G,Z,Y,W,H,I);return}let p=!1,k=Y;if(L){s("tengu_streaming_tool_execution_used",{tool_count:e.length,queryChainId:E,queryDepth:V.depth});for await(let IA of L.getRemainingResults()){let PA=IA.message;if(!PA)continue;if(yield PA,PA&&PA.type==="attachment"&&PA.attachment.type==="hook_stopped_continuation")p=!0;O.push(...WY([PA]).filter((kA)=>kA.type==="user"))}k={...L.getUpdatedContext(),queryTracking:V}}else{s("tengu_streaming_tool_execution_not_used",{tool_count:e.length,queryChainId:E,queryDepth:V.depth});for await(let IA of MQ0(e,$,Z,Y)){if(IA.message){if(yield IA.message,IA.message.type==="attachment"&&IA.message.attachment.type==="hook_stopped_continuation")p=!0;O.push(...WY([IA.message]).filter((PA)=>PA.type==="user"))}if(IA.newContext)k={...IA.newContext,queryTracking:V}}}if(Y.abortController.signal.aborted){yield uMA({toolUse:!0});return}if(p)return;if(H?.compacted)H.turnCounter++,s("tengu_post_autocompact_turn",{turnId:H.turnId,turnCounter:H.turnCounter,queryChainId:E,queryDepth:V.depth});let t=[...(await k.getAppState()).queuedCommands],AA=[];s("tengu_query_before_attachments",{messagesForQueryCount:D.length,assistantMessagesCount:$.length,toolResultsCount:O.length,queryChainId:E,queryDepth:V.depth});for await(let IA of mYA(null,k,null,t,[...D,...$,...O],W))if(yield IA,O.push(IA),DQ1(IA))AA.push(IA);let VA=O.filter((IA)=>IA.type==="attachment"&&IA.attachment.type==="edited_text_file").length;s("tengu_query_after_attachments",{totalToolResultsCount:O.length,fileChangeAttachmentCount:VA,queryChainId:E,queryDepth:V.depth}),Z_B(t,k.setAppState);let OA={...k,pendingSteeringAttachments:AA.length>0?AA:void 0,queryTracking:V};yield*kU({messages:[...D,...$,...O],systemPrompt:Q,userContext:B,systemContext:G,canUseTool:Z,toolUseContext:OA,autoCompactTracking:H,fallbackModel:I,stopHookActive:X,querySource:W})}async function*pD8(A,Q,B,G,Z,Y,J,I,X,W){if(J.pendingSteeringAttachments&&J.pendingSteeringAttachments.length>0){let K=[];for(let V of J.pendingSteeringAttachments){let E=V.attachment;if(E.type==="queued_command"){let D=g0({content:E.prompt,isMeta:!0});K.push(D)}}if(K.length>0){let V={...J,pendingSteeringAttachments:void 0};s("tengu_steering_attachment_resending",{queryChainId:J.queryTracking?.chainId,queryDepth:J.queryTracking?.depth}),yield*kU({messages:[...A,...Q,...K],systemPrompt:B,userContext:G,systemContext:Z,canUseTool:Y,toolUseContext:V,autoCompactTracking:X,fallbackModel:W,querySource:I})}return}}async function*lD8(A,Q,B,G,Z,Y,J,I,X,W,K){let V=Date.now(),E={messages:[...A,...Q],systemPrompt:B,userContext:G,systemContext:Z,toolUseContext:J,querySource:I};if(l12(E),process.env.CLAUDE_CODE_ENABLE_PROMPT_SUGGESTION!=="false")s12(E);try{let D=[],F=(await J.getAppState()).toolPermissionContext.mode,C=xQ0(F,J.abortController.signal,void 0,K??!1,J.agentId!==W0()?J.agentId:void 0,J,Q),$="",O=0,M=!1,L="",_=!1,T=[],x=[];for await(let b of C){if(b.message){if(yield b.message,b.message.type==="progress"&&b.message.toolUseID){$=b.message.toolUseID,O++;let v=b.message.data;if(v.command)x.push({command:v.command,promptText:v.promptText})}if(b.message.type==="attachment"){let v=b.message.attachment;if("hookEvent"in v&&(v.hookEvent==="Stop"||v.hookEvent==="SubagentStop")){if(v.type==="hook_non_blocking_error")T.push(v.stderr||`Exit code ${v.exitCode}`),_=!0;else if(v.type==="hook_error_during_execution")T.push(v.content),_=!0;else if(v.type==="hook_success"){if(v.stdout&&v.stdout.trim()||v.stderr&&v.stderr.trim())_=!0}}}}if(b.blockingError){let v=g0({content:TQ0(b.blockingError),isMeta:!0});D.push(v),yield v,_=!0,T.push(b.blockingError.blockingError)}if(b.preventContinuation)M=!0,L=b.stopReason||"Stop hook prevented continuation",yield r9({type:"hook_stopped_continuation",message:L,hookName:"Stop",toolUseID:$,hookEvent:"Stop"});if(J.abortController.signal.aborted){s("tengu_pre_stop_hooks_cancelled",{queryChainId:J.queryTracking?.chainId,queryDepth:J.queryTracking?.depth}),yield uMA({toolUse:!1});return}}if(O>0){if(yield B02(O,x,T,M,L,_,"suggestion",$),T.length>0)J.addNotification?.({key:"stop-hook-error",text:"Stop hook error occurred ¬∑ ctrl+o to see",priority:"immediate"})}if(M)return;if(D.length>0)yield*kU({messages:[...A,...Q,...D],systemPrompt:B,userContext:G,systemContext:Z,canUseTool:Y,toolUseContext:J,autoCompactTracking:X,fallbackModel:W,stopHookActive:!0,querySource:I})}catch(D){let H=Date.now()-V;s("tengu_stop_hook_error",{duration:H,queryChainId:J.queryTracking?.chainId,queryDepth:J.queryTracking?.depth}),yield ET(`Stop hook failed: ${D instanceof Error?D.message:String(D)}`,"warning")}}async function*MQ0(A,Q,B,G){let Z=G;for(let{isConcurrencySafe:Y,blocks:J}of iD8(A,Z))if(Y){let I={};for await(let X of aD8(J,Q,B,Z)){if(X.contextModifier){let{toolUseID:W,modifyContext:K}=X.contextModifier;if(!I[W])I[W]=[];I[W].push(K)}yield{message:X.message,newContext:Z}}for(let X of J){let W=I[X.id];if(!W)continue;for(let K of W)Z=K(Z)}yield{newContext:Z}}else for await(let I of nD8(J,Q,B,Z)){if(I.newContext)Z=I.newContext;yield{message:I.message,newContext:Z}}}function iD8(A,Q){return A.reduce((B,G)=>{let Z=Q.options.tools.find((I)=>I.name===G.name),Y=Z?.inputSchema.safeParse(G.input),J=Y?.success?Boolean(Z?.isConcurrencySafe(Y.data)):!1;if(J&&B[B.length-1]?.isConcurrencySafe)B[B.length-1].blocks.push(G);else B.push({isConcurrencySafe:J,blocks:[G]});return B},[])}async function*nD8(A,Q,B,G){let Z=G;for(let Y of A){G.setInProgressToolUseIDs((J)=>new Set([...J,Y.id]));for await(let J of WB1(Y,Q.find((I)=>I.message.content.some((X)=>X.type==="tool_use"&&X.id===Y.id)),B,Z)){if(J.contextModifier)Z=J.contextModifier.modifyContext(Z);yield{message:J.message,newContext:Z}}A02(G,Y.id)}}async function*aD8(A,Q,B,G){yield*GJA(A.map(async function*(Z){G.setInProgressToolUseIDs((Y)=>new Set([...Y,Z.id])),yield*WB1(Z,Q.find((Y)=>Y.message.content.some((J)=>J.type==="tool_use"&&J.id===Z.id)),B,G),A02(G,Z.id)}),cD8())}function A02(A,Q){A.setInProgressToolUseIDs((B)=>new Set([...B].filter((G)=>G!==Q)))}function oD8(A,Q){if(!A.startsWith("mcp__"))return;let B=HV(A);if(!B)return;let G=Q.find((Z)=>Z.name===B.serverName);if(G?.type==="connected")return G.config.type??"stdio";return}async function*WB1(A,Q,B,G){let Z=A.name,Y=$lQ(G.options.tools,Z),J=Q.message.id,I=Q.requestId,X=oD8(Z,G.options.mcpClients);if(!Y){s("tengu_tool_use_error",{error:`No such tool available: ${Z}`,toolName:Z,toolUseID:A.id,isMcp:Z.startsWith("mcp__"),queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}}),yield{message:g0({content:[{type:"tool_result",content:`<tool_use_error>Error: No such tool available: ${Z}</tool_use_error>`,is_error:!0,tool_use_id:A.id}],toolUseResult:`Error: No such tool available: ${Z}`})};return}let W=A.input;try{if(G.abortController.signal.aborted){s("tengu_tool_use_cancelled",{toolName:Y.name,toolUseID:A.id,isMcp:Y.isMcp??!1,queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}});let K=RQ0(A.id);yield{message:g0({content:[K],toolUseResult:ZJA})};return}for await(let K of rD8(Y,A.id,W,G,B,Q,J,I,X))yield K}catch(K){r(K instanceof Error?K:Error(String(K)));let V=K instanceof Error?K.message:String(K),D=`Error calling tool${Y?` (${Y.name})`:""}: ${V}`;yield{message:g0({content:[{type:"tool_result",content:`<tool_use_error>${D}</tool_use_error>`,is_error:!0,tool_use_id:A.id}],toolUseResult:D})}}}function rD8(A,Q,B,G,Z,Y,J,I,X){let W=new gMA;return sD8(A,Q,B,G,Z,Y,J,I,X,(K)=>{s("tengu_tool_use_progress",{messageID:J,toolName:A.name,isMcp:A.isMcp??!1,queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}}),W.enqueue({message:Q02({toolUseID:K.toolUseID,parentToolUseID:Q,data:K.data})})}).then((K)=>{for(let V of K)W.enqueue(V)}).catch((K)=>{W.error(K)}).finally(()=>{W.done()}),W}async function sD8(A,Q,B,G,Z,Y,J,I,X,W){let K=A.inputSchema.safeParse(B);if(!K.success){let T=QH8(A.name,K.error);return s("tengu_tool_use_error",{error:"InputValidationError",errorDetails:T.slice(0,2000),messageID:J,toolName:A.name,isMcp:A.isMcp??!1,queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}}),[{message:g0({content:[{type:"tool_result",content:`<tool_use_error>InputValidationError: ${T}</tool_use_error>`,is_error:!0,tool_use_id:Q}],toolUseResult:`InputValidationError: ${K.error.message}`})}]}let V=await A.validateInput?.(K.data,G);if(V?.result===!1)return s("tengu_tool_use_error",{messageID:J,toolName:A.name,error:V.message,errorCode:V.errorCode,isMcp:A.isMcp??!1,queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}}),[{message:g0({content:[{type:"tool_result",content:`<tool_use_error>${V.message}</tool_use_error>`,is_error:!0,tool_use_id:Q}],toolUseResult:`Error: ${V.message}`})}];let E=[],D=K.data,H=!1,F,C;for await(let T of AH8(G,A,D,Q,Y.message.id,I,X))switch(T.type){case"message":if(T.message.message.type==="progress")W(T.message.message);else E.push(T.message);break;case"hookPermissionResult":C=T.hookPermissionResult;break;case"preventContinuation":H=T.shouldPreventContinuation;break;case"stopReason":F=T.stopReason;break;case"stop":return E.push({message:g0({content:[RQ0(Q)],toolUseResult:`Error: ${F}`})}),E}let $={};if(D&&typeof D==="object"){if(A.name===W5&&"file_path"in D)$.file_path=String(D.file_path);else if((A.name===i6||A.name===oX)&&"file_path"in D)$.file_path=String(D.file_path);else if(A.name===n9&&"command"in D){let T=D;$.full_command=T.command}}alB(A.name,$),olB();let O;if(C!==void 0&&C.behavior==="allow"&&!A.requiresUserInteraction?.())f(`Hook approved tool use for ${A.name}, bypassing permission check`),O=C;else if(C!==void 0&&C.behavior==="allow"&&A.requiresUserInteraction?.())f(`Hook approved tool use for ${A.name}, but tool requires user interaction`),O=await Z(A,D,G,Y,Q);else if(C!==void 0&&C.behavior==="deny")f(`Hook denied tool use for ${A.name}`),O=C;else{let T=C?.behavior==="ask"?C:void 0;O=await Z(A,D,G,Y,Q,T)}if(O.decisionReason?.type==="hook"&&O.decisionReason.hookName==="PermissionRequest"&&O.behavior!=="ask")E.push({message:r9({type:"hook_permission_decision",decision:O.behavior,toolUseID:Q,hookEvent:"PermissionRequest"})});if(O.behavior!=="allow"){let T=G.toolDecisions?.get(Q);fe1("reject",T?.source||"unknown"),R01(),s("tengu_tool_use_can_use_tool_rejected",{messageID:J,toolName:A.name,queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}});let x=O.message;if(H&&!x)x=`Execution stopped by PreToolUse hook${F?`: ${F}`:""}`;return E.push({message:g0({content:[{type:"tool_result",content:x,is_error:!0,tool_use_id:Q}],toolUseResult:`Error: ${x}`})}),E}s("tengu_tool_use_can_use_tool_allowed",{messageID:J,toolName:A.name,queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}}),D=O.updatedInput;let M={};if(A.name===n9&&"command"in D){let T=D;M={bash_command:T.command.trim().split(/\s+/)[0]||"",full_command:T.command,...T.timeout!==void 0&&{timeout:T.timeout},...T.description!==void 0&&{description:T.description},..."dangerouslyDisableSandbox"in T&&{dangerouslyDisableSandbox:T.dangerouslyDisableSandbox}}}let L=G.toolDecisions?.get(Q);fe1(L?.decision||"unknown",L?.source||"unknown"),rlB();let _=Date.now();try{let T=await A.call(D,{...G,userModified:O.userModified??!1},Z,Y,(c)=>{s("tengu_tool_use_progress",{messageID:Y.message.id,toolName:A.name,isMcp:A.isMcp??!1,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}}),W({toolUseID:c.toolUseID,data:c.data})}),x=Date.now()-_;if($G1(x),T.data&&typeof T.data==="object"){let c={};if(A.name===W5&&"content"in T.data){if("file_path"in D)c.file_path=String(D.file_path);c.content=String(T.data.content)}if((A.name===i6||A.name===oX)&&"file_path"in D){if(c.file_path=String(D.file_path),A.name===i6&&"diff"in T.data)c.diff=String(T.data.diff);if(A.name===oX&&"content"in D)c.content=String(D.content)}if(A.name===n9&&"command"in D){let t=D;if(c.bash_command=t.command,"output"in T.data)c.output=String(T.data.output)}if(Object.keys(c).length>0)slB("tool.output",c)}if(typeof T==="object"&&"structured_output"in T)E.push({message:r9({type:"structured_output",data:T.structured_output})});be1({success:!0});let b=T.data&&typeof T.data==="object"?JSON.stringify(T.data):String(T.data??"");R01(b);let v=0;try{v=JSON.stringify(T.data).length}catch(c){r(c instanceof Error?c:Error(String(c)))}s("tengu_tool_use_success",{messageID:J,toolName:A.name,isMcp:A.isMcp??!1,durationMs:x,toolResultSizeBytes:v,queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}});let m=kM(A)?LQ0(A.name):null;jU("tool_result",{tool_name:A.name,success:"true",duration_ms:String(x),...Object.keys(M).length>0&&{tool_parameters:JSON.stringify(M)},tool_result_size_bytes:String(v),...L&&{decision_source:L.source,decision_type:L.decision},...m&&{mcp_server_scope:m}});let u=T.data,e=[],p=T.contextModifier;async function k(c){E.push({message:g0({content:[await aOB(A,c,Q)],toolUseResult:c}),contextModifier:p?{toolUseID:Q,modifyContext:p}:void 0})}if(!kM(A))await k(u);for await(let c of tD8(G,A,Q,Y.message.id,O,u,I,X))if("updatedMCPToolOutput"in c){if(kM(A))u=c.updatedMCPToolOutput}else if(kM(A))e.push(c);else E.push(c);if(kM(A))await k(u);if(T.newMessages&&T.newMessages.length>0)for(let c of T.newMessages)E.push({message:c});if(H)E.push({message:r9({type:"hook_stopped_continuation",message:F||"Execution stopped by hook",hookName:`PreToolUse:${A.name}`,toolUseID:Q,hookEvent:"PreToolUse"})});for(let c of e)E.push(c);return E}catch(T){let x=Date.now()-_;if($G1(x),be1({success:!1,error:T instanceof Error?T.message:String(T)}),R01(),!(T instanceof FJ)){if(!(T instanceof ej))r(T instanceof Error?T:Error(String(T)));s("tengu_tool_use_error",{messageID:J,toolName:A.name,error:T instanceof Error?T.constructor.name:"UnknownError",isMcp:A.isMcp??!1,queryChainId:G.queryTracking?.chainId,queryDepth:G.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}});let u=kM(A)?LQ0(A.name):null;jU("tool_result",{tool_name:A.name,use_id:Q,success:"false",duration_ms:String(x),error:T instanceof Error?T.message:String(T),...Object.keys(M).length>0&&{tool_parameters:JSON.stringify(M)},...L&&{decision_source:L.source,decision_type:L.decision},...u&&{mcp_server_scope:u}})}let b=$B1(T),v=T instanceof FJ,m=[];for await(let u of eD8(G,A,Q,J,D,b,v,I,X))m.push(u);return[{message:g0({content:[{type:"tool_result",content:b,is_error:!0,tool_use_id:Q}],toolUseResult:`Error: ${b}`})},...m]}finally{if(L)G.toolDecisions?.delete(Q)}}async function*tD8(A,Q,B,G,Z,Y,J,I){let X=Date.now();try{let K=(await A.getAppState()).toolPermissionContext.mode,V=Y;for await(let E of PQ0(Q.name,B,Z.updatedInput,V,A,K,A.abortController.signal))try{if(E.message?.type==="attachment"&&E.message.attachment.type==="hook_cancelled"){s("tengu_post_tool_hooks_cancelled",{toolName:Q.name,queryChainId:A.queryTracking?.chainId,queryDepth:A.queryTracking?.depth}),yield{message:r9({type:"hook_cancelled",hookName:`PostToolUse:${Q.name}`,toolUseID:B,hookEvent:"PostToolUse"})};continue}if(E.message)yield{message:E.message};if(E.blockingError)yield{message:r9({type:"hook_blocking_error",hookName:`PostToolUse:${Q.name}`,toolUseID:B,hookEvent:"PostToolUse",blockingError:E.blockingError})};if(E.preventContinuation){yield{message:r9({type:"hook_stopped_continuation",message:E.stopReason||"Execution stopped by PostToolUse hook",hookName:`PostToolUse:${Q.name}`,toolUseID:B,hookEvent:"PostToolUse"})};return}if(E.additionalContexts&&E.additionalContexts.length>0)yield{message:r9({type:"hook_additional_context",content:E.additionalContexts,hookName:`PostToolUse:${Q.name}`,toolUseID:B,hookEvent:"PostToolUse"})};if(E.updatedMCPToolOutput&&kM(Q))V=E.updatedMCPToolOutput,yield{updatedMCPToolOutput:V}}catch(D){let H=Date.now()-X;s("tengu_post_tool_hook_error",{messageID:G,toolName:Q.name,isMcp:Q.isMcp??!1,duration:H,queryChainId:A.queryTracking?.chainId,queryDepth:A.queryTracking?.depth,...I?{mcpServerType:I}:{},...J?{requestId:J}:{}}),yield{message:r9({type:"hook_error_during_execution",content:$B1(D),hookName:`PostToolUse:${Q.name}`,toolUseID:B,hookEvent:"PostToolUse"})}}}catch(W){r(W instanceof Error?W:Error(String(W)))}}async function*eD8(A,Q,B,G,Z,Y,J,I,X){let W=Date.now();try{let V=(await A.getAppState()).toolPermissionContext.mode;for await(let E of SQ0(Q.name,B,Z,Y,A,J,V,A.abortController.signal))try{if(E.message?.type==="attachment"&&E.message.attachment.type==="hook_cancelled"){s("tengu_post_tool_failure_hooks_cancelled",{toolName:Q.name,queryChainId:A.queryTracking?.chainId,queryDepth:A.queryTracking?.depth}),yield{message:r9({type:"hook_cancelled",hookName:`PostToolUseFailure:${Q.name}`,toolUseID:B,hookEvent:"PostToolUseFailure"})};continue}if(E.message)yield{message:E.message};if(E.blockingError)yield{message:r9({type:"hook_blocking_error",hookName:`PostToolUseFailure:${Q.name}`,toolUseID:B,hookEvent:"PostToolUseFailure",blockingError:E.blockingError})};if(E.additionalContexts&&E.additionalContexts.length>0)yield{message:r9({type:"hook_additional_context",content:E.additionalContexts,hookName:`PostToolUseFailure:${Q.name}`,toolUseID:B,hookEvent:"PostToolUseFailure"})}}catch(D){let H=Date.now()-W;s("tengu_post_tool_failure_hook_error",{messageID:G,toolName:Q.name,isMcp:Q.isMcp??!1,duration:H,queryChainId:A.queryTracking?.chainId,queryDepth:A.queryTracking?.depth,...X?{mcpServerType:X}:{},...I?{requestId:I}:{}}),yield{message:r9({type:"hook_error_during_execution",content:$B1(D),hookName:`PostToolUseFailure:${Q.name}`,toolUseID:B,hookEvent:"PostToolUseFailure"})}}}catch(K){r(K instanceof Error?K:Error(String(K)))}}async function*AH8(A,Q,B,G,Z,Y,J){let I=Date.now();try{let X=await A.getAppState();for await(let W of jQ0(Q.name,G,B,A,X.toolPermissionContext.mode,A.abortController.signal))try{if(W.message)yield{type:"message",message:{message:W.message}};if(W.blockingError){let K=_Q0(`PreToolUse:${Q.name}`,W.blockingError);yield{type:"hookPermissionResult",hookPermissionResult:{behavior:"deny",message:K,decisionReason:{type:"hook",hookName:`PreToolUse:${Q.name}`,reason:K}}}}if(W.preventContinuation){if(yield{type:"preventContinuation",shouldPreventContinuation:!0},W.stopReason)yield{type:"stopReason",stopReason:W.stopReason}}if(W.permissionBehavior!==void 0){f(`Hook result has permissionBehavior=${W.permissionBehavior}`);let K={type:"hook",hookName:`PreToolUse:${Q.name}`,reason:W.hookPermissionDecisionReason};if(W.permissionBehavior==="allow")yield{type:"hookPermissionResult",hookPermissionResult:{behavior:"allow",updatedInput:W.updatedInput||B,decisionReason:K}};else yield{type:"hookPermissionResult",hookPermissionResult:{behavior:W.permissionBehavior,message:W.hookPermissionDecisionReason||`Hook PreToolUse:${Q.name} ${JRB(W.permissionBehavior)} this tool`,decisionReason:K}}}if(A.abortController.signal.aborted){s("tengu_pre_tool_hooks_cancelled",{toolName:Q.name,queryChainId:A.queryTracking?.chainId,queryDepth:A.queryTracking?.depth}),yield{type:"message",message:{message:r9({type:"hook_cancelled",hookName:`PreToolUse:${Q.name}`,toolUseID:G,hookEvent:"PreToolUse"})}},yield{type:"stop"};return}}catch(K){r(K instanceof Error?K:Error(String(K)));let V=Date.now()-I;s("tengu_pre_tool_hook_error",{messageID:Z,toolName:Q.name,isMcp:Q.isMcp??!1,duration:V,queryChainId:A.queryTracking?.chainId,queryDepth:A.queryTracking?.depth,...J?{mcpServerType:J}:{},...Y?{requestId:Y}:{}}),yield{type:"message",message:{message:r9({type:"hook_error_during_execution",content:$B1(K),hookName:`PreToolUse:${Q.name}`,toolUseID:G,hookEvent:"PreToolUse"})}},yield{type:"stop"}}}catch(X){r(X instanceof Error?X:Error(String(X))),yield{type:"stop"};return}}function $B1(A){if(A instanceof FJ)return A.message||fM;if(!(A instanceof Error))return String(A);let B=OQ0(A).filter(Boolean).join(`
bundles/ClaudeAgentSDKCode/cli.js:2631:`)}function tU2(){let{columns:A}=SB(),[{inbox:Q}]=RQ(),B=Q.messages.filter((J)=>J.status==="pending");if(B.length===0)return null;let G=B.slice(0,B65),Z=B.length-G.length,Y=Math.max(20,A-4-2-4);return gT.createElement(j,{marginTop:1,paddingLeft:2,flexDirection:"column",width:A-4},gT.createElement(z,{dimColor:!0},"Queued teammate ",B.length===1?"message":"messages",":"),G.map((J,I)=>gT.createElement(z,{key:I,color:G65(J.color),wrap:"wrap"},"‚óè ",gT.createElement(z,{bold:!0},J.from,":")," ",Z65(J.text,Q65,Y))),Z>0&&gT.createElement(z,{dimColor:!0},"(...",Z," more)"))}var gT,A65="ansi:cyan",Q65=3,B65=2;var eU2=q(()=>{hA();y3();f2();gT=o(KA(),1)});function A$2({hasStash:A}){if(!A)return null;return U_A.createElement(j,{paddingLeft:2},U_A.createElement(z,{dimColor:!0},X1.pointerSmall," Stashed (auto-restores after submit)"))}var U_A;var Q$2=q(()=>{hA();v2();U_A=o(KA(),1)});function B$2(A,Q,B,G,Z,Y,J,I,X){let[W,K]=SN.useState(""),[V,E]=SN.useState(!1),[D,H]=SN.useState(""),[F,C]=SN.useState(0),[$,O]=SN.useState("prompt"),[M,L]=SN.useState(void 0),_=SN.useRef(void 0),T=SN.useRef(new Set),x=SN.useRef(null);function b(){if(_.current)_.current.return(void 0),_.current=void 0}function v(){X(!1),K(""),E(!1),H(""),C(0),O("prompt"),L(void 0),b(),T.current.clear()}async function m(u,e){if(!I)return;if(W.length===0){b(),T.current.clear(),L(void 0),E(!1),B(D),G(F),Y($);return}if(!u)b(),_.current=kcA(),T.current.clear();if(!_.current)return;while(!0){if(e?.aborted)return;let p=await _.current.next();if(p.done){E(!0);return}let k=p.value.display,c=k.lastIndexOf(W);if(c!==-1&&!T.current.has(k)){T.current.add(k),L(p.value),E(!1);let t=zf(k);Y(t),B(k);let VA=hs(k).lastIndexOf(W);G(VA!==-1?VA:c);return}}}return f1((u,e)=>{if(I){if(e.ctrl&&u==="r")m(!0);else if(e.escape||e.tab){if(M){let p=typeof M==="string"?M:M.display,k=zf(p),c=hs(p);B(c),Y(k)}v()}else if(e.ctrl&&u==="c"||e.backspace&&W==="")B(D),G(F),v();else if(e.return){if(W.length===0)A({display:D,pastedContents:{}});else if(M){let p=typeof M==="string"?M:M.display,k=zf(p),c=hs(p);Y(k),A({display:c,pastedContents:{}})}v()}}else if(e.ctrl&&u==="r")X(!0),H(Q),C(Z),O(J),_.current=kcA(),T.current.clear()},{isActive:!0}),SN.useEffect(()=>{x.current?.abort();let u=new AbortController;return x.current=u,m(!1,u.signal),()=>{u.abort()}},[W]),{historyQuery:W,setHistoryQuery:K,historyMatch:M,historyFailedMatch:V}}var SN;var G$2=q(()=>{hA();Xc();SN=o(KA(),1)});function Y$2({inputValue:A,isAssistantResponding:Q}){let[B,G]=RQ(),{text:Z,shownAt:Y,acceptedAt:J}=B.promptSuggestion,I=Q||A.length>0?null:Z,X=Z&&Y>0,W=$_A.useCallback(()=>{G((D)=>({...D,promptSuggestion:{text:null,shownAt:0,acceptedAt:0}}))},[G]),K=$_A.useCallback(()=>{if(!X)return;G((D)=>({...D,promptSuggestion:{...D.promptSuggestion,acceptedAt:Date.now()}}))},[X,G]),V=$_A.useCallback(()=>{if(I&&Y===0)G((D)=>({...D,promptSuggestion:{...D.promptSuggestion,shownAt:Date.now()}}))},[I,Y,G]),E=$_A.useCallback((D)=>{if(!X)return;let H=J>Y||D===Z,F=H?J||Date.now():Date.now();s("tengu_prompt_suggestion",{outcome:H?"accepted":"ignored",...H&&{timeToAcceptMs:F-Y},...!H&&{timeToIgnoreMs:F-Y},...!1}),W()},[X,J,Y,Z,W]);return{suggestion:I,markAccepted:K,markShown:V,logOutcomeAtSubmission:E}}var $_A,Z$2=" (tab to accept)";var J$2=q(()=>{f2();_0();$_A=o(KA(),1)});function yIA({initial:A,sessionModel:Q,onSelect:B,onCancel:G,isStandaloneCommand:Z}){let Y=A===null?Q50:A,J=10,I=jQ(),X=K61.useMemo(()=>wmA(),[]),W=K61.useMemo(()=>X.map((D)=>({...D,value:D.value===null?Q50:D.value})),[X]),K=K61.useMemo(()=>W.some((D)=>D.value===Y)?Y:W[0]?.value??void 0,[W,Y]),V=Math.min(10,W.length),E=Math.max(0,W.length-V);return N6.createElement(j,{flexDirection:"column",width:"100%"},Z&&N6.createElement(a8,{dividerColor:"permission",dividerDimColor:!1}),N6.createElement(j,{flexDirection:"column",paddingX:Z?1:0},N6.createElement(j,{flexDirection:"column"},N6.createElement(j,{marginBottom:1,flexDirection:"column"},N6.createElement(z,{color:"remember",bold:!0},"Select model"),N6.createElement(z,{dimColor:!0},"Switch between Claude models. Applies to this session and future Claude Code sessions. For other/previous model names, specify with --model."),Q&&N6.createElement(z,{dimColor:!0},"Currently using ",DL(Q)," for this session (set by plan mode). Selecting a model will undo this.")),N6.createElement(j,{flexDirection:"column",marginBottom:1},N6.createElement(j,{flexDirection:"column"},N6.createElement(S0,{defaultValue:Y,defaultFocusValue:K,options:W,onChange:(D)=>B(D===Q50?null:D),onCancel:G??(()=>{}),visibleOptionCount:V})),E>0&&N6.createElement(j,{paddingLeft:3},N6.createElement(z,{dimColor:!0},"and ",E," more‚Ä¶")))),Z&&N6.createElement(z,{dimColor:!0,italic:!0},I.pending?N6.createElement(N6.Fragment,null,"Press ",I.keyName," again to exit"):N6.createElement($B,null,N6.createElement(L0,{shortcut:"Enter",action:"confirm"}),N6.createElement(L0,{shortcut:"Esc",action:"exit"})))))}var N6,K61,Q50="__NO_PREFERENCE__";var V61=q(()=>{hA();d2();G6();o9();AK();t4();i3();N6=o(KA(),1),K61=o(KA(),1)});import*as I$2 from"path";function Y65({debug:A,ideSelection:Q,toolPermissionContext:B,setToolPermissionContext:G,apiKeyStatus:Z,commands:Y,agents:J,isLoading:I,verbose:X,messages:W,onAutoUpdaterResult:K,autoUpdaterResult:V,input:E,onInputChange:D,mode:H,onModeChange:F,stashedPrompt:C,setStashedPrompt:$,submitCount:O,onShowMessageSelector:M,mcpClients:L,pastedContents:_,setPastedContents:T,vimMode:x,setVimMode:b,showBashesDialog:v,setShowBashesDialog:m,showDiffDialog:u,setShowDiffDialog:e,tasksSelected:p,setTasksSelected:k,diffSelected:c,setDiffSelected:t,onExit:AA,getToolUseContext:VA,onSubmit:OA,isSearchingHistory:IA,setIsSearchingHistory:PA}){let kA=En(),[YA,ZA]=YG.useState(!1),[zA,bA]=YG.useState({show:!1}),[TA,B1]=YG.useState(E.length),[JA,CA]=RQ(),{historyQuery:MA,setHistoryQuery:NA,historyMatch:UA,historyFailedMatch:LA}=B$2((s0)=>{let mQ=typeof s0==="string"?s0:s0.display;iA(mQ)},E,D,B1,TA,F,H,IA,PA),nA=YG.useMemo(()=>{let s0=Object.keys(_).map(Number);if(s0.length===0)return 1;return Math.max(...s0)+1},[_]),[gA,I1]=YG.useState(!1),[q1,_A]=YG.useState(!1),[Q1,h1]=YG.useState(!1),[_1,V0]=YG.useState(!1),{suggestion:AQ,markAccepted:n0,logOutcomeAtSubmission:JQ,markShown:BQ}=Y$2({inputValue:E,isAssistantResponding:I}),F1=YG.useMemo(()=>IA&&UA?hs(typeof UA==="string"?UA:UA.display):E,[IA,UA,E]),eA=YG.useMemo(()=>qB1(F1),[F1]),K1=YG.useMemo(()=>{let s0=[];if(IA&&UA&&!LA)s0.push({start:TA,end:TA+MA.length,style:{type:"solid",color:"warning"},priority:20});if(eA.length>0){let mQ=dMA(F1);if(mQ.level!=="none"){let XB=wB1[mQ.level],e9=G02[mQ.level];for(let x2 of eA)s0.push({start:x2.start,end:x2.end,style:NB1(x2.word)?{type:"rainbow",useShimmer:!0}:{type:"shimmer",baseColor:XB,shimmerColor:e9},priority:10})}}return s0},[IA,MA,UA,LA,TA,eA,F1]),{addNotification:O1}=fG();YG.useEffect(()=>{if(!eA.length)return;if(eA.length&&!JA.thinkingEnabled)O1({key:"thinking-toggled-via-keyword",jsx:r8.createElement(z,{color:"suggestion"},"Thinking on"),priority:"immediate",timeoutMs:3000})},[O1,JA.thinkingEnabled,CA,eA.length]);let[G0,$0]=YG.useState(!1),F0=yJA(G0?M31:0),HA=G0&&!F0,$A=YG.useRef(E.length);YG.useEffect(()=>{let s0=$A.current,mQ=E.length;if(s0>=20&&mQ<=5&&s0-mQ>=15){if(!c1().hasSeenStashHint)$0(!0),i0((x2)=>({...x2,hasSeenStashHint:!0}))}$A.current=mQ},[E.length]);let{pushToBuffer:A1,undo:N1,canUndo:C1,clearBuffer:D1}=HH2({maxBufferSize:50,debounceMs:1000});uU2({input:E,pastedContents:_,onInputChange:D,setCursorOffset:B1,setPastedContents:T});let B0=iU2({input:E,mode:H,submitCount:O}),i1=YG.useCallback((s0)=>{if(s0==="?"){s("tengu_help_toggled",{}),I1((WG)=>!WG);return}I1(!1);let mQ=s0.length===E.length+1,XB=TA===0,e9=zf(s0);if(mQ&&XB&&e9!=="prompt"){F(e9);return}let x2=s0.replaceAll("\t","    ");if(E!==x2)A1(E,TA,_);D(x2)},[D,F,E,TA,A1,_]),{resetHistory:P0,onHistoryUp:IQ,onHistoryDown:fB,shouldShowSearchHint:oQ,dismissSearchHint:H2,historyIndex:d0}=wE2((s0,mQ,XB)=>{i1(s0),F(mQ),T(XB)},E,_,B1);YG.useEffect(()=>{if(IA)H2()},[IA,H2]);function NQ(s0){k(s0==="tasks"),t(s0==="diff")}function RB(){if(z1.length>1)return;if(JA.queuedCommands.length>0){B9();return}if(c){let s0=Object.values(JA.tasks).filter((mQ)=>mQ.status==="running").length;NQ(s0>0?"tasks":"none");return}if(p)NQ("none");else IQ()}function z9(){if(z1.length>1)return;let s0=Object.values(JA.tasks).filter((XB)=>XB.status==="running").length;if(p)return;if(c)return;if(fB()){if(s0>0){if(NQ("tasks"),!c1().hasSeenTasksHint)i0((e9)=>{if(e9.hasSeenTasksHint===!0)return e9;return{...e9,hasSeenTasksHint:!0}})}}}let[JB,V1]=YG.useState({suggestions:[],selectedSuggestion:-1,commandArgumentHint:void 0}),iA=YG.useCallback(async(s0,mQ=!1,XB)=>{if(p||c)return;if(s0.trim()==="")return;let e9=JB.suggestions.length>0&&JB.suggestions.every((x2)=>x2.description==="directory");if(JB.suggestions.length>0&&!mQ&&!e9)return;if(JA.promptSuggestion.text&&JA.promptSuggestion.shownAt>0)JQ(s0);await OA(s0,XB,{setCursorOffset:B1,clearBuffer:D1,resetHistory:P0})},[JA.promptSuggestion,p,c,JB.suggestions,OA,D1,P0,JQ]),{suggestions:z1,selectedSuggestion:A0,commandArgumentHint:E0}=OD2({commands:Y,onInputChange:D,onSubmit:iA,setCursorOffset:B1,input:E,cursorOffset:TA,mode:H,agents:J,setSuggestionsState:V1,suggestionsState:JB,suppressSuggestions:IA||d0>0,markAccepted:n0}),xQ=H==="prompt"&&z1.length===0&&AQ?(()=>{return BQ(),AQ+Z$2})():B0;if(JA.promptSuggestion.text&&!AQ&&JA.promptSuggestion.shownAt===0)NQ0("timing",JA.promptSuggestion.text),CA((s0)=>({...s0,promptSuggestion:{text:null,shownAt:0,acceptedAt:0}}));function eB(s0,mQ,XB){s("tengu_paste_image",{}),F("prompt");let e9={id:nA,type:"image",content:s0,mediaType:mQ||"image/png",dimensions:XB};T((x2)=>({...x2,[nA]:e9})),Q9(DlQ(e9.id))}function X9(s0){let mQ=cI(s0).replace(/\r/g,`[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"XJ8\\(|DI8\\(\" bundles/ClaudeAgentSDKCode/cli.js bundles/ClaudeCodeCode/cli.js | head -n 20"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 41ms:[0m
[2mbundles/ClaudeAgentSDKCode/cli.js:1586:`))}}function PoB(A){for(let[Q,B]of Object.entries(A))if(typeof B!=="string"){let G=Error(`Invalid header value for "${Q}": headers must be strings, got ${typeof B}`);throw r(G),G}}var SoB=q(()=>{rZ();o2();_0();g1()});import{randomUUID as ZJ8}from"crypto";function YJ8(A){if(A===null)return ET("Session resumed","suggestion");let Q=A instanceof oZ?A.formattedMessage:A.message;return ET(`Session resumed without branch: ${Q}`,"warning")}function JJ8(){return g0({content:`This session is being continued from another machine. Application state may have changed. The updated working directory is ${cQ()}`,isMeta:!0})}async function XJ8(A,Q){let B=A.length>75?A.slice(0,75)+"‚Ä¶":A,G="claude/task";try{let Z=IJ8.replace("{description}",A),Y="<title>",I=(await QW({systemPrompt:[],userPrompt:Z,assistantPrompt:"<title>",signal:Q,options:{querySource:"teleport_generate_title",agents:[],isNonInteractiveSession:!1,hasAppendSystemPrompt:!1,mcpTools:[],agentIdOrSessionId:W0()}})).message.content[0];if(I?.type==="text"){let X="<title>"+I.text.trim(),W=X.match(/<title>(.*?)<\/title>/s),K=W?W[1]?.trim():B,V=X.match(/<branch>(.*?)<\/branch>/s),E=V?V[1]?.trim():"claude/task";return{title:K||B,branchName:E||"claude/task"}}}catch(Z){r(Error(`Error generating title and branch: ${Z}`))}return{title:B,branchName:"claude/task"}}async function WQ1(){if(!await Bt())throw s("tengu_teleport_error_git_not_clean",{}),new oZ("Git working directory is not clean. Please commit or stash your changes before using --teleport.",pA.red(`Error: Git working directory is not clean. Please commit or stash your changes before using --teleport.
bundles/ClaudeAgentSDKCode/cli.js:1597:${pA.dim("Run /status in Claude Code to check your account.")}`);throw r(Y),Error(`Failed to fetch session from Sessions API: ${Y.message}`)}}async function KMA(A){let{initialMessage:Q,description:B,signal:G}=A;try{await pk();let Z=r3()?.accessToken;if(!Z)return r(Error("No access token found for remote session creation")),null;let Y=await AP();if(!Y)return r(Error("Unable to get organization UUID for remote session creation")),null;let J=await EM(),I=null,X=null,{title:W,branchName:K}=await XJ8(B||Q||"Background task",G);if(J){let[x,b]=J.split("/");if(x&&b)I={type:"git_repository",url:`https://github.com/${x}/${b}`,revision:A.branchName},X={type:"git_repository",git_info:{type:"github",repo:`${x}/${b}`,branches:[K]}};else r(Error(`Invalid repository format: ${J} - expected 'owner/name'`))}let V=await gYA();if(!V||V.length===0)return r(Error("No environments available for session creation")),null;let D=CQ()?.remote?.defaultEnvironmentId,H=V[0];if(D){let x=V.find((b)=>b.environment_id===D);if(x)H=x,f(`Using configured default environment: ${D}`);else f(`Configured default environment ${D} not found in available environments, using first available`)}if(!H)return r(Error("No environments available for session creation")),null;let F=H.environment_id;f(`Selected environment: ${F} (${H.name})`);let C=`${k9().BASE_API_URL}/v1/sessions`,$={...oW(Z),"x-organization-uuid":Y},O={sources:I?[I]:[],outcomes:X?[X]:[],model:c8()},M=Q?[{type:"event",data:{uuid:ZJ8(),session_id:"",type:"user",parent_tool_use_id:null,message:{role:"user",content:Q}}}]:[],L={title:W,events:M,session_context:O,environment_id:F};f(`Creating session with payload: ${JSON.stringify(L,null,2)}`);let _=await FQ.post(C,L,{headers:$,signal:G});if(_.status!==200&&_.status!==201)return r(Error(`API request failed with status ${_.status}: ${_.statusText}
bundles/ClaudeAgentSDKCode/cli.js:1644:${W.newCustomInstructions}`:W.newCustomInstructions;let K=W.userDisplayMessage;Q.setStreamMode?.("requesting"),Q.setResponseLength?.(()=>0),Q.setSpinnerMessage?.("Compacting conversation");let V=La1(G),E=g0({content:V}),H=cYA({messages:WY([...HT(A),E]),systemPrompt:["You are a helpful AI assistant tasked with summarizing conversations."],maxThinkingTokens:0,tools:[H6],signal:Q.abortController.signal,options:{async getToolPermissionContext(){return(await Q.getAppState()).toolPermissionContext},model:c8(),toolChoice:void 0,isNonInteractiveSession:Q.options.isNonInteractiveSession,hasAppendSystemPrompt:Q.options.hasAppendSystemPrompt,maxOutputTokensOverride:UG1,querySource:"compact",agents:Q.options.agentDefinitions.activeAgents,mcpTools:[],agentIdOrSessionId:W0()}})[Symbol.asyncIterator](),F=await H.next(),C=!1,$;while(!F.done){let k=F.value;if(!C&&k.type==="stream_event"&&k.event.type==="content_block_start"&&k.event.content_block.type==="text")C=!0,Q.setStreamMode?.("responding");if(k.type==="stream_event"&&k.event.type==="content_block_delta"&&k.event.delta.type==="text_delta"){let c=k.event.delta.text.length;Q.setResponseLength?.((t)=>t+c)}if(k.type==="assistant")$=k;F=await H.next()}if(!$)throw Error("Failed to get summary response from streaming");let O=w1A($);if(!O)throw s("tengu_compact_failed",{reason:"no_summary",preCompactTokenCount:Y}),Error("Failed to generate conversation summary - response did not contain valid text content");else if(O.startsWith(tW))throw s("tengu_compact_failed",{reason:"api_error",preCompactTokenCount:Y}),Error(O);else if(O.startsWith(IZA))throw s("tengu_compact_failed",{reason:"prompt_too_long",preCompactTokenCount:Y}),Error(EI8);let M=URB(Q.readFileState);Q.readFileState.clear();let[L,_]=await Promise.all([HI8(M,Q,WI8),CI8(Q)]),T=[...L,..._],x=FI8(Q.agentId);if(x)T.push(x);let b=Z10(Q.agentId);if(b)T.push(b);Q.setSpinnerMessage?.("Running SessionStart hooks...");let v=await NU("compact"),m=qV([$]),u=ueA($);s("tengu_compact",{preCompactTokenCount:Y,postCompactTokenCount:m,compactionInputTokens:u?.input_tokens,compactionOutputTokens:u?.output_tokens,compactionCacheReadTokens:u?.cache_read_input_tokens??0,compactionCacheCreationTokens:u?.cache_creation_input_tokens??0,compactionTotalTokens:u?u.input_tokens+(u.cache_creation_input_tokens??0)+(u.cache_read_input_tokens??0)+u.output_tokens:0,...I});let e=zQ1(Z?"auto":"manual",Y??0),p=[g0({content:deA(O,B),isCompactSummary:!0,isVisibleInTranscriptOnly:!0})];return{boundaryMarker:e,summaryMessages:p,attachments:T,hookResults:v,userDisplayMessage:K,preCompactTokenCount:Y,postCompactTokenCount:m,compactionUsage:u}}catch(Y){throw DI8(Y,Q),Y}finally{Q.setStreamMode?.("requesting"),Q.setResponseLength?.(()=>0),Q.setSpinnerMessage?.(null),Q.setSDKStatus?.(null),Q.setSpinnerColor?.(null),Q.setSpinnerShimmerColor?.(null)}}function DI8(A,Q){if(!gKA(A,EMA)&&!gKA(A,VMA))Q.addNotification?.({key:"error-compacting-conversation",text:"Error compacting conversation",priority:"immediate",color:"error"})}async function HI8(A,Q,B){let G=Object.entries(A).map(([J,I])=>({filename:J,...I})).filter((J)=>!zI8(J.filename,Q.agentId)).sort((J,I)=>I.timestamp-J.timestamp).slice(0,B),Z=await Promise.all(G.map(async(J)=>{let I=await Q10(J.filename,{...Q,fileReadingLimits:{maxTokens:VI8}},"tengu_post_compact_file_restore_success","tengu_post_compact_file_restore_error","compact");return I?r9(I):null})),Y=0;return Z.filter((J)=>{if(J===null)return!1;let I=jG(JSON.stringify(J));if(Y+I<=KI8)return Y+=I,!0;return!1})}function FI8(A){let Q=eb(A);if(Q.length===0)return null;return r9({type:"todo",content:Q,itemCount:Q.length,context:"post-compact"})}function Z10(A){let Q=XU(A);if(!Q)return null;let B=sF(A);return r9({type:"plan_file_reference",planFilePath:B,planContent:Q})}async function CI8(A){let Q=await A.getAppState();return Object.values(Q.tasks).filter((G)=>G.type==="local_agent").flatMap((G)=>{if(G.retrieved)return[];let{status:Z}=G;if(Z==="completed"||Z==="failed"||Z==="killed")return[r9({type:"task_status",taskId:G.agentId,taskType:"local_agent",description:G.description,status:Z,deltaSummary:G.error??null})];return[]})}function zI8(A,Q){let B=Rp(A);try{let G=Rp(Ml(Q));if(B===G)return!0}catch{}try{let G=Rp(sF(Q));if(B===G)return!0}catch{}try{if(new Set(HrB.map((Z)=>Rp(yAA(Z)))).has(B))return!0}catch{}return!1}var WI8=5,KI8=50000,VI8=5000,VMA="Not enough messages to compact.",EI8="Conversation too long. Press esc twice to go up a few messages and try again.",EMA="API Error: Request was aborted.";var DMA=q(()=>{PG();wM();KB();_0();rZ();NM();bw();nw();Ma1();d2();OM();Ol();vQ();tF();N9();G10();nL();UrB();g1();aw();uAA();u0()});function wrB(){return $rB}function NrB(A){$rB=A}function qrB(){UQ1=Date.now()}function LrB(){UQ1=void 0}async function MrB(){let A=Date.now();while(UQ1){if(Date.now()-UQ1>$I8)return;if(Date.now()-A>UI8)return;await new Promise((B)=>setTimeout(B,1000))}}function OrB(){let A=jA(),Q=$Q1();if(!A.existsSync(Q))return null;return A.readFileSync(Q,{encoding:"utf-8"})}var UI8=15000,$I8=60000,$rB,UQ1;var J10=q(()=>{YQ();mY()});function wI8(A){return typeof A==="string"&&(A===Ba1||A.includes(OeA))}function OI8(A,Q){if(!Q.some((G)=>G.type==="assistant")&&!W10.has(A)){if(u7("cc_microcompact_ext","mc_disabled",!1))W10.add(A)}return W10.has(A)}function TrB(A){if(!A.content)return 0;if(typeof A.content==="string")return jG(A.content);return A.content.reduce((Q,B)=>{if(B.type==="text")return Q+jG(B.text);else if(B.type==="image")return Q+_rB;return Q},0)}function RI8(A,Q){let B=RrB.get(A);if(B===void 0)B=TrB(Q),RrB.set(A,B);return B}function K10(A){let Q=0;for(let B of A){if(B.type!=="user"&&B.type!=="assistant")continue;if(!Array.isArray(B.message.content))continue;for(let G of B.message.content)if(G.type==="text")Q+=jG(G.text);else if(G.type==="tool_result")Q+=TrB(G);else if(G.type==="image")Q+=_rB;else Q+=jG(JSON.stringify(G))}return Math.ceil(Q*1.3333333333333333)}function _I8(A){return wQ1.push(A),()=>{wQ1=wQ1.filter((Q)=>Q!==A)}}function TI8(){wQ1.forEach((A)=>A())}async function Ph(A,Q,B){if(NQ1=!1,C0(process.env.DISABLE_MICROCOMPACT))return{messages:A};if(OI8(W0(),A))return{messages:A};C0(process.env.USE_API_CONTEXT_MANAGEMENT);let G=Q!==void 0,Z=G?Q:qI8,Y=[],J=new Map;for(let D of A)if((D.type==="user"||D.type==="assistant")&&Array.isArray(D.message.content)){for(let H of D.message.content)if(H.type==="tool_use"&&MI8.has(H.name)){if(!I10.has(H.id))Y.push(H.id)}else if(H.type==="tool_result"&&Y.includes(H.tool_use_id)){let F=RI8(H.tool_use_id,H);J.set(H.tool_use_id,F)}}let I=Y.slice(-LI8),X=Array.from(J.values()).reduce((D,H)=>D+H,0),W=0,K=new Set;for(let D of Y){if(I.includes(D))continue;if(X-W>Z)K.add(D),W+=J.get(D)||0}if(!G){let D=qV(A);if(!q1A(D).isAboveWarningThreshold||W<NI8)K.clear(),W=0}let V=(D)=>{return I10.has(D)||K.has(D)};if(K.size>0,K.size>0)A.filter((H)=>H&&H.type==="attachment"&&H.attachment.type==="memory"&&!X10.has(H.uuid)).map((H)=>({uuid:H.uuid})).forEach((H)=>X10.add(H.uuid));let E=[];for(let D of A){if(D.type==="attachment"&&X10.has(D.uuid))continue;if(D.type!=="user"&&D.type!=="assistant"){E.push(D);continue}if(!Array.isArray(D.message.content)){E.push(D);continue}if(D.type==="user"){let H=[],F=!1;for(let C of D.message.content)if(C.type==="tool_result"&&V(C.tool_use_id)&&C.content&&!wI8(C.content)){F=!0;let $=Ba1;if(await JZ("tengu_compact_mc_files")){let O=await Ga1(C.content,C.tool_use_id);if(!Za1(O))$=`${OeA}Tool result saved to: ${O.filepath}
bundles/ClaudeCodeCode/cli.js:1574:`,{level:"error"});throw D}}),K.getMeter("com.anthropic.claude_code",{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.69",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues",BUILD_TIME:"2025-12-13T00:32:01Z"}.VERSION)}async function ciB(){let A=wK0();if(!A)return;let Q=parseInt(process.env.CLAUDE_CODE_OTEL_FLUSH_TIMEOUT_MS||"5000");try{let B=[A.forceFlush()],G=dG1();if(G)B.push(G.forceFlush());let Z=cG1();if(Z)B.push(Z.forceFlush());await Promise.race([Promise.all(B),new Promise((Y,J)=>setTimeout(()=>J(Error("OpenTelemetry flush timeout")),Q))]),f("Telemetry flushed successfully")}catch(B){if(B instanceof Error&&B.message.includes("timeout"))f(`Telemetry flush timed out after ${Q}ms. Some metrics may not be exported.`,{level:"warn"});else f(`Telemetry flush failed: ${B instanceof Error?B.message:String(B)}`,{level:"error"})}}function JA0(){let A=Id(),Q=FR(),B=process.env.OTEL_EXPORTER_OTLP_ENDPOINT;if(!A||B&&fgA(B))return Q?{httpAgentOptions:Q}:{};return{httpAgentOptions:(Z)=>{return Q?new ZA0.HttpsProxyAgent(A,{cert:Q.cert,key:Q.key,passphrase:Q.passphrase}):new ZA0.HttpsProxyAgent(A)}}}var UYA,GA0,O01,xiB,yiB,viB,kiB,YA0,$YA,fiB,biB,hiB,wYA,giB,uiB,miB,QT,cl,ZA0,FY8=60000,CY8=5000,zY8=5000;var IA0=L(()=>{ViB();EiB();bW();Xd();F2();g0();dl();k3();F2();jB();Y0();Ta();u6A();rQ();UYA=o(O9(),1),GA0=o(JT1(),1),O01=o(zl(),1),xiB=o(DkB(),1),yiB=o(RcB(),1),viB=o(yA1(),1),kiB=o(kcB(),1),YA0=o(zl(),1),$YA=o(gT1(),1),fiB=o(icB(),1),biB=o(tcB(),1),hiB=o(WpB(),1),wYA=o(flB(),1),giB=o(nlB(),1),uiB=o(elB(),1),miB=o(KiB(),1),QT=o(e6A(),1),cl=o(vr(),1),ZA0=o(oEA(),1)});var _KG,piB;var liB=L(()=>{z2();_KG=P.object({checksum:P.string(),version:P.string().optional()}),piB=P.object({uuid:P.string(),checksum:P.string(),settings:P.record(P.unknown())})});function NYA({title:A,subtitle:Q,color:B="permission"}){return ob.createElement(j,{flexDirection:"column"},ob.createElement(j,{flexDirection:"row",gap:1},ob.createElement(z,{bold:!0,color:B},A),Q!==void 0&&ob.createElement(z,{wrap:"truncate-start"},Q)))}var ob;var R01=L(()=>{fA();ob=o(WA(),1)});var UI;var xx=L(()=>{$8();UI=JQ.platform==="darwin"?"‚è∫":"‚óè"});function MY8(A){return`ansi:${A}`}function _01({name:A,color:Q}){let B=MY8(Q);return B1A.createElement(j,{flexDirection:"row",gap:1},B1A.createElement(z,{color:B},UI," ",B1A.createElement(z,{bold:!0},A)))}var B1A;var XA0=L(()=>{fA();xx();B1A=o(WA(),1)});function YZ({title:A,subtitle:Q,color:B="permission",titleColor:G,innerPaddingX:Z=1,workerBadge:Y,children:J}){return BT.createElement(j,{flexDirection:"column",borderStyle:"round",borderColor:B,borderLeft:!1,borderRight:!1,borderBottom:!1,marginTop:1},BT.createElement(j,{paddingX:1,flexDirection:"column"},Y&&BT.createElement(_01,{name:Y.name,color:Y.color}),BT.createElement(NYA,{title:A,subtitle:Q,color:G})),BT.createElement(j,{flexDirection:"column",paddingX:Z},J))}var BT;var UU=L(()=>{fA();R01();XA0();BT=o(WA(),1)});var iiB,xLA;var WA0=L(()=>{iiB=["apiKeyHelper","awsAuthRefresh","awsCredentialExport","otelHeadersHelper","statusLine"],xLA=new Set(["ANTHROPIC_CUSTOM_HEADERS","ANTHROPIC_DEFAULT_HAIKU_MODEL","ANTHROPIC_DEFAULT_OPUS_MODEL","ANTHROPIC_DEFAULT_SONNET_MODEL","ANTHROPIC_FOUNDRY_API_KEY","ANTHROPIC_MODEL","ANTHROPIC_SMALL_FAST_MODEL_AWS_REGION","ANTHROPIC_SMALL_FAST_MODEL","AWS_DEFAULT_REGION","AWS_PROFILE","AWS_REGION","BASH_DEFAULT_TIMEOUT_MS","BASH_MAX_OUTPUT_LENGTH","BASH_MAX_TIMEOUT_MS","CLAUDE_BASH_MAINTAIN_PROJECT_WORKING_DIR","CLAUDE_CODE_API_KEY_HELPER_TTL_MS","CLAUDE_CODE_DISABLE_EXPERIMENTAL_BETAS","CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC","CLAUDE_CODE_DISABLE_TERMINAL_TITLE","CLAUDE_CODE_ENABLE_TELEMETRY","CLAUDE_CODE_IDE_SKIP_AUTO_INSTALL","CLAUDE_CODE_MAX_OUTPUT_TOKENS","CLAUDE_CODE_SKIP_BEDROCK_AUTH","CLAUDE_CODE_SKIP_FOUNDRY_AUTH","CLAUDE_CODE_SKIP_VERTEX_AUTH","CLAUDE_CODE_SUBAGENT_MODEL","CLAUDE_CODE_USE_BEDROCK","CLAUDE_CODE_USE_FOUNDRY","CLAUDE_CODE_USE_VERTEX","DISABLE_AUTOUPDATER","DISABLE_BUG_COMMAND","DISABLE_COST_WARNINGS","DISABLE_ERROR_REPORTING","DISABLE_TELEMETRY","MAX_MCP_OUTPUT_TOKENS","MAX_THINKING_TOKENS","MCP_TIMEOUT","MCP_TOOL_TIMEOUT","OTEL_EXPORTER_OTLP_HEADERS","OTEL_EXPORTER_OTLP_LOGS_HEADERS","OTEL_EXPORTER_OTLP_LOGS_PROTOCOL","OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE","OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY","OTEL_EXPORTER_OTLP_METRICS_HEADERS","OTEL_EXPORTER_OTLP_METRICS_PROTOCOL","OTEL_EXPORTER_OTLP_PROTOCOL","OTEL_EXPORTER_OTLP_TRACES_HEADERS","OTEL_LOG_USER_PROMPTS","OTEL_LOGS_EXPORT_INTERVAL","OTEL_LOGS_EXPORTER","OTEL_METRIC_EXPORT_INTERVAL","OTEL_METRICS_EXPORTER","OTEL_METRICS_INCLUDE_ACCOUNT_UUID","OTEL_METRICS_INCLUDE_SESSION_ID","OTEL_METRICS_INCLUDE_VERSION","OTEL_RESOURCE_ATTRIBUTES","USE_BUILTIN_RIPGREP","VERTEX_REGION_CLAUDE_3_5_HAIKU","VERTEX_REGION_CLAUDE_3_5_SONNET","VERTEX_REGION_CLAUDE_3_7_SONNET","VERTEX_REGION_CLAUDE_4_0_OPUS","VERTEX_REGION_CLAUDE_4_0_SONNET","VERTEX_REGION_CLAUDE_4_1_OPUS","VERTEX_REGION_CLAUDE_HAIKU_4_5"])});function qYA(A){if(!A)return{shellSettings:{},envVars:{},hasHooks:!1};let Q={};for(let Z of iiB){let Y=A[Z];if(typeof Y==="string"&&Y.length>0)Q[Z]=Y}let B={};if(A.env&&typeof A.env==="object"){for(let[Z,Y]of Object.entries(A.env))if(typeof Y==="string"&&Y.length>0){if(!xLA.has(Z.toUpperCase()))B[Z]=Y}}let G=A.hooks!==void 0&&A.hooks!==null&&typeof A.hooks==="object"&&Object.keys(A.hooks).length>0;return{shellSettings:Q,envVars:B,hasHooks:G,hooks:G?A.hooks:void 0}}function T01(A){return Object.keys(A.shellSettings).length>0||Object.keys(A.envVars).length>0||A.hasHooks}function niB(A,Q){let B=qYA(A),G=qYA(Q);if(!T01(G))return!1;if(!T01(B))return!0;let Z=JSON.stringify({shellSettings:B.shellSettings,envVars:B.envVars,hooks:B.hooks}),Y=JSON.stringify({shellSettings:G.shellSettings,envVars:G.envVars,hooks:G.hooks});return Z!==Y}function aiB(A){let Q=[];for(let B of Object.keys(A.shellSettings))Q.push(B);for(let B of Object.keys(A.envVars))Q.push(B);if(A.hasHooks)Q.push("hooks");return Q}var KA0=L(()=>{WA0()});function oiB({settings:A,onAccept:Q,onReject:B}){let G=qYA(A),Z=aiB(G),Y=_Q();k1((I,X)=>{if(X.escape){B();return}});function J(I){if(I==="exit"){B();return}Q()}return cE.default.createElement(YZ,{color:"warning",titleColor:"warning",title:"Managed settings require approval"},cE.default.createElement(j,{flexDirection:"column",gap:1,paddingTop:1},cE.default.createElement(z,null,"Your organization has configured managed settings that could allow execution of arbitrary code or interception of your prompts and responses."),cE.default.createElement(j,{flexDirection:"column"},cE.default.createElement(z,{dimColor:!0},"Settings requiring approval:"),Z.map((I,X)=>cE.default.createElement(j,{key:X,paddingLeft:2},cE.default.createElement(z,null,cE.default.createElement(z,{dimColor:!0},"¬∑ "),cE.default.createElement(z,null,I))))),cE.default.createElement(z,null,"Only accept if you trust your organization's IT administration and expect these settings to be configured."),cE.default.createElement(S0,{options:[{label:"Yes, I trust these settings",value:"accept"},{label:"No, exit Claude Code",value:"exit"}],onChange:(I)=>J(I),onCancel:()=>J("exit")}),cE.default.createElement(z,{dimColor:!0},Y.pending?cE.default.createElement(cE.default.Fragment,null,"Press ",Y.keyName," again to exit"):cE.default.createElement(cE.default.Fragment,null,"Enter to confirm ¬∑ Esc to exit"))))}var cE;var riB=L(()=>{fA();Y3();UU();c9();KA0();cE=o(WA(),1)});async function siB(A,Q){if(!Q||!T01(qYA(Q)))return"no_check_needed";if(!niB(A,Q))return"no_check_needed";if(!SBA())return"no_check_needed";return r("tengu_managed_settings_security_dialog_shown",{}),new Promise((B)=>{(async()=>{let{unmount:G}=await $5(VA0.default.createElement(u5,null,VA0.default.createElement(oiB,{settings:Q,onAccept:()=>{r("tengu_managed_settings_security_dialog_accepted",{}),G(),B("approved")},onReject:()=>{r("tengu_managed_settings_security_dialog_rejected",{}),G(),B("rejected")}})),{exitOnCtrlC:!1})})()})}function tiB(A){if(A==="rejected")return f6(1),!1;return!0}var VA0;var eiB=L(()=>{fA();riB();u2();g0();T0();iY();KA0();VA0=o(WA(),1)});import{join as OY8}from"path";import{createHash as RY8}from"crypto";import{existsSync as AnB,unlinkSync as _Y8}from"fs";function QnB(){if(vLA)return;if(sb())vLA=new Promise((A)=>{rb=A,setTimeout(()=>{if(rb)f("Remote settings: Loading promise timed out, resolving anyway"),rb(),rb=null},SY8)})}function HA0(){return OY8(mQ(),TY8)}function xY8(){return`${process.env.ANTHROPIC_BASE_URL||"https://api.anthropic.com"}/api/claude_code/settings`}function DA0(A){if(Array.isArray(A))return A.map(DA0);if(A!==null&&typeof A==="object"){let Q={};for(let B of Object.keys(A).sort())Q[B]=DA0(A[B]);return Q}return A}function yY8(A){let Q=DA0(A),B=JSON.stringify(Q);return`sha256:${RY8("sha256").update(B).digest("hex")}`}function sb(){if(X6()!=="firstParty")return!1;if(!Ym0())return!1;try{let{key:Q}=cD({skipRetrievingKeyFromApiKeyHelper:!0});if(Q)return!0}catch{}let A=t6();if(!A?.accessToken)return!1;if(!A.scopes?.includes(E9A))return!1;if(A.subscriptionType!=="enterprise")return!1;return!0}function BnB(){return sb()}function vY8(){try{let{key:Q}=cD({skipRetrievingKeyFromApiKeyHelper:!0});if(Q)return{headers:{"x-api-key":Q}}}catch{}let A=t6();if(A?.accessToken)return{headers:{Authorization:`Bearer ${A.accessToken}`,"anthropic-beta":tu}};return{headers:{},error:"No authentication available"}}async function kY8(A){let Q=null;for(let B=1;B<=EA0+1;B++){if(Q=await fY8(A),Q.success)return Q;if(Q.skipRetry)return Q;if(B>EA0)return Q;let G=ga1(B);f(`Remote settings: Retry ${B}/${EA0} after ${G}ms`),await jeA(G)}return Q}async function fY8(A){try{await Mk();let Q=vY8();if(Q.error)return{success:!1,error:"Authentication required for remote settings",skipRetry:!0};let B=xY8(),G={...Q.headers,"User-Agent":iI()};if(A)G["If-None-Match"]=`"${A}"`;let Z=await wQ.get(B,{headers:G,timeout:jY8,validateStatus:(I)=>I===200||I===304||I===404});if(Z.status===304)return f("Remote settings: Using cached settings (304)"),{success:!0,settings:null,checksum:A};if(Z.status===404)return f("Remote settings: No settings found (404)"),{success:!0,settings:{},checksum:void 0};let Y=piB.safeParse(Z.data);if(!Y.success)return f(`Remote settings: Invalid response format - ${Y.error.message}`),{success:!1,error:"Invalid remote settings format"};let J=Jb.safeParse(Y.data.settings);if(!J.success)return f(`Remote settings: Settings validation failed - ${J.error.message}`),{success:!1,error:"Invalid settings structure"};return f("Remote settings: Fetched successfully"),{success:!0,settings:J.data,checksum:Y.data.checksum}}catch(Q){if(wQ.isAxiosError(Q)){let B=Q;if(B.response?.status===404)return{success:!0,settings:{},checksum:""};if(B.response?.status===401||B.response?.status===403)return{success:!1,error:"Not authorized for remote settings",skipRetry:!0};if(B.code==="ECONNABORTED")return{success:!1,error:"Remote settings request timeout"};if(B.code==="ECONNREFUSED"||B.code==="ENOTFOUND")return{success:!1,error:"Cannot connect to server"}}return{success:!1,error:Q instanceof Error?Q.message:"Unknown error"}}}function GnB(){try{let A=HA0();if(!AnB(A))return null;let Q=wE(A),B=h8(Q,!1);if(!B||typeof B!=="object"||Array.isArray(B))return null;return B}catch{return null}}function bY8(A){try{let Q=HA0();rL(Q,JSON.stringify(A,null,2),{encoding:"utf-8",mode:384}),f(`Remote settings: Saved to ${Q}`)}catch(Q){f(`Remote settings: Failed to save - ${Q instanceof Error?Q.message:"unknown error"}`)}}function FA0(){JnB(),kw=null,vLA=null,rb=null;try{let A=HA0();if(AnB(A))_Y8(A)}catch{}}async function CA0(){if(!sb())return null;let A=GnB(),Q=A?yY8(A):void 0;try{let B=await kY8(Q);if(!B.success){if(A)return f("Remote settings: Using stale cache after fetch failure"),kw=A,A;return null}if(B.settings===null&&A)return f("Remote settings: Cache still valid (304 Not Modified)"),kw=A,A;let G=B.settings||{};if(Object.keys(G).length>0){let Y=await siB(A,G);if(!tiB(Y))return f("Remote settings: User rejected new settings, using cached settings"),A;return kw=G,bY8(G),f("Remote settings: Applied new settings successfully"),G}return kw=G,G}catch{if(A)return f("Remote settings: Using stale cache after error"),kw=A,A;return null}}function zA0(){if(!sb())return null;if(kw)return kw;let A=GnB();if(A)return kw=A,A;return null}async function ZnB(){if(sb()&&!vLA)vLA=new Promise((A)=>{rb=A});try{let A=await CA0();if(sb())gY8();if(A!==null)TR(),NF.notifyChange("policySettings")}finally{if(rb)rb(),rb=null}}async function YnB(){if(FA0(),!sb()){TR(),NF.notifyChange("policySettings");return}await CA0(),f("Remote settings: Refreshed after auth change"),TR(),NF.notifyChange("policySettings")}async function hY8(){if(!sb())return;let A=kw?JSON.stringify(kw):null;try{if(await CA0(),(kw?JSON.stringify(kw):null)!==A)f("Remote settings: Changed during background poll"),TR(),NF.notifyChange("policySettings")}catch{}}function gY8(){if(yLA!==null)return;if(!sb())return;yLA=setInterval(()=>{hY8()},PY8),U8(async()=>JnB())}function JnB(){if(yLA!==null)clearInterval(yLA),yLA=null}var TY8="remote-settings.json",jY8=1e4,EA0=5,PY8=3600000,yLA=null,vLA=null,rb=null,SY8=30000,kw=null;var LYA=L(()=>{b8();lD();Y0();eJ();F2();Te();liB();rQ();hX();M9();uI();beA();YZA();Rs();jB();bW();eiB()});async function $A0({clearOnboarding:A=!1}){await ciB(),mCQ(),$$().delete(),j01(),i0((B)=>{let G={...B};if(A){if(G.hasCompletedOnboarding=!1,G.subscriptionNoticeCount=0,G.hasAvailableSubscription=!1,G.customApiKeyResponses?.approved)G.customApiKeyResponses={...G.customApiKeyResponses,approved:[]}}return G.oauthAccount=void 0,G})}var UA0,j01=()=>{t6.cache?.clear?.(),oyA(),XnB(),GbQ(),As.cache?.clear?.(),Fl.cache?.clear?.(),FA0()},InB;var P01=L(()=>{xQ();tf();Fs();fA();F2();uyA();fv();J4();Sk();iY();wZA();IA0();LYA();ar();UA0=o(WA(),1);InB={type:"local-jsx",name:"logout",description:"Sign out from your Anthropic account",isEnabled:()=>!process.env.DISABLE_LOGOUT_COMMAND,isHidden:!1,async call(){if(!oD())await EI();await $A0({clearOnboarding:!0});let A=UA0.createElement(z,null,"Successfully logged out from your Anthropic account.");return setTimeout(()=>{f6(0,"logout")},200),A},userFacingName(){return"logout"}}});class kLA{codeVerifier;authCodeListener=null;port=null;manualAuthCodeResolver=null;constructor(){this.codeVerifier=a_B()}async startOAuthFlow(A,Q){this.authCodeListener=new zo1,this.port=await this.authCodeListener.start();let B=o_B(this.codeVerifier),G=r_B(),Z={codeChallenge:B,state:G,port:this.port,loginWithClaudeAi:Q?.loginWithClaudeAi,inferenceOnly:Q?.inferenceOnly,orgUUID:Q?.orgUUID},Y=tK1({...Z,isManual:!0}),J=tK1({...Z,isManual:!1}),I=await this.waitForAuthorizationCode(G,async()=>{await A(Y),await e5(J)}),X=this.authCodeListener?.hasPendingResponse()??!1;r("tengu_oauth_auth_code_received",{automatic:X});try{let W=await lu0(I,G,this.codeVerifier,this.port,!X,Q?.expiresIn);await $A0({clearOnboarding:!1});let K=await eK1(W.access_token);if(W.account)AV1({accountUuid:W.account.uuid,emailAddress:W.account.email_address,organizationUuid:W.organization?.uuid,displayName:K.displayName,hasExtraUsageEnabled:K.hasExtraUsageEnabled??void 0});if(X){let V=dyA(W.scope);this.authCodeListener?.handleSuccessRedirect(V)}return this.formatTokens(W,K.subscriptionType,K.rateLimitTier)}catch(W){if(X)this.authCodeListener?.handleErrorRedirect();throw W}finally{this.authCodeListener?.close()}}async waitForAuthorizationCode(A,Q){return new Promise((B,G)=>{this.manualAuthCodeResolver=B,this.authCodeListener?.waitForAuthorization(A,Q).then((Z)=>{this.manualAuthCodeResolver=null,B(Z)}).catch((Z)=>{this.manualAuthCodeResolver=null,G(Z)})})}handleManualAuthCodeInput(A){if(this.manualAuthCodeResolver)this.manualAuthCodeResolver(A.authorizationCode),this.manualAuthCodeResolver=null,this.authCodeListener?.close()}formatTokens(A,Q,B){return{accessToken:A.access_token,refreshToken:A.refresh_token,expiresAt:Date.now()+A.expires_in*1000,scopes:dyA(A.scope),subscriptionType:Q,rateLimitTier:B}}cleanup(){this.authCodeListener?.close(),this.manualAuthCodeResolver=null}}var wA0=L(()=>{AU();n_B();s_B();Xq();P01();T0()});async function uY8(){try{if(z0(process.env.CLAUDE_CODE_USE_BEDROCK)||z0(process.env.CLAUDE_CODE_USE_VERTEX)||z0(process.env.CLAUDE_CODE_USE_FOUNDRY))return!0;return await wQ.get("https://api.anthropic.com/api/hello",{timeout:5000,headers:{"Cache-Control":"no-cache"}}),!0}catch(A){if(!(A instanceof ok0))return!0;return A.code!=="EHOSTUNREACH"}}function NA0(){let[A,Q]=S01.useState(null);return S01.useEffect(()=>{let B=!0;if(process.env.CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC)return;let G=async()=>{if(!B)return;let Y=await uY8();if(B)Q(Y)};G();let Z=setInterval(G,mY8);return()=>{B=!1,clearInterval(Z)}},[]),{isConnected:A}}var S01,mY8=30000;var WnB=L(()=>{b8();rQ();S01=o(WA(),1)});class MYA{activeOperations=new Set;lastUserActivityTime=0;lastCLIRecordedTime=Date.now();isCLIActive=!1;USER_ACTIVITY_TIMEOUT_MS=5000;static instance=null;static getInstance(){if(!MYA.instance)MYA.instance=new MYA;return MYA.instance}recordUserActivity(){if(!this.isCLIActive&&this.lastUserActivityTime!==0){let Q=(Date.now()-this.lastUserActivityTime)/1000;if(Q>0){let B=mG1();if(B){let G=this.USER_ACTIVITY_TIMEOUT_MS/1000;if(Q<G)B.add(Q,{type:"user"})}}}this.lastUserActivityTime=Date.now()}startCLIActivity(A){if(this.activeOperations.has(A))this.endCLIActivity(A);let Q=this.activeOperations.size===0;if(this.activeOperations.add(A),Q)this.isCLIActive=!0,this.lastCLIRecordedTime=Date.now()}endCLIActivity(A){if(this.activeOperations.delete(A),this.activeOperations.size===0){let Q=Date.now(),B=(Q-this.lastCLIRecordedTime)/1000;if(B>0){let G=mG1();if(G)G.add(B,{type:"cli"})}this.lastCLIRecordedTime=Q,this.isCLIActive=!1}}async trackOperation(A,Q){this.startCLIActivity(A);try{return await Q()}finally{this.endCLIActivity(A)}}getActivityStates(){return{isUserActive:(Date.now()-this.lastUserActivityTime)/1000<this.USER_ACTIVITY_TIMEOUT_MS/1000,isCLIActive:this.isCLIActive,activeOperationCount:this.activeOperations.size}}}var fLA;var qA0=L(()=>{g0();fLA=MYA.getInstance()});function pl({todos:A,isStandalone:Q=!1}){if(A.length===0)return null;let B=OV.createElement(OV.Fragment,null,A.map((G,Z)=>{let Y=G.status==="completed"?X1.checkboxOn:X1.checkboxOff;return OV.createElement(j,{key:Z},OV.createElement(z,{dimColor:G.status==="completed"},Y," "),OV.createElement(z,{bold:G.status==="in_progress",dimColor:G.status==="completed",strikethrough:G.status==="completed"},G.content))}));if(Q)return OV.createElement(j,{flexDirection:"column",marginTop:1,marginLeft:2},OV.createElement(z,{bold:!0,dimColor:!0},"Todos"),B);return OV.createElement(j,{flexDirection:"column"},B)}var OV;var bLA=L(()=>{fA();g2();OV=o(WA(),1)});function KnB({streamMode:A}){let[Q,B]=hLA.useState(null),[G,Z]=hLA.useState(null);if(hLA.useEffect(()=>{if(A==="thinking"&&Q===null)B(Date.now());else if(A!=="thinking"&&Q!==null)Z(Date.now()-Q),B(null)},[A,Q]),A==="thinking")return GT.createElement(j,{marginTop:1},GT.createElement(z,{dimColor:!0},"‚à¥ Thinking‚Ä¶"));if(G!==null)return GT.createElement(j,{marginTop:1},GT.createElement(z,{dimColor:!0},"‚à¥ Thought for ",Math.max(1,Math.round(G/1000)),"s (",GT.createElement(z,{dimColor:!0,bold:!0},"ctrl+o")," ","to show thinking)"));return null}var GT,hLA;var VnB=L(()=>{fA();GT=o(WA(),1),hLA=o(WA(),1)});function gLA(){if(process.env.TERM==="xterm-ghostty")return["¬∑","‚ú¢","‚ú≥","‚ú∂","‚úª","*"];return process.platform==="darwin"?["¬∑","‚ú¢","‚ú≥","‚ú∂","‚úª","‚úΩ"]:["¬∑","‚ú¢","*","‚ú∂","‚úª","‚úΩ"]}function G1A(A,Q,B){return{r:Math.round(A.r+(Q.r-A.r)*B),g:Math.round(A.g+(Q.g-A.g)*B),b:Math.round(A.b+(Q.b-A.b)*B)}}function OYA(A){return`rgb(${A.r},${A.g},${A.b})`}function MA0({char:A,flashOpacity:Q}){let Z=G1A({r:215,g:119,b:87},{r:245,g:149,b:117},Q);return LA0.createElement(z,{color:OYA(Z)},A)}var LA0;var OA0=L(()=>{fA();LA0=o(WA(),1)});function RYA({char:A,index:Q,glimmerIndex:B,messageColor:G,shimmerColor:Z}){let Y=Q===B,J=Math.abs(Q-B)===1;return RA0.createElement(z,{color:Y||J?Z:G},A)}var RA0;var x01=L(()=>{fA();RA0=o(WA(),1)});function _A0({message:A,mode:Q,isConnected:B,messageColor:G,glimmerIndex:Z,flashOpacity:Y,shimmerColor:J,stalledIntensity:I=0}){if(!A)return null;if(B===!1)return $I.createElement(z,{color:G},A," ");if(I>0){let K=G1A({r:215,g:119,b:87},{r:171,g:43,b:63},I),V=OYA(K);return $I.createElement($I.Fragment,null,$I.createElement(z,{color:V},A),$I.createElement(z,{color:V}," "))}return $I.createElement($I.Fragment,null,A.split("").map((X,W)=>{if(Q==="tool-use")return $I.createElement(MA0,{key:W,char:X,flashOpacity:Y});else return $I.createElement(RYA,{key:W,char:X,index:W,glimmerIndex:Z,messageColor:G,shimmerColor:J})}),$I.createElement(z,{color:G}," "))}var $I;var EnB=L(()=>{fA();OA0();x01();$I=o(WA(),1)});function TA0({frame:A,messageColor:Q,stalledIntensity:B=0,isConnected:G}){let Z=HnB[A%HnB.length];if(G===!1)return fw.createElement(j,{flexWrap:"wrap",height:1,width:2},fw.createElement(z,{color:Q},Z));if(B>0){let I=G1A({r:215,g:119,b:87},{r:171,g:43,b:63},B);return fw.createElement(j,{flexWrap:"wrap",height:1,width:2},fw.createElement(z,{color:OYA(I)},Z))}return fw.createElement(j,{flexWrap:"wrap",height:1,width:2},fw.createElement(z,{color:Q},Z))}var fw,DnB,HnB;var FnB=L(()=>{fA();fw=o(WA(),1),DnB=gLA(),HnB=[...DnB,...[...DnB].reverse()]});function uLA(A,Q,B,G){let Z=_YA.useRef(Date.now()),[Y,J]=_YA.useState(A==="requesting"?-1:10),I=_YA.useMemo(()=>{if(A==="requesting")return 50;return 200},[A]);return aG(()=>{if(B===!1||G)return;let X=Date.now()-Z.current,W=Math.floor(X/I),K=Q.length,V=K+20;if(A==="requesting"){let E=W%V-10;J(E)}else{let E=K+10-W%V;J(E)}},I),Y}var _YA;var jA0=L(()=>{UE();_YA=o(WA(),1)});function PA0(A){let[Q,B]=CnB.useState(0);return aG(()=>{if(A==="tool-use")B(()=>{let G=Date.now()/1000;return(Math.sin(G*Math.PI)+1)/2});else B(0)},50),Q}var CnB;var znB=L(()=>{UE();CnB=o(WA(),1)});function SA0(A,Q=!1){let[B,G]=Z1A.useState(0),[Z,Y]=Z1A.useState(0),J=Z1A.useRef(A);Z1A.useEffect(()=>{if(A>J.current)G(0),Y(0),J.current=A},[A]),aG(()=>{if(A>0&&A===J.current&&!Q)G((W)=>W+100);else if(A===0||Q)G(0)},100);let I=B>3000&&!Q,X=I?Math.min((B-3000)/2000,1):0;return aG(()=>{Y((W)=>{let K=X,V=K-W;if(Math.abs(V)<0.01)return K;return W+V*0.1})},50),{isStalled:I,stalledIntensity:Z}}var Z1A;var UnB=L(()=>{UE();Z1A=o(WA(),1)});var $nB=L(()=>{OA0();x01();EnB();FnB();jA0();znB();UnB()});function qnB({mode:A,elapsedTimeMs:Q,spinnerTip:B,currentResponseLength:G,overrideColor:Z,overrideShimmerColor:Y,overrideMessage:J,spinnerSuffix:I,verbose:X,todos:W,hasActiveTools:K=!1,hideThinkingIndicator:V=!1}){let E=lY8(),[D,H]=yx.useState(0),[F,C]=yx.useState(0),[U]=yQ(),{isConnected:O}=NA0(),{columns:q}=kB(),M=W?.find((yA)=>yA.status==="in_progress"),_=W?.find((yA)=>yA.status==="pending"),[T]=yx.useState(()=>pr(E)),y=(J??M?.activeForm??T)+"‚Ä¶",{isStalled:h,stalledIntensity:x}=SA0(G,K),m=uLA(A,y,O,h),g=PA0(A),t=yx.useRef(G);yx.useEffect(()=>{let yA="spinner-"+A;return fLA.startCLIActivity(yA),()=>{fLA.endCLIActivity(yA)}},[A]),yx.useEffect(()=>{t.current=G},[G]),aG(()=>{if(!O){H(4);return}H((yA)=>yA+1)},120),aG(()=>{C((yA)=>{let ZA=t.current-yA;if(ZA<=0)return yA;let GA;if(ZA<70)GA=1;else if(ZA<200)GA=Math.max(2,Math.ceil(ZA*0.08));else GA=18;return Math.min(yA+GA,t.current)})},10);let p=y.length+2,k=16,c=q>p+20,e=W&&W.length>0&&c&&q>p+k+25,AA=(X||Q>cY8)&&c&&q>p+k+(e?25:0)+25,VA=[...c?[T2.createElement(z,{dimColor:!0,key:"esc"},T2.createElement(R0,{shortcut:"esc",action:"interrupt",bold:!0}))]:[],...I?[T2.createElement(z,{dimColor:!0,key:"suffix"},I)]:[],...e?[T2.createElement(z,{dimColor:!0,key:"todo"},T2.createElement(R0,{shortcut:"ctrl+t",action:`${U.showExpandedTodos?"hide":"show"} todos`,bold:!0}))]:[],...AA?[T2.createElement(z,{dimColor:!0,key:"elapsedTime"},lK(Q)),T2.createElement(j,{flexDirection:"row",key:"tokens"},T2.createElement(pY8,{mode:A,key:"spinnerMode"}),T2.createElement(z,{dimColor:!0},g3(Math.round(F/4))," tokens"))]:[]];if(O===!1)VA.push(T2.createElement(j,{key:"offline"},T2.createElement(z,{color:"error",bold:!0},"offline")));let OA=Z??(O===!1?"inactive":"claude"),EA=Y??"claudeShimmer",SA=VA.length>0?T2.createElement(T2.Fragment,null,T2.createElement(z,{dimColor:!0},"("),T2.createElement(LB,null,VA),T2.createElement(z,{dimColor:!0},")")):null;return T2.createElement(j,{flexDirection:"column",width:"100%",alignItems:"flex-start"},!V&&T2.createElement(KnB,{streamMode:A}),T2.createElement(j,{flexDirection:"row",flexWrap:"wrap",marginTop:1,width:"100%"},T2.createElement(TA0,{frame:D,messageColor:OA,stalledIntensity:x,isConnected:O}),T2.createElement(_A0,{message:y,mode:A,isConnected:O,messageColor:OA,glimmerIndex:m,flashOpacity:g,shimmerColor:EA,stalledIntensity:x}),SA),U.showExpandedTodos&&W&&W.length>0?T2.createElement(j,{width:"100%",flexDirection:"column"},T2.createElement(h0,null,T2.createElement(pl,{todos:W}))):_||B?T2.createElement(j,{width:"100%"},T2.createElement(h0,null,T2.createElement(z,{dimColor:!0},_?`Next: ${_.content}`:`Tip: ${B}`))):null)}function pY8({mode:A}){switch(A){case"tool-input":case"tool-use":case"responding":case"thinking":return T2.createElement(j,{width:2},T2.createElement(z,{dimColor:!0},X1.arrowDown));case"requesting":return T2.createElement(j,{width:2},T2.createElement(z,{dimColor:!0},X1.arrowUp))}}function a9(){let[A,Q]=yx.useState(0),{isConnected:B}=NA0();return aG(()=>{Q((Z)=>(Z+1)%NnB.length)},120),T2.createElement(j,{flexWrap:"wrap",height:1,width:2},T2.createElement(z,{color:B===!1?"inactive":"text"},NnB[A]))}function lY8(){return y01("tengu_spinner_words",dY8).words}var T2,yx,wnB,NnB,dY8,cY8=30000;var SG=L(()=>{fA();luA();UE();g2();WnB();qA0();J4();h4();bLA();u2();y6();VnB();s4();l6();$nB();T2=o(WA(),1),yx=o(WA(),1),wnB=gLA(),NnB=[...wnB,...[...wnB].reverse()],dY8={words:["Accomplishing","Actioning","Actualizing","Baking","Booping","Brewing","Calculating","Cerebrating","Channelling","Churning","Clauding","Coalescing","Cogitating","Computing","Combobulating","Concocting","Considering","Contemplating","Cooking","Crafting","Creating","Crunching","Deciphering","Deliberating","Determining","Discombobulating","Doing","Effecting","Elucidating","Enchanting","Envisioning","Finagling","Flibbertigibbeting","Forging","Forming","Frolicking","Generating","Germinating","Hatching","Herding","Honking","Ideating","Imagining","Incubating","Inferring","Manifesting","Marinating","Meandering","Moseying","Mulling","Mustering","Musing","Noodling","Percolating","Perusing","Philosophising","Pontificating","Pondering","Processing","Puttering","Puzzling","Reticulating","Ruminating","Scheming","Schlepping","Shimmying","Simmering","Smooshing","Spelunking","Spinning","Stewing","Sussing","Synthesizing","Thinking","Tinkering","Transmuting","Unfurling","Unravelling","Vibing","Wandering","Whirring","Wibbling","Working","Wrangling"]}});var mLA=w((aY8)=>{function iY8(A,Q,B){if(B===void 0)B=Array.prototype;if(A&&typeof B.find==="function")return B.find.call(A,Q);for(var G=0;G<A.length;G++)if(Object.prototype.hasOwnProperty.call(A,G)){var Z=A[G];if(Q.call(void 0,Z,G,A))return Z}}function xA0(A,Q){if(Q===void 0)Q=Object;return Q&&typeof Q.freeze==="function"?Q.freeze(A):A}function nY8(A,Q){if(A===null||typeof A!=="object")throw TypeError("target is not an object");for(var B in Q)if(Object.prototype.hasOwnProperty.call(Q,B))A[B]=Q[B];return A}var LnB=xA0({HTML:"text/html",isHTML:function(A){return A===LnB.HTML},XML_APPLICATION:"application/xml",XML_TEXT:"text/xml",XML_XHTML_APPLICATION:"application/xhtml+xml",XML_SVG_IMAGE:"image/svg+xml"}),MnB=xA0({HTML:"http://www.w3.org/1999/xhtml",isHTML:function(A){return A===MnB.HTML},SVG:"http://www.w3.org/2000/svg",XML:"http://www.w3.org/XML/1998/namespace",XMLNS:"http://www.w3.org/2000/xmlns/"});aY8.assign=nY8;aY8.find=iY8;aY8.freeze=xA0;aY8.MIME_TYPE=LnB;aY8.NAMESPACE=MnB});var cA0=w((DJ8)=>{var xnB=mLA(),vx=xnB.find,dLA=xnB.NAMESPACE;function AJ8(A){return A!==""}function QJ8(A){return A?A.split(/[\t\n\f\r ]+/).filter(AJ8):[]}function BJ8(A,Q){if(!A.hasOwnProperty(Q))A[Q]=!0;return A}function OnB(A){if(!A)return[];var Q=QJ8(A);return Object.keys(Q.reduce(BJ8,{}))}function GJ8(A){return function(Q){return A&&A.indexOf(Q)!==-1}}function pLA(A,Q){for(var B in A)if(Object.prototype.hasOwnProperty.call(A,B))Q[B]=A[B]}function wU(A,Q){var B=A.prototype;if(!(B instanceof Q)){let Z=function(){};var G=Z;Z.prototype=Q.prototype,Z=new Z,pLA(B,Z),A.prototype=B=Z}if(B.constructor!=A){if(typeof A!="function")console.error("unknown Class:"+A);B.constructor=A}}var NU={},ZT=NU.ELEMENT_NODE=1,jYA=NU.ATTRIBUTE_NODE=2,v01=NU.TEXT_NODE=3,ynB=NU.CDATA_SECTION_NODE=4,vnB=NU.ENTITY_REFERENCE_NODE=5,ZJ8=NU.ENTITY_NODE=6,knB=NU.PROCESSING_INSTRUCTION_NODE=7,fnB=NU.COMMENT_NODE=8,bnB=NU.DOCUMENT_NODE=9,hnB=NU.DOCUMENT_TYPE_NODE=10,eb=NU.DOCUMENT_FRAGMENT_NODE=11,YJ8=NU.NOTATION_NODE=12,FH={},RV={},oEG=FH.INDEX_SIZE_ERR=(RV[1]="Index size error",1),rEG=FH.DOMSTRING_SIZE_ERR=(RV[2]="DOMString size error",2),$U=FH.HIERARCHY_REQUEST_ERR=(RV[3]="Hierarchy request error",3),sEG=FH.WRONG_DOCUMENT_ERR=(RV[4]="Wrong document",4),tEG=FH.INVALID_CHARACTER_ERR=(RV[5]="Invalid character",5),eEG=FH.NO_DATA_ALLOWED_ERR=(RV[6]="No data allowed",6),ADG=FH.NO_MODIFICATION_ALLOWED_ERR=(RV[7]="No modification allowed",7),gnB=FH.NOT_FOUND_ERR=(RV[8]="Not found",8),QDG=FH.NOT_SUPPORTED_ERR=(RV[9]="Not supported",9),RnB=FH.INUSE_ATTRIBUTE_ERR=(RV[10]="Attribute in use",10),BDG=FH.INVALID_STATE_ERR=(RV[11]="Invalid state",11),GDG=FH.SYNTAX_ERR=(RV[12]="Syntax error",12),ZDG=FH.INVALID_MODIFICATION_ERR=(RV[13]="Invalid modification",13),YDG=FH.NAMESPACE_ERR=(RV[14]="Invalid namespace",14),JDG=FH.INVALID_ACCESS_ERR=(RV[15]="Invalid access",15);function VX(A,Q){if(Q instanceof Error)var B=Q;else if(B=this,Error.call(this,RV[A]),this.message=RV[A],Error.captureStackTrace)Error.captureStackTrace(this,VX);if(B.code=A,Q)this.message=this.message+": "+Q;return B}VX.prototype=Error.prototype;pLA(FH,VX);function tb(){}tb.prototype={length:0,item:function(A){return A>=0&&A<this.length?this[A]:null},toString:function(A,Q){for(var B=[],G=0;G<this.length;G++)TYA(this[G],B,A,Q);return B.join("")},filter:function(A){return Array.prototype.filter.call(this,A)},indexOf:function(A){return Array.prototype.indexOf.call(this,A)}};function PYA(A,Q){this._node=A,this._refresh=Q,kA0(this)}function kA0(A){var Q=A._node._inc||A._node.ownerDocument._inc;if(A._inc!==Q){var B=A._refresh(A._node);if(snB(A,"length",B.length),!A.$$length||B.length<A.$$length){for(var G=B.length;G in A;G++)if(Object.prototype.hasOwnProperty.call(A,G))delete A[G]}pLA(B,A),A._inc=Q}}PYA.prototype.item=function(A){return kA0(this),this[A]||null};wU(PYA,tb);function k01(){}function unB(A,Q){var B=A.length;while(B--)if(A[B]===Q)return B}function _nB(A,Q,B,G){if(G)Q[unB(Q,G)]=B;else Q[Q.length++]=B;if(A){B.ownerElement=A;var Z=A.ownerDocument;if(Z)G&&cnB(Z,A,G),JJ8(Z,A,B)}}function TnB(A,Q,B){var G=unB(Q,B);if(G>=0){var Z=Q.length-1;while(G<Z)Q[G]=Q[++G];if(Q.length=Z,A){var Y=A.ownerDocument;if(Y)cnB(Y,A,B),B.ownerElement=null}}else throw new VX(gnB,Error(A.tagName+"@"+B))}k01.prototype={length:0,item:tb.prototype.item,getNamedItem:function(A){var Q=this.length;while(Q--){var B=this[Q];if(B.nodeName==A)return B}},setNamedItem:function(A){var Q=A.ownerElement;if(Q&&Q!=this._ownerElement)throw new VX(RnB);var B=this.getNamedItem(A.nodeName);return _nB(this._ownerElement,this,A,B),B},setNamedItemNS:function(A){var Q=A.ownerElement,B;if(Q&&Q!=this._ownerElement)throw new VX(RnB);return B=this.getNamedItemNS(A.namespaceURI,A.localName),_nB(this._ownerElement,this,A,B),B},removeNamedItem:function(A){var Q=this.getNamedItem(A);return TnB(this._ownerElement,this,Q),Q},removeNamedItemNS:function(A,Q){var B=this.getNamedItemNS(A,Q);return TnB(this._ownerElement,this,B),B},getNamedItemNS:function(A,Q){var B=this.length;while(B--){var G=this[B];if(G.localName==Q&&G.namespaceURI==A)return G}return null}};function mnB(){}mnB.prototype={hasFeature:function(A,Q){return!0},createDocument:function(A,Q,B){var G=new lLA;if(G.implementation=this,G.childNodes=new tb,G.doctype=B||null,B)G.appendChild(B);if(Q){var Z=G.createElementNS(A,Q);G.appendChild(Z)}return G},createDocumentType:function(A,Q,B){var G=new h01;return G.name=A,G.nodeName=A,G.publicId=Q||"",G.systemId=B||"",G}};function t7(){}t7.prototype={firstChild:null,lastChild:null,previousSibling:null,nextSibling:null,attributes:null,parentNode:null,childNodes:null,ownerDocument:null,nodeValue:null,namespaceURI:null,prefix:null,localName:null,insertBefore:function(A,Q){return f01(this,A,Q)},replaceChild:function(A,Q){if(f01(this,A,Q,lnB),Q)this.removeChild(Q)},removeChild:function(A){return pnB(this,A)},appendChild:function(A){return this.insertBefore(A,null)},hasChildNodes:function(){return this.firstChild!=null},cloneNode:function(A){return vA0(this.ownerDocument||this,this,A)},normalize:function(){var A=this.firstChild;while(A){var Q=A.nextSibling;if(Q&&Q.nodeType==v01&&A.nodeType==v01)this.removeChild(Q),A.appendData(Q.data);else A.normalize(),A=Q}},isSupported:function(A,Q){return this.ownerDocument.implementation.hasFeature(A,Q)},hasAttributes:function(){return this.attributes.length>0},lookupPrefix:function(A){var Q=this;while(Q){var B=Q._nsMap;if(B){for(var G in B)if(Object.prototype.hasOwnProperty.call(B,G)&&B[G]===A)return G}Q=Q.nodeType==jYA?Q.ownerDocument:Q.parentNode}return null},lookupNamespaceURI:function(A){var Q=this;while(Q){var B=Q._nsMap;if(B){if(Object.prototype.hasOwnProperty.call(B,A))return B[A]}Q=Q.nodeType==jYA?Q.ownerDocument:Q.parentNode}return null},isDefaultNamespace:function(A){var Q=this.lookupPrefix(A);return Q==null}};function dnB(A){return A=="<"&&"&lt;"||A==">"&&"&gt;"||A=="&"&&"&amp;"||A=='"'&&"&quot;"||"&#"+A.charCodeAt()+";"}pLA(NU,t7);pLA(NU,t7.prototype);function cLA(A,Q){if(Q(A))return!0;if(A=A.firstChild)do if(cLA(A,Q))return!0;while(A=A.nextSibling)}function lLA(){this.ownerDocument=this}function JJ8(A,Q,B){A&&A._inc++;var G=B.namespaceURI;if(G===dLA.XMLNS)Q._nsMap[B.prefix?B.localName:""]=B.value}function cnB(A,Q,B,G){A&&A._inc++;var Z=B.namespaceURI;if(Z===dLA.XMLNS)delete Q._nsMap[B.prefix?B.localName:""]}function fA0(A,Q,B){if(A&&A._inc){A._inc++;var G=Q.childNodes;if(B)G[G.length++]=B;else{var Z=Q.firstChild,Y=0;while(Z)G[Y++]=Z,Z=Z.nextSibling;G.length=Y,delete G[G.length]}}}function pnB(A,Q){var{previousSibling:B,nextSibling:G}=Q;if(B)B.nextSibling=G;else A.firstChild=G;if(G)G.previousSibling=B;else A.lastChild=B;return Q.parentNode=null,Q.previousSibling=null,Q.nextSibling=null,fA0(A.ownerDocument,A),Q}function IJ8(A){return A&&(A.nodeType===t7.DOCUMENT_NODE||A.nodeType===t7.DOCUMENT_FRAGMENT_NODE||A.nodeType===t7.ELEMENT_NODE)}function XJ8(A){return A&&(kx(A)||bA0(A)||Ah(A)||A.nodeType===t7.DOCUMENT_FRAGMENT_NODE||A.nodeType===t7.COMMENT_NODE||A.nodeType===t7.PROCESSING_INSTRUCTION_NODE)}function Ah(A){return A&&A.nodeType===t7.DOCUMENT_TYPE_NODE}function kx(A){return A&&A.nodeType===t7.ELEMENT_NODE}function bA0(A){return A&&A.nodeType===t7.TEXT_NODE}function jnB(A,Q){var B=A.childNodes||[];if(vx(B,kx)||Ah(Q))return!1;var G=vx(B,Ah);return!(Q&&G&&B.indexOf(G)>B.indexOf(Q))}function PnB(A,Q){var B=A.childNodes||[];function G(Y){return kx(Y)&&Y!==Q}if(vx(B,G))return!1;var Z=vx(B,Ah);return!(Q&&Z&&B.indexOf(Z)>B.indexOf(Q))}function WJ8(A,Q,B){if(!IJ8(A))throw new VX($U,"Unexpected parent node type "+A.nodeType);if(B&&B.parentNode!==A)throw new VX(gnB,"child not in parent");if(!XJ8(Q)||Ah(Q)&&A.nodeType!==t7.DOCUMENT_NODE)throw new VX($U,"Unexpected node type "+Q.nodeType+" for parent node type "+A.nodeType)}function KJ8(A,Q,B){var G=A.childNodes||[],Z=Q.childNodes||[];if(Q.nodeType===t7.DOCUMENT_FRAGMENT_NODE){var Y=Z.filter(kx);if(Y.length>1||vx(Z,bA0))throw new VX($U,"More than one element or text in fragment");if(Y.length===1&&!jnB(A,B))throw new VX($U,"Element in fragment can not be inserted before doctype")}if(kx(Q)){if(!jnB(A,B))throw new VX($U,"Only one element can be added and only after doctype")}if(Ah(Q)){if(vx(G,Ah))throw new VX($U,"Only one doctype is allowed");var J=vx(G,kx);if(B&&G.indexOf(J)<G.indexOf(B))throw new VX($U,"Doctype can only be inserted before an element");if(!B&&J)throw new VX($U,"Doctype can not be appended since element is present")}}function lnB(A,Q,B){var G=A.childNodes||[],Z=Q.childNodes||[];if(Q.nodeType===t7.DOCUMENT_FRAGMENT_NODE){var Y=Z.filter(kx);if(Y.length>1||vx(Z,bA0))throw new VX($U,"More than one element or text in fragment");if(Y.length===1&&!PnB(A,B))throw new VX($U,"Element in fragment can not be inserted before doctype")}if(kx(Q)){if(!PnB(A,B))throw new VX($U,"Only one element can be added and only after doctype")}if(Ah(Q)){let X=function(W){return Ah(W)&&W!==B};var I=X;if(vx(G,X))throw new VX($U,"Only one doctype is allowed");var J=vx(G,kx);if(B&&G.indexOf(J)<G.indexOf(B))throw new VX($U,"Doctype can only be inserted before an element")}}function f01(A,Q,B,G){if(WJ8(A,Q,B),A.nodeType===t7.DOCUMENT_NODE)(G||KJ8)(A,Q,B);var Z=Q.parentNode;if(Z)Z.removeChild(Q);if(Q.nodeType===eb){var Y=Q.firstChild;if(Y==null)return Q;var J=Q.lastChild}else Y=J=Q;var I=B?B.previousSibling:A.lastChild;if(Y.previousSibling=I,J.nextSibling=B,I)I.nextSibling=Y;else A.firstChild=Y;if(B==null)A.lastChild=J;else B.previousSibling=J;do Y.parentNode=A;while(Y!==J&&(Y=Y.nextSibling));if(fA0(A.ownerDocument||A,A),Q.nodeType==eb)Q.firstChild=Q.lastChild=null;return Q}function VJ8(A,Q){if(Q.parentNode)Q.parentNode.removeChild(Q);if(Q.parentNode=A,Q.previousSibling=A.lastChild,Q.nextSibling=null,Q.previousSibling)Q.previousSibling.nextSibling=Q;else A.firstChild=Q;return A.lastChild=Q,fA0(A.ownerDocument,A,Q),Q}lLA.prototype={nodeName:"#document",nodeType:bnB,doctype:null,documentElement:null,_inc:1,insertBefore:function(A,Q){if(A.nodeType==eb){var B=A.firstChild;while(B){var G=B.nextSibling;this.insertBefore(B,Q),B=G}return A}if(f01(this,A,Q),A.ownerDocument=this,this.documentElement===null&&A.nodeType===ZT)this.documentElement=A;return A},removeChild:function(A){if(this.documentElement==A)this.documentElement=null;return pnB(this,A)},replaceChild:function(A,Q){if(f01(this,A,Q,lnB),A.ownerDocument=this,Q)this.removeChild(Q);if(kx(A))this.documentElement=A},importNode:function(A,Q){return rnB(this,A,Q)},getElementById:function(A){var Q=null;return cLA(this.documentElement,function(B){if(B.nodeType==ZT){if(B.getAttribute("id")==A)return Q=B,!0}}),Q},getElementsByClassName:function(A){var Q=OnB(A);return new PYA(this,function(B){var G=[];if(Q.length>0)cLA(B.documentElement,function(Z){if(Z!==B&&Z.nodeType===ZT){var Y=Z.getAttribute("class");if(Y){var J=A===Y;if(!J){var I=OnB(Y);J=Q.every(GJ8(I))}if(J)G.push(Z)}}});return G})},createElement:function(A){var Q=new Y1A;Q.ownerDocument=this,Q.nodeName=A,Q.tagName=A,Q.localName=A,Q.childNodes=new tb;var B=Q.attributes=new k01;return B._ownerElement=Q,Q},createDocumentFragment:function(){var A=new g01;return A.ownerDocument=this,A.childNodes=new tb,A},createTextNode:function(A){var Q=new hA0;return Q.ownerDocument=this,Q.appendData(A),Q},createComment:function(A){var Q=new gA0;return Q.ownerDocument=this,Q.appendData(A),Q},createCDATASection:function(A){var Q=new uA0;return Q.ownerDocument=this,Q.appendData(A),Q},createProcessingInstruction:function(A,Q){var B=new dA0;return B.ownerDocument=this,B.tagName=B.nodeName=B.target=A,B.nodeValue=B.data=Q,B},createAttribute:function(A){var Q=new b01;return Q.ownerDocument=this,Q.name=A,Q.nodeName=A,Q.localName=A,Q.specified=!0,Q},createEntityReference:function(A){var Q=new mA0;return Q.ownerDocument=this,Q.nodeName=A,Q},createElementNS:function(A,Q){var B=new Y1A,G=Q.split(":"),Z=B.attributes=new k01;if(B.childNodes=new tb,B.ownerDocument=this,B.nodeName=Q,B.tagName=Q,B.namespaceURI=A,G.length==2)B.prefix=G[0],B.localName=G[1];else B.localName=Q;return Z._ownerElement=B,B},createAttributeNS:function(A,Q){var B=new b01,G=Q.split(":");if(B.ownerDocument=this,B.nodeName=Q,B.name=Q,B.namespaceURI=A,B.specified=!0,G.length==2)B.prefix=G[0],B.localName=G[1];else B.localName=Q;return B}};wU(lLA,t7);function Y1A(){this._nsMap={}}Y1A.prototype={nodeType:ZT,hasAttribute:function(A){return this.getAttributeNode(A)!=null},getAttribute:function(A){var Q=this.getAttributeNode(A);return Q&&Q.value||""},getAttributeNode:function(A){return this.attributes.getNamedItem(A)},setAttribute:function(A,Q){var B=this.ownerDocument.createAttribute(A);B.value=B.nodeValue=""+Q,this.setAttributeNode(B)},removeAttribute:function(A){var Q=this.getAttributeNode(A);Q&&this.removeAttributeNode(Q)},appendChild:function(A){if(A.nodeType===eb)return this.insertBefore(A,null);else return VJ8(this,A)},setAttributeNode:function(A){return this.attributes.setNamedItem(A)},setAttributeNodeNS:function(A){return this.attributes.setNamedItemNS(A)},removeAttributeNode:function(A){return this.attributes.removeNamedItem(A.nodeName)},removeAttributeNS:function(A,Q){var B=this.getAttributeNodeNS(A,Q);B&&this.removeAttributeNode(B)},hasAttributeNS:function(A,Q){return this.getAttributeNodeNS(A,Q)!=null},getAttributeNS:function(A,Q){var B=this.getAttributeNodeNS(A,Q);return B&&B.value||""},setAttributeNS:function(A,Q,B){var G=this.ownerDocument.createAttributeNS(A,Q);G.value=G.nodeValue=""+B,this.setAttributeNode(G)},getAttributeNodeNS:function(A,Q){return this.attributes.getNamedItemNS(A,Q)},getElementsByTagName:function(A){return new PYA(this,function(Q){var B=[];return cLA(Q,function(G){if(G!==Q&&G.nodeType==ZT&&(A==="*"||G.tagName==A))B.push(G)}),B})},getElementsByTagNameNS:function(A,Q){return new PYA(this,function(B){var G=[];return cLA(B,function(Z){if(Z!==B&&Z.nodeType===ZT&&(A==="*"||Z.namespaceURI===A)&&(Q==="*"||Z.localName==Q))G.push(Z)}),G})}};lLA.prototype.getElementsByTagName=Y1A.prototype.getElementsByTagName;lLA.prototype.getElementsByTagNameNS=Y1A.prototype.getElementsByTagNameNS;wU(Y1A,t7);function b01(){}b01.prototype.nodeType=jYA;wU(b01,t7);function iLA(){}iLA.prototype={data:"",substringData:function(A,Q){return this.data.substring(A,A+Q)},appendData:function(A){A=this.data+A,this.nodeValue=this.data=A,this.length=A.length},insertData:function(A,Q){this.replaceData(A,0,Q)},appendChild:function(A){throw Error(RV[$U])},deleteData:function(A,Q){this.replaceData(A,Q,"")},replaceData:function(A,Q,B){var G=this.data.substring(0,A),Z=this.data.substring(A+Q);B=G+B+Z,this.nodeValue=this.data=B,this.length=B.length}};wU(iLA,t7);function hA0(){}hA0.prototype={nodeName:"#text",nodeType:v01,splitText:function(A){var Q=this.data,B=Q.substring(A);Q=Q.substring(0,A),this.data=this.nodeValue=Q,this.length=Q.length;var G=this.ownerDocument.createTextNode(B);if(this.parentNode)this.parentNode.insertBefore(G,this.nextSibling);return G}};wU(hA0,iLA);function gA0(){}gA0.prototype={nodeName:"#comment",nodeType:fnB};wU(gA0,iLA);function uA0(){}uA0.prototype={nodeName:"#cdata-section",nodeType:ynB};wU(uA0,iLA);function h01(){}h01.prototype.nodeType=hnB;wU(h01,t7);function inB(){}inB.prototype.nodeType=YJ8;wU(inB,t7);function nnB(){}nnB.prototype.nodeType=ZJ8;wU(nnB,t7);function mA0(){}mA0.prototype.nodeType=vnB;wU(mA0,t7);function g01(){}g01.prototype.nodeName="#document-fragment";g01.prototype.nodeType=eb;wU(g01,t7);function dA0(){}dA0.prototype.nodeType=knB;wU(dA0,t7);function anB(){}anB.prototype.serializeToString=function(A,Q,B){return onB.call(A,Q,B)};t7.prototype.toString=onB;function onB(A,Q){var B=[],G=this.nodeType==9&&this.documentElement||this,Z=G.prefix,Y=G.namespaceURI;if(Y&&Z==null){var Z=G.lookupPrefix(Y);if(Z==null)var J=[{namespace:Y,prefix:null}]}return TYA(this,B,A,Q,J),B.join("")}function SnB(A,Q,B){var G=A.prefix||"",Z=A.namespaceURI;if(!Z)return!1;if(G==="xml"&&Z===dLA.XML||Z===dLA.XMLNS)return!1;var Y=B.length;while(Y--){var J=B[Y];if(J.prefix===G)return J.namespace!==Z}return!0}function yA0(A,Q,B){A.push(" ",Q,'="',B.replace(/[<>&"\t\n\r]/g,dnB),'"')}function TYA(A,Q,B,G,Z){if(!Z)Z=[];if(G)if(A=G(A),A){if(typeof A=="string"){Q.push(A);return}}else return;switch(A.nodeType){case ZT:var Y=A.attributes,J=Y.length,U=A.firstChild,I=A.tagName;B=dLA.isHTML(A.namespaceURI)||B;var X=I;if(!B&&!A.prefix&&A.namespaceURI){var W;for(var K=0;K<Y.length;K++)if(Y.item(K).name==="xmlns"){W=Y.item(K).value;break}if(!W)for(var V=Z.length-1;V>=0;V--){var E=Z[V];if(E.prefix===""&&E.namespace===A.namespaceURI){W=E.namespace;break}}if(W!==A.namespaceURI)for(var V=Z.length-1;V>=0;V--){var E=Z[V];if(E.namespace===A.namespaceURI){if(E.prefix)X=E.prefix+":"+I;break}}}Q.push("<",X);for(var D=0;D<J;D++){var H=Y.item(D);if(H.prefix=="xmlns")Z.push({prefix:H.localName,namespace:H.value});else if(H.nodeName=="xmlns")Z.push({prefix:"",namespace:H.value})}for(var D=0;D<J;D++){var H=Y.item(D);if(SnB(H,B,Z)){var F=H.prefix||"",C=H.namespaceURI;yA0(Q,F?"xmlns:"+F:"xmlns",C),Z.push({prefix:F,namespace:C})}TYA(H,Q,B,G,Z)}if(I===X&&SnB(A,B,Z)){var F=A.prefix||"",C=A.namespaceURI;yA0(Q,F?"xmlns:"+F:"xmlns",C),Z.push({prefix:F,namespace:C})}if(U||B&&!/^(?:meta|link|img|br|hr|input)$/i.test(I)){if(Q.push(">"),B&&/^script$/i.test(I))while(U){if(U.data)Q.push(U.data);else TYA(U,Q,B,G,Z.slice());U=U.nextSibling}else while(U)TYA(U,Q,B,G,Z.slice()),U=U.nextSibling;Q.push("</",X,">")}else Q.push("/>");return;case bnB:case eb:var U=A.firstChild;while(U)TYA(U,Q,B,G,Z.slice()),U=U.nextSibling;return;case jYA:return yA0(Q,A.name,A.value);case v01:return Q.push(A.data.replace(/[<&>]/g,dnB));case ynB:return Q.push("<![CDATA[",A.data,"]]>");case fnB:return Q.push("<!--",A.data,"-->");case hnB:var{publicId:O,systemId:q}=A;if(Q.push("<!DOCTYPE ",A.name),O){if(Q.push(" PUBLIC ",O),q&&q!=".")Q.push(" ",q);Q.push(">")}else if(q&&q!=".")Q.push(" SYSTEM ",q,">");else{var M=A.internalSubset;if(M)Q.push(" [",M,"]");Q.push(">")}return;case knB:return Q.push("<?",A.target," ",A.data,"?>");case vnB:return Q.push("&",A.nodeName,";");default:Q.push("??",A.nodeName)}}function rnB(A,Q,B){var G;switch(Q.nodeType){case ZT:G=Q.cloneNode(!1),G.ownerDocument=A;case eb:break;case jYA:B=!0;break}if(!G)G=Q.cloneNode(!1);if(G.ownerDocument=A,G.parentNode=null,B){var Z=Q.firstChild;while(Z)G.appendChild(rnB(A,Z,B)),Z=Z.nextSibling}return G}function vA0(A,Q,B){var G=new Q.constructor;for(var Z in Q)if(Object.prototype.hasOwnProperty.call(Q,Z)){var Y=Q[Z];if(typeof Y!="object"){if(Y!=G[Z])G[Z]=Y}}if(Q.childNodes)G.childNodes=new tb;switch(G.ownerDocument=A,G.nodeType){case ZT:var J=Q.attributes,I=G.attributes=new k01,X=J.length;I._ownerElement=G;for(var W=0;W<X;W++)G.setAttributeNode(vA0(A,J.item(W),!0));break;case jYA:B=!0}if(B){var K=Q.firstChild;while(K)G.appendChild(vA0(A,K,B)),K=K.nextSibling}return G}function snB(A,Q,B){A[Q]=B}try{if(Object.defineProperty){let A=function(Q){switch(Q.nodeType){case ZT:case eb:var B=[];Q=Q.firstChild;while(Q){if(Q.nodeType!==7&&Q.nodeType!==8)B.push(A(Q));Q=Q.nextSibling}return B.join("");default:return Q.nodeValue}};EJ8=A,Object.defineProperty(PYA.prototype,"length",{get:function(){return kA0(this),this.$$length}}),Object.defineProperty(t7.prototype,"textContent",{get:function(){return A(this)},set:function(Q){switch(this.nodeType){case ZT:case eb:while(this.firstChild)this.removeChild(this.firstChild);if(Q||String(Q))this.appendChild(this.ownerDocument.createTextNode(Q));break;default:this.data=Q,this.value=Q,this.nodeValue=Q}}}),snB=function(Q,B,G){Q["$$"+B]=G}}}catch(A){}var EJ8;DJ8.DocumentType=h01;DJ8.DOMException=VX;DJ8.DOMImplementation=mnB;DJ8.Element=Y1A;DJ8.Node=t7;DJ8.NodeList=tb;DJ8.XMLSerializer=anB});var AaB=w((NJ8)=>{var tnB=mLA().freeze;NJ8.XML_ENTITIES=tnB({amp:"&",apos:"'",gt:">",lt:"<",quot:'"'});NJ8.HTML_ENTITIES=tnB({Aacute:"√Å",aacute:"√°",Abreve:"ƒÇ",abreve:"ƒÉ",ac:"‚àæ",acd:"‚àø",acE:"‚àæÃ≥",Acirc:"√Ç",acirc:"√¢",acute:"¬¥",Acy:"–ê",acy:"–∞",AElig:"√Ü",aelig:"√¶",af:"‚Å°",Afr:"\uD835\uDD04",afr:"\uD835\uDD1E",Agrave:"√Ä",agrave:"√†",alefsym:"‚Ñµ",aleph:"‚Ñµ",Alpha:"Œë",alpha:"Œ±",Amacr:"ƒÄ",amacr:"ƒÅ",amalg:"‚®ø",AMP:"&",amp:"&",And:"‚©ì",and:"‚àß",andand:"‚©ï",andd:"‚©ú",andslope:"‚©ò",andv:"‚©ö",ang:"‚à†",ange:"‚¶§",angle:"‚à†",angmsd:"‚à°",angmsdaa:"‚¶®",angmsdab:"‚¶©",angmsdac:"‚¶™",angmsdad:"‚¶´",angmsdae:"‚¶¨",angmsdaf:"‚¶≠",angmsdag:"‚¶Æ",angmsdah:"‚¶Ø",angrt:"‚àü",angrtvb:"‚äæ",angrtvbd:"‚¶ù",angsph:"‚à¢",angst:"√Ö",angzarr:"‚çº",Aogon:"ƒÑ",aogon:"ƒÖ",Aopf:"\uD835\uDD38",aopf:"\uD835\uDD52",ap:"‚âà",apacir:"‚©Ø",apE:"‚©∞",ape:"‚âä",apid:"‚âã",apos:"'",ApplyFunction:"‚Å°",approx:"‚âà",approxeq:"‚âä",Aring:"√Ö",aring:"√•",Ascr:"\uD835\uDC9C",ascr:"\uD835\uDCB6",Assign:"‚âî",ast:"*",asymp:"‚âà",asympeq:"‚âç",Atilde:"√É",atilde:"√£",Auml:"√Ñ",auml:"√§",awconint:"‚à≥",awint:"‚®ë",backcong:"‚âå",backepsilon:"œ∂",backprime:"‚Äµ",backsim:"‚àΩ",backsimeq:"‚ãç",Backslash:"‚àñ",Barv:"‚´ß",barvee:"‚äΩ",Barwed:"‚åÜ",barwed:"‚åÖ",barwedge:"‚åÖ",bbrk:"‚éµ",bbrktbrk:"‚é∂",bcong:"‚âå",Bcy:"–ë",bcy:"–±",bdquo:"‚Äû",becaus:"‚àµ",Because:"‚àµ",because:"‚àµ",bemptyv:"‚¶∞",bepsi:"œ∂",bernou:"‚Ñ¨",Bernoullis:"‚Ñ¨",Beta:"Œí",beta:"Œ≤",beth:"‚Ñ∂",between:"‚â¨",Bfr:"\uD835\uDD05",bfr:"\uD835\uDD1F",bigcap:"‚ãÇ",bigcirc:"‚óØ",bigcup:"‚ãÉ",bigodot:"‚®Ä",bigoplus:"‚®Å",bigotimes:"‚®Ç",bigsqcup:"‚®Ü",bigstar:"‚òÖ",bigtriangledown:"‚ñΩ",bigtriangleup:"‚ñ≥",biguplus:"‚®Ñ",bigvee:"‚ãÅ",bigwedge:"‚ãÄ",bkarow:"‚§ç",blacklozenge:"‚ß´",blacksquare:"‚ñ™",blacktriangle:"‚ñ¥",blacktriangledown:"‚ñæ",blacktriangleleft:"‚óÇ",blacktriangleright:"‚ñ∏",blank:"‚ê£",blk12:"‚ñí",blk14:"‚ñë",blk34:"‚ñì",block:"‚ñà",bne:"=‚É•",bnequiv:"‚â°‚É•",bNot:"‚´≠",bnot:"‚åê",Bopf:"\uD835\uDD39",bopf:"\uD835\uDD53",bot:"‚ä•",bottom:"‚ä•",bowtie:"‚ãà",boxbox:"‚ßâ",boxDL:"‚ïó",boxDl:"‚ïñ",boxdL:"‚ïï",boxdl:"‚îê",boxDR:"‚ïî",boxDr:"‚ïì",boxdR:"‚ïí",boxdr:"‚îå",boxH:"‚ïê",boxh:"‚îÄ",boxHD:"‚ï¶",boxHd:"‚ï§",boxhD:"‚ï•",boxhd:"‚î¨",boxHU:"‚ï©",boxHu:"‚ïß",boxhU:"‚ï®",boxhu:"‚î¥",boxminus:"‚äü",boxplus:"‚äû",boxtimes:"‚ä†",boxUL:"‚ïù",boxUl:"‚ïú",boxuL:"‚ïõ",boxul:"‚îò",boxUR:"‚ïö",boxUr:"‚ïô",boxuR:"‚ïò",boxur:"‚îî",boxV:"‚ïë",boxv:"‚îÇ",boxVH:"‚ï¨",boxVh:"‚ï´",boxvH:"‚ï™",boxvh:"‚îº",boxVL:"‚ï£",boxVl:"‚ï¢",boxvL:"‚ï°",boxvl:"‚î§",boxVR:"‚ï†",boxVr:"‚ïü",boxvR:"‚ïû",boxvr:"‚îú",bprime:"‚Äµ",Breve:"Àò",breve:"Àò",brvbar:"¬¶",Bscr:"‚Ñ¨",bscr:"\uD835\uDCB7",bsemi:"‚Åè",bsim:"‚àΩ",bsime:"‚ãç",bsol:"\\",bsolb:"‚ßÖ",bsolhsub:"‚üà",bull:"‚Ä¢",bullet:"‚Ä¢",bump:"‚âé",bumpE:"‚™Æ",bumpe:"‚âè",Bumpeq:"‚âé",bumpeq:"‚âè",Cacute:"ƒÜ",cacute:"ƒá",Cap:"‚ãí",cap:"‚à©",capand:"‚©Ñ",capbrcup:"‚©â",capcap:"‚©ã",capcup:"‚©á",capdot:"‚©Ä",CapitalDifferentialD:"‚ÖÖ",caps:"‚à©Ô∏Ä",caret:"‚ÅÅ",caron:"Àá",Cayleys:"‚Ñ≠",ccaps:"‚©ç",Ccaron:"ƒå",ccaron:"ƒç",Ccedil:"√á",ccedil:"√ß",Ccirc:"ƒà",ccirc:"ƒâ",Cconint:"‚à∞",ccups:"‚©å",ccupssm:"‚©ê",Cdot:"ƒä",cdot:"ƒã",cedil:"¬∏",Cedilla:"¬∏",cemptyv:"‚¶≤",cent:"¬¢",CenterDot:"¬∑",centerdot:"¬∑",Cfr:"‚Ñ≠",cfr:"\uD835\uDD20",CHcy:"–ß",chcy:"—á",check:"‚úì",checkmark:"‚úì",Chi:"Œß",chi:"œá",cir:"‚óã",circ:"ÀÜ",circeq:"‚âó",circlearrowleft:"‚Ü∫",circlearrowright:"‚Üª",circledast:"‚äõ",circledcirc:"‚äö",circleddash:"‚äù",CircleDot:"‚äô",circledR:"¬Æ",circledS:"‚ìà",CircleMinus:"‚äñ",CirclePlus:"‚äï",CircleTimes:"‚äó",cirE:"‚ßÉ",cire:"‚âó",cirfnint:"‚®ê",cirmid:"‚´Ø",cirscir:"‚ßÇ",ClockwiseContourIntegral:"‚à≤",CloseCurlyDoubleQuote:"‚Äù",CloseCurlyQuote:"‚Äô",clubs:"‚ô£",clubsuit:"‚ô£",Colon:"‚à∑",colon:":",Colone:"‚©¥",colone:"‚âî",coloneq:"‚âî",comma:",",commat:"@",comp:"‚àÅ",compfn:"‚àò",complement:"‚àÅ",complexes:"‚ÑÇ",cong:"‚âÖ",congdot:"‚©≠",Congruent:"‚â°",Conint:"‚àØ",conint:"‚àÆ",ContourIntegral:"‚àÆ",Copf:"‚ÑÇ",copf:"\uD835\uDD54",coprod:"‚àê",Coproduct:"‚àê",COPY:"¬©",copy:"¬©",copysr:"‚Ñó",CounterClockwiseContourIntegral:"‚à≥",crarr:"‚Üµ",Cross:"‚®Ø",cross:"‚úó",Cscr:"\uD835\uDC9E",cscr:"\uD835\uDCB8",csub:"‚´è",csube:"‚´ë",csup:"‚´ê",csupe:"‚´í",ctdot:"‚ãØ",cudarrl:"‚§∏",cudarrr:"‚§µ",cuepr:"‚ãû",cuesc:"‚ãü",cularr:"‚Ü∂",cularrp:"‚§Ω",Cup:"‚ãì",cup:"‚à™",cupbrcap:"‚©à",CupCap:"‚âç",cupcap:"‚©Ü",cupcup:"‚©ä",cupdot:"‚äç",cupor:"‚©Ö",cups:"‚à™Ô∏Ä",curarr:"‚Ü∑",curarrm:"‚§º",curlyeqprec:"‚ãû",curlyeqsucc:"‚ãü",curlyvee:"‚ãé",curlywedge:"‚ãè",curren:"¬§",curvearrowleft:"‚Ü∂",curvearrowright:"‚Ü∑",cuvee:"‚ãé",cuwed:"‚ãè",cwconint:"‚à≤",cwint:"‚à±",cylcty:"‚å≠",Dagger:"‚Ä°",dagger:"‚Ä†",daleth:"‚Ñ∏",Darr:"‚Ü°",dArr:"‚áì",darr:"‚Üì",dash:"‚Äê",Dashv:"‚´§",dashv:"‚ä£",dbkarow:"‚§è",dblac:"Àù",Dcaron:"ƒé",dcaron:"ƒè",Dcy:"–î",dcy:"–¥",DD:"‚ÖÖ",dd:"‚ÖÜ",ddagger:"‚Ä°",ddarr:"‚áä",DDotrahd:"‚§ë",ddotseq:"‚©∑",deg:"¬∞",Del:"‚àá",Delta:"Œî",delta:"Œ¥",demptyv:"‚¶±",dfisht:"‚•ø",Dfr:"\uD835\uDD07",dfr:"\uD835\uDD21",dHar:"‚••",dharl:"‚áÉ",dharr:"‚áÇ",DiacriticalAcute:"¬¥",DiacriticalDot:"Àô",DiacriticalDoubleAcute:"Àù",DiacriticalGrave:"`",DiacriticalTilde:"Àú",diam:"‚ãÑ",Diamond:"‚ãÑ",diamond:"‚ãÑ",diamondsuit:"‚ô¶",diams:"‚ô¶",die:"¬®",DifferentialD:"‚ÖÜ",digamma:"œù",disin:"‚ã≤",div:"√∑",divide:"√∑",divideontimes:"‚ãá",divonx:"‚ãá",DJcy:"–Ç",djcy:"—í",dlcorn:"‚åû",dlcrop:"‚åç",dollar:"$",Dopf:"\uD835\uDD3B",dopf:"\uD835\uDD55",Dot:"¬®",dot:"Àô",DotDot:"‚Éú",doteq:"‚âê",doteqdot:"‚âë",DotEqual:"‚âê",dotminus:"‚à∏",dotplus:"‚àî",dotsquare:"‚ä°",doublebarwedge:"‚åÜ",DoubleContourIntegral:"‚àØ",DoubleDot:"¬®",DoubleDownArrow:"‚áì",DoubleLeftArrow:"‚áê",DoubleLeftRightArrow:"‚áî",DoubleLeftTee:"‚´§",DoubleLongLeftArrow:"‚ü∏",DoubleLongLeftRightArrow:"‚ü∫",DoubleLongRightArrow:"‚üπ",DoubleRightArrow:"‚áí",DoubleRightTee:"‚ä®",DoubleUpArrow:"‚áë",DoubleUpDownArrow:"‚áï",DoubleVerticalBar:"‚à•",DownArrow:"‚Üì",Downarrow:"‚áì",downarrow:"‚Üì",DownArrowBar:"‚§ì",DownArrowUpArrow:"‚áµ",DownBreve:"Ãë",downdownarrows:"‚áä",downharpoonleft:"‚áÉ",downharpoonright:"‚áÇ",DownLeftRightVector:"‚•ê",DownLeftTeeVector:"‚•û",DownLeftVector:"‚ÜΩ",DownLeftVectorBar:"‚•ñ",DownRightTeeVector:"‚•ü",DownRightVector:"‚áÅ",DownRightVectorBar:"‚•ó",DownTee:"‚ä§",DownTeeArrow:"‚Üß",drbkarow:"‚§ê",drcorn:"‚åü",drcrop:"‚åå",Dscr:"\uD835\uDC9F",dscr:"\uD835\uDCB9",DScy:"–Ö",dscy:"—ï",dsol:"‚ß∂",Dstrok:"ƒê",dstrok:"ƒë",dtdot:"‚ã±",dtri:"‚ñø",dtrif:"‚ñæ",duarr:"‚áµ",duhar:"‚•Ø",dwangle:"‚¶¶",DZcy:"–è",dzcy:"—ü",dzigrarr:"‚üø",Eacute:"√â",eacute:"√©",easter:"‚©Æ",Ecaron:"ƒö",ecaron:"ƒõ",ecir:"‚âñ",Ecirc:"√ä",ecirc:"√™",ecolon:"‚âï",Ecy:"–≠",ecy:"—ç",eDDot:"‚©∑",Edot:"ƒñ",eDot:"‚âë",edot:"ƒó",ee:"‚Öá",efDot:"‚âí",Efr:"\uD835\uDD08",efr:"\uD835\uDD22",eg:"‚™ö",Egrave:"√à",egrave:"√®",egs:"‚™ñ",egsdot:"‚™ò",el:"‚™ô",Element:"‚àà",elinters:"‚èß",ell:"‚Ñì",els:"‚™ï",elsdot:"‚™ó",Emacr:"ƒí",emacr:"ƒì",empty:"‚àÖ",emptyset:"‚àÖ",EmptySmallSquare:"‚óª",emptyv:"‚àÖ",EmptyVerySmallSquare:"‚ñ´",emsp:"‚ÄÉ",emsp13:"‚ÄÑ",emsp14:"‚ÄÖ",ENG:"≈ä",eng:"≈ã",ensp:"‚ÄÇ",Eogon:"ƒò",eogon:"ƒô",Eopf:"\uD835\uDD3C",eopf:"\uD835\uDD56",epar:"‚ãï",eparsl:"‚ß£",eplus:"‚©±",epsi:"Œµ",Epsilon:"Œï",epsilon:"Œµ",epsiv:"œµ",eqcirc:"‚âñ",eqcolon:"‚âï",eqsim:"‚âÇ",eqslantgtr:"‚™ñ",eqslantless:"‚™ï",Equal:"‚©µ",equals:"=",EqualTilde:"‚âÇ",equest:"‚âü",Equilibrium:"‚áå",equiv:"‚â°",equivDD:"‚©∏",eqvparsl:"‚ß•",erarr:"‚•±",erDot:"‚âì",Escr:"‚Ñ∞",escr:"‚ÑØ",esdot:"‚âê",Esim:"‚©≥",esim:"‚âÇ",Eta:"Œó",eta:"Œ∑",ETH:"√ê",eth:"√∞",Euml:"√ã",euml:"√´",euro:"‚Ç¨",excl:"!",exist:"‚àÉ",Exists:"‚àÉ",expectation:"‚Ñ∞",ExponentialE:"‚Öá",exponentiale:"‚Öá",fallingdotseq:"‚âí",Fcy:"–§",fcy:"—Ñ",female:"‚ôÄ",ffilig:"Ô¨É",fflig:"Ô¨Ä",ffllig:"Ô¨Ñ",Ffr:"\uD835\uDD09",ffr:"\uD835\uDD23",filig:"Ô¨Å",FilledSmallSquare:"‚óº",FilledVerySmallSquare:"‚ñ™",fjlig:"fj",flat:"‚ô≠",fllig:"Ô¨Ç",fltns:"‚ñ±",fnof:"∆í",Fopf:"\uD835\uDD3D",fopf:"\uD835\uDD57",ForAll:"‚àÄ",forall:"‚àÄ",fork:"‚ãî",forkv:"‚´ô",Fouriertrf:"‚Ñ±",fpartint:"‚®ç",frac12:"¬Ω",frac13:"‚Öì",frac14:"¬º",frac15:"‚Öï",frac16:"‚Öô",frac18:"‚Öõ",frac23:"‚Öî",frac25:"‚Öñ",frac34:"¬æ",frac35:"‚Öó",frac38:"‚Öú",frac45:"‚Öò",frac56:"‚Öö",frac58:"‚Öù",frac78:"‚Öû",frasl:"‚ÅÑ",frown:"‚å¢",Fscr:"‚Ñ±",fscr:"\uD835\uDCBB",gacute:"«µ",Gamma:"Œì",gamma:"Œ≥",Gammad:"œú",gammad:"œù",gap:"‚™Ü",Gbreve:"ƒû",gbreve:"ƒü",Gcedil:"ƒ¢",Gcirc:"ƒú",gcirc:"ƒù",Gcy:"–ì",gcy:"–≥",Gdot:"ƒ†",gdot:"ƒ°",gE:"‚âß",ge:"‚â•",gEl:"‚™å",gel:"‚ãõ",geq:"‚â•",geqq:"‚âß",geqslant:"‚©æ",ges:"‚©æ",gescc:"‚™©",gesdot:"‚™Ä",gesdoto:"‚™Ç",gesdotol:"‚™Ñ",gesl:"‚ãõÔ∏Ä",gesles:"‚™î",Gfr:"\uD835\uDD0A",gfr:"\uD835\uDD24",Gg:"‚ãô",gg:"‚â´",ggg:"‚ãô",gimel:"‚Ñ∑",GJcy:"–É",gjcy:"—ì",gl:"‚â∑",gla:"‚™•",glE:"‚™í",glj:"‚™§",gnap:"‚™ä",gnapprox:"‚™ä",gnE:"‚â©",gne:"‚™à",gneq:"‚™à",gneqq:"‚â©",gnsim:"‚ãß",Gopf:"\uD835\uDD3E",gopf:"\uD835\uDD58",grave:"`",GreaterEqual:"‚â•",GreaterEqualLess:"‚ãõ",GreaterFullEqual:"‚âß",GreaterGreater:"‚™¢",GreaterLess:"‚â∑",GreaterSlantEqual:"‚©æ",GreaterTilde:"‚â≥",Gscr:"\uD835\uDCA2",gscr:"‚Ñä",gsim:"‚â≥",gsime:"‚™é",gsiml:"‚™ê",Gt:"‚â´",GT:">",gt:">",gtcc:"‚™ß",gtcir:"‚©∫",gtdot:"‚ãó",gtlPar:"‚¶ï",gtquest:"‚©º",gtrapprox:"‚™Ü",gtrarr:"‚•∏",gtrdot:"‚ãó",gtreqless:"‚ãõ",gtreqqless:"‚™å",gtrless:"‚â∑",gtrsim:"‚â≥",gvertneqq:"‚â©Ô∏Ä",gvnE:"‚â©Ô∏Ä",Hacek:"Àá",hairsp:"‚Ää",half:"¬Ω",hamilt:"‚Ñã",HARDcy:"–™",hardcy:"—ä",hArr:"‚áî",harr:"‚Üî",harrcir:"‚•à",harrw:"‚Ü≠",Hat:"^",hbar:"‚Ñè",Hcirc:"ƒ§",hcirc:"ƒ•",hearts:"‚ô•",heartsuit:"‚ô•",hellip:"‚Ä¶",hercon:"‚äπ",Hfr:"‚Ñå",hfr:"\uD835\uDD25",HilbertSpace:"‚Ñã",hksearow:"‚§•",hkswarow:"‚§¶",hoarr:"‚áø",homtht:"‚àª",hookleftarrow:"‚Ü©",hookrightarrow:"‚Ü™",Hopf:"‚Ñç",hopf:"\uD835\uDD59",horbar:"‚Äï",HorizontalLine:"‚îÄ",Hscr:"‚Ñã",hscr:"\uD835\uDCBD",hslash:"‚Ñè",Hstrok:"ƒ¶",hstrok:"ƒß",HumpDownHump:"‚âé",HumpEqual:"‚âè",hybull:"‚ÅÉ",hyphen:"‚Äê",Iacute:"√ç",iacute:"√≠",ic:"‚Å£",Icirc:"√é",icirc:"√Æ",Icy:"–ò",icy:"–∏",Idot:"ƒ∞",IEcy:"–ï",iecy:"–µ",iexcl:"¬°",iff:"‚áî",Ifr:"‚Ñë",ifr:"\uD835\uDD26",Igrave:"√å",igrave:"√¨",ii:"‚Öà",iiiint:"‚®å",iiint:"‚à≠",iinfin:"‚ßú",iiota:"‚Ñ©",IJlig:"ƒ≤",ijlig:"ƒ≥",Im:"‚Ñë",Imacr:"ƒ™",imacr:"ƒ´",image:"‚Ñë",ImaginaryI:"‚Öà",imagline:"‚Ñê",imagpart:"‚Ñë",imath:"ƒ±",imof:"‚ä∑",imped:"∆µ",Implies:"‚áí",in:"‚àà",incare:"‚ÑÖ",infin:"‚àû",infintie:"‚ßù",inodot:"ƒ±",Int:"‚à¨",int:"‚à´",intcal:"‚ä∫",integers:"‚Ñ§",Integral:"‚à´",intercal:"‚ä∫",Intersection:"‚ãÇ",intlarhk:"‚®ó",intprod:"‚®º",InvisibleComma:"‚Å£",InvisibleTimes:"‚Å¢",IOcy:"–Å",iocy:"—ë",Iogon:"ƒÆ",iogon:"ƒØ",Iopf:"\uD835\uDD40",iopf:"\uD835\uDD5A",Iota:"Œô",iota:"Œπ",iprod:"‚®º",iquest:"¬ø",Iscr:"‚Ñê",iscr:"\uD835\uDCBE",isin:"‚àà",isindot:"‚ãµ",isinE:"‚ãπ",isins:"‚ã¥",isinsv:"‚ã≥",isinv:"‚àà",it:"‚Å¢",Itilde:"ƒ®",itilde:"ƒ©",Iukcy:"–Ü",iukcy:"—ñ",Iuml:"√è",iuml:"√Ø",Jcirc:"ƒ¥",jcirc:"ƒµ",Jcy:"–ô",jcy:"–π",Jfr:"\uD835\uDD0D",jfr:"\uD835\uDD27",jmath:"»∑",Jopf:"\uD835\uDD41",jopf:"\uD835\uDD5B",Jscr:"\uD835\uDCA5",jscr:"\uD835\uDCBF",Jsercy:"–à",jsercy:"—ò",Jukcy:"–Ñ",jukcy:"—î",Kappa:"Œö",kappa:"Œ∫",kappav:"œ∞",Kcedil:"ƒ∂",kcedil:"ƒ∑",Kcy:"–ö",kcy:"–∫",Kfr:"\uD835\uDD0E",kfr:"\uD835\uDD28",kgreen:"ƒ∏",KHcy:"–•",khcy:"—Ö",KJcy:"–å",kjcy:"—ú",Kopf:"\uD835\uDD42",kopf:"\uD835\uDD5C",Kscr:"\uD835\uDCA6",kscr:"\uD835\uDCC0",lAarr:"‚áö",Lacute:"ƒπ",lacute:"ƒ∫",laemptyv:"‚¶¥",lagran:"‚Ñí",Lambda:"Œõ",lambda:"Œª",Lang:"‚ü™",lang:"‚ü®",langd:"‚¶ë",langle:"‚ü®",lap:"‚™Ö",Laplacetrf:"‚Ñí",laquo:"¬´",Larr:"‚Üû",lArr:"‚áê",larr:"‚Üê",larrb:"‚á§",larrbfs:"‚§ü",larrfs:"‚§ù",larrhk:"‚Ü©",larrlp:"‚Ü´",larrpl:"‚§π",larrsim:"‚•≥",larrtl:"‚Ü¢",lat:"‚™´",lAtail:"‚§õ",latail:"‚§ô",late:"‚™≠",lates:"‚™≠Ô∏Ä",lBarr:"‚§é",lbarr:"‚§å",lbbrk:"‚ù≤",lbrace:"{",lbrack:"[",lbrke:"‚¶ã",lbrksld:"‚¶è",lbrkslu:"‚¶ç",Lcaron:"ƒΩ",lcaron:"ƒæ",Lcedil:"ƒª",lcedil:"ƒº",lceil:"‚åà",lcub:"{",Lcy:"–õ",lcy:"–ª",ldca:"‚§∂",ldquo:"‚Äú",ldquor:"‚Äû",ldrdhar:"‚•ß",ldrushar:"‚•ã",ldsh:"‚Ü≤",lE:"‚â¶",le:"‚â§",LeftAngleBracket:"‚ü®",LeftArrow:"‚Üê",Leftarrow:"‚áê",leftarrow:"‚Üê",LeftArrowBar:"‚á§",LeftArrowRightArrow:"‚áÜ",leftarrowtail:"‚Ü¢",LeftCeiling:"‚åà",LeftDoubleBracket:"‚ü¶",LeftDownTeeVector:"‚•°",LeftDownVector:"‚áÉ",LeftDownVectorBar:"‚•ô",LeftFloor:"‚åä",leftharpoondown:"‚ÜΩ",leftharpoonup:"‚Üº",leftleftarrows:"‚áá",LeftRightArrow:"‚Üî",Leftrightarrow:"‚áî",leftrightarrow:"‚Üî",leftrightarrows:"‚áÜ",leftrightharpoons:"‚áã",leftrightsquigarrow:"‚Ü≠",LeftRightVector:"‚•é",LeftTee:"‚ä£",LeftTeeArrow:"‚Ü§",LeftTeeVector:"‚•ö",leftthreetimes:"‚ãã",LeftTriangle:"‚ä≤",LeftTriangleBar:"‚ßè",LeftTriangleEqual:"‚ä¥",LeftUpDownVector:"‚•ë",LeftUpTeeVector:"‚•†",LeftUpVector:"‚Üø",LeftUpVectorBar:"‚•ò",LeftVector:"‚Üº",LeftVectorBar:"‚•í",lEg:"‚™ã",leg:"‚ãö",leq:"‚â§",leqq:"‚â¶",leqslant:"‚©Ω",les:"‚©Ω",lescc:"‚™®",lesdot:"‚©ø",lesdoto:"‚™Å",lesdotor:"‚™É",lesg:"‚ãöÔ∏Ä",lesges:"‚™ì",lessapprox:"‚™Ö",lessdot:"‚ãñ",lesseqgtr:"‚ãö",lesseqqgtr:"‚™ã",LessEqualGreater:"‚ãö",LessFullEqual:"‚â¶",LessGreater:"‚â∂",lessgtr:"‚â∂",LessLess:"‚™°",lesssim:"‚â≤",LessSlantEqual:"‚©Ω",LessTilde:"‚â≤",lfisht:"‚•º",lfloor:"‚åä",Lfr:"\uD835\uDD0F",lfr:"\uD835\uDD29",lg:"‚â∂",lgE:"‚™ë",lHar:"‚•¢",lhard:"‚ÜΩ",lharu:"‚Üº",lharul:"‚•™",lhblk:"‚ñÑ",LJcy:"–â",ljcy:"—ô",Ll:"‚ãò",ll:"‚â™",llarr:"‚áá",llcorner:"‚åû",Lleftarrow:"‚áö",llhard:"‚•´",lltri:"‚ó∫",Lmidot:"ƒø",lmidot:"≈Ä",lmoust:"‚é∞",lmoustache:"‚é∞",lnap:"‚™â",lnapprox:"‚™â",lnE:"‚â®",lne:"‚™á",lneq:"‚™á",lneqq:"‚â®",lnsim:"‚ã¶",loang:"‚ü¨",loarr:"‚áΩ",lobrk:"‚ü¶",LongLeftArrow:"‚üµ",Longleftarrow:"‚ü∏",longleftarrow:"‚üµ",LongLeftRightArrow:"‚ü∑",Longleftrightarrow:"‚ü∫",longleftrightarrow:"‚ü∑",longmapsto:"‚üº",LongRightArrow:"‚ü∂",Longrightarrow:"‚üπ",longrightarrow:"‚ü∂",looparrowleft:"‚Ü´",looparrowright:"‚Ü¨",lopar:"‚¶Ö",Lopf:"\uD835\uDD43",lopf:"\uD835\uDD5D",loplus:"‚®≠",lotimes:"‚®¥",lowast:"‚àó",lowbar:"_",LowerLeftArrow:"‚Üô",LowerRightArrow:"‚Üò",loz:"‚óä",lozenge:"‚óä",lozf:"‚ß´",lpar:"(",lparlt:"‚¶ì",lrarr:"‚áÜ",lrcorner:"‚åü",lrhar:"‚áã",lrhard:"‚•≠",lrm:"‚Äé",lrtri:"‚äø",lsaquo:"‚Äπ",Lscr:"‚Ñí",lscr:"\uD835\uDCC1",Lsh:"‚Ü∞",lsh:"‚Ü∞",lsim:"‚â≤",lsime:"‚™ç",lsimg:"‚™è",lsqb:"[",lsquo:"‚Äò",lsquor:"‚Äö",Lstrok:"≈Å",lstrok:"≈Ç",Lt:"‚â™",LT:"<",lt:"<",ltcc:"‚™¶",ltcir:"‚©π",ltdot:"‚ãñ",lthree:"‚ãã",ltimes:"‚ãâ",ltlarr:"‚•∂",ltquest:"‚©ª",ltri:"‚óÉ",ltrie:"‚ä¥",ltrif:"‚óÇ",ltrPar:"‚¶ñ",lurdshar:"‚•ä",luruhar:"‚•¶",lvertneqq:"‚â®Ô∏Ä",lvnE:"‚â®Ô∏Ä",macr:"¬Ø",male:"‚ôÇ",malt:"‚ú†",maltese:"‚ú†",Map:"‚§Ö",map:"‚Ü¶",mapsto:"‚Ü¶",mapstodown:"‚Üß",mapstoleft:"‚Ü§",mapstoup:"‚Ü•",marker:"‚ñÆ",mcomma:"‚®©",Mcy:"–ú",mcy:"–º",mdash:"‚Äî",mDDot:"‚à∫",measuredangle:"‚à°",MediumSpace:"‚Åü",Mellintrf:"‚Ñ≥",Mfr:"\uD835\uDD10",mfr:"\uD835\uDD2A",mho:"‚Ñß",micro:"¬µ",mid:"‚à£",midast:"*",midcir:"‚´∞",middot:"¬∑",minus:"‚àí",minusb:"‚äü",minusd:"‚à∏",minusdu:"‚®™",MinusPlus:"‚àì",mlcp:"‚´õ",mldr:"‚Ä¶",mnplus:"‚àì",models:"‚äß",Mopf:"\uD835\uDD44",mopf:"\uD835\uDD5E",mp:"‚àì",Mscr:"‚Ñ≥",mscr:"\uD835\uDCC2",mstpos:"‚àæ",Mu:"Œú",mu:"Œº",multimap:"‚ä∏",mumap:"‚ä∏",nabla:"‚àá",Nacute:"≈É",nacute:"≈Ñ",nang:"‚à†‚Éí",nap:"‚ââ",napE:"‚©∞Ã∏",napid:"‚âãÃ∏",napos:"≈â",napprox:"‚ââ",natur:"‚ôÆ",natural:"‚ôÆ",naturals:"‚Ñï",nbsp:"¬†",nbump:"‚âéÃ∏",nbumpe:"‚âèÃ∏",ncap:"‚©É",Ncaron:"≈á",ncaron:"≈à",Ncedil:"≈Ö",ncedil:"≈Ü",ncong:"‚âá",ncongdot:"‚©≠Ã∏",ncup:"‚©Ç",Ncy:"–ù",ncy:"–Ω",ndash:"‚Äì",ne:"‚â†",nearhk:"‚§§",neArr:"‚áó",nearr:"‚Üó",nearrow:"‚Üó",nedot:"‚âêÃ∏",NegativeMediumSpace:"‚Äã",NegativeThickSpace:"‚Äã",NegativeThinSpace:"‚Äã",NegativeVeryThinSpace:"‚Äã",nequiv:"‚â¢",nesear:"‚§®",nesim:"‚âÇÃ∏",NestedGreaterGreater:"‚â´",NestedLessLess:"‚â™",NewLine:`
bundles/ClaudeCodeCode/cli.js:1586:`))}}function ZrB(A){for(let[Q,B]of Object.entries(A))if(typeof B!=="string"){let G=Error(`Invalid header value for "${Q}": headers must be strings, got ${typeof B}`);throw s(G),G}}var YrB=L(()=>{eZ();t2();T0();h1()});import{randomUUID as WI8}from"crypto";function KI8(A){if(A===null)return YT("Session resumed","suggestion");let Q=A instanceof tZ?A.formattedMessage:A.message;return YT(`Session resumed without branch: ${Q}`,"warning")}function VI8(){return u0({content:`This session is being continued from another machine. Application state may have changed. The updated working directory is ${pQ()}`,isMeta:!0})}async function DI8(A,Q){let B=A.length>75?A.slice(0,75)+"‚Ä¶":A,G="claude/task";try{let Z=EI8.replace("{description}",A),Y="<title>",I=(await GW({systemPrompt:[],userPrompt:Z,assistantPrompt:"<title>",signal:Q,options:{querySource:"teleport_generate_title",agents:[],isNonInteractiveSession:!1,hasAppendSystemPrompt:!1,mcpTools:[],agentIdOrSessionId:W0()}})).message.content[0];if(I?.type==="text"){let X="<title>"+I.text.trim(),W=X.match(/<title>(.*?)<\/title>/s),K=W?W[1]?.trim():B,V=X.match(/<branch>(.*?)<\/branch>/s),E=V?V[1]?.trim():"claude/task";return{title:K||B,branchName:E||"claude/task"}}}catch(Z){s(Error(`Error generating title and branch: ${Z}`))}return{title:B,branchName:"claude/task"}}async function IQ1(){if(!await ds())throw r("tengu_teleport_error_git_not_clean",{}),new tZ("Git working directory is not clean. Please commit or stash your changes before using --teleport.",cA.red(`Error: Git working directory is not clean. Please commit or stash your changes before using --teleport.
bundles/ClaudeCodeCode/cli.js:1597:${cA.dim("Run /status in Claude Code to check your account.")}`);throw s(Y),Error(`Failed to fetch session from Sessions API: ${Y.message}`)}}async function YMA(A){let{initialMessage:Q,description:B,signal:G}=A;try{await Mk();let Z=t6()?.accessToken;if(!Z)return s(Error("No access token found for remote session creation")),null;let Y=await mj();if(!Y)return s(Error("Unable to get organization UUID for remote session creation")),null;let J=await tL(),I=null,X=null,{title:W,branchName:K}=await DI8(B||Q||"Background task",G);if(J){let[y,h]=J.split("/");if(y&&h)I={type:"git_repository",url:`https://github.com/${y}/${h}`,revision:A.branchName},X={type:"git_repository",git_info:{type:"github",repo:`${y}/${h}`,branches:[K]}};else s(Error(`Invalid repository format: ${J} - expected 'owner/name'`))}let V=await bYA();if(!V||V.length===0)return s(Error("No environments available for session creation")),null;let D=NQ()?.remote?.defaultEnvironmentId,H=V[0];if(D){let y=V.find((h)=>h.environment_id===D);if(y)H=y,f(`Using configured default environment: ${D}`);else f(`Configured default environment ${D} not found in available environments, using first available`)}if(!H)return s(Error("No environments available for session creation")),null;let F=H.environment_id;f(`Selected environment: ${F} (${H.name})`);let C=`${u9().BASE_API_URL}/v1/sessions`,U={...oW(Z),"x-organization-uuid":Y},O={sources:I?[I]:[],outcomes:X?[X]:[],model:g8()},q=Q?[{type:"event",data:{uuid:WI8(),session_id:"",type:"user",parent_tool_use_id:null,message:{role:"user",content:Q}}}]:[],M={title:W,events:q,session_context:O,environment_id:F};f(`Creating session with payload: ${JSON.stringify(M,null,2)}`);let _=await wQ.post(C,M,{headers:U,signal:G});if(_.status!==200&&_.status!==201)return s(Error(`API request failed with status ${_.status}: ${_.statusText}[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"MAGIC\\\\s+DOC\" bundles/ClaudeAgentSDKCode/cli.js bundles/ClaudeCodeCode/cli.js | head -n 20"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 36ms:[0m
[2mbundles/ClaudeCodeCode/cli.js:4499:- Preserve the Magic Doc header exactly as-is: # MAGIC DOC: {{docTitle}}
bundles/ClaudeCodeCode/cli.js:4533:REMEMBER: Only update if there is substantial new information. The Magic Doc header (# MAGIC DOC: {{docTitle}}) must remain unchanged.`}async function UD5(){let A=jA(),Q=CD5(mQ(),"magic-docs","prompt.md");if(A.existsSync(Q))try{return A.readFileSync(Q,{encoding:"utf-8"})}catch{}return zD5()}function $D5(A,Q){let B=A;for(let[G,Z]of Object.entries(Q))B=B.replace(new RegExp(`\\{\\{${G}\\}\\}`,"g"),Z);return B}async function lm2(A,Q,B,G){let Z=await UD5(),Y=G?`
bundles/ClaudeAgentSDKCode/cli.js:4509:- Preserve the Magic Doc header exactly as-is: # MAGIC DOC: {{docTitle}}
bundles/ClaudeAgentSDKCode/cli.js:4543:REMEMBER: Only update if there is substantial new information. The Magic Doc header (# MAGIC DOC: {{docTitle}}) must remain unchanged.`}async function tV5(){let A=jA(),Q=rV5(uQ(),"magic-docs","prompt.md");if(A.existsSync(Q))try{return A.readFileSync(Q,{encoding:"utf-8"})}catch{}return sV5()}function eV5(A,Q){let B=A;for(let[G,Z]of Object.entries(Q))B=B.replace(new RegExp(`\\{\\{${G}\\}\\}`,"g"),Z);return B}async function uu2(A,Q,B,G){let Z=await tV5(),Y=G?`[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "Background task" bundles/ClaudeAgentSDKCode/cli.js bundles/ClaudeCodeCode/cli.js | head -n 20'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 38ms:[0m
[2mbundles/ClaudeAgentSDKCode/cli.js:1597:${pA.dim("Run /status in Claude Code to check your account.")}`);throw r(Y),Error(`Failed to fetch session from Sessions API: ${Y.message}`)}}async function KMA(A){let{initialMessage:Q,description:B,signal:G}=A;try{await pk();let Z=r3()?.accessToken;if(!Z)return r(Error("No access token found for remote session creation")),null;let Y=await AP();if(!Y)return r(Error("Unable to get organization UUID for remote session creation")),null;let J=await EM(),I=null,X=null,{title:W,branchName:K}=await XJ8(B||Q||"Background task",G);if(J){let[x,b]=J.split("/");if(x&&b)I={type:"git_repository",url:`https://github.com/${x}/${b}`,revision:A.branchName},X={type:"git_repository",git_info:{type:"github",repo:`${x}/${b}`,branches:[K]}};else r(Error(`Invalid repository format: ${J} - expected 'owner/name'`))}let V=await gYA();if(!V||V.length===0)return r(Error("No environments available for session creation")),null;let D=CQ()?.remote?.defaultEnvironmentId,H=V[0];if(D){let x=V.find((b)=>b.environment_id===D);if(x)H=x,f(`Using configured default environment: ${D}`);else f(`Configured default environment ${D} not found in available environments, using first available`)}if(!H)return r(Error("No environments available for session creation")),null;let F=H.environment_id;f(`Selected environment: ${F} (${H.name})`);let C=`${k9().BASE_API_URL}/v1/sessions`,$={...oW(Z),"x-organization-uuid":Y},O={sources:I?[I]:[],outcomes:X?[X]:[],model:c8()},M=Q?[{type:"event",data:{uuid:ZJ8(),session_id:"",type:"user",parent_tool_use_id:null,message:{role:"user",content:Q}}}]:[],L={title:W,events:M,session_context:O,environment_id:F};f(`Creating session with payload: ${JSON.stringify(L,null,2)}`);let _=await FQ.post(C,L,{headers:$,signal:G});if(_.status!==200&&_.status!==201)return r(Error(`API request failed with status ${_.status}: ${_.statusText}
bundles/ClaudeAgentSDKCode/cli.js:1623:Please generate a title and branch name for this session.`;var $1A=q(()=>{Q3();aI();zZA();o2();rZ();Q0();g1();hA();f2();iA0();V2();qq();m8();nJ();V2();FAA();PG();d2();_0();KB();u0();mb();YQ1();SoB();gB();nA0=o(KA(),1)});async function goB(){let A=[],[Q,B,G,Z]=await Promise.all([JQ1(),OoB(),RoB(),EM()]);if(Q)A.push({type:"not_logged_in"});if(!B)A.push({type:"no_remote_environment"});if(!G)A.push({type:"not_in_git_repo"});if(Z){let[Y,J]=Z.split("/");if(Y&&J){if(!await _oB(Y,J))A.push({type:"github_app_not_installed"})}}return A}var uoB=q(()=>{pA0();FAA()});async function moB(){let A=await goB();if(A.length>0)return{eligible:!1,errors:A};return{eligible:!0}}function doB(A){switch(A.type){case"not_logged_in":return"Please run /login and sign in with your Claude.ai account (not Console).";case"no_remote_environment":return"No environments available, please ensure you've gone through onboarding at claude.ai/code";case"not_in_git_repo":return"Background tasks require a git repository. Initialize git or run from a git repository.";case"github_app_not_installed":return`The Claude GitHub app must be installed on this repository first.
bundles/ClaudeAgentSDKCode/cli.js:2620:`);for(let B=Q.length-1;B>=0;B--){let G=Q[B]?.trim();if(G)return G}return""}var xIA;var TU2=q(()=>{hA();MM();xIA=o(KA(),1)});function jU2({task:A}){switch(A.type){case"local_bash":return jN.createElement(z,null,I5(A.command,40,!0)," ",jN.createElement(_U2,{shell:A}));case"remote_agent":return jN.createElement(z,null,I5(A.title,40,!0)," ",jN.createElement(c31,{session:A}));case"local_agent":return jN.createElement(z,null,I5(A.description,40,!0)," ",jN.createElement(z,{dimColor:!0},"(",A.status,A.status==="completed"&&!A.notified&&", unread",")"))}}var jN;var PU2=q(()=>{TU2();I80();hA();jN=o(KA(),1)});function W61({onDone:A,toolUseContext:Q}){let[{tasks:B},G]=RQ(),[Z,Y]=f0A.useState(null),[J,I]=f0A.useState(0);f1((b,v)=>{if(!Z&&v.escape)A("Background tasks dialog dismissed",{display:"system"});if(!Z&&v.return&&O)Y(O.id);if(!Z&&b==="k"&&O?.type==="local_bash"&&O.status==="running")W(O.id);if(!Z&&b==="k"&&O?.type==="local_agent"&&O.status==="running")K(O.id);if(!Z&&(v.upArrow||v.downArrow)){let m=$.length;if(m===0)return;if(v.upArrow)I((u)=>Math.max(0,u-1));else I((u)=>Math.min(m-1,u+1))}});let X=jQ();async function W(b){await Rl.kill(b,{abortController:Q.abortController,getAppState:Q.getAppState,setAppState:G})}async function K(b){await GA1.kill(b,{abortController:Q.abortController,getAppState:Q.getAppState,setAppState:G})}let V=B,E=Object.values(V??{}).map(l35),D=E.sort((b,v)=>{if(b.status==="running"&&v.status!=="running")return-1;if(b.status!=="running"&&v.status==="running")return 1;return v.task.startTime-b.task.startTime}),H=D.filter((b)=>b.type==="local_bash"),F=D.filter((b)=>b.type==="remote_agent"),C=D.filter((b)=>b.type==="local_agent"),$=f0A.useMemo(()=>{return[...H,...F,...C]},[H,F,C]),O=$[J]||null;if(f0A.useEffect(()=>{if(Z&&!Object.keys(V??{}).includes(Z))Y(null);let b=$.length;if(J>=b&&b>0)I(b-1)},[Z,V,J,$]),Z&&V){let b=V[Z];if(!b)return null;switch(b.type){case"local_bash":return w6.default.createElement(CH2,{shell:b,onDone:A,onKillShell:()=>void W(b.id),onBack:()=>Y(null),key:`shell-${b.id}`});case"local_agent":return w6.default.createElement(OU2,{agent:b,onDone:A,onKillAgent:()=>void K(b.id),onBack:()=>Y(null),key:`agent-${b.id}`});case"remote_agent":return w6.default.createElement(LU2,{session:b,onDone:A,toolUseContext:Q,onBack:()=>Y(null),key:`session-${b.id}`})}}let M=H.filter((b)=>b.status==="running").length,L=F.filter((b)=>b.status==="running"||b.status==="pending").length,_=C.filter((b)=>b.status==="running").length,T=EC([...M>0?[w6.default.createElement(z,{key:"shells"},M," ",M!==1?"active shells":"active shell")]:[],...L>0?[w6.default.createElement(z,{key:"sessions"},L," ",L!==1?"active sessions":"active session")]:[],..._>0?[w6.default.createElement(z,{key:"agents"},_," ",_!==1?"active agents":"active agent")]:[]],(b)=>w6.default.createElement(z,{key:`separator-${b}`}," ¬∑ ")),x=[w6.default.createElement(L0,{key:"upDown",shortcut:"‚Üë/‚Üì",action:"select"}),w6.default.createElement(L0,{key:"enter",shortcut:"Enter",action:"view"}),...(O?.type==="local_bash"||O?.type==="local_agent")&&O.status==="running"?[w6.default.createElement(L0,{key:"kill",shortcut:"k",action:"kill"})]:[],w6.default.createElement(L0,{key:"esc",shortcut:"Esc",action:"close"})];return w6.default.createElement(j,{width:"100%",flexDirection:"column"},w6.default.createElement(j,{borderStyle:"round",borderColor:"background",flexDirection:"column",marginTop:1,paddingLeft:1,paddingRight:1,width:"100%"},w6.default.createElement(z,{color:"background",bold:!0},"Background tasks"),w6.default.createElement(z,{dimColor:!0},T),E.length===0?w6.default.createElement(z,{dimColor:!0},"No tasks currently running"):w6.default.createElement(j,{flexDirection:"column",marginTop:1},H.length>0&&w6.default.createElement(j,{flexDirection:"column"},(F.length>0||C.length>0)&&w6.default.createElement(z,{dimColor:!0},w6.default.createElement(z,{bold:!0},"  ","Bashes")," (",H.length,")"),w6.default.createElement(j,{flexDirection:"column"},H.map((b,v)=>w6.default.createElement(r80,{key:b.id,item:b,isSelected:v===J})))),F.length>0&&w6.default.createElement(j,{flexDirection:"column",marginTop:H.length>0?1:0},w6.default.createElement(z,{dimColor:!0},w6.default.createElement(z,{bold:!0},"  ","Remote sessions")," (",F.length,")"),w6.default.createElement(j,{flexDirection:"column"},F.map((b,v)=>w6.default.createElement(r80,{key:b.id,item:b,isSelected:H.length+v===J})))),C.length>0&&w6.default.createElement(j,{flexDirection:"column",marginTop:H.length>0||F.length>0?1:0},w6.default.createElement(z,{dimColor:!0},w6.default.createElement(z,{bold:!0},"  ","Async agents")," (",C.length,")"),w6.default.createElement(j,{flexDirection:"column"},C.map((b,v)=>w6.default.createElement(r80,{key:b.id,item:b,isSelected:H.length+F.length+v===J})))))),w6.default.createElement(j,{marginLeft:2},X.pending?w6.default.createElement(z,{dimColor:!0},"Press ",X.keyName," again to exit"):w6.default.createElement(z,{dimColor:!0},w6.default.createElement($B,null,x))))}function l35(A){switch(A.type){case"local_bash":return{id:A.id,type:"local_bash",label:A.command,status:A.status,task:A};case"remote_agent":return{id:A.id,type:"remote_agent",label:A.title,status:A.status,task:A};case"local_agent":return{id:A.id,type:"local_agent",label:A.description,status:A.status,task:A}}}function r80({item:A,isSelected:Q}){return w6.default.createElement(j,{flexDirection:"row",gap:1},w6.default.createElement(z,{color:Q?"suggestion":void 0},Q?X1.pointer+" ":"  ",w6.default.createElement(jU2,{task:A.task})))}var w6,f0A;var s80=q(()=>{hA();v2();o9();zH2();MU2();RU2();f2();UqA();ZA1();PU2();t4();i3();w6=o(KA(),1),f0A=o(KA(),1)});var i35;var SU2=q(()=>{f2();i35=o(KA(),1)});var xU2;var yU2=q(()=>{hA();y3();xU2=o(KA(),1)});var vU2;var kU2=q(()=>{hA();ib();N9();pB();vU2=o(KA(),1)});var t80;var fU2=q(()=>{hA();o9();SU2();yU2();kU2();t80=o(KA(),1)});function a35(A,Q){if(A.length<=n35)return{truncatedText:A,placeholderContent:""};let B=Math.floor(bU2/2),G=Math.floor(bU2/2),Z=A.slice(0,B),Y=A.slice(-G),J=A.slice(B,-G),I=vcA(J),W=o35(Q,I);return{truncatedText:Z+W+Y,placeholderContent:J}}function o35(A,Q){return`[...Truncated text #${A} +${Q} lines...]`}function hU2(A,Q){let B=Object.keys(Q).map(Number),G=B.length>0?Math.max(...B)+1:1,{truncatedText:Z,placeholderContent:Y}=a35(A,G);if(!Y)return{newInput:A,newPastedContents:Q};return{newInput:Z,newPastedContents:{...Q,[G]:{id:G,type:"text",content:Y}}}}var n35=1e4,bU2=1000;var gU2=q(()=>{Xc()});function uU2({input:A,pastedContents:Q,onInputChange:B,setCursorOffset:G,setPastedContents:Z}){let[Y,J]=C_A.useState(!1);C_A.useEffect(()=>{if(Y)return;if(A.length<=1e4)return;let{newInput:I,newPastedContents:X}=hU2(A,Q);B(I),G(I.length),Z(X),J(!0)},[A,Y,Q,B,Z,G]),C_A.useEffect(()=>{if(A==="")J(!1)},[A])}var C_A;var mU2=q(()=>{gU2();C_A=o(KA(),1)});function dU2(A,Q=20){let B=new Map;for(let Z of A)B.set(Z,(B.get(Z)||0)+1);return Array.from(B.entries()).sort((Z,Y)=>Y[1]-Z[1]).slice(0,Q).map(([Z,Y])=>`${Y.toString().padStart(6)} ${Z}`).join(`
bundles/ClaudeAgentSDKCode/cli.js:2637:${v}</bash-stderr>`})],shouldQuery:!1}}let W=await WaQ(),K=await jf(),V=await Cy1(),E=W.commitsAheadOfDefaultBranch===0;if((W.hasUncommitted||W.hasUnpushed)&&!E){let v=await new Promise((m)=>{Z({jsx:JG.createElement(j,{flexDirection:"column"},JG.createElement(S0A,{addMargin:!0,param:J}),JG.createElement(Y50,{issue:W,branchName:K,onDone:m,color:"background"})),shouldHidePromptInput:!0})});if(v==="cancel")return{messages:[XK(),I,...B,g0({content:"<bash-stderr>Background task cancelled.</bash-stderr>"})],shouldQuery:!1};if(v==="commit-push"){let m=(p)=>{Z({jsx:JG.createElement(j,{flexDirection:"column"},JG.createElement(S0A,{addMargin:!0,param:J}),JG.createElement(Y50,{issue:W,branchName:K,onDone:()=>{},color:"background",loadingState:p})),shouldHidePromptInput:!0})};if(W.hasUncommitted)m("committing");else m("pushing");let u=`Background task: ${A.slice(0,60)}${A.length>60?"...":""}`,e=await KaQ(u,(p)=>{m(p)});if(!e.success)return{messages:[XK(),I,...B,g0({content:`<bash-stderr>Failed to commit and push changes:
bundles/ClaudeCodeCode/cli.js:1597:${cA.dim("Run /status in Claude Code to check your account.")}`);throw s(Y),Error(`Failed to fetch session from Sessions API: ${Y.message}`)}}async function YMA(A){let{initialMessage:Q,description:B,signal:G}=A;try{await Mk();let Z=t6()?.accessToken;if(!Z)return s(Error("No access token found for remote session creation")),null;let Y=await mj();if(!Y)return s(Error("Unable to get organization UUID for remote session creation")),null;let J=await tL(),I=null,X=null,{title:W,branchName:K}=await DI8(B||Q||"Background task",G);if(J){let[y,h]=J.split("/");if(y&&h)I={type:"git_repository",url:`https://github.com/${y}/${h}`,revision:A.branchName},X={type:"git_repository",git_info:{type:"github",repo:`${y}/${h}`,branches:[K]}};else s(Error(`Invalid repository format: ${J} - expected 'owner/name'`))}let V=await bYA();if(!V||V.length===0)return s(Error("No environments available for session creation")),null;let D=NQ()?.remote?.defaultEnvironmentId,H=V[0];if(D){let y=V.find((h)=>h.environment_id===D);if(y)H=y,f(`Using configured default environment: ${D}`);else f(`Configured default environment ${D} not found in available environments, using first available`)}if(!H)return s(Error("No environments available for session creation")),null;let F=H.environment_id;f(`Selected environment: ${F} (${H.name})`);let C=`${u9().BASE_API_URL}/v1/sessions`,U={...oW(Z),"x-organization-uuid":Y},O={sources:I?[I]:[],outcomes:X?[X]:[],model:g8()},q=Q?[{type:"event",data:{uuid:WI8(),session_id:"",type:"user",parent_tool_use_id:null,message:{role:"user",content:Q}}}]:[],M={title:W,events:q,session_context:O,environment_id:F};f(`Creating session with payload: ${JSON.stringify(M,null,2)}`);let _=await wQ.post(C,M,{headers:U,signal:G});if(_.status!==200&&_.status!==201)return s(Error(`API request failed with status ${_.status}: ${_.statusText}
bundles/ClaudeCodeCode/cli.js:1623:Please generate a title and branch name for this session.`;var I1A=L(()=>{I6();AX();CZA();t2();eZ();Y0();h1();fA();u2();I10();F2();Xq();b8();eJ();F2();BAA();RG();l2();T0();HB();g0();zb();GQ1();YrB();jB();X10=o(WA(),1)});async function DrB(){let A=[],[Q,B,G,Z]=await Promise.all([ZQ1(),eoB(),ArB(),tL()]);if(Q)A.push({type:"not_logged_in"});if(!B)A.push({type:"no_remote_environment"});if(!G)A.push({type:"not_in_git_repo"});if(Z){let[Y,J]=Z.split("/");if(Y&&J){if(!await QrB(Y,J))A.push({type:"github_app_not_installed"})}}return A}var HrB=L(()=>{Y10();BAA()});async function FrB(){let A=await DrB();if(A.length>0)return{eligible:!1,errors:A};return{eligible:!0}}function CrB(A){switch(A.type){case"not_logged_in":return"Please run /login and sign in with your Claude.ai account (not Console).";case"no_remote_environment":return"No environments available, please ensure you've gone through onboarding at claude.ai/code";case"not_in_git_repo":return"Background tasks require a git repository. Initialize git or run from a git repository.";case"github_app_not_installed":return`The Claude GitHub app must be installed on this repository first.
bundles/ClaudeCodeCode/cli.js:2621:`);for(let B=Q.length-1;B>=0;B--){let G=Q[B]?.trim();if(G)return G}return""}var kIA;var hw2=L(()=>{fA();WM();kIA=o(WA(),1)});function gw2({task:A}){switch(A.type){case"local_bash":return XN.createElement(z,null,Q5(A.command,40,!0)," ",XN.createElement(bw2,{shell:A}));case"remote_agent":return XN.createElement(z,null,Q5(A.title,40,!0)," ",XN.createElement(i61,{session:A}));case"local_agent":return XN.createElement(z,null,Q5(A.description,40,!0)," ",XN.createElement(z,{dimColor:!0},"(",A.status,A.status==="completed"&&!A.notified&&", unread",")"))}}var XN;var uw2=L(()=>{hw2();R80();fA();XN=o(WA(),1)});function S31({onDone:A,toolUseContext:Q}){let[{tasks:B},G]=yQ(),[Z,Y]=_0A.useState({mode:"list"}),[J,I]=_0A.useState(0),X=B,W=Object.values(X??{}).map(h85),K=W.sort((x,m)=>{if(x.status==="running"&&m.status!=="running")return-1;if(x.status!=="running"&&m.status==="running")return 1;return m.task.startTime-x.task.startTime}),V=K.filter((x)=>x.type==="local_bash"),E=K.filter((x)=>x.type==="remote_agent"),D=K.filter((x)=>x.type==="local_agent"),H=_0A.useMemo(()=>{return[...V,...E,...D]},[V,E,D]),F=H[J]||null;k1((x,m)=>{if(Z.mode!=="list")return;if(m.escape){A("Background tasks dialog dismissed",{display:"system"});return}if(m.upArrow){I((g)=>Math.max(0,g-1));return}if(m.downArrow){I((g)=>Math.min(H.length-1,g+1));return}if(!F)return;if(m.return){Y({mode:"detail",itemId:F.id});return}if(x==="k"){if(F.type==="local_bash"&&F.status==="running")U(F.id);else if(F.type==="local_agent"&&F.status==="running")O(F.id)}});let C=_Q();async function U(x){await Vl.kill(x,{abortController:Q.abortController,getAppState:Q.getAppState,setAppState:G})}async function O(x){await QA1.kill(x,{abortController:Q.abortController,getAppState:Q.getAppState,setAppState:G})}_0A.useEffect(()=>{if(Z.mode!=="list"&&!Object.keys(X??{}).includes(Z.itemId))Y({mode:"list"});let x=H.length;if(J>=x&&x>0)I(x-1)},[Z,X,J,H]);let q=()=>{Y({mode:"list"})};if(Z.mode!=="list"&&X){let x=X[Z.itemId];if(!x)return null;switch(x.type){case"local_bash":return z3.default.createElement(IF2,{shell:x,onDone:A,onKillShell:()=>void U(x.id),onBack:q,key:`shell-${x.id}`});case"local_agent":return z3.default.createElement(R$2,{agent:x,onDone:A,onKillAgent:()=>void O(x.id),onBack:q,key:`agent-${x.id}`});case"remote_agent":return z3.default.createElement(M$2,{session:x,onDone:A,toolUseContext:Q,onBack:q,key:`session-${x.id}`})}}let M=V.filter((x)=>x.status==="running").length,_=E.filter((x)=>x.status==="running"||x.status==="pending").length,T=D.filter((x)=>x.status==="running").length,y=GC([...M>0?[z3.default.createElement(z,{key:"shells"},M," ",M!==1?"active shells":"active shell")]:[],..._>0?[z3.default.createElement(z,{key:"sessions"},_," ",_!==1?"active sessions":"active session")]:[],...T>0?[z3.default.createElement(z,{key:"agents"},T," ",T!==1?"active agents":"active agent")]:[]],(x)=>z3.default.createElement(z,{key:`separator-${x}`}," ¬∑ ")),h=[z3.default.createElement(R0,{key:"upDown",shortcut:"‚Üë/‚Üì",action:"select"}),z3.default.createElement(R0,{key:"enter",shortcut:"Enter",action:"view"}),...[],...(F?.type==="local_bash"||F?.type==="local_agent")&&F.status==="running"?[z3.default.createElement(R0,{key:"kill",shortcut:"k",action:"kill"})]:[],z3.default.createElement(R0,{key:"esc",shortcut:"Esc",action:"close"})];return z3.default.createElement(j,{width:"100%",flexDirection:"column"},z3.default.createElement(j,{borderStyle:"round",borderColor:"background",flexDirection:"column",marginTop:1,paddingLeft:1,paddingRight:1,width:"100%"},z3.default.createElement(z,{color:"background",bold:!0},"Background tasks"),z3.default.createElement(z,{dimColor:!0},y),W.length===0?z3.default.createElement(z,{dimColor:!0},"No tasks currently running"):z3.default.createElement(j,{flexDirection:"column",marginTop:1},V.length>0&&z3.default.createElement(j,{flexDirection:"column"},(E.length>0||D.length>0)&&z3.default.createElement(z,{dimColor:!0},z3.default.createElement(z,{bold:!0},"  ","Bashes")," (",V.length,")"),z3.default.createElement(j,{flexDirection:"column"},V.map((x,m)=>z3.default.createElement(S50,{key:x.id,item:x,isSelected:m===J})))),E.length>0&&z3.default.createElement(j,{flexDirection:"column",marginTop:V.length>0?1:0},z3.default.createElement(z,{dimColor:!0},z3.default.createElement(z,{bold:!0},"  ","Remote sessions")," (",E.length,")"),z3.default.createElement(j,{flexDirection:"column"},E.map((x,m)=>z3.default.createElement(S50,{key:x.id,item:x,isSelected:V.length+m===J})))),D.length>0&&z3.default.createElement(j,{flexDirection:"column",marginTop:V.length>0||E.length>0?1:0},z3.default.createElement(z,{dimColor:!0},z3.default.createElement(z,{bold:!0},"  ","Async agents")," (",D.length,")"),z3.default.createElement(j,{flexDirection:"column"},D.map((x,m)=>z3.default.createElement(S50,{key:x.id,item:x,isSelected:V.length+E.length+m===J})))))),z3.default.createElement(j,{marginLeft:2},C.pending?z3.default.createElement(z,{dimColor:!0},"Press ",C.keyName," again to exit"):z3.default.createElement(z,{dimColor:!0},z3.default.createElement(LB,null,h))))}function h85(A){switch(A.type){case"local_bash":return{id:A.id,type:"local_bash",label:A.command,status:A.status,task:A};case"remote_agent":return{id:A.id,type:"remote_agent",label:A.title,status:A.status,task:A};case"local_agent":return{id:A.id,type:"local_agent",label:A.description,status:A.status,task:A}}}function S50({item:A,isSelected:Q}){return z3.default.createElement(j,{flexDirection:"row",gap:1},z3.default.createElement(z,{color:Q?"suggestion":void 0},Q?X1.pointer+" ":"  ",z3.default.createElement(gw2,{task:A.task})))}var z3,_0A;var x50=L(()=>{fA();g2();c9();XF2();O$2();_$2();fw2();u2();DqA();BA1();uw2();$H();s4();l6();z3=o(WA(),1),_0A=o(WA(),1)});var g85;var mw2=L(()=>{u2();g85=o(WA(),1)});var dw2;var cw2=L(()=>{fA();y6();dw2=o(WA(),1)});var pw2;var lw2=L(()=>{fA();qb();M9();pB();pw2=o(WA(),1)});var y50;var iw2=L(()=>{fA();c9();mw2();cw2();lw2();y50=o(WA(),1)});function m85(A,Q){if(A.length<=u85)return{truncatedText:A,placeholderContent:""};let B=Math.floor(nw2/2),G=Math.floor(nw2/2),Z=A.slice(0,B),Y=A.slice(-G),J=A.slice(B,-G),I=ycA(J),W=d85(Q,I);return{truncatedText:Z+W+Y,placeholderContent:J}}function d85(A,Q){return`[...Truncated text #${A} +${Q} lines...]`}function aw2(A,Q){let B=Object.keys(Q).map(Number),G=B.length>0?Math.max(...B)+1:1,{truncatedText:Z,placeholderContent:Y}=m85(A,G);if(!Y)return{newInput:A,newPastedContents:Q};return{newInput:Z,newPastedContents:{...Q,[G]:{id:G,type:"text",content:Y}}}}var u85=1e4,nw2=1000;var ow2=L(()=>{nd()});function rw2({input:A,pastedContents:Q,onInputChange:B,setCursorOffset:G,setPastedContents:Z}){let[Y,J]=M_A.useState(!1);M_A.useEffect(()=>{if(Y)return;if(A.length<=1e4)return;let{newInput:I,newPastedContents:X}=aw2(A,Q);B(I),G(I.length),Z(X),J(!0)},[A,Y,Q,B,Z,G]),M_A.useEffect(()=>{if(A==="")J(!1)},[A])}var M_A;var sw2=L(()=>{ow2();M_A=o(WA(),1)});function tw2(A,Q=20){let B=new Map;for(let Z of A)B.set(Z,(B.get(Z)||0)+1);return Array.from(B.entries()).sort((Z,Y)=>Y[1]-Z[1]).slice(0,Q).map(([Z,Y])=>`${Y.toString().padStart(6)} ${Z}`).join(`
bundles/ClaudeCodeCode/cli.js:2638:${x}</bash-stderr>`})],shouldQuery:!1}}let W=await paQ(),K=await If(),V=await fy1(),E=W.commitsAheadOfDefaultBranch===0;if((W.hasUncommitted||W.hasUnpushed)&&!E){let x=await new Promise((m)=>{Z({jsx:GG.createElement(j,{flexDirection:"column"},GG.createElement(w0A,{addMargin:!0,param:J}),GG.createElement(g50,{issue:W,branchName:K,onDone:m,color:"background"})),shouldHidePromptInput:!0})});if(x==="cancel")return{messages:[WK(),I,...B,u0({content:"<bash-stderr>Background task cancelled.</bash-stderr>"})],shouldQuery:!1};if(x==="commit-push"){let m=(p)=>{Z({jsx:GG.createElement(j,{flexDirection:"column"},GG.createElement(w0A,{addMargin:!0,param:J}),GG.createElement(g50,{issue:W,branchName:K,onDone:()=>{},color:"background",loadingState:p})),shouldHidePromptInput:!0})};if(W.hasUncommitted)m("committing");else m("pushing");let g=`Background task: ${A.slice(0,60)}${A.length>60?"...":""}`,t=await laQ(g,(p)=>{m(p)});if(!t.success)return{messages:[WK(),I,...B,u0({content:`<bash-stderr>Failed to commit and push changes:[0m

[35m[3mthinking[0m[0m
**Exploring tool capabilities**

I'm looking into whether the tool pipeline in core/tools/runner supports the "run_in_background" feature. It seems like it may not, but I suspect that the Phase 8 tool pipeline could have it. So, I'll search within core/tools/runner to find specific details about "run_in_background". It's interesting to see what capabilities might exist there, and I hope I can clarify this soon!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "run_in_background|background" src/core/tools | head -n 50'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 45ms:[0m
[2m[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,320p' src/core/tools/registry.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 48ms:[0m
[2mimport type { HostCapabilities } from "../types/host.js";
import type { ToolCapabilityRequirement, ToolDefinition, ToolLookup, ToolName, ToolId } from "./types.js";

export type ToolSource = "builtin" | "mcp" | "plugin";

export type RegisteredTool = {
  source: ToolSource;
  tool: ToolDefinition<any, any>;
};

function normalizeServerName(server: string): string {
  return server.trim().toLowerCase().replace(/[^a-z0-9_-]+/g, "-");
}

export function toMcpToolName(server: string, toolName: string): ToolName {
  return `mcp__${normalizeServerName(server)}__${toolName}`;
}

export function normalizeToolIdentifier(name: string): ToolName {
  const trimmed = name.trim();[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/tools/types.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 32ms:[0m
[2mimport type { JsonObject } from "../types/json.js";
import type { EngineEventSensitivity } from "../types/events.js";
import type { HostCapabilities } from "../types/host.js";
import type { ToolRunId, AttachmentId } from "../types/state.js";
import type { ToolPermissionCheckContext, ToolSpecificPermissionDecision } from "../permissions/types.js";

export type ToolName = string;
export type ToolId = string;

export type ToolRiskLevel = "low" | "medium" | "high";
export type ToolIdempotency = "idempotent" | "non_idempotent" | "unknown";

export type ToolCapabilityRequirement =
  | { kind: "host_capability"; key: keyof HostCapabilities; optional?: boolean }
  | { kind: "all_of"; requirements: ToolCapabilityRequirement[] }
  | { kind: "any_of"; requirements: ToolCapabilityRequirement[] };

export type ToolPermissionCategory = "read" | "write" | "network" | "auth" | "remote_execution" | "other";

export type ToolSchema<T> = {[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/tools/runner.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 33ms:[0m
[2mimport type { HostCapabilities } from "../types/host.js";
import type { MonotonicClock } from "../runtime/clock.js";
import type { IdSource } from "../runtime/ids.js";
import type { ToolRunId } from "../types/state.js";
import { asToolRunId } from "../types/state.js";
import type { ToolLookup, ToolName, ToolResult, ToolContext, ToolBudget, ToolPermissions } from "./types.js";
import type { ToolStream } from "./stream.js";
import { createToolStream } from "./stream.js";
import { ToolError } from "./errors.js";
import { createCapabilityView } from "../capabilities/view.js";

export type ToolExecutionPipelineHooks = {
  beforeTool?: (
    toolName: ToolName,
    input: unknown,
    ctx: { toolRunId: ToolRunId; signal?: AbortSignal; sessionId?: string }
  ) => Promise<{ blocked?: boolean; updatedInput?: unknown; hookRun?: unknown }>;
  afterTool?: (
    toolName: ToolName,
    input: unknown,[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/engine/index.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 40ms:[0m
[2mexport type { Engine, EngineCommand, EngineCreateOptions, EngineEventHandler, EngineFactory } from "../types/engine.js";
[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,300p' src/core/types/engine.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 37ms:[0m
[2mimport type { EngineEventEnvelope, HostEvent } from "./events.js";
import type { HostCapabilities } from "./host.js";

export type EngineCommand =
  | { type: "engine/start" }
  | { type: "engine/stop"; reason?: string }
  | { type: "engine/dispatchHostEvent"; event: HostEvent };

export type EngineEventHandler = (event: EngineEventEnvelope) => void;
export type Unsubscribe = () => void;

export type Engine = {
  start: () => Promise<void>;
  stop: (reason?: string) => Promise<void>;
  dispatch: (command: EngineCommand) => Promise<void>;
  subscribe: (handler: EngineEventHandler) => Unsubscribe;
};

export type EngineCreateOptions = {
  host: HostCapabilities;[0m

[35m[3mthinking[0m[0m
**Investigating engine implementation**

I‚Äôm realizing that there aren‚Äôt any background tasks or actual engine implementations here, just types. Maybe core or runtime kernels are being used by the UI, but it seems like they might not be built yet. It seems like Phase 11 could be the point where core agents are integrated with the runtime kernel. Hmm, I think it‚Äôs worth checking src/core/runtime/index.ts to uncover more details about this!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,220p' src/core/runtime/index.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 40ms:[0m
[2mexport * from "./clock.js";
export * from "./ids.js";
export * from "./deferred.js";
export * from "./queue.js";
export * from "./scheduler.js";
export * from "./scope.js";
export * from "./kernel.js";
export * from "./stream.js";
export * from "./streamSummary.js";
export * from "./hang.js";
export * from "./replay.js";
export * from "./replayDiff.js";
export * from "./seededRandom.js";[0m


[35m[3mthinking[0m[0m
**Designing agent structures**

I'm considering a runtime kernel for deterministic tasks, which we can leverage. For background agents, I can model them as tasks in this kernel. Specifically, I see "agents" as long-lived systems that trigger based on events or timing. I plan to define an AgentManager to start and schedule these agents, while enforcing budgets. I'll also explore the idea of worker-style isolation, potentially creating new modules for agent types, registries, and management. It seems implementing just the types and minimal in-memory solutions may work best for now.
[35m[3mthinking[0m[0m
**Maintaining module boundaries**

I need to ensure that the core module doesn‚Äôt import from platform or UI, which is crucial for maintaining proper boundaries. Updating the import boundary checks is also essential, so I‚Äôll need to run tests that cover these boundaries. First, I think it would be helpful to inspect the existing tests to see how they validate the import rules. This way, I can confirm that everything is working as intended and compliant with the overall module structure.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'find tests -type f | sort'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 37ms:[0m
[2mtests/.tmp-phase9-plugins/plugins/p1/hooks/hooks.json
tests/.tmp-phase9-plugins/plugins/p2/hooks/hooks.json
tests/fixtures/phase8-grep-expected.json
tests/fixtures/phase8-grep-repo/a.txt
tests/fixtures/phase8-grep-repo/sub/b.txt
tests/phase1-fixtures.test.ts
tests/phase1-legacy-spec.test.ts
tests/phase10-mcp.test.ts
tests/phase2-architecture-boundaries.test.ts
tests/phase3-determinism.test.ts
tests/phase3-event-bus.test.ts
tests/phase3-replay-adapters.test.ts
tests/phase3-replay-conformance.test.ts
tests/phase3-runtime.test.ts
tests/phase3-shutdown-summary.test.ts
tests/phase4-capabilities.test.ts
tests/phase4-leak-prevention.test.ts
tests/phase4-mobile-safe-conformance.test.ts
tests/phase5-notifications-and-redaction.test.ts
tests/phase5-queues-and-viewmodels.test.ts[0m

[35m[3mthinking[0m[0m
**Organizing test files**

I‚Äôm looking at the project where we have `phase10-mcp.test` and need to add a new test file, `phase11-agents.test.ts`. First, I should find the import boundary check script, which might be located in `tests/phase2`. It looks like the next step is to open up that `tests/phase2` file to see how everything is structured and find what I need. This should help in organizing the new test properly!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,240p' tests/phase2-architecture-boundaries.test.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 40ms:[0m
[2mimport { describe, expect, test } from "bun:test";
import { canonicalJsonStringify } from "../src/core/types/canonicalJson.js";
import { smokeCheckHostCapabilities } from "../src/platform/smoke.js";
import { unavailableCapability } from "../src/core/types/host.js";
import { createNodeHostCapabilities } from "../src/platform/node/host.js";
import { NODE_REQUIRED_CAPABILITIES } from "../src/platform/node/index.js";
import { createReactNativeHostCapabilities, RN_MINIMAL_REQUIRED_CAPABILITIES } from "../src/platform/rn/index.js";
import { createWebHostCapabilities, WEB_MINIMAL_REQUIRED_CAPABILITIES } from "../src/platform/web/index.js";

describe("Phase 2: architecture/boundaries", () => {
  test("import boundary script passes", () => {
    const proc = Bun.spawnSync(["node", "scripts/check-import-boundaries.mjs"], { stdout: "pipe", stderr: "pipe" });
    expect(proc.exitCode).toBe(0);
  });

  test("host capability smoke check reports missing required", () => {
    const host = {
      clock: unavailableCapability({ kind: "not-provided" }),
      random: unavailableCapability({ kind: "not-provided" }),
      crypto: unavailableCapability({ kind: "not-provided" }),[0m

[35m[3mthinking[0m[0m
**Planning module integration**

I'm starting to look into how to implement the agent module after checking the import boundaries using the relevant Node script. My next step is to run tests with bun to make sure everything's working correctly. Then, I plan to examine the existing infrastructure in `src/core/runtime/scope.ts` to see how tasks are spawned. This seems crucial for properly integrating the new functionality, so I'm excited to dive in!
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,280p' src/core/runtime/scope.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 38ms:[0m
[2mimport type { CancellationReason, TaskFailurePolicy, TaskId, TaskPriority, TaskResult, TaskScopeId, TaskScopeKind } from "../types/runtime.js";
import { createDeferred, type Deferred } from "./deferred.js";

export type SpawnTaskOptions = {
  label?: string;
  priority?: TaskPriority;
  failurePolicy?: TaskFailurePolicy;
  parentTaskId?: TaskId;
  timeoutMs?: number;
  correlationIds?: Record<string, string>;
  metadata?: Readonly<Record<string, unknown>>;
};

export type TaskExecutionContext = {
  taskId: TaskId;
  scopeId: TaskScopeId;
  signal: AbortSignal;
  nowMonoMs: () => number;
  yield: (priority?: TaskPriority) => Promise<void>;
  sleep: (delayMs: number, reason?: CancellationReason) => Promise<void>;[0m

[35m[3mthinking[0m[0m
**Inspecting feature flags**

I want to check the core settings for any feature flags. The settings schema should show these flags and toggles, so I'll take a quick look for `featureFlags` and anything tagged with `tengu_`. I‚Äôm curious about how these flags are set up and the impact they might have. Let's dig into this without spending too much time.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "feature|tengu_|magic|session_memory|prompt_suggestion" src/core/settings src/spec src/core | head -n 50'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 55ms:[0m
[2m[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/index.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 62ms:[0m
[2mexport * from "./types/index.js";
export * from "./engine/index.js";
export * from "./events/index.js";
export * from "./runtime/index.js";
export * from "./state/index.js";
export * from "./settings/index.js";
export * from "./permissions/index.js";
export * from "./hooks/index.js";
export * from "./tools/index.js";
export * from "./commands/index.js";
export * from "./mcp/index.js";
export * from "./agents/index.js";
export * from "./capabilities/index.js";
export * from "./network/index.js";
export * from "./filesystem/index.js";[0m

[35m[3mthinking[0m[0m
**Planning for TS modules**

I‚Äôm looking at exporting core agents and thinking of expanding them further. I see there's a need to check AGENTS.md for instructions, which is important. But before I dive into coding, I should create a plan using the update_plan tool. The user didn‚Äôt specifically ask for this, but the developer‚Äôs instructions suggest it's a good idea for more complex tasks. Since this involves multiple files, I‚Äôll definitely want to outline the steps!
[35mPlan update[0m
  [36m‚Üí[0m Inspect Phase 11 requirements
  [2m‚Ä¢[0m [2mImplement agents/task/worker modules[0m
  [2m‚Ä¢[0m [2mAdd Phase 11 tests[0m
  [2m‚Ä¢[0m [2mUpdate checklist and changelog[0m
  [2m‚Ä¢[0m [2mRun validations[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,200p' runner-v2.sh"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 44ms:[0m
[2m#!/usr/bin/env bash
set -euo pipefail

# Ensure bun + codex are available
export PATH="$HOME/.bun/bin:$PATH"

ROOT_DIR="$(pwd)"
SRC_DIR="$ROOT_DIR/src"
CHANGELOG_ROOT="$ROOT_DIR/changelogs"
PLAN_FILE="$ROOT_DIR/implementation/1-initial-rewrite-implementation-checklist.md"

# Where your minified bundles live (adjust this!)
BUNDLES_DIR="$ROOT_DIR/bundles"   # e.g. contains ClaudeAgentSDKCode/cli.js, ClaudeCodeCode/cli.js

# Optional: additional docs
DOCS_DIR="$ROOT_DIR/docs"

TIMESTAMP="$(date +%Y%m%d-%H%M%S)"
RUN_ID="implementation-$TIMESTAMP"
RUN_CHANGELOG_DIR="$CHANGELOG_ROOT/$RUN_ID"[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'cat package.json'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 39ms:[0m
[2m{
  "name": "claude-code-ts-rewrite",
  "private": true,
  "type": "module",
  "scripts": {
    "test": "bun test",
    "typecheck": "tsc -p tsconfig.json --noEmit",
    "check:boundaries": "node scripts/check-import-boundaries.mjs"
  },
  "devDependencies": {
    "@types/node": "^22.10.2",
    "typescript": "^5.8.3"
  }
}[0m

[35m[3mthinking[0m[0m
**Defining Phase 11 module**

I'm focusing on defining the Phase 11 module to implement. I just need to ensure I‚Äôm covering all the necessary aspects. Alright, let‚Äôs mark step 1 as complete! I‚Äôm curious about what the next steps will involve and how they‚Äôll fit into the overall process. It‚Äôs important to maintain clarity and structure as I move forward.
[35mPlan update[0m
[3mPhase 11 scope identified from the implementation checklist and legacy bundle/encyclopedia; proceeding to implement the agent/task/worker scaffolding in src.[0m
  [32m‚úì[0m Inspect Phase 11 requirements
  [36m‚Üí[0m Implement agents/task/worker modules
  [2m‚Ä¢[0m [2mAdd Phase 11 tests[0m
  [2m‚Ä¢[0m [2mUpdate checklist and changelog[0m
  [2m‚Ä¢[0m [2mRun validations[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"createLimiter|acquire|release\" -n src/core/runtime/kernel.ts && sed -n '260,560p' src/core/runtime/kernel.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 56ms:[0m
[2m323:  async acquireLimiter(name: string, options: { ownerTaskId?: TaskId; signal?: AbortSignal } = {}): Promise<() => void> {

    return {
      id: taskId,
      done: done.promise as Promise<TaskResult<T>>,
      cancel: (reason) => controller.abort(reason)
    };
  }

  private async closeScope(scopeId: TaskScopeId, reason: CancellationReason = { kind: "stop_request" }): Promise<void> {
    const scope = this.scopes.get(scopeId);
    if (!scope) return;
    if (scope.closedAtMonoMs !== undefined) return;

    scope.closedAtMonoMs = this.nowMonoMs();
    scope.controller.abort(reason);

    const cancelledQueued = [...scope.taskIds.values()].filter((taskId) => this.tasks.get(taskId)?.state === "queued").length;

    // Ensure queued tasks resolve deterministically even if the scheduler never ticks again.[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' src/core/events/bus.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 44ms:[0m
[2mimport type {
  EngineEvent,
  EngineEventChannel,
  EngineEventCorrelationIds,
  EngineEventEnvelope,
  EngineEventSensitivity,
  EngineEventSeverity
} from "../types/events.js";
import { SCHEMA_VERSION } from "../types/schema.js";
import type { MonotonicClock } from "../runtime/clock.js";
import type { IdSource } from "../runtime/ids.js";
import { BoundedAsyncQueue, type DropPolicy } from "../runtime/queue.js";

export type ChannelPolicy = {
  bufferSize: number;
  dropPolicy: DropPolicy;
  mustDeliver: boolean;
  coalesce?: {
    key: (envelope: EngineEventEnvelope) => string | null;
    minIntervalMs?: number;[0m





[35m[3mthinking[0m[0m
**Designing implementation plans**

I'm focused on creating an implementation plan. First, I'll suggest implementing suppression heuristics as a pure function, along with tests. For Magic Docs, I'll work on the parser `parseMagicDocHeader` and a simple template renderer that safely handles naive replacements. I need to define the file discovery plan, which includes using glob and marker parsing, although that requires the filesystem. I should also establish a notes schema as a JSON document and consider compaction logic as part of Phase 11.2.
[35m[3mthinking[0m[0m
**Implementing task coordination**

I'm focusing on task coordination and cancellation. First, I need to define how tasks are registered and surfaced in state, including their resumption and a durable record. I'll create a cancellation propagation method and a safe stop path, which should include a task summary payload. 

In the code, I plan to implement a `DurableTaskRecordV1` type with relevant fields. I'll also define a `TaskSummary` type for the UI and create a `TaskRegistry` class to manage tasks and persist durable records. Finally, I‚Äôll ensure we define how tasks are resumed after a restart without blocking the app.
[35m[3mthinking[0m[0m
**Implementing agent lifecycle management**

I‚Äôm focusing on implementing `AgentManager.stop` with a timeout, where I'll use the runtime kernel to close the scope and wait for agent tasks to finish within a set time frame. I need to ensure that I have a deterministic scheduler. To manage graceful stopping, I can create a `stopGracefully` method with maxTicks.

For Phase 11.4, I'll define how tasks respond to being backgrounded or foregrounded. The `AgentManager` will handle different policies for each agent's background behavior on events, allowing for cancellation or pausing. Implementing pause semantics requires coordinating with agent tasks while considering ongoing work.
[35m[3mthinking[0m[0m
**Managing task states and resources**

I'm planning to handle task management by canceling ongoing runs and marking them as paused. When the foreground state is back, I can restart tasks if allowed. I also need to manage network connectivity changes using the `HostEvent` for network states, so if tasks require a network and we‚Äôre offline, the manager won‚Äôt start them. Additionally, during high memory pressure, I'll cancel lower-priority tasks and release caches. 

For worker isolation in Phase 11.5, I‚Äôll create a `WorkerPool` interface that ensures agent tasks run with a strict capabilities subset, maintaining portability with a defined `WorkerTransport` interface.
[35m[3mthinking[0m[0m
**Defining worker task management**

I'm focusing on creating a `WorkerTaskRunner` that facilitates running a single call in a worker. This will involve sending requests with an ID and payload, while the worker will return responses. If it falls back to the main thread, it will simply call the handler function. 

I'll ensure the payload is JSON-serializable‚Äîperhaps using `structuredClone` or `JSON.stringify`. Next, I need to establish rules for worker capability injection since the main thread will only pass a filtered subset of capabilities. I'll create a `WorkerCapabilityFilter` type to manage this. 

Finally, I plan to implement the structural updates across various files and ensure that I follow guidelines for simplicity. I'll begin with updates to `events.ts` and create `agents.ts` for shared types to avoid any cycle issues.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,220p' src/core/types/index.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 45ms:[0m
[2mexport * from "./json.js";
export * from "./schema.js";
export * from "./canonicalJson.js";
export * from "./errors.js";
export * from "./events.js";
export * from "./host.js";
export * from "./workspace.js";
export * from "./engine.js";
export * from "./runtime.js";
export * from "./state.js";[0m



[35m[3mthinking[0m[0m
**Implementing agent types**

I need to add exports for agent types in `src/core/types/agents.ts`. This will include defining types like `AgentId`, which might be branded. Also, I‚Äôm thinking of `BackgroundAgentKind` with options like "magic_docs" and "prompt_suggestion". To keep it simple, I'll define various types related to agent lifecycle and tasks, such as `AgentLifecycleStateV1` and `AgentSummaryV1`. I can reference existing `schemaVersion: 1` definitions in `core/types/state.ts` and include events in `core/types/events.ts`. Let's proceed with this implementation.
[35m[3mthinking[0m[0m
**Updating task state structures**

I see that the event union relies on agent types from the types folder, so it's safe to import from `./agents.js`. I also want to add new elements to the HostEvent union, like network-state and memory-pressure, perhaps host/connection change. In `src/core/types/state.ts`, I‚Äôll import `LongRunningTaskEntityV1` and `DurableTaskRecordV1`, then update `PersistedAppStateV1` to optionally include `tasks` and `durableTasks`. It seems best to keep durable records within task entities, so tasks will be stored in the app state without introducing complicated cross-references. Lastly, I‚Äôll adjust the `createEmptyPersistedAppState` and `reduceAppState` to handle these updates.
[35m[3mthinking[0m[0m
**Considering session state updates**

I need to update `createEmptyPersistedSessionState` as well. There‚Äôs session creation logic in `state/commands`, so it‚Äôs important to check where exactly this creation happens. I‚Äôll search for "createEmptyPersistedSessionState" to see its current implementation and ensure it aligns with the other updates I‚Äôm making. It‚Äôs crucial to keep everything consistent, especially regarding how sessions are managed within the app state. Let‚Äôs make sure I understand the full picture before I proceed.
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "createEmptyPersistedSession" -S src/core/state'[0m in /Users/ronaldeddings/ClaudeCodeTS[31m exited 1 in 58ms:[0m
[2m[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "PersistedSessionStateV1" src/core/state | head -n 40'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 50ms:[0m
[2msrc/core/state/sessionExport.ts:4:  PersistedSessionStateV1,
src/core/state/sessionExport.ts:15:export function createSessionExport(session: PersistedSessionStateV1, exportedAtWallMs: number): SessionExportV1 {
src/core/state/sessionExport.ts:35:export function importSessionExport(exported: SessionExportV1, nowMonoMs: number): PersistedSessionStateV1 {
src/core/state/state.ts:10:  type PersistedSessionStateV1,
src/core/state/state.ts:100:  | { type: "app/session-created"; session: PersistedSessionStateV1 }
src/core/state/state.ts:189:  const nextSessions: Record<string, PersistedSessionStateV1> = {};
src/core/state/state.ts:229:  update: (session: PersistedSessionStateV1) => PersistedSessionStateV1
src/core/state/state.ts:267:      const nextSessionBase: PersistedSessionStateV1 = {
src/core/state/state.ts:275:      const nextSessions: Record<string, PersistedSessionStateV1> = { ...state.persisted.sessions };
src/core/state/state.ts:651:      const session: PersistedSessionStateV1 = {[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '240,340p' src/core/state/state.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 46ms:[0m
[2m}

function setTranscriptBounded(log: TranscriptLogV1, bounded: TranscriptLogV1["bounded"]): TranscriptLogV1 {
  if (bounded) return { ...log, bounded };
  const { bounded: _removed, ...rest } = log;
  return rest;
}

export function reduceAppState(state: AppState, action: StateAction): { state: AppState; effects: StateEffect[]; events: StateUiEvent[] } {
  switch (action.type) {
    case "app/restore-persisted": {
      const next: AppState = { persisted: action.persisted, ui: createEmptyUiState() };
      return { state: next, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
    }
    case "app/session-created": {
      const sessions = { ...state.persisted.sessions, [action.session.id]: action.session };
      const nextPersisted: PersistedAppStateV1 = {
        ...state.persisted,
        sessions,
        activeSessionId: state.persisted.activeSessionId ?? action.session.id,[0m
[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"function commandToActions\" -n src/core/state/state.ts && sed -n '600,740p' src/core/state/state.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 58ms:[0m
[2m642:export function commandToActions(
        effects,
        events: [{ type: "ui/state-changed", actionType: action.type }]
      };
    }
    case "ui/message-selector/set-open": {
      return {
        state: { ...state, ui: { ...state.ui, messageSelectorOpen: action.open } },
        effects: [],
        events: [{ type: "ui/state-changed", actionType: action.type }]
      };
    }
    case "ui/cost-notice/set-active": {
      return {
        state: { ...state, ui: { ...state.ui, costNoticeActive: action.active } },
        effects: [],
        events: [{ type: "ui/state-changed", actionType: action.type }]
      };
    }
    case "ui/ide-onboarding/set-active": {[0m
[3m[35mfile update[0m[0m
[35mD /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/index.ts[0m
[31mexport type AgentsPlaceholder = {[0m
[31m  phase: "2";[0m
[31m};[0m
[31m[0m
[32mapply_patch(auto_approved=true) exited 0 in 10ms:[0m
[2mSuccess. Updated the following files:[0m
[2mD src/core/agents/index.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
deleted file mode 100644
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..0000000000000000000000000000000000000000
--- a/src/core/agents/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
-

[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
deleted file mode 100644
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..0000000000000000000000000000000000000000
--- a/src/core/agents/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
-

[3m[35mfile update[0m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/index.ts[0m
[32mexport * from "./types.js";[0m
[32mexport * from "./registry.js";[0m
[32mexport * from "./manager.js";[0m
[32mexport * from "./tasks.js";[0m
[32mexport * from "./builtins/index.js";[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/builtins/sessionMemory.ts[0m
[32mimport type { AgentDefinition } from "../types.js";[0m
[32mimport { createBuiltInAgentId } from "../manager.js";[0m
[32mimport { canonicalJsonStringify } from "../../types/canonicalJson.js";[0m
[32m[0m
[32mexport type SessionMemoryNotesV1 = {[0m
[32m  schemaVersion: 1;[0m
[32m  sessionId: string;[0m
[32m  createdAtMonoMs: number;[0m
[32m  updatedAtMonoMs: number;[0m
[32m  lastCheckpointId?: string;[0m
[32m  notes: string;[0m
[32m};[0m
[32m[0m
[32mexport function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {[0m
[32m  return canonicalJsonStringify(notes);[0m
[32m}[0m
[32m[0m
[32mexport function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {[0m
[32m  const parsed = JSON.parse(text) as unknown;[0m
[32m  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");[0m
[32m  const obj = parsed as Record<string, unknown>;[0m
[32m  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);[0m
[32m  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");[0m
[32m  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");[0m
[32m  return parsed as SessionMemoryNotesV1;[0m
[32m}[0m
[32m[0m
[32mexport const SESSION_MEMORY_AGENT: AgentDefinition = {[0m
[32m  id: createBuiltInAgentId("session_memory"),[0m
[32m  name: "Session memory",[0m
[32m  kind: "background",[0m
[32m  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },[0m
[32m  requiredCapabilities: ["storage"],[0m
[32m  run: async (ctx) => {[0m
[32m    void ctx;[0m
[32m    return { kind: "completed" };[0m
[32m  }[0m
[32m};[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/builtins/classifier.ts[0m
[32mimport type { AgentDefinition } from "../types.js";[0m
[32mimport { createBuiltInAgentId } from "../manager.js";[0m
[32m[0m
[32mexport const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {[0m
[32m  id: createBuiltInAgentId("session_quality_classifier"),[0m
[32m  name: "Session quality classifier",[0m
[32m  kind: "background",[0m
[32m  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },[0m
[32m  requiredCapabilities: ["storage"],[0m
[32m  run: async (ctx) => {[0m
[32m    void ctx;[0m
[32m    return { kind: "completed" };[0m
[32m  }[0m
[32m};[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/builtins/index.ts[0m
[32mexport * from "./promptSuggestion.js";[0m
[32mexport * from "./magicDocs.js";[0m
[32mexport * from "./sessionMemory.js";[0m
[32mexport * from "./classifier.js";[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/manager.ts[0m
[32mimport type { EventBus } from "../events/bus.js";[0m
[32mimport type { MonotonicClock } from "../runtime/clock.js";[0m
[32mimport type { IdSource } from "../runtime/ids.js";[0m
[32mimport type { RuntimeKernel } from "../runtime/kernel.js";[0m
[32mimport type { TaskScope } from "../runtime/scope.js";[0m
[32mimport type { HostCapabilities } from "../types/host.js";[0m
[32mimport type { HostEvent } from "../types/events.js";[0m
[32mimport type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";[0m
[32mimport { asAgentId } from "../types/agents.js";[0m
[32mimport type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";[0m
[32mimport { AgentRegistry } from "./registry.js";[0m
[32m[0m
[32mtype LifecycleState = {[0m
[32m  backgrounded: boolean;[0m
[32m  network: "online" | "offline" | "unknown";[0m
[32m  memoryPressure: "low" | "medium" | "high" | "unknown";[0m
[32m};[0m
[32m[0m
[32mfunction initialLifecycleState(): LifecycleState {[0m
[32m  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };[0m
[32m}[0m
[32m[0m
[32mexport class AgentManager {[0m
[32m  private readonly host: HostCapabilities;[0m
[32m  private readonly idSource: IdSource;[0m
[32m  private readonly clock: MonotonicClock;[0m
[32m  private readonly runtime: RuntimeKernel;[0m
[32m  private readonly bus: EventBus;[0m
[32m[0m
[32m  private readonly registry = new AgentRegistry();[0m
[32m  private readonly scope: TaskScope;[0m
[32m  private lifecycle: LifecycleState = initialLifecycleState();[0m
[32m[0m
[32m  private readonly agents = new Map<AgentId, AgentInstance>();[0m
[32m  private readonly warnOnce = new Set<string>();[0m
[32m[0m
[32m  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {[0m
[32m    this.host = options.host;[0m
[32m    this.idSource = options.idSource;[0m
[32m    this.clock = options.clock;[0m
[32m    this.runtime = options.runtime;[0m
[32m    this.bus = options.bus;[0m
[32m    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });[0m
[32m  }[0m
[32m[0m
[32m  getRegistry(): AgentRegistry {[0m
[32m    return this.registry;[0m
[32m  }[0m
[32m[0m
[32m  register(def: AgentDefinition): void {[0m
[32m    this.registry.register(def);[0m
[32m    const now = this.clock.nowMs();[0m
[32m    const summary: AgentSummaryV1 = {[0m
[32m      id: def.id,[0m
[32m      kind: def.kind,[0m
[32m      name: def.name,[0m
[32m      state: "scheduled",[0m
[32m      createdAtMonoMs: now,[0m
[32m      updatedAtMonoMs: now,[0m
[32m      ...(def.persistence ? { persistence: def.persistence } : {})[0m
[32m    };[0m
[32m    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });[0m
[32m    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });[0m
[32m    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });[0m
[32m  }[0m
[32m[0m
[32m  getAgent(id: AgentId): AgentSummaryV1 | null {[0m
[32m    return this.agents.get(id)?.summary ?? null;[0m
[32m  }[0m
[32m[0m
[32m  listAgents(): AgentSummaryV1[] {[0m
[32m    return [...this.agents.values()][0m
[32m      .map((a) => a.summary)[0m
[32m      .sort((a, b) => a.name.localeCompare(b.name));[0m
[32m  }[0m
[32m[0m
[32m  async handleHostEvent(event: HostEvent): Promise<void> {[0m
[32m    const now = this.clock.nowMs();[0m
[32m    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };[0m
[32m    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };[0m
[32m    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };[0m
[32m    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };[0m
[32m[0m
[32m    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;[0m
[32m[0m
[32m    for (const inst of this.agents.values()) {[0m
[32m      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;[0m
[32m      if (shouldRun) await this.startAgent(inst.def.id);[0m
[32m    }[0m
[32m[0m
[32m    if (event.type === "host/backgrounded") {[0m
[32m      for (const inst of this.agents.values()) {[0m
[32m        if (inst.def.kind !== "background") continue;[0m
[32m        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {[0m
[32m          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });[0m
[32m        }[0m
[32m      }[0m
[32m    }[0m
[32m  }[0m
[32m[0m
[32m  async startAgent(id: AgentId): Promise<void> {[0m
[32m    const inst = this.agents.get(id);[0m
[32m    if (!inst) throw new Error(`Unknown agent: ${id}`);[0m
[32m    if (inst.summary.state === "running") return;[0m
[32m    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {[0m
[32m      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);[0m
[32m      return;[0m
[32m    }[0m
[32m    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {[0m
[32m      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);[0m
[32m      return;[0m
[32m    }[0m
[32m[0m
[32m    const now = this.clock.nowMs();[0m
[32m    inst.turnsUsed += 1;[0m
[32m    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {[0m
[32m      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };[0m
[32m      inst.summary = next;[0m
[32m      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });[0m
[32m      return;[0m
[32m    }[0m
[32m[0m
[32m    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };[0m
[32m    inst.summary = nextRunning;[0m
[32m    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });[0m
[32m[0m
[32m    const taskHandle = inst.scope.spawn([0m
[32m      async (task) => {[0m
[32m        const emit = async (evt: import("./types.js").AgentEvent) => {[0m
[32m          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });[0m
[32m          if (evt.type === "agent/progress") {[0m
[32m            await this.bus.emit([0m
[32m              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },[0m
[32m              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }[0m
[32m            );[0m
[32m          }[0m
[32m          if (evt.type === "agent/result") {[0m
[32m            await this.bus.emit([0m
[32m              { type: "agent/result", agentId: evt.agentId, result: evt.result },[0m
[32m              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }[0m
[32m            );[0m
[32m          }[0m
[32m        };[0m
[32m[0m
[32m        const ctx: import("./types.js").AgentContext = {[0m
[32m          agentId: inst.def.id,[0m
[32m          signal: task.signal,[0m
[32m          host: this.host,[0m
[32m          task,[0m
[32m          scope: inst.scope,[0m
[32m          emit,[0m
[32m          nowMonoMs: () => this.clock.nowMs(),[0m
[32m          getLifecycle: () => ({ ...this.lifecycle })[0m
[32m        };[0m
[32m[0m
[32m        const result: AgentRunResult = await inst.def.run(ctx);[0m
[32m        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });[0m
[32m        return result;[0m
[32m      },[0m
[32m      {[0m
[32m        label: `agent_run:${inst.def.name}`,[0m
[32m        priority: inst.def.budget?.priority ?? "low",[0m
[32m        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})[0m
[32m      }[0m
[32m    );[0m
[32m[0m
[32m    inst.taskId = taskHandle.id;[0m
[32m    void taskHandle.done.then([0m
[32m      async (res) => {[0m
[32m        const now2 = this.clock.nowMs();[0m
[32m        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });[0m
[32m        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };[0m
[32m        inst.taskId = null;[0m
[32m        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });[0m
[32m      },[0m
[32m      async () => {[0m
[32m        const now2 = this.clock.nowMs();[0m
[32m        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };[0m
[32m        inst.taskId = null;[0m
[32m        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });[0m
[32m      }[0m
[32m    );[0m
[32m  }[0m
[32m[0m
[32m  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {[0m
[32m    const inst = this.agents.get(id);[0m
[32m    if (!inst) return;[0m
[32m    const now = this.clock.nowMs();[0m
[32m    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;[0m
[32m    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };[0m
[32m    inst.scope.close(reason).catch(() => {});[0m
[32m    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });[0m
[32m  }[0m
[32m[0m
[32m  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {[0m
[32m    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;[0m
[32m    await this.scope.close(reason);[0m
[32m[0m
[32m    const maxTicks = options.maxTicks ?? 10_000;[0m
[32m    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);[0m
[32m    while (this.clock.nowMs() < deadline) {[0m
[32m      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });[0m
[32m      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");[0m
[32m      if (!running) return;[0m
[32m      if (this.runtime.getScheduler().currentTick > maxTicks) break;[0m
[32m    }[0m
[32m  }[0m
[32m[0m
[32m  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {[0m
[32m    const base = inst.summary;[0m
[32m    if (result.kind === "completed") return { ...base, state: "completed" };[0m
[32m    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };[0m
[32m    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };[0m
[32m    return { ...base, state: "failed", error: "unknown agent outcome" };[0m
[32m  }[0m
[32m[0m
[32m  private noteWarnOnce(key: string, message: string): void {[0m
[32m    if (this.warnOnce.has(key)) return;[0m
[32m    this.warnOnce.add(key);[0m
[32m    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });[0m
[32m  }[0m
[32m}[0m
[32m[0m
[32mexport function createBuiltInAgentId(name: string): AgentId {[0m
[32m  return asAgentId(`agent:${name}`);[0m
[32m}[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/registry.ts[0m
[32mimport type { AgentDefinition } from "./types.js";[0m
[32mimport type { AgentId } from "../types/agents.js";[0m
[32m[0m
[32mexport class AgentRegistry {[0m
[32m  private readonly byId = new Map<AgentId, AgentDefinition>();[0m
[32m[0m
[32m  register(def: AgentDefinition): void {[0m
[32m    const existing = this.byId.get(def.id);[0m
[32m    if (existing) throw new Error(`Agent already registered: ${def.id}`);[0m
[32m    this.byId.set(def.id, def);[0m
[32m  }[0m
[32m[0m
[32m  get(id: AgentId): AgentDefinition | null {[0m
[32m    return this.byId.get(id) ?? null;[0m
[32m  }[0m
[32m[0m
[32m  list(): AgentDefinition[] {[0m
[32m    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));[0m
[32m  }[0m
[32m}[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/builtins/promptSuggestion.ts[0m
[32mimport type { AgentDefinition } from "../types.js";[0m
[32mimport { createBuiltInAgentId } from "../manager.js";[0m
[32m[0m
[32mexport type PromptSuggestionSuppressionReason =[0m
[32m  | "empty"[0m
[32m  | "done"[0m
[32m  | "too_long"[0m
[32m  | "formatting"[0m
[32m  | "context_limit_error"[0m
[32m  | "gratitude_or_closure";[0m
[32m[0m
[32mexport function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {[0m
[32m  const maxChars = options.maxChars ?? 100;[0m
[32m  const trimmed = text.trim();[0m
[32m  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };[0m
[32m  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };[0m
[32m  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };[0m
[32m  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };[0m
[32m  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };[0m
[32m  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {[0m
[32m    return { suppressed: true, reason: "gratitude_or_closure" };[0m
[32m  }[0m
[32m  return { suppressed: false };[0m
[32m}[0m
[32m[0m
[32mexport const PROMPT_SUGGESTION_AGENT: AgentDefinition = {[0m
[32m  id: createBuiltInAgentId("prompt_suggestion"),[0m
[32m  name: "Prompt suggestion",[0m
[32m  kind: "background",[0m
[32m  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },[0m
[32m  requiredCapabilities: ["storage"],[0m
[32m  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },[0m
[32m  run: async (ctx) => {[0m
[32m    void ctx;[0m
[32m    return { kind: "completed" };[0m
[32m  }[0m
[32m};[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/tasks.ts[0m
[32mimport type { MonotonicClock } from "../runtime/clock.js";[0m
[32mimport type { IdSource } from "../runtime/ids.js";[0m
[32mimport type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";[0m
[32mimport { canonicalJsonStringify } from "../types/canonicalJson.js";[0m
[32mimport type { HostStorage, StorageNamespace } from "../types/host.js";[0m
[32m[0m
[32mexport const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";[0m
[32m[0m
[32mexport type DurableTasksDocumentV1 = {[0m
[32m  schemaVersion: 1;[0m
[32m  tasks: Record<string, DurableTaskRecordV1>;[0m
[32m};[0m
[32m[0m
[32mexport function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {[0m
[32m  return canonicalJsonStringify(doc);[0m
[32m}[0m
[32m[0m
[32mexport function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {[0m
[32m  const parsed = JSON.parse(text) as unknown;[0m
[32m  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");[0m
[32m  const obj = parsed as Record<string, unknown>;[0m
[32m  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);[0m
[32m  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");[0m
[32m  return parsed as DurableTasksDocumentV1;[0m
[32m}[0m
[32m[0m
[32mexport async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {[0m
[32m  const found = await storage.get(namespace, key);[0m
[32m  if (!found) return null;[0m
[32m  return decodeDurableTasksDocument(found.value);[0m
[32m}[0m
[32m[0m
[32mexport async function saveDurableTasks([0m
[32m  storage: HostStorage,[0m
[32m  namespace: StorageNamespace,[0m
[32m  doc: DurableTasksDocumentV1,[0m
[32m  key = DURABLE_TASKS_STORAGE_KEY,[0m
[32m  options?: { expectedVersion?: string | null }[0m
[32m): Promise<{ version: string }> {[0m
[32m  const encoded = encodeDurableTasksDocument(doc);[0m
[32m  return await storage.set(namespace, key, encoded, options);[0m
[32m}[0m
[32m[0m
[32mexport type TaskRegistrySnapshot = {[0m
[32m  tasks: Record<string, LongRunningTaskEntityV1>;[0m
[32m};[0m
[32m[0m
[32mexport class TaskRegistry {[0m
[32m  private readonly idSource: IdSource;[0m
[32m  private readonly clock: MonotonicClock;[0m
[32m  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();[0m
[32m[0m
[32m  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {[0m
[32m    this.idSource = options.idSource;[0m
[32m    this.clock = options.clock;[0m
[32m  }[0m
[32m[0m
[32m  snapshot(): TaskRegistrySnapshot {[0m
[32m    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };[0m
[32m  }[0m
[32m[0m
[32m  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {[0m
[32m    const id = this.idSource.nextId("lrt");[0m
[32m    const now = this.clock.nowMs();[0m
[32m    const task: LongRunningTaskEntityV1 = {[0m
[32m      id,[0m
[32m      label,[0m
[32m      state: "scheduled",[0m
[32m      createdAtMonoMs: now,[0m
[32m      updatedAtMonoMs: now,[0m
[32m      ...(initial ?? {})[0m
[32m    };[0m
[32m    this.tasks.set(id, task);[0m
[32m    return task;[0m
[32m  }[0m
[32m[0m
[32m  upsert(task: LongRunningTaskEntityV1): void {[0m
[32m    this.tasks.set(task.id, task);[0m
[32m  }[0m
[32m[0m
[32m  get(id: string): LongRunningTaskEntityV1 | null {[0m
[32m    return this.tasks.get(id) ?? null;[0m
[32m  }[0m
[32m[0m
[32m  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {[0m
[32m    const prev = this.tasks.get(id);[0m
[32m    if (!prev) return null;[0m
[32m    const next = updater(prev);[0m
[32m    this.tasks.set(id, next);[0m
[32m    return next;[0m
[32m  }[0m
[32m[0m
[32m  remove(id: string): void {[0m
[32m    this.tasks.delete(id);[0m
[32m  }[0m
[32m}[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/types/agents.ts[0m
[32mimport type { EngineEventSensitivity } from "./events.js";[0m
[32mimport type { CancellationReason, TaskPriority } from "./runtime.js";[0m
[32m[0m
[32mexport type AgentId = string & { readonly __brand: "AgentId" };[0m
[32mexport function asAgentId(value: string): AgentId {[0m
[32m  return value as AgentId;[0m
[32m}[0m
[32m[0m
[32mexport type AgentKindV1 = "background" | "foreground";[0m
[32m[0m
[32mexport type AgentLifecycleStateV1 =[0m
[32m  | "scheduled"[0m
[32m  | "running"[0m
[32m  | "awaiting_input"[0m
[32m  | "paused"[0m
[32m  | "completed"[0m
[32m  | "failed"[0m
[32m  | "cancelled";[0m
[32m[0m
[32mexport type AgentBudgetV1 = {[0m
[32m  timeoutMs?: number;[0m
[32m  maxTurns?: number;[0m
[32m  maxConcurrent?: number;[0m
[32m  priority?: TaskPriority;[0m
[32m};[0m
[32m[0m
[32mexport type AgentPersistencePolicyV1 =[0m
[32m  | { kind: "none" }[0m
[32m  | { kind: "summary"; sensitivity?: EngineEventSensitivity }[0m
[32m  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };[0m
[32m[0m
[32mexport type AgentProgressV1 = {[0m
[32m  tsMonoMs: number;[0m
[32m  message?: string;[0m
[32m  percent?: number;[0m
[32m  details?: unknown;[0m
[32m};[0m
[32m[0m
[32mexport type AgentSummaryV1 = {[0m
[32m  id: AgentId;[0m
[32m  kind: AgentKindV1;[0m
[32m  name: string;[0m
[32m  state: AgentLifecycleStateV1;[0m
[32m  createdAtMonoMs: number;[0m
[32m  updatedAtMonoMs: number;[0m
[32m  startedAtMonoMs?: number;[0m
[32m  endedAtMonoMs?: number;[0m
[32m  lastProgress?: AgentProgressV1;[0m
[32m  error?: string;[0m
[32m  cancelled?: CancellationReason;[0m
[32m  persistence?: AgentPersistencePolicyV1;[0m
[32m};[0m
[32m[0m
[32mexport type DurableTaskCheckpointV1 = {[0m
[32m  cursor: string;[0m
[32m  tsMonoMs: number;[0m
[32m  summary?: string;[0m
[32m};[0m
[32m[0m
[32mexport type DurableTaskRetryStateV1 = {[0m
[32m  attempt: number;[0m
[32m  nextDelayMs?: number;[0m
[32m  lastError?: string;[0m
[32m};[0m
[32m[0m
[32mexport type DurableTaskRecordV1 = {[0m
[32m  schemaVersion: 1;[0m
[32m  id: string;[0m
[32m  label?: string;[0m
[32m  scope: "app" | "workspace" | "session";[0m
[32m  sessionId?: string;[0m
[32m  workspaceId?: string;[0m
[32m  requiredCapabilities?: string[];[0m
[32m  createdAtMonoMs: number;[0m
[32m  updatedAtMonoMs: number;[0m
[32m  lastCheckpoint?: DurableTaskCheckpointV1;[0m
[32m  retry?: DurableTaskRetryStateV1;[0m
[32m};[0m
[32m[0m
[32mexport type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";[0m
[32m[0m
[32mexport type LongRunningTaskEntityV1 = {[0m
[32m  id: string;[0m
[32m  label: string;[0m
[32m  state: LongRunningTaskStateV1;[0m
[32m  createdAtMonoMs: number;[0m
[32m  updatedAtMonoMs: number;[0m
[32m  startedAtMonoMs?: number;[0m
[32m  endedAtMonoMs?: number;[0m
[32m  priority?: TaskPriority;[0m
[32m  progress?: AgentProgressV1;[0m
[32m  error?: string;[0m
[32m  cancelled?: CancellationReason;[0m
[32m  durable?: DurableTaskRecordV1;[0m
[32m};[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/types.ts[0m
[32mimport type { HostCapabilities } from "../types/host.js";[0m
[32mimport type { EngineEventSensitivity, HostEvent } from "../types/events.js";[0m
[32mimport type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";[0m
[32mimport type { CancellationReason, TaskExecutionContext, TaskScope } from "../runtime/scope.js";[0m
[32mimport type { EngineError } from "../types/errors.js";[0m
[32m[0m
[32mexport type BackgroundAgentQualification = {[0m
[32m  kind: AgentKindV1;[0m
[32m  rationale: string;[0m
[32m};[0m
[32m[0m
[32mexport function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {[0m
[32m  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };[0m
[32m  return {[0m
[32m    kind: "background",[0m
[32m    rationale:[0m
[32m      input.invokedFrom === "user_prompt"[0m
[32m        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."[0m
[32m        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."[0m
[32m  };[0m
[32m}[0m
[32m[0m
[32mexport type AgentRunResult =[0m
[32m  | { kind: "completed"; summary?: string }[0m
[32m  | { kind: "failed"; error: EngineError }[0m
[32m  | { kind: "cancelled"; reason: CancellationReason };[0m
[32m[0m
[32mexport type AgentEvent =[0m
[32m  | { type: "agent/state"; agent: AgentSummaryV1 }[0m
[32m  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }[0m
[32m  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };[0m
[32m[0m
[32mexport type AgentEventSink = (event: AgentEvent) => Promise<void>;[0m
[32m[0m
[32mexport type AgentContext = {[0m
[32m  agentId: AgentId;[0m
[32m  signal: AbortSignal;[0m
[32m  host: HostCapabilities;[0m
[32m  task: TaskExecutionContext;[0m
[32m  scope: TaskScope;[0m
[32m  emit: AgentEventSink;[0m
[32m  nowMonoMs: () => number;[0m
[32m  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };[0m
[32m};[0m
[32m[0m
[32mexport type AgentDefinition = {[0m
[32m  id: AgentId;[0m
[32m  name: string;[0m
[32m  kind: AgentKindV1;[0m
[32m  budget?: AgentBudgetV1;[0m
[32m  persistence?: AgentPersistencePolicyV1;[0m
[32m  requiredCapabilities?: Array<keyof HostCapabilities>;[0m
[32m  triggers?: {[0m
[32m    onHostEvent?: (event: HostEvent) => boolean;[0m
[32m    intervalMs?: number;[0m
[32m  };[0m
[32m  run: (ctx: AgentContext) => Promise<AgentRunResult>;[0m
[32m};[0m
[32m[0m
[32mexport type AgentInstance = {[0m
[32m  def: AgentDefinition;[0m
[32m  summary: AgentSummaryV1;[0m
[32m  scope: TaskScope;[0m
[32m  taskId: string | null;[0m
[32m  turnsUsed: number;[0m
[32m  lastHostEventAtMonoMs?: number;[0m
[32m};[0m
[32m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/builtins/magicDocs.ts[0m
[32mimport type { AgentDefinition } from "../types.js";[0m
[32mimport { createBuiltInAgentId } from "../manager.js";[0m
[32m[0m
[32mexport type MagicDocHeaderParseResult = { title: string; instructions?: string };[0m
[32m[0m
[32mexport function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {[0m
[32m  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;[0m
[32m  const match = header.exec(contents);[0m
[32m  if (!match) return null;[0m
[32m  const title = (match[1] ?? "").trim();[0m
[32m  if (title === "") return null;[0m
[32m[0m
[32m  const after = contents.slice(match.index + match[0].length);[0m
[32m  const lines = after.split(/\r?\n/);[0m
[32m  let cursor = 0;[0m
[32m  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;[0m
[32m  if (cursor < lines.length) {[0m
[32m    const line = lines[cursor]!.trim();[0m
[32m    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);[0m
[32m    if (instr && instr[1]) return { title, instructions: instr[1].trim() };[0m
[32m  }[0m
[32m  return { title };[0m
[32m}[0m
[32m[0m
[32mexport function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {[0m
[32m  let out = template;[0m
[32m  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);[0m
[32m  return out;[0m
[32m}[0m
[32m[0m
[32mexport const MAGIC_DOCS_AGENT: AgentDefinition = {[0m
[32m  id: createBuiltInAgentId("magic_docs"),[0m
[32m  name: "Magic Docs",[0m
[32m  kind: "background",[0m
[32m  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },[0m
[32m  requiredCapabilities: ["storage"],[0m
[32m  run: async (ctx) => {[0m
[32m    void ctx;[0m
[32m    return { kind: "completed" };[0m
[32m  }[0m
[32m};[0m
[32m[0m
[32mapply_patch(auto_approved=true) exited 0 in 70ms:[0m
[2mSuccess. Updated the following files:[0m
[2mA src/core/types/agents.ts[0m
[2mA src/core/agents/index.ts[0m
[2mA src/core/agents/types.ts[0m
[2mA src/core/agents/registry.ts[0m
[2mA src/core/agents/tasks.ts[0m
[2mA src/core/agents/manager.ts[0m
[2mA src/core/agents/builtins/index.ts[0m
[2mA src/core/agents/builtins/promptSuggestion.ts[0m
[2mA src/core/agents/builtins/magicDocs.ts[0m
[2mA src/core/agents/builtins/sessionMemory.ts[0m
[2mA src/core/agents/builtins/classifier.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ee36cd224f978d5d628eeb9e9c03a33e48c34ea
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,227 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res) => {
+        const now2 = this.clock.nowMs();
+        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };
+    return { ...base, state: "failed", error: "unknown agent outcome" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
+
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dee22cd94c69290e6d74bc9d01e2d2b2e22c7910
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,68 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import type { CancellationReason, TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { EngineError } from "../types/errors.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: EngineError }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
+
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..416d069f5ca4f72bede7dcdc413c317ec855b7b0
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,96 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
+



[35m[3mthinking[0m[0m
**Fixing import issues**

I‚Äôve added many new files, and I need to ensure the imports are correct. In core/agents/types.ts, I mistakenly imported CancellationReason from "../runtime/scope.js," but it should be from types/runtime. I also referenced `EngineError`, which needs fixing. In manager.ts, I used `TaskScope` from runtime/scope, but I realize TaskScopeKind doesn't include "agent" yet, so I'll update core/types/runtime.ts later. There are several adjustments to make, like correcting the imports and updating exports in core/types/index.ts. Let‚Äôs patch this up!
[35m[3mthinking[0m[0m
**Updating event types**

I need to update core/types/events.ts to include both agent events and new host events. It's important to ensure that all relevant events are properly defined so that everything works smoothly. I‚Äôll make a note to patch this as soon as possible. Keeping these types updated is crucial for maintaining the overall functionality and consistency in the system. Let‚Äôs get this done to avoid any future issues!
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ee36cd224f978d5d628eeb9e9c03a33e48c34ea
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,227 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res) => {
+        const now2 = this.clock.nowMs();
+        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };
+    return { ...base, state: "failed", error: "unknown agent outcome" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
+
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dee22cd94c69290e6d74bc9d01e2d2b2e22c7910
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,68 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import type { CancellationReason, TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { EngineError } from "../types/errors.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: EngineError }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
+
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..416d069f5ca4f72bede7dcdc413c317ec855b7b0
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,96 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/types/index.ts[0m
@@ -9,2 +9,3 @@
 export * from "./runtime.js";
[32m+export * from "./agents.js";[0m
 export * from "./state.js";
[32mapply_patch(auto_approved=true) exited 0 in 77ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/types/index.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ee36cd224f978d5d628eeb9e9c03a33e48c34ea
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,227 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res) => {
+        const now2 = this.clock.nowMs();
+        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };
+    return { ...base, state: "failed", error: "unknown agent outcome" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
+
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dee22cd94c69290e6d74bc9d01e2d2b2e22c7910
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,68 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import type { CancellationReason, TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { EngineError } from "../types/errors.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: EngineError }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
+
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..416d069f5ca4f72bede7dcdc413c317ec855b7b0
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,96 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
+
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";

[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ee36cd224f978d5d628eeb9e9c03a33e48c34ea
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,227 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res) => {
+        const now2 = this.clock.nowMs();
+        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };
+    return { ...base, state: "failed", error: "unknown agent outcome" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
+
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dee22cd94c69290e6d74bc9d01e2d2b2e22c7910
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,68 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import type { CancellationReason, TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { EngineError } from "../types/errors.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: EngineError }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
+
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..416d069f5ca4f72bede7dcdc413c317ec855b7b0
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,96 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
+
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/types.ts[0m
@@ -3,3 +3,4 @@
 import type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
[31m-import type { CancellationReason, TaskExecutionContext, TaskScope } from "../runtime/scope.js";[0m
[32m+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";[0m
[32m+import type { CancellationReason } from "../types/runtime.js";[0m
 import type { EngineError } from "../types/errors.js";
@@ -67,2 +68 @@
 };
[31m-[0m
[32mapply_patch(auto_approved=true) exited 0 in 74ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/agents/types.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ee36cd224f978d5d628eeb9e9c03a33e48c34ea
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,227 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res) => {
+        const now2 = this.clock.nowMs();
+        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };
+    return { ...base, state: "failed", error: "unknown agent outcome" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
+
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..caa534dd85aaaaf9b40c0ceec0a7647e55cf9cd0
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,68 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { EngineError } from "../types/errors.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: EngineError }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..416d069f5ca4f72bede7dcdc413c317ec855b7b0
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,96 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
+
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";

[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ee36cd224f978d5d628eeb9e9c03a33e48c34ea
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,227 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res) => {
+        const now2 = this.clock.nowMs();
+        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };
+    return { ...base, state: "failed", error: "unknown agent outcome" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
+
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..caa534dd85aaaaf9b40c0ceec0a7647e55cf9cd0
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,68 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { EngineError } from "../types/errors.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: EngineError }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..416d069f5ca4f72bede7dcdc413c317ec855b7b0
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,96 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
+
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/types/events.ts[0m
@@ -4,2 +4,3 @@
 import type { StateSnapshotV1 } from "./state.js";
[32m+import type { AgentId, AgentProgressV1, AgentRunResultForEvent } from "./eventsAgentCompat.js";[0m
 
@@ -34,2 +35,5 @@
   | { type: "ui/prompt"; promptId: string; message: string }
[32m+  | { type: "agent/updated"; agent: unknown }[0m
[32m+  | { type: "agent/progress"; agentId: string; progress: AgentProgressV1 }[0m
[32m+  | { type: "agent/result"; agentId: string; result: AgentRunResultForEvent }[0m
   | {
@@ -62,2 +66,4 @@
   | { type: "host/backgrounded" }
[31m-  | { type: "host/foregrounded" };[0m
[32m+  | { type: "host/foregrounded" }[0m
[32m+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }[0m
[32m+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };[0m
[32mapply_patch(auto_approved=true) exited 0 in 75ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/types/events.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ee36cd224f978d5d628eeb9e9c03a33e48c34ea
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,227 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res) => {
+        const now2 = this.clock.nowMs();
+        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };
+    return { ...base, state: "failed", error: "unknown agent outcome" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
+
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..caa534dd85aaaaf9b40c0ceec0a7647e55cf9cd0
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,68 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { EngineError } from "../types/errors.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: EngineError }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..416d069f5ca4f72bede7dcdc413c317ec855b7b0
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,96 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..c440fc2b6ce478d6ae0d8ec8b7d8891d569af756
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultForEvent } from "./eventsAgentCompat.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: unknown }
+  | { type: "agent/progress"; agentId: string; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: string; result: AgentRunResultForEvent }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";

[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ee36cd224f978d5d628eeb9e9c03a33e48c34ea
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,227 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res) => {
+        const now2 = this.clock.nowMs();
+        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };
+    return { ...base, state: "failed", error: "unknown agent outcome" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
+
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..caa534dd85aaaaf9b40c0ceec0a7647e55cf9cd0
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,68 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { EngineError } from "../types/errors.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: EngineError }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..416d069f5ca4f72bede7dcdc413c317ec855b7b0
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,96 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..c440fc2b6ce478d6ae0d8ec8b7d8891d569af756
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultForEvent } from "./eventsAgentCompat.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: unknown }
+  | { type: "agent/progress"; agentId: string; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: string; result: AgentRunResultForEvent }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";


[35m[3mthinking[0m[0m
**Reviewing agent types**

I‚Äôm realizing that the types file in `types/agents.ts` doesn‚Äôt define `AgentRunResult`; it's actually in `core/agents/types.ts`. So, I need to add a new type called `AgentRunResultV1` in `core/types/agents.ts` independently. Once I have that in place, I‚Äôll patch everything accordingly at the end. For now, I‚Äôll just open the part of `types/agents.ts` we created and take a quick look.
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ee36cd224f978d5d628eeb9e9c03a33e48c34ea
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,227 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res) => {
+        const now2 = this.clock.nowMs();
+        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };
+    return { ...base, state: "failed", error: "unknown agent outcome" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
+
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..caa534dd85aaaaf9b40c0ceec0a7647e55cf9cd0
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,68 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { EngineError } from "../types/errors.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: EngineError }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..416d069f5ca4f72bede7dcdc413c317ec855b7b0
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,96 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..c440fc2b6ce478d6ae0d8ec8b7d8891d569af756
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultForEvent } from "./eventsAgentCompat.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: unknown }
+  | { type: "agent/progress"; agentId: string; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: string; result: AgentRunResultForEvent }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'tail -n 80 src/core/types/agents.ts'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 44ms:[0m
[2m  | "failed"
  | "cancelled";

export type AgentBudgetV1 = {
  timeoutMs?: number;
  maxTurns?: number;
  maxConcurrent?: number;
  priority?: TaskPriority;
};

export type AgentPersistencePolicyV1 =
  | { kind: "none" }
  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };

export type AgentProgressV1 = {
  tsMonoMs: number;
  message?: string;
  percent?: number;
  details?: unknown;[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ee36cd224f978d5d628eeb9e9c03a33e48c34ea
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,227 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res) => {
+        const now2 = this.clock.nowMs();
+        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };
+    return { ...base, state: "failed", error: "unknown agent outcome" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
+
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..caa534dd85aaaaf9b40c0ceec0a7647e55cf9cd0
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,68 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { EngineError } from "../types/errors.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: EngineError }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..416d069f5ca4f72bede7dcdc413c317ec855b7b0
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,96 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
+
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..c440fc2b6ce478d6ae0d8ec8b7d8891d569af756
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultForEvent } from "./eventsAgentCompat.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: unknown }
+  | { type: "agent/progress"; agentId: string; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: string; result: AgentRunResultForEvent }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/types/agents.ts[0m
@@ -53,2 +53,7 @@
 
[32m+export type AgentRunResultV1 =[0m
[32m+  | { kind: "completed"; summary?: string }[0m
[32m+  | { kind: "failed"; error: string }[0m
[32m+  | { kind: "cancelled"; reason: CancellationReason };[0m
[32m+[0m
 export type DurableTaskCheckpointV1 = {
@@ -95,2 +100 @@
 };
[31m-[0m
[32mapply_patch(auto_approved=true) exited 0 in 77ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/types/agents.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ee36cd224f978d5d628eeb9e9c03a33e48c34ea
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,227 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res) => {
+        const now2 = this.clock.nowMs();
+        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };
+    return { ...base, state: "failed", error: "unknown agent outcome" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
+
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..caa534dd85aaaaf9b40c0ceec0a7647e55cf9cd0
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,68 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { EngineError } from "../types/errors.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: EngineError }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..c440fc2b6ce478d6ae0d8ec8b7d8891d569af756
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultForEvent } from "./eventsAgentCompat.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: unknown }
+  | { type: "agent/progress"; agentId: string; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: string; result: AgentRunResultForEvent }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";

[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ee36cd224f978d5d628eeb9e9c03a33e48c34ea
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,227 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res) => {
+        const now2 = this.clock.nowMs();
+        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };
+    return { ...base, state: "failed", error: "unknown agent outcome" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
+
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..caa534dd85aaaaf9b40c0ceec0a7647e55cf9cd0
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,68 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { EngineError } from "../types/errors.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: EngineError }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..c440fc2b6ce478d6ae0d8ec8b7d8891d569af756
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultForEvent } from "./eventsAgentCompat.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: unknown }
+  | { type: "agent/progress"; agentId: string; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: string; result: AgentRunResultForEvent }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,140p' src/core/types/events.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 34ms:[0m
[2mimport type { EngineError } from "./errors.js";
import type { VersionedEnvelopeBase } from "./schema.js";
import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
import type { StateSnapshotV1 } from "./state.js";
import type { AgentId, AgentProgressV1, AgentRunResultForEvent } from "./eventsAgentCompat.js";

export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
export type EngineEventSeverity = "debug" | "info" | "warn" | "error";

export type EngineEventSensitivity = "public" | "internal" | "pii" | "secret";

export type EngineEventCorrelationIds = {
  taskId?: TaskId;
  toolRunId?: string;
  hookRunId?: string;
  mcpRequestId?: string;
};

export type EngineEventCursor = {
  channel: EngineEventChannel;[0m

[35m[3mthinking[0m[0m
**Patching imports and types**

I need to remove the `eventsAgentCompat` import and switch to using agent types instead. I'll replace the import line with `import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";`  

For the union, I see that `agent/updated` should utilize `AgentSummaryV1`, and `agentId` should use `AgentId`. However, for the event envelope JSON, it might be better to stick with a string for the ID but still keep it type-safe by using `AgentId` for the `agentId` fields. Let‚Äôs patch that up!
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ee36cd224f978d5d628eeb9e9c03a33e48c34ea
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,227 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res) => {
+        const now2 = this.clock.nowMs();
+        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };
+    return { ...base, state: "failed", error: "unknown agent outcome" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
+
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..caa534dd85aaaaf9b40c0ceec0a7647e55cf9cd0
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,68 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { EngineError } from "../types/errors.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: EngineError }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..c440fc2b6ce478d6ae0d8ec8b7d8891d569af756
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultForEvent } from "./eventsAgentCompat.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: unknown }
+  | { type: "agent/progress"; agentId: string; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: string; result: AgentRunResultForEvent }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/types/events.ts[0m
@@ -4,3 +4,3 @@
 import type { StateSnapshotV1 } from "./state.js";
[31m-import type { AgentId, AgentProgressV1, AgentRunResultForEvent } from "./eventsAgentCompat.js";[0m
[32m+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";[0m
 
@@ -35,5 +35,5 @@
   | { type: "ui/prompt"; promptId: string; message: string }
[31m-  | { type: "agent/updated"; agent: unknown }[0m
[31m-  | { type: "agent/progress"; agentId: string; progress: AgentProgressV1 }[0m
[31m-  | { type: "agent/result"; agentId: string; result: AgentRunResultForEvent }[0m
[32m+  | { type: "agent/updated"; agent: AgentSummaryV1 }[0m
[32m+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }[0m
[32m+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }[0m
   | {
[32mapply_patch(auto_approved=true) exited 0 in 81ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/types/events.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ee36cd224f978d5d628eeb9e9c03a33e48c34ea
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,227 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res) => {
+        const now2 = this.clock.nowMs();
+        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };
+    return { ...base, state: "failed", error: "unknown agent outcome" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
+
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..caa534dd85aaaaf9b40c0ceec0a7647e55cf9cd0
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,68 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { EngineError } from "../types/errors.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: EngineError }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";

[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ee36cd224f978d5d628eeb9e9c03a33e48c34ea
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,227 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res) => {
+        const now2 = this.clock.nowMs();
+        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };
+    return { ...base, state: "failed", error: "unknown agent outcome" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
+
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..caa534dd85aaaaf9b40c0ceec0a7647e55cf9cd0
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,68 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+import type { EngineError } from "../types/errors.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: EngineError }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/types.ts[0m
@@ -2,6 +2,14 @@
 import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
[31m-import type { AgentBudgetV1, AgentId, AgentKindV1, AgentLifecycleStateV1, AgentPersistencePolicyV1, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";[0m
[32m+import type {[0m
[32m+  AgentBudgetV1,[0m
[32m+  AgentId,[0m
[32m+  AgentKindV1,[0m
[32m+  AgentLifecycleStateV1,[0m
[32m+  AgentPersistencePolicyV1,[0m
[32m+  AgentProgressV1,[0m
[32m+  AgentRunResultV1,[0m
[32m+  AgentSummaryV1[0m
[32m+} from "../types/agents.js";[0m
 import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
 import type { CancellationReason } from "../types/runtime.js";
[31m-import type { EngineError } from "../types/errors.js";[0m
 
@@ -23,6 +31,3 @@
 
[31m-export type AgentRunResult =[0m
[31m-  | { kind: "completed"; summary?: string }[0m
[31m-  | { kind: "failed"; error: EngineError }[0m
[31m-  | { kind: "cancelled"; reason: CancellationReason };[0m
[32m+export type AgentRunResult = AgentRunResultV1;[0m
 
[32mapply_patch(auto_approved=true) exited 0 in 84ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/agents/types.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ee36cd224f978d5d628eeb9e9c03a33e48c34ea
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,227 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res) => {
+        const now2 = this.clock.nowMs();
+        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };
+    return { ...base, state: "failed", error: "unknown agent outcome" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
+
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";

[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ee36cd224f978d5d628eeb9e9c03a33e48c34ea
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,227 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res) => {
+        const now2 = this.clock.nowMs();
+        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };
+    return { ...base, state: "failed", error: "unknown agent outcome" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
+
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/manager.ts[0m
@@ -7,4 +7,5 @@
 import type { HostEvent } from "../types/events.js";
[31m-import type { AgentId, AgentProgressV1, AgentSummaryV1 } from "../types/agents.js";[0m
[32m+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";[0m
 import { asAgentId } from "../types/agents.js";
[32m+import type { CancellationReason, TaskResult } from "../types/runtime.js";[0m
 import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
@@ -168,5 +169,13 @@
     void taskHandle.done.then(
[31m-      async (res) => {[0m
[32m+      async (res: TaskResult) => {[0m
         const now2 = this.clock.nowMs();
[31m-        const final = this.finalizeFromResult(inst, res.kind === "success" ? (res.value as AgentRunResult) : { kind: res.kind, ...(res as any) });[0m
[32m+        const agentResult: AgentRunResult =[0m
[32m+          res.kind === "success"[0m
[32m+            ? (res.value as AgentRunResult)[0m
[32m+            : res.kind === "cancelled" || res.kind === "timeout"[0m
[32m+              ? { kind: "cancelled", reason: res.reason }[0m
[32m+              : res.kind === "error"[0m
[32m+                ? { kind: "failed", error: res.error.message }[0m
[32m+                : { kind: "failed", error: "unknown task outcome" };[0m
[32m+        const final = this.finalizeFromResult(inst, agentResult);[0m
         inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
@@ -184,3 +193,3 @@
 
[31m-  async cancelAgent(id: AgentId, reason: import("../types/runtime.js").CancellationReason): Promise<void> {[0m
[32m+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {[0m
     const inst = this.agents.get(id);
@@ -208,3 +217,3 @@
 
[31m-  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult | { kind: string; [k: string]: any }): AgentSummaryV1 {[0m
[32m+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {[0m
     const base = inst.summary;
@@ -212,4 +221,4 @@
     if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
[31m-    if (result.kind === "failed") return { ...base, state: "failed", error: result.error.message };[0m
[31m-    return { ...base, state: "failed", error: "unknown agent outcome" };[0m
[32m+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };[0m
[32m+    return { ...base, state: "failed", error: "unknown agent result" };[0m
   }
@@ -226,2 +235 @@
 }
[31m-[0m
[32mapply_patch(auto_approved=true) exited 0 in 127ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/agents/manager.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";

[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/types/runtime.ts[0m
@@ -45,2 +45,3 @@
   | "mcp_connection"
[32m+  | "agent"[0m
   | "custom";
[32mapply_patch(auto_approved=true) exited 0 in 87ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/types/runtime.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {


[35m[3mthinking[0m[0m
**Implementing worker abstraction**

I‚Äôm considering whether I need to update any tests that expect a list, but maybe none are necessary. Now, I'm moving on to implement worker abstraction in the runtime. So, for Phase 11.5, I‚Äôll create a new file called `src/core/runtime/worker.ts`, focusing on a simple in-memory worker. I also need to update the `runtime/index.ts` to include this new export. I just need to patch everything together next!
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/runtime/index.ts[0m
@@ -13 +13,2 @@
 export * from "./seededRandom.js";
[32m+export * from "./worker.js";[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/runtime/worker.ts[0m
[32mimport type { CancellationReason } from "../types/runtime.js";[0m
[32mimport type { Capability, HostCapabilities } from "../types/host.js";[0m
[32mimport { unavailableCapability } from "../types/host.js";[0m
[32mimport { createCapabilityView } from "../capabilities/view.js";[0m
[32m[0m
[32mexport type JsonSerializable =[0m
[32m  | null[0m
[32m  | boolean[0m
[32m  | number[0m
[32m  | string[0m
[32m  | JsonSerializable[][0m
[32m  | { [k: string]: JsonSerializable };[0m
[32m[0m
[32mexport type WorkerRequest = {[0m
[32m  id: string;[0m
[32m  type: string;[0m
[32m  payload: JsonSerializable;[0m
[32m};[0m
[32m[0m
[32mexport type WorkerResponse =[0m
[32m  | { id: string; ok: true; payload: JsonSerializable }[0m
[32m  | { id: string; ok: false; error: string };[0m
[32m[0m
[32mexport type WorkerPort = {[0m
[32m  post: (msg: WorkerRequest) => Promise<void>;[0m
[32m  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;[0m
[32m  close?: () => Promise<void>;[0m
[32m};[0m
[32m[0m
[32mexport type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;[0m
[32m[0m
[32mexport function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {[0m
[32m  try {[0m
[32m    JSON.stringify(value);[0m
[32m  } catch (e) {[0m
[32m    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);[0m
[32m  }[0m
[32m}[0m
[32m[0m
[32mexport function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {[0m
[32m  const mainHandlers = new Set<(msg: WorkerResponse) => void>();[0m
[32m  const workerHandlers = new Set<(msg: WorkerResponse) => void>();[0m
[32m[0m
[32m  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {[0m
[32m    for (const h of handlers) h(msg);[0m
[32m  };[0m
[32m[0m
[32m  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {[0m
[32m    const isMain = direction === "main_to_worker";[0m
[32m    return {[0m
[32m      post: async (req) => {[0m
[32m        assertJsonSerializable(req.payload);[0m
[32m        if (isMain) {[0m
[32m          const res = await handler(req, {});[0m
[32m          await deliver(mainHandlers, res);[0m
[32m        } else {[0m
[32m          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });[0m
[32m        }[0m
[32m      },[0m
[32m      onMessage: (cb) => {[0m
[32m        const set = isMain ? mainHandlers : workerHandlers;[0m
[32m        set.add(cb);[0m
[32m        return () => set.delete(cb);[0m
[32m      }[0m
[32m    };[0m
[32m  };[0m
[32m[0m
[32m  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };[0m
[32m}[0m
[32m[0m
[32mexport async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {[0m
[32m  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");[0m
[32m  const controller = new AbortController();[0m
[32m  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });[0m
[32m[0m
[32m  return await new Promise<WorkerResponse>((resolve, reject) => {[0m
[32m    const timeout = options.timeoutMs[0m
[32m      ? setTimeout(() => {[0m
[32m          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);[0m
[32m        }, options.timeoutMs)[0m
[32m      : null;[0m
[32m[0m
[32m    const unsub = port.onMessage((msg) => {[0m
[32m      if (msg.id !== request.id) return;[0m
[32m      if (timeout) clearTimeout(timeout);[0m
[32m      unsub();[0m
[32m      resolve(msg);[0m
[32m    });[0m
[32m[0m
[32m    const onAbort = () => {[0m
[32m      if (timeout) clearTimeout(timeout);[0m
[32m      unsub();[0m
[32m      reject(controller.signal.reason ?? new Error("aborted"));[0m
[32m    };[0m
[32m    controller.signal.addEventListener("abort", onAbort, { once: true });[0m
[32m[0m
[32m    port[0m
[32m      .post(request)[0m
[32m      .catch((err) => {[0m
[32m        if (timeout) clearTimeout(timeout);[0m
[32m        unsub();[0m
[32m        reject(err);[0m
[32m      })[0m
[32m      .finally(() => {[0m
[32m        controller.signal.removeEventListener("abort", onAbort);[0m
[32m      });[0m
[32m  });[0m
[32m}[0m
[32m[0m
[32mexport function filterHostCapabilitiesForWorker([0m
[32m  host: HostCapabilities,[0m
[32m  allowed: readonly (keyof HostCapabilities)[],[0m
[32m  options?: { policyId?: string }[0m
[32m): HostCapabilities {[0m
[32m  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });[0m
[32m  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {[0m
[32m    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),[0m
[32m    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })[0m
[32m  };[0m
[32m  return { ...filtered, ...deny } as HostCapabilities;[0m
[32m}[0m
[32m[0m
[32mapply_patch(auto_approved=true) exited 0 in 107ms:[0m
[2mSuccess. Updated the following files:[0m
[2mA src/core/runtime/worker.ts[0m
[2mM src/core/runtime/index.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {

[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/types/state.ts[0m
@@ -3,2 +3,3 @@
 import type { CancellationReason } from "./runtime.js";
[32m+import type { LongRunningTaskEntityV1 } from "./agents.js";[0m
 
@@ -176,2 +177,3 @@
   sessions: Record<string, PersistedSessionStateV1>;
[32m+  tasks?: Record<string, LongRunningTaskEntityV1>;[0m
 };
[32mapply_patch(auto_approved=true) exited 0 in 134ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/types/state.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {


[35m[3mthinking[0m[0m
**Updating app state**

I'm focusing on making tasks optional for backward compatibility. To normalize everything, I‚Äôll update the `state.ts` to create an empty persisted app state that includes tasks as an empty object. Then, in `recoverPersistedAppState`, it's important to keep tasks intact and ensure they exist. I plan to patch everything accordingly so that it functions smoothly. I'll make sure all these updates align correctly.
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/state/state.ts[0m
@@ -166,3 +166,4 @@
     updatedAtMonoMs: now,
[31m-    sessions: {}[0m
[32m+    sessions: {},[0m
[32m+    tasks: {}[0m
   };
@@ -221,3 +222,6 @@
 
[31m-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };[0m
[32m+  return {[0m
[32m+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },[0m
[32m+    report[0m
[32m+  };[0m
 }
[32mapply_patch(auto_approved=true) exited 0 in 136ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/state/state.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..6a161ab75753148c9308548baa0441201f4dc2a7
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -164,7 +164,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +220,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {

[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..6a161ab75753148c9308548baa0441201f4dc2a7
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -164,7 +164,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +220,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/state/state.ts[0m
@@ -7,2 +7,3 @@
   type HookRunEntityV1,
[32m+  type LongRunningTaskEntityV1,[0m
   type McpConnectionEntityV1,
@@ -101,2 +102,4 @@
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
[32m+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }[0m
[32m+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }[0m
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
@@ -297,2 +300,14 @@
     }
[32m+    case "app/task/upsert": {[0m
[32m+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };[0m
[32m+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };[0m
[32m+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };[0m
[32m+    }[0m
[32m+    case "app/task/remove": {[0m
[32m+      const existing = state.persisted.tasks ?? {};[0m
[32m+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };[0m
[32m+      const { [action.taskId]: _removed, ...rest } = existing;[0m
[32m+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };[0m
[32m+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };[0m
[32m+    }[0m
     case "session/transcript/append-event": {
[32mapply_patch(auto_approved=true) exited 0 in 122ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/state/state.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..5361ddc51462434df23744cb5d972365fc16c48e
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -5,6 +5,7 @@
   asSessionId,
   type AttachmentRefV1,
   type HookRunEntityV1,
+  type LongRunningTaskEntityV1,
   type McpConnectionEntityV1,
   type PersistedAppStateV1,
   type PersistedSessionStateV1,
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {

[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..5361ddc51462434df23744cb5d972365fc16c48e
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -5,6 +5,7 @@
   asSessionId,
   type AttachmentRefV1,
   type HookRunEntityV1,
+  type LongRunningTaskEntityV1,
   type McpConnectionEntityV1,
   type PersistedAppStateV1,
   type PersistedSessionStateV1,
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/state/state.ts[0m
@@ -7,3 +7,2 @@
   type HookRunEntityV1,
[31m-  type LongRunningTaskEntityV1,[0m
   type McpConnectionEntityV1,
@@ -18,2 +17,3 @@
 } from "../types/state.js";
[32m+import type { LongRunningTaskEntityV1 } from "../types/agents.js";[0m
 import { SCHEMA_VERSION } from "../types/schema.js";
[32mapply_patch(auto_approved=true) exited 0 in 164ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/state/state.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {


[35m[3mthinking[0m[0m
**Checking module boundaries**

I‚Äôm looking at the module tree, and it seems like core/agents is part of core and can rely on runtime, events, and state. That might be acceptable. But I want to keep boundaries clear, so I‚Äôll check the import boundary script. It probably permits core to import core, but I‚Äôm wondering if there are specific boundary rules. I think I‚Äôll need to quickly review the scripts/check-import-boundaries.mjs to clarify.
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,260p' scripts/check-import-boundaries.mjs"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 40ms:[0m
[2mimport { readdir, readFile } from "node:fs/promises";
import path from "node:path";

const repoRoot = process.cwd();
const srcRoot = path.join(repoRoot, "src");
const coreRoot = path.join(srcRoot, "core");
const platformRoot = path.join(srcRoot, "platform");
const uiRoot = path.join(srcRoot, "ui");

const nodeBuiltins = new Set([
  "assert",
  "buffer",
  "child_process",
  "cluster",
  "crypto",
  "dgram",
  "dns",
  "events",
  "fs",
  "http",[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,220p' src/core/runtime/clock.ts && sed -n '1,220p' src/core/runtime/ids.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 36ms:[0m
[2mexport type MonotonicClock = {
  nowMs: () => number;
};

export type WallClock = {
  nowMs: () => number;
};

export function systemMonotonicClock(): MonotonicClock {
  const hasPerformance = typeof globalThis.performance !== "undefined" && typeof globalThis.performance.now === "function";
  const baseWall = Date.now();
  const baseMono = hasPerformance ? globalThis.performance.now() : 0;
  return {
    nowMs() {
      if (!hasPerformance) return Date.now();
      return Math.round(baseWall + (globalThis.performance.now() - baseMono));
    }
  };
}
[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "rg -n \"create.*HostCapabilities\\(|unavailableCapability\\(\" tests | head -n 40"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 54ms:[0m
[2mtests/phase3-determinism.test.ts:42:    const host = createNodeHostCapabilities({ configDir });
tests/phase3-determinism.test.ts:70:      const host = createNodeHostCapabilities({ configDir });
tests/phase4-capabilities.test.ts:22:      clock: unavailableCapability({ kind: "not-provided" }),
tests/phase4-capabilities.test.ts:23:      random: unavailableCapability({ kind: "disabled" }),
tests/phase4-capabilities.test.ts:24:      crypto: unavailableCapability({ kind: "unsupported" }),
tests/phase4-capabilities.test.ts:25:      secrets: unavailableCapability({ kind: "not-provided" }),
tests/phase4-capabilities.test.ts:26:      storage: unavailableCapability({ kind: "not-provided" }),
tests/phase4-capabilities.test.ts:27:      filesystem: unavailableCapability({ kind: "not-provided" }),
tests/phase4-capabilities.test.ts:28:      network: unavailableCapability({ kind: "not-provided" }),
tests/phase4-capabilities.test.ts:29:      lifecycle: unavailableCapability({ kind: "not-provided" }),
tests/phase4-capabilities.test.ts:30:      background: unavailableCapability({ kind: "not-provided" }),
tests/phase4-capabilities.test.ts:31:      fileTransfer: unavailableCapability({ kind: "not-provided" }),
tests/phase4-capabilities.test.ts:32:      shell: unavailableCapability({ kind: "not-provided" }),
tests/phase4-capabilities.test.ts:33:      localEndpoint: unavailableCapability({ kind: "not-provided" }),
tests/phase4-capabilities.test.ts:34:      ipc: unavailableCapability({ kind: "not-provided" }),
tests/phase4-capabilities.test.ts:35:      process: unavailableCapability({ kind: "not-provided" }),
tests/phase4-capabilities.test.ts:36:      clipboard: unavailableCapability({ kind: "not-provided" }),
tests/phase4-capabilities.test.ts:37:      notifications: unavailableCapability({ kind: "not-provided" }),
tests/phase4-capabilities.test.ts:38:      haptics: unavailableCapability({ kind: "not-provided" })
tests/phase4-capabilities.test.ts:43:    const host2 = { ...host, network: unavailableCapability({ kind: "policy-denied", message: "no", policyId: "p1" }) };[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1,120p' tests/phase4-capabilities.test.ts"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 35ms:[0m
[2mimport { describe, expect, test } from "bun:test";
import os from "node:os";
import path from "node:path";
import { mkdtemp, rm } from "node:fs/promises";
import {
  CapabilityPolicyDeniedError,
  CapabilityUnavailableError,
  availableCapability,
  requireCapability,
  unavailableCapability
} from "../src/core/types/host.js";
import { normalizePortablePath } from "../src/core/filesystem/path.js";
import { computeBackoffDelayMs, retryWithBackoff } from "../src/core/network/retry.js";
import { allowAllCapabilitiesPolicy } from "../src/core/capabilities/policy.js";
import { createCapabilityView } from "../src/core/capabilities/view.js";
import { buildCapabilityComplianceReport } from "../src/core/capabilities/compliance.js";
import { createNodeHostCapabilities } from "../src/platform/node/host.js";

describe("Phase 4: host capabilities", () => {
  test("requireCapability throws typed errors", () => {[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {

[3m[35mfile update[0m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/tests/phase11-agents.test.ts[0m
[32mimport { describe, expect, test } from "bun:test";[0m
[32mimport { availableCapability, unavailableCapability } from "../src/core/types/host.js";[0m
[32mimport { TestClock } from "../src/core/runtime/clock.js";[0m
[32mimport { createMonotonicIdSource } from "../src/core/runtime/ids.js";[0m
[32mimport { RuntimeKernel } from "../src/core/runtime/kernel.js";[0m
[32mimport { EventBus } from "../src/core/events/bus.js";[0m
[32mimport { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";[0m
[32mimport type { AgentDefinition } from "../src/core/agents/types.js";[0m
[32mimport { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";[0m
[32mimport { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";[0m
[32mimport { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";[0m
[32mimport { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";[0m
[32m[0m
[32mdescribe("Phase 11: background agents + long-running tasks", () => {[0m
[32m  test("prompt suggestion suppression heuristics are stable", () => {[0m
[32m    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });[0m
[32m    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });[0m
[32m    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });[0m
[32m    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });[0m
[32m    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });[0m
[32m  });[0m
[32m[0m
[32m  test("magic docs parsing and template rendering match legacy behavior", () => {[0m
[32m    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;[0m
[32m    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });[0m
[32m[0m
[32m    const contents2 = `# magic doc: Title Only\n\nrest`;[0m
[32m    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });[0m
[32m[0m
[32m    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");[0m
[32m  });[0m
[32m[0m
[32m  test("agent manager cancels background agents on host backgrounded", async () => {[0m
[32m    const clock = new TestClock(0);[0m
[32m    const idSource = createMonotonicIdSource();[0m
[32m[0m
[32m    const host = {[0m
[32m      clock: availableCapability({ nowMs: () => clock.nowMs() }),[0m
[32m      random: unavailableCapability({ kind: "not-provided" }),[0m
[32m      crypto: unavailableCapability({ kind: "not-provided" }),[0m
[32m      secrets: unavailableCapability({ kind: "not-provided" }),[0m
[32m      storage: unavailableCapability({ kind: "not-provided" }),[0m
[32m      filesystem: unavailableCapability({ kind: "not-provided" }),[0m
[32m      network: unavailableCapability({ kind: "not-provided" }),[0m
[32m      lifecycle: unavailableCapability({ kind: "not-provided" }),[0m
[32m      background: unavailableCapability({ kind: "not-provided" }),[0m
[32m      fileTransfer: unavailableCapability({ kind: "not-provided" }),[0m
[32m      shell: unavailableCapability({ kind: "not-provided" }),[0m
[32m      localEndpoint: unavailableCapability({ kind: "not-provided" }),[0m
[32m      ipc: unavailableCapability({ kind: "not-provided" }),[0m
[32m      process: unavailableCapability({ kind: "not-provided" }),[0m
[32m      clipboard: unavailableCapability({ kind: "not-provided" }),[0m
[32m      notifications: unavailableCapability({ kind: "not-provided" }),[0m
[32m      haptics: unavailableCapability({ kind: "not-provided" })[0m
[32m    };[0m
[32m[0m
[32m    const runtime = new RuntimeKernel({ clock, idSource });[0m
[32m    const bus = new EventBus({ idSource, clock });[0m
[32m    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });[0m
[32m[0m
[32m    const agentId = createBuiltInAgentId("test_background");[0m
[32m    const def: AgentDefinition = {[0m
[32m      id: agentId,[0m
[32m      name: "Test background agent",[0m
[32m      kind: "background",[0m
[32m      budget: { timeoutMs: 1_000, priority: "low" },[0m
[32m      run: async (ctx) => {[0m
[32m        await ctx.task.yield("low");[0m
[32m        return { kind: "completed" };[0m
[32m      }[0m
[32m    };[0m
[32m    mgr.register(def);[0m
[32m[0m
[32m    await mgr.startAgent(agentId);[0m
[32m    await mgr.handleHostEvent({ type: "host/backgrounded" });[0m
[32m    await runtime.getScheduler().runUntilIdle();[0m
[32m[0m
[32m    const summary = mgr.getAgent(agentId);[0m
[32m    expect(summary?.state).toBe("cancelled");[0m
[32m  });[0m
[32m[0m
[32m  test("worker capability filtering never exposes secrets/ipc", () => {[0m
[32m    const host = {[0m
[32m      clock: availableCapability({ nowMs: () => 1 }),[0m
[32m      random: unavailableCapability({ kind: "not-provided" }),[0m
[32m      crypto: unavailableCapability({ kind: "not-provided" }),[0m
[32m      secrets: availableCapability({ getSecret: async () => "x" }),[0m
[32m      storage: unavailableCapability({ kind: "not-provided" }),[0m
[32m      filesystem: unavailableCapability({ kind: "not-provided" }),[0m
[32m      network: unavailableCapability({ kind: "not-provided" }),[0m
[32m      lifecycle: unavailableCapability({ kind: "not-provided" }),[0m
[32m      background: unavailableCapability({ kind: "not-provided" }),[0m
[32m      fileTransfer: unavailableCapability({ kind: "not-provided" }),[0m
[32m      shell: unavailableCapability({ kind: "not-provided" }),[0m
[32m      localEndpoint: unavailableCapability({ kind: "not-provided" }),[0m
[32m      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),[0m
[32m      process: unavailableCapability({ kind: "not-provided" }),[0m
[32m      clipboard: unavailableCapability({ kind: "not-provided" }),[0m
[32m      notifications: unavailableCapability({ kind: "not-provided" }),[0m
[32m      haptics: unavailableCapability({ kind: "not-provided" })[0m
[32m    };[0m
[32m[0m
[32m    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);[0m
[32m    expect(filtered.clock.kind).toBe("available");[0m
[32m    expect(filtered.secrets.kind).toBe("unavailable");[0m
[32m    expect(filtered.ipc.kind).toBe("unavailable");[0m
[32m  });[0m
[32m[0m
[32m  test("durable task document is stable via canonical JSON and decodes", () => {[0m
[32m    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });[0m
[32m    const decoded = decodeDurableTasksDocument(encoded);[0m
[32m    expect(decoded.schemaVersion).toBe(1);[0m
[32m    expect(decoded.tasks.t1?.id).toBe("t1");[0m
[32m  });[0m
[32m});[0m
[32m[0m
[32mapply_patch(auto_approved=true) exited 0 in 116ms:[0m
[2mSuccess. Updated the following files:[0m
[2mA tests/phase11-agents.test.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+


[35m[3mthinking[0m[0m
**Updating package exports**

I‚Äôm considering whether we need to update the package exports, but maybe not. First things first: let's run the type check or the bun test. Following the instructions, I must run the bun test and include the boundary check with the node script after I make the necessary modifications. Oh, and I should update the plan steps accordingly before I run the `bun test`. Alright, let's do this!
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'bun test'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 4.02s:[0m
[2mbun test v1.3.4 (5eb2145b)

tests/phase6-settings.test.ts:
(pass) Phase 6: settings system > enabled sources flag parser matches legacy [1.80ms]
(pass) Phase 6: settings system > enabled file sources always include policy+flag (and preserve legacy order) [0.09ms]
(pass) Phase 6: settings system > patch semantics: delete on undefined + arrays replace [0.64ms]
(pass) Phase 6: settings system > storage-backed settings manager merges enabled sources and suppresses self-triggered watch events [4.12ms]
(pass) Phase 6: settings system > export/import bundle captures per-source settings objects [0.43ms]
(pass) Phase 6: settings system > invalid policy settings fail-closed in EffectiveConfig [0.24ms]
(pass) Phase 6: settings system > remote policy refresh writes to cache (storage) [0.12ms]

tests/phase3-event-bus.test.ts:
(pass) Phase 3: event bus semantics > emits monotonic seq per channel and supports cursors [1.63ms]
(pass) Phase 3: event bus semantics > recording helper captures envelopes and can be stopped [0.23ms]
(pass) Phase 3: event bus semantics > includeSnapshot yields a snapshot envelope before live events [0.14ms]
(pass) Phase 3: event bus semantics > coalescing policy can replace queued events deterministically [0.12ms]

tests/phase4-leak-prevention.test.ts:
(pass) Phase 4: capability leak prevention heuristics > no module-level HostCapabilities singletons in portable src/core [25.23ms]
[0m

[35m[3mthinking[0m[0m
**Considering test requirements**

All tests have passed, which includes the import boundary check in the phase2 test. However, the requirement mentions that I also need to run the same commands from the previous cli.js files. This probably means using `bun test` and related commands, which I've already completed. But to be thorough, I think I should also run `node scripts/check-import-boundaries.mjs` separately, even though it's run in the test, just to ensure everything is satisfied.
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'node scripts/check-import-boundaries.mjs'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 82ms:[0m
[2mImport boundary check passed.[0m



[35m[3mthinking[0m[0m
**Clarifying execution commands**

I need to run certain commands from previous cli.js files, like `claude --dangerously-skip-permissions -p sayhello`, but I'm not sure if they're installed in the repository. The instructions say if the command works, the credentials should be good, but there might be some issues with the code. It's confusing since this phase is about the agents but also requires us to run those old commands. I'll go ahead and execute the specified command for authentication requirements.
[35m[3mthinking[0m[0m
**Exploring command requirements**

The requirement is clear: I must run identical commands from previous cli.js files, which may relate to authentication or keychain access. It's tricky because they mention running commands like `claude --dangerously-skip-permissions -p sayhello`, suggesting that if this works, our credentials are valid even if the code isn‚Äôt. I want to ensure I'm following the guidelines correctly, so I‚Äôll go ahead and execute `claude --dangerously-skip-permissions -p sayhello` to validate everything.
[35m[3mthinking[0m[0m
**Executing the command**

I realize it might take some time to run the command, and I need to check if the CLI is installed on the system. The network is enabled, so I can proceed. If I run this command, it'll confirm that the existing command is functional, and it's safe to do so. I‚Äôll capture the output specifically for the changelog, ensuring that only the changelog sections are reflected and no source code. Let's go ahead and run the command!
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'claude --dangerously-skip-permissions -p sayhello'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 11.03s:[0m
[2mHello! How can I help you today with your software engineering tasks?[0m

[35m[3mthinking[0m[0m
**Implementing Phase 11 updates**

It's working out! I need to note in the changelog that the existing `claude` is functioning, which is a good sign for the credentials. Next, I'll set up an update checklist for Phase 11. I have to change all relevant checkboxes in the plan file to mark them as completed. I must ensure I'm only modifying items in Phase 11, while still being careful about any references to later phases. I‚Äôll reprint the Phase 11 section for clarity before applying the patch.
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "nl -ba implementation/1-initial-rewrite-implementation-checklist.md | sed -n '1290,1455p'"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 46ms:[0m
[2m  1290	  - [x] buffered responses with bounded memory usage
  1291	  - [x] UI messaging that explains reduced fidelity
  1292	  - [x] test fixtures that assert identical behavior across hosts lacking fetch streaming
  1293	
  1294	---
  1295	
  1296	***Phase 11: Background Agents and Long-Running Tasks (Async, Budgeted, Portable)***
  1297	
  1298	Why this phase exists: legacy includes multiple ‚Äúbackground-ish‚Äù agents (Magic Docs, classifier, session memory, prompt suggestion) and long-running operations. The rewrite must run them in the main runtime cooperatively and portably.
  1299	
  1300	Risks mitigated: runaway resource usage, unpredictable concurrency, and mobile lifecycle breakage.
  1301	
  1302	Dependencies: Phase 3 scheduler, Phase 5 state model, Phase 8 tool pipeline.
  1303	
  1304	11.1 Agent/task model (portable, explicit)
  1305	- [ ] Define what qualifies as a ‚Äúbackground agent‚Äù vs a ‚Äúforeground tool run‚Äù.
  1306	- [ ] Define the agent lifecycle (scheduled, running, awaiting input, paused, completed, failed, cancelled).
  1307	- [ ] Define budgeting for agents (max turns, timeouts, token budgets, concurrency).
  1308	- [ ] Define how agents emit progress and results (typed events, not console output).
  1309	- [ ] Define how agent outputs are persisted (summary-only vs full trace) with privacy constraints.[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1346,1390p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 48ms:[0m
[2m  - [ ] memory pressure signals (if host provides)
- [ ] Define which tasks are allowed to run in background on iOS and which must pause/cancel.
- [ ] Define a consistent user experience when tasks pause/resume (notifications, banners, state indicators).
- [ ] Define a ‚Äúbackground-safe‚Äù whitelist of operations (e.g., local bookkeeping, in-memory summarization) vs forbidden operations (network calls) when the host signals background constraints.

11.5 Optional worker-style isolation (without OS processes)
- [ ] Define a worker abstraction that can run tasks in:
  - [ ] Web Workers (web)
  - [ ] dedicated JS runtimes/native modules (mobile/desktop) if available
  - [ ] main thread fallback (portable baseline)
- [ ] Define message-passing contracts and serialization constraints (no functions, transferable payloads where possible).
- [ ] Define worker capability injection rules:
  - [ ] worker gets a strictly filtered capability subset (no direct access to UI, secrets, or unrestricted network)
  - [ ] permission/policy enforcement stays authoritative in the main runtime (worker requests are mediated)
  - [ ] worker cannot mint new permissions or bypass approval queues
- [ ] Define deterministic worker scheduling expectations:
  - [ ] worker tasks still contribute to the same logical budget accounting (time/event budgets)
  - [ ] event ordering between worker-produced events and main-thread events is explicit and testable (sequence number merge rules)
  - [ ] deterministic replay mode can replace the worker with an in-thread simulation adapter
- [ ] Define crash/isolation semantics:[0m


[35m[3mthinking[0m[0m
**Clarifying Phase Implementation**

I'm noticing there's a Phase 11.6 to 11.9 that wasn't fully captured before; it seems like the initial output only included up to Phase 11.5, skipping ahead to Phase 12. The complete file has details for 11.6 to 11.9, which we need to implement, along with items like the supervision tree and teleport plans. Oops, I need to make sure we address all items in Phase 11, including 11.1 to 11.9.
[35m[3mthinking[0m[0m
**Extending Phase Implementation**

I need to ensure we're fully implementing Phase 11, which means including items 11.6 to 11.9. We can't skip to Phase 12 just yet. I'll scroll through the plan to cover the remaining items, especially 11.9. It looks like Phase 12 starts around line 1406, so I should check lines 1390 to 1406 to capture everything in Phase 11. This should help clarify the definitions we need.
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '1390,1410p' implementation/1-initial-rewrite-implementation-checklist.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 48ms:[0m
[2m  - [ ] what state is authoritative (remote transcript vs local cached view)
- [ ] Define CLI parity targets for `--remote` and `--teleport` behaviors:
  - [ ] remote session creation prints a resume link + a ‚Äúresume command‚Äù hint (UI adapter responsibility; engine provides the data)
  - [ ] teleport resume validates workspace requirements (repo identity) before applying remote state locally
  - [ ] interactive ‚Äúresolve teleport errors‚Äù flow (clean repo / stash path) is expressed as deterministic prompts + tool invocations, not shell
- [ ] Define dependencies on git tooling (Phase 8.10):
  - [ ] ‚Äúrepo cleanliness‚Äù detection
  - [ ] optional stash/unstash flows
  - [ ] branch detection for remote session metadata
- [ ] Define ‚ÄúRemoteAgentTask‚Äù parity as a background task type:
  - [ ] surfaced in task registry and attachments/progress artifacts
  - [ ] resumable state model (if required) without relying on subprocess state
- [ ] Add regression fixtures for teleport flows (clean repo, dirty repo requiring stash, wrong workspace) with deterministic expected event sequences.

---

***Phase 12: Host Adapters and UI Integration (CLI, iOS, Web, Desktop)***

Why this phase exists: the engine must be usable via thin adapters across platforms. UI and host code must not leak into core, but must provide required capabilities and render engine events.
[0m

[35m[3mthinking[0m[0m
**Exploring teleport tasks**

I need to check the CLI bundles related to teleport tasks to better understand them. There might be information on teleport in the CLI Encyclopedia, possibly in Chapter 11? However, the plan refers to Phase 11.9. So, I need to look in the CLI Encyclopedia for teleport remote sessions tasks. It seems like there's a clear path to gather the information I need. Let‚Äôs see what I can find!
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "Teleport|--teleport|--remote|remote session|RemoteAgentTask" CLI_ENCYCLOPEDIA.md | head -n 60'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 50ms:[0m
[2m2075:## Chapter 8 ‚Äî Teleport + remote sessions (resume web sessions across machines)
2077:This chapter documents ‚ÄúTeleport‚Äù, which is the CLI‚Äôs mechanism for:
2084:It also documents `--remote <description>`, which creates a new ‚Äúremote session‚Äù (a server-side session record) and prints a link + teleport command for resuming it later.
2086:Important: Teleport/remote sessions require **Claude.ai OAuth** (a ‚ÄúClaude account‚Äù), not API-key-only auth.
2104:| Create remote session wrapper | `hoB(description, signal)` | `ErB(description, signal)` |
2105:| Create remote session (API POST) | `KMA({initialMessage, description, signal})` | `YMA({initialMessage, description, signal})` |
2113:- `--teleport [session]` (hidden option)
2114:- `--remote <description>` (hidden option)
2118:- Teleport block begins around `ClaudeAgentSDKCode/cli.js:1586` (byte offset ~`7462604`)
2119:- Teleport block begins around `ClaudeCodeCode/cli.js:1586` (byte offset ~`7457234`)
2124:### 8.2 CLI flags behavior: `--remote` and `--teleport`
2128:- If `--remote <description>` is provided:
2129:  - it creates a remote session via `hoB/ErB`
2131:    - `Created remote session: <title>`
2133:    - `Resume with: claude --teleport <id>`
2136:- Else if `--teleport` is provided:
2137:  - if `--teleport` is passed with no argument (`true` or empty string):
2139:  - if `--teleport <id>` is provided:
2146:`--remote <description>` calls:
2159:- clean git is *not* required to create the remote session (it only matters when you later teleport into it)[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc "sed -n '2060,2415p' CLI_ENCYCLOPEDIA.md"[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 36ms:[0m
[2m#### 7.7.2 Queue draining: ‚Äúshow next if idle‚Äù

The hook defines an internal ‚Äúdrain‚Äù function (`B` in both snippets):

- If `current !== null`, do nothing.
- Else pick next notification from `queue`:
  - set it to `current`
  - remove it from the queue
  - start a timeout that clears `current` after `timeoutMs ?? 8000`
  - when cleared, call drain again to show the next.

This produces a simple FIFO-like experience, but with priority reordering.

---

## Chapter 8 ‚Äî Teleport + remote sessions (resume web sessions across machines)

This chapter documents ‚ÄúTeleport‚Äù, which is the CLI‚Äôs mechanism for:

- resuming a Claude Code **web session** (hosted at `https://claude.ai/code/<id>`) into a local CLI run[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[35m[3mexec[0m[0m
[1m/bin/zsh -lc 'rg -n "vcs|git" src/core/tools src/core/filesystem src/core/network src/core | head -n 60'[0m in /Users/ronaldeddings/ClaudeCodeTS[32m succeeded in 60ms:[0m
[2msrc/core/permissions/sources.ts:22:    localSettings: { sentence: "project local settings", title: "Project local settings", short: "project, gitignored" },[0m

[35m[3mthinking[0m[0m
**Implementing updates**

I'm currently working on implementing the updates. First, I'll update the plan tool, and it‚Äôs step 2, which is still in progress. I'll keep going with that. The next task is to implement the runtime/supervision module, and I need to export from runtime/index.ts. Once I finish that, I‚Äôll look into patching everything. It's a step-by-step process, but I'm making progress!
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..d90898acf2249301f3cb3423d41c479405c528b2
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,4 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[3m[35mfile update[0m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/runtime/supervision.ts[0m
[32mimport type { RuntimeSnapshot, TaskId, TaskScopeId, TaskScopeSnapshot } from "../types/runtime.js";[0m
[32m[0m
[32mexport type SupervisionNode = {[0m
[32m  scope: TaskScopeSnapshot;[0m
[32m  children: SupervisionNode[];[0m
[32m};[0m
[32m[0m
[32mexport function buildSupervisionForest(snapshot: RuntimeSnapshot): SupervisionNode[] {[0m
[32m  const scopesById = new Map<TaskScopeId, TaskScopeSnapshot>();[0m
[32m  for (const s of snapshot.scopes) scopesById.set(s.id, s);[0m
[32m[0m
[32m  const childrenByParent = new Map<TaskScopeId, TaskScopeSnapshot[]>();[0m
[32m  const roots: TaskScopeSnapshot[] = [];[0m
[32m[0m
[32m  for (const scope of snapshot.scopes) {[0m
[32m    const parent = scope.parentScopeId;[0m
[32m    if (!parent) {[0m
[32m      roots.push(scope);[0m
[32m      continue;[0m
[32m    }[0m
[32m    const list = childrenByParent.get(parent) ?? [];[0m
[32m    list.push(scope);[0m
[32m    childrenByParent.set(parent, list);[0m
[32m  }[0m
[32m[0m
[32m  for (const list of childrenByParent.values()) list.sort((a, b) => a.id.localeCompare(b.id));[0m
[32m  roots.sort((a, b) => a.id.localeCompare(b.id));[0m
[32m[0m
[32m  const visit = (scope: TaskScopeSnapshot): SupervisionNode => {[0m
[32m    const kids = childrenByParent.get(scope.id) ?? [];[0m
[32m    return { scope, children: kids.map(visit) };[0m
[32m  };[0m
[32m[0m
[32m  void scopesById;[0m
[32m  return roots.map(visit);[0m
[32m}[0m
[32m[0m
[32mexport function detectLeakedTasks(snapshot: RuntimeSnapshot, options: { endedScopeIds: readonly TaskScopeId[] }): TaskId[] {[0m
[32m  const ended = new Set<TaskScopeId>(options.endedScopeIds);[0m
[32m  const leaked: TaskId[] = [];[0m
[32m  for (const task of snapshot.tasks) {[0m
[32m    const scopeId = task.scopeId;[0m
[32m    if (!scopeId) continue;[0m
[32m    if (!ended.has(scopeId)) continue;[0m
[32m    if (task.state === "completed") continue;[0m
[32m    leaked.push(task.id);[0m
[32m  }[0m
[32m  leaked.sort((a, b) => a.localeCompare(b));[0m
[32m  return leaked;[0m
[32m}[0m
[32m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/runtime/index.ts[0m
@@ -14 +14,2 @@
 export * from "./worker.js";
[32m+export * from "./supervision.js";[0m
[32mapply_patch(auto_approved=true) exited 0 in 112ms:[0m
[2mSuccess. Updated the following files:[0m
[2mA src/core/runtime/supervision.ts[0m
[2mM src/core/runtime/index.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..7bc74dee431ae197fe22b4060dbb49166e049cd0
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,5 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
+export * from "./supervision.js";
diff --git a/src/core/runtime/supervision.ts b/src/core/runtime/supervision.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2d31c2757d6e689c0e976a2ec9784b37fe45481a
--- /dev/null
+++ b/src/core/runtime/supervision.ts
@@ -0,0 +1,51 @@
+import type { RuntimeSnapshot, TaskId, TaskScopeId, TaskScopeSnapshot } from "../types/runtime.js";
+
+export type SupervisionNode = {
+  scope: TaskScopeSnapshot;
+  children: SupervisionNode[];
+};
+
+export function buildSupervisionForest(snapshot: RuntimeSnapshot): SupervisionNode[] {
+  const scopesById = new Map<TaskScopeId, TaskScopeSnapshot>();
+  for (const s of snapshot.scopes) scopesById.set(s.id, s);
+
+  const childrenByParent = new Map<TaskScopeId, TaskScopeSnapshot[]>();
+  const roots: TaskScopeSnapshot[] = [];
+
+  for (const scope of snapshot.scopes) {
+    const parent = scope.parentScopeId;
+    if (!parent) {
+      roots.push(scope);
+      continue;
+    }
+    const list = childrenByParent.get(parent) ?? [];
+    list.push(scope);
+    childrenByParent.set(parent, list);
+  }
+
+  for (const list of childrenByParent.values()) list.sort((a, b) => a.id.localeCompare(b.id));
+  roots.sort((a, b) => a.id.localeCompare(b.id));
+
+  const visit = (scope: TaskScopeSnapshot): SupervisionNode => {
+    const kids = childrenByParent.get(scope.id) ?? [];
+    return { scope, children: kids.map(visit) };
+  };
+
+  void scopesById;
+  return roots.map(visit);
+}
+
+export function detectLeakedTasks(snapshot: RuntimeSnapshot, options: { endedScopeIds: readonly TaskScopeId[] }): TaskId[] {
+  const ended = new Set<TaskScopeId>(options.endedScopeIds);
+  const leaked: TaskId[] = [];
+  for (const task of snapshot.tasks) {
+    const scopeId = task.scopeId;
+    if (!scopeId) continue;
+    if (!ended.has(scopeId)) continue;
+    if (task.state === "completed") continue;
+    leaked.push(task.id);
+  }
+  leaked.sort((a, b) => a.localeCompare(b));
+  return leaked;
+}
+
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+





[35m[3mthinking[0m[0m
**Planning for regression fixtures**

I'm thinking about how to set up the fixtures directory for the regression tests. I'll create a `tests/fixtures/phase11-teleport/` directory and include three JSON files with arrays of step IDs. I need to keep it clean, including expected steps like `["preflight/auth_required", "preflight/git_clean_required", "fetch_remote_session", "validate_repo_identity", "checkout_branch", "import_log"]`. To ensure we get deterministic outputs, I'll represent this with a `TeleportPlan` and define the necessary actions within it, considering our current tool capabilities.
[35m[3mthinking[0m[0m
**Implementing teleport plan**

To simplify the process, I plan to return a list of `TeleportIssue` along with the next action. I'll implement `planTeleportResume` with inputs like `mode`, `target`, `repoMatch`, `gitClean`, and more. 

I need to define the steps based on conditions: If the user isn't authenticated, create an issue for needing login and a prompt for that. If the git isn't clean and not ignored, create an issue for needing a stash. If there‚Äôs a repo mismatch, create an abort step. 

Additionally, I‚Äôve got to consider the outputs, including `RemoteSessionCreatedInfo`, for handling remote sessions and defining UI-related tasks separately from core logic.
[35m[3mthinking[0m[0m
**Updating task models**

I'm planning to model remote tasks by adding a `kind` property to the `LongRunningTaskEntity`. I‚Äôll update `LongRunningTaskEntityV1` to include a `kind` string union and an optional `nextAction`. 

I need to patch `types/agents.ts` to require the `kind` attribute in `TaskRegistry.create`. The types will include options like `"background_agent"`, `"remote_agent_task"`, and others. 

While including `kind` as required might be an issue for older tasks, making it optional will help maintain compatibility without running into runtime problems. So I‚Äôll keep `kind` optional for now.
[35m[3mthinking[0m[0m
**Simplifying task requirements**

I'm deciding to make `kind` a required field while keeping tasks optional. Currently, our creation functions don't use tasks, and the existing tests for durable tasks don‚Äôt involve this entity either. While the tasks map is empty right now, it could change in the future.

I realize the state reducer expects an entity, and since `TaskRegistry.create` currently lacks the `kind` field, I‚Äôll need to update that function to set a default `kind` value of "custom". I'll patch `types/agents.ts` and `core/agents/tasks.ts` accordingly.
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d415f5ddf5d38e34d04629927347651a53b391a6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
+
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..7bc74dee431ae197fe22b4060dbb49166e049cd0
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,5 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
+export * from "./supervision.js";
diff --git a/src/core/runtime/supervision.ts b/src/core/runtime/supervision.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2d31c2757d6e689c0e976a2ec9784b37fe45481a
--- /dev/null
+++ b/src/core/runtime/supervision.ts
@@ -0,0 +1,51 @@
+import type { RuntimeSnapshot, TaskId, TaskScopeId, TaskScopeSnapshot } from "../types/runtime.js";
+
+export type SupervisionNode = {
+  scope: TaskScopeSnapshot;
+  children: SupervisionNode[];
+};
+
+export function buildSupervisionForest(snapshot: RuntimeSnapshot): SupervisionNode[] {
+  const scopesById = new Map<TaskScopeId, TaskScopeSnapshot>();
+  for (const s of snapshot.scopes) scopesById.set(s.id, s);
+
+  const childrenByParent = new Map<TaskScopeId, TaskScopeSnapshot[]>();
+  const roots: TaskScopeSnapshot[] = [];
+
+  for (const scope of snapshot.scopes) {
+    const parent = scope.parentScopeId;
+    if (!parent) {
+      roots.push(scope);
+      continue;
+    }
+    const list = childrenByParent.get(parent) ?? [];
+    list.push(scope);
+    childrenByParent.set(parent, list);
+  }
+
+  for (const list of childrenByParent.values()) list.sort((a, b) => a.id.localeCompare(b.id));
+  roots.sort((a, b) => a.id.localeCompare(b.id));
+
+  const visit = (scope: TaskScopeSnapshot): SupervisionNode => {
+    const kids = childrenByParent.get(scope.id) ?? [];
+    return { scope, children: kids.map(visit) };
+  };
+
+  void scopesById;
+  return roots.map(visit);
+}
+
+export function detectLeakedTasks(snapshot: RuntimeSnapshot, options: { endedScopeIds: readonly TaskScopeId[] }): TaskId[] {
+  const ended = new Set<TaskScopeId>(options.endedScopeIds);
+  const leaked: TaskId[] = [];
+  for (const task of snapshot.tasks) {
+    const scopeId = task.scopeId;
+    if (!scopeId) continue;
+    if (!ended.has(scopeId)) continue;
+    if (task.state === "completed") continue;
+    leaked.push(task.id);
+  }
+  leaked.sort((a, b) => a.localeCompare(b));
+  return leaked;
+}
+
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..508ab06f47a02560df3b045dbb64d08aafff3391
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,100 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/types/agents.ts[0m
@@ -86,4 +86,7 @@
 
[32m+export type LongRunningTaskKindV1 = "background_agent" | "remote_agent_task" | "local_bash" | "tool_run" | "custom";[0m
[32m+[0m
 export type LongRunningTaskEntityV1 = {
   id: string;
[32m+  kind: LongRunningTaskKindV1;[0m
   label: string;
@@ -96,2 +99,3 @@
   progress?: AgentProgressV1;
[32m+  nextAction?: string;[0m
   error?: string;
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/tasks.ts[0m
@@ -66,2 +66,3 @@
       id,
[32m+      kind: initial?.kind ?? "custom",[0m
       label,
@@ -96,2 +97 @@
 }
[31m-[0m
[32mapply_patch(auto_approved=true) exited 0 in 120ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/types/agents.ts[0m
[2mM src/core/agents/tasks.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0de6a25dd099d64eb9e10df4ea8c630295abbff6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      kind: initial?.kind ?? "custom",
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..7bc74dee431ae197fe22b4060dbb49166e049cd0
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,5 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
+export * from "./supervision.js";
diff --git a/src/core/runtime/supervision.ts b/src/core/runtime/supervision.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2d31c2757d6e689c0e976a2ec9784b37fe45481a
--- /dev/null
+++ b/src/core/runtime/supervision.ts
@@ -0,0 +1,51 @@
+import type { RuntimeSnapshot, TaskId, TaskScopeId, TaskScopeSnapshot } from "../types/runtime.js";
+
+export type SupervisionNode = {
+  scope: TaskScopeSnapshot;
+  children: SupervisionNode[];
+};
+
+export function buildSupervisionForest(snapshot: RuntimeSnapshot): SupervisionNode[] {
+  const scopesById = new Map<TaskScopeId, TaskScopeSnapshot>();
+  for (const s of snapshot.scopes) scopesById.set(s.id, s);
+
+  const childrenByParent = new Map<TaskScopeId, TaskScopeSnapshot[]>();
+  const roots: TaskScopeSnapshot[] = [];
+
+  for (const scope of snapshot.scopes) {
+    const parent = scope.parentScopeId;
+    if (!parent) {
+      roots.push(scope);
+      continue;
+    }
+    const list = childrenByParent.get(parent) ?? [];
+    list.push(scope);
+    childrenByParent.set(parent, list);
+  }
+
+  for (const list of childrenByParent.values()) list.sort((a, b) => a.id.localeCompare(b.id));
+  roots.sort((a, b) => a.id.localeCompare(b.id));
+
+  const visit = (scope: TaskScopeSnapshot): SupervisionNode => {
+    const kids = childrenByParent.get(scope.id) ?? [];
+    return { scope, children: kids.map(visit) };
+  };
+
+  void scopesById;
+  return roots.map(visit);
+}
+
+export function detectLeakedTasks(snapshot: RuntimeSnapshot, options: { endedScopeIds: readonly TaskScopeId[] }): TaskId[] {
+  const ended = new Set<TaskScopeId>(options.endedScopeIds);
+  const leaked: TaskId[] = [];
+  for (const task of snapshot.tasks) {
+    const scopeId = task.scopeId;
+    if (!scopeId) continue;
+    if (!ended.has(scopeId)) continue;
+    if (task.state === "completed") continue;
+    leaked.push(task.id);
+  }
+  leaked.sort((a, b) => a.localeCompare(b));
+  return leaked;
+}
+
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fcf367c1a22ba8038c625399340439ecf6d991a6
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,104 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskKindV1 = "background_agent" | "remote_agent_task" | "local_bash" | "tool_run" | "custom";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  kind: LongRunningTaskKindV1;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  nextAction?: string;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+


[35m[3mthinking[0m[0m
**Patching kernel functions**

It looks like the runtime kernel function `defineLimiter` doesn't provide a list, but it seems safe to use. I plan to call `defineLimiter` within `startAgent` when it's required. Also, I noticed that the summary progress isn‚Äôt updated, so I might need to implement `setAgentProgress`. Hmm, I‚Äôll have to think about that a bit more. For now, it seems like I have to focus on patching things up.
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e24ae2ee8f0b6c64d9fcc618819df693185219f
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,235 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0de6a25dd099d64eb9e10df4ea8c630295abbff6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      kind: initial?.kind ?? "custom",
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..7bc74dee431ae197fe22b4060dbb49166e049cd0
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,5 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
+export * from "./supervision.js";
diff --git a/src/core/runtime/supervision.ts b/src/core/runtime/supervision.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2d31c2757d6e689c0e976a2ec9784b37fe45481a
--- /dev/null
+++ b/src/core/runtime/supervision.ts
@@ -0,0 +1,51 @@
+import type { RuntimeSnapshot, TaskId, TaskScopeId, TaskScopeSnapshot } from "../types/runtime.js";
+
+export type SupervisionNode = {
+  scope: TaskScopeSnapshot;
+  children: SupervisionNode[];
+};
+
+export function buildSupervisionForest(snapshot: RuntimeSnapshot): SupervisionNode[] {
+  const scopesById = new Map<TaskScopeId, TaskScopeSnapshot>();
+  for (const s of snapshot.scopes) scopesById.set(s.id, s);
+
+  const childrenByParent = new Map<TaskScopeId, TaskScopeSnapshot[]>();
+  const roots: TaskScopeSnapshot[] = [];
+
+  for (const scope of snapshot.scopes) {
+    const parent = scope.parentScopeId;
+    if (!parent) {
+      roots.push(scope);
+      continue;
+    }
+    const list = childrenByParent.get(parent) ?? [];
+    list.push(scope);
+    childrenByParent.set(parent, list);
+  }
+
+  for (const list of childrenByParent.values()) list.sort((a, b) => a.id.localeCompare(b.id));
+  roots.sort((a, b) => a.id.localeCompare(b.id));
+
+  const visit = (scope: TaskScopeSnapshot): SupervisionNode => {
+    const kids = childrenByParent.get(scope.id) ?? [];
+    return { scope, children: kids.map(visit) };
+  };
+
+  void scopesById;
+  return roots.map(visit);
+}
+
+export function detectLeakedTasks(snapshot: RuntimeSnapshot, options: { endedScopeIds: readonly TaskScopeId[] }): TaskId[] {
+  const ended = new Set<TaskScopeId>(options.endedScopeIds);
+  const leaked: TaskId[] = [];
+  for (const task of snapshot.tasks) {
+    const scopeId = task.scopeId;
+    if (!scopeId) continue;
+    if (!ended.has(scopeId)) continue;
+    if (task.state === "completed") continue;
+    leaked.push(task.id);
+  }
+  leaked.sort((a, b) => a.localeCompare(b));
+  return leaked;
+}
+
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fcf367c1a22ba8038c625399340439ecf6d991a6
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,104 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskKindV1 = "background_agent" | "remote_agent_task" | "local_bash" | "tool_run" | "custom";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  kind: LongRunningTaskKindV1;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  nextAction?: string;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/manager.ts[0m
@@ -33,2 +33,7 @@
   private lifecycle: LifecycleState = initialLifecycleState();
[32m+  private lastUserInputAtMonoMs: number | null = null;[0m
[32m+[0m
[32m+  private readonly backgroundLimiterName = "agents_background";[0m
[32m+  private readonly backgroundMaxConcurrent: number;[0m
[32m+  private readonly userActiveWindowMs: number;[0m
 
@@ -37,3 +42,10 @@
 
[31m-  constructor(options: { host: HostCapabilities; idSource: IdSource; clock: MonotonicClock; runtime: RuntimeKernel; bus: EventBus }) {[0m
[32m+  constructor(options: {[0m
[32m+    host: HostCapabilities;[0m
[32m+    idSource: IdSource;[0m
[32m+    clock: MonotonicClock;[0m
[32m+    runtime: RuntimeKernel;[0m
[32m+    bus: EventBus;[0m
[32m+    backgroundBudget?: { maxConcurrentBackgroundAgents?: number; userActiveWindowMs?: number };[0m
[32m+  }) {[0m
     this.host = options.host;
@@ -44,2 +56,5 @@
     this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
[32m+    this.backgroundMaxConcurrent = Math.max(1, options.backgroundBudget?.maxConcurrentBackgroundAgents ?? 2);[0m
[32m+    this.userActiveWindowMs = Math.max(0, options.backgroundBudget?.userActiveWindowMs ?? 5_000);[0m
[32m+    this.runtime.defineLimiter(this.backgroundLimiterName, this.backgroundMaxConcurrent);[0m
   }
@@ -79,2 +94,3 @@
     const now = this.clock.nowMs();
[32m+    if (event.type === "host/user-input") this.lastUserInputAtMonoMs = now;[0m
     if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
@@ -113,2 +129,10 @@
     }
[32m+    if (inst.def.kind === "background" && this.lifecycle.memoryPressure === "high") {[0m
[32m+      this.noteWarnOnce(`agent_mem_high:${id}`, `Skipping background agent '${inst.def.name}' due to high memory pressure`);[0m
[32m+      return;[0m
[32m+    }[0m
[32m+    if (inst.def.kind === "background" && this.lastUserInputAtMonoMs !== null && this.clock.nowMs() - this.lastUserInputAtMonoMs <= this.userActiveWindowMs) {[0m
[32m+      this.noteWarnOnce(`agent_overload:${id}`, `Deferring background agent '${inst.def.name}' while user is active`);[0m
[32m+      return;[0m
[32m+    }[0m
 
@@ -129,2 +153,15 @@
       async (task) => {
[32m+        const releases: Array<() => void> = [];[0m
[32m+        try {[0m
[32m+          if (inst.def.kind === "background") {[0m
[32m+            const release = await this.runtime.acquireLimiter(this.backgroundLimiterName, { ownerTaskId: task.taskId, signal: task.signal });[0m
[32m+            releases.push(release);[0m
[32m+          }[0m
[32m+          if (inst.def.budget?.maxConcurrent !== undefined) {[0m
[32m+            const limiter = `agent:${inst.def.id}`;[0m
[32m+            this.runtime.defineLimiter(limiter, Math.max(1, inst.def.budget.maxConcurrent));[0m
[32m+            const release = await this.runtime.acquireLimiter(limiter, { ownerTaskId: task.taskId, signal: task.signal });[0m
[32m+            releases.push(release);[0m
[32m+          }[0m
[32m+[0m
         const emit = async (evt: import("./types.js").AgentEvent) => {
@@ -159,2 +196,5 @@
         return result;
[32m+        } finally {[0m
[32m+          for (const release of releases) release();[0m
[32m+        }[0m
       },
[32mapply_patch(auto_approved=true) exited 0 in 187ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/agents/manager.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8945ddfcc6b42147ca9ddb8329366bd7830ddbf
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,275 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+  private lastUserInputAtMonoMs: number | null = null;
+
+  private readonly backgroundLimiterName = "agents_background";
+  private readonly backgroundMaxConcurrent: number;
+  private readonly userActiveWindowMs: number;
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: {
+    host: HostCapabilities;
+    idSource: IdSource;
+    clock: MonotonicClock;
+    runtime: RuntimeKernel;
+    bus: EventBus;
+    backgroundBudget?: { maxConcurrentBackgroundAgents?: number; userActiveWindowMs?: number };
+  }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+    this.backgroundMaxConcurrent = Math.max(1, options.backgroundBudget?.maxConcurrentBackgroundAgents ?? 2);
+    this.userActiveWindowMs = Math.max(0, options.backgroundBudget?.userActiveWindowMs ?? 5_000);
+    this.runtime.defineLimiter(this.backgroundLimiterName, this.backgroundMaxConcurrent);
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/user-input") this.lastUserInputAtMonoMs = now;
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lifecycle.memoryPressure === "high") {
+      this.noteWarnOnce(`agent_mem_high:${id}`, `Skipping background agent '${inst.def.name}' due to high memory pressure`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lastUserInputAtMonoMs !== null && this.clock.nowMs() - this.lastUserInputAtMonoMs <= this.userActiveWindowMs) {
+      this.noteWarnOnce(`agent_overload:${id}`, `Deferring background agent '${inst.def.name}' while user is active`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const releases: Array<() => void> = [];
+        try {
+          if (inst.def.kind === "background") {
+            const release = await this.runtime.acquireLimiter(this.backgroundLimiterName, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+          if (inst.def.budget?.maxConcurrent !== undefined) {
+            const limiter = `agent:${inst.def.id}`;
+            this.runtime.defineLimiter(limiter, Math.max(1, inst.def.budget.maxConcurrent));
+            const release = await this.runtime.acquireLimiter(limiter, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+        } finally {
+          for (const release of releases) release();
+        }
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0de6a25dd099d64eb9e10df4ea8c630295abbff6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      kind: initial?.kind ?? "custom",
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..7bc74dee431ae197fe22b4060dbb49166e049cd0
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,5 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
+export * from "./supervision.js";
diff --git a/src/core/runtime/supervision.ts b/src/core/runtime/supervision.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2d31c2757d6e689c0e976a2ec9784b37fe45481a
--- /dev/null
+++ b/src/core/runtime/supervision.ts
@@ -0,0 +1,51 @@
+import type { RuntimeSnapshot, TaskId, TaskScopeId, TaskScopeSnapshot } from "../types/runtime.js";
+
+export type SupervisionNode = {
+  scope: TaskScopeSnapshot;
+  children: SupervisionNode[];
+};
+
+export function buildSupervisionForest(snapshot: RuntimeSnapshot): SupervisionNode[] {
+  const scopesById = new Map<TaskScopeId, TaskScopeSnapshot>();
+  for (const s of snapshot.scopes) scopesById.set(s.id, s);
+
+  const childrenByParent = new Map<TaskScopeId, TaskScopeSnapshot[]>();
+  const roots: TaskScopeSnapshot[] = [];
+
+  for (const scope of snapshot.scopes) {
+    const parent = scope.parentScopeId;
+    if (!parent) {
+      roots.push(scope);
+      continue;
+    }
+    const list = childrenByParent.get(parent) ?? [];
+    list.push(scope);
+    childrenByParent.set(parent, list);
+  }
+
+  for (const list of childrenByParent.values()) list.sort((a, b) => a.id.localeCompare(b.id));
+  roots.sort((a, b) => a.id.localeCompare(b.id));
+
+  const visit = (scope: TaskScopeSnapshot): SupervisionNode => {
+    const kids = childrenByParent.get(scope.id) ?? [];
+    return { scope, children: kids.map(visit) };
+  };
+
+  void scopesById;
+  return roots.map(visit);
+}
+
+export function detectLeakedTasks(snapshot: RuntimeSnapshot, options: { endedScopeIds: readonly TaskScopeId[] }): TaskId[] {
+  const ended = new Set<TaskScopeId>(options.endedScopeIds);
+  const leaked: TaskId[] = [];
+  for (const task of snapshot.tasks) {
+    const scopeId = task.scopeId;
+    if (!scopeId) continue;
+    if (!ended.has(scopeId)) continue;
+    if (task.state === "completed") continue;
+    leaked.push(task.id);
+  }
+  leaked.sort((a, b) => a.localeCompare(b));
+  return leaked;
+}
+
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fcf367c1a22ba8038c625399340439ecf6d991a6
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,104 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskKindV1 = "background_agent" | "remote_agent_task" | "local_bash" | "tool_run" | "custom";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  kind: LongRunningTaskKindV1;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  nextAction?: string;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8945ddfcc6b42147ca9ddb8329366bd7830ddbf
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,275 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+  private lastUserInputAtMonoMs: number | null = null;
+
+  private readonly backgroundLimiterName = "agents_background";
+  private readonly backgroundMaxConcurrent: number;
+  private readonly userActiveWindowMs: number;
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: {
+    host: HostCapabilities;
+    idSource: IdSource;
+    clock: MonotonicClock;
+    runtime: RuntimeKernel;
+    bus: EventBus;
+    backgroundBudget?: { maxConcurrentBackgroundAgents?: number; userActiveWindowMs?: number };
+  }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+    this.backgroundMaxConcurrent = Math.max(1, options.backgroundBudget?.maxConcurrentBackgroundAgents ?? 2);
+    this.userActiveWindowMs = Math.max(0, options.backgroundBudget?.userActiveWindowMs ?? 5_000);
+    this.runtime.defineLimiter(this.backgroundLimiterName, this.backgroundMaxConcurrent);
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/user-input") this.lastUserInputAtMonoMs = now;
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lifecycle.memoryPressure === "high") {
+      this.noteWarnOnce(`agent_mem_high:${id}`, `Skipping background agent '${inst.def.name}' due to high memory pressure`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lastUserInputAtMonoMs !== null && this.clock.nowMs() - this.lastUserInputAtMonoMs <= this.userActiveWindowMs) {
+      this.noteWarnOnce(`agent_overload:${id}`, `Deferring background agent '${inst.def.name}' while user is active`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const releases: Array<() => void> = [];
+        try {
+          if (inst.def.kind === "background") {
+            const release = await this.runtime.acquireLimiter(this.backgroundLimiterName, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+          if (inst.def.budget?.maxConcurrent !== undefined) {
+            const limiter = `agent:${inst.def.id}`;
+            this.runtime.defineLimiter(limiter, Math.max(1, inst.def.budget.maxConcurrent));
+            const release = await this.runtime.acquireLimiter(limiter, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+        } finally {
+          for (const release of releases) release();
+        }
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0de6a25dd099d64eb9e10df4ea8c630295abbff6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      kind: initial?.kind ?? "custom",
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..7bc74dee431ae197fe22b4060dbb49166e049cd0
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,5 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
+export * from "./supervision.js";
diff --git a/src/core/runtime/supervision.ts b/src/core/runtime/supervision.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2d31c2757d6e689c0e976a2ec9784b37fe45481a
--- /dev/null
+++ b/src/core/runtime/supervision.ts
@@ -0,0 +1,51 @@
+import type { RuntimeSnapshot, TaskId, TaskScopeId, TaskScopeSnapshot } from "../types/runtime.js";
+
+export type SupervisionNode = {
+  scope: TaskScopeSnapshot;
+  children: SupervisionNode[];
+};
+
+export function buildSupervisionForest(snapshot: RuntimeSnapshot): SupervisionNode[] {
+  const scopesById = new Map<TaskScopeId, TaskScopeSnapshot>();
+  for (const s of snapshot.scopes) scopesById.set(s.id, s);
+
+  const childrenByParent = new Map<TaskScopeId, TaskScopeSnapshot[]>();
+  const roots: TaskScopeSnapshot[] = [];
+
+  for (const scope of snapshot.scopes) {
+    const parent = scope.parentScopeId;
+    if (!parent) {
+      roots.push(scope);
+      continue;
+    }
+    const list = childrenByParent.get(parent) ?? [];
+    list.push(scope);
+    childrenByParent.set(parent, list);
+  }
+
+  for (const list of childrenByParent.values()) list.sort((a, b) => a.id.localeCompare(b.id));
+  roots.sort((a, b) => a.id.localeCompare(b.id));
+
+  const visit = (scope: TaskScopeSnapshot): SupervisionNode => {
+    const kids = childrenByParent.get(scope.id) ?? [];
+    return { scope, children: kids.map(visit) };
+  };
+
+  void scopesById;
+  return roots.map(visit);
+}
+
+export function detectLeakedTasks(snapshot: RuntimeSnapshot, options: { endedScopeIds: readonly TaskScopeId[] }): TaskId[] {
+  const ended = new Set<TaskScopeId>(options.endedScopeIds);
+  const leaked: TaskId[] = [];
+  for (const task of snapshot.tasks) {
+    const scopeId = task.scopeId;
+    if (!scopeId) continue;
+    if (!ended.has(scopeId)) continue;
+    if (task.state === "completed") continue;
+    leaked.push(task.id);
+  }
+  leaked.sort((a, b) => a.localeCompare(b));
+  return leaked;
+}
+
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fcf367c1a22ba8038c625399340439ecf6d991a6
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,104 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskKindV1 = "background_agent" | "remote_agent_task" | "local_bash" | "tool_run" | "custom";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  kind: LongRunningTaskKindV1;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  nextAction?: string;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[3m[35mfile update[0m[0m
[35mA /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/builtins/plans.ts[0m
[32mimport type { HostCapabilities } from "../../types/host.js";[0m
[32m[0m
[32mexport type BuiltInSubsystemTriggerPlan =[0m
[32m  | { kind: "time"; intervalMs: number; note?: string }[0m
[32m  | { kind: "event"; event: string; note?: string };[0m
[32m[0m
[32mexport type BuiltInSubsystemCapabilityPlan = {[0m
[32m  key: keyof HostCapabilities;[0m
[32m  optional?: boolean;[0m
[32m  note?: string;[0m
[32m};[0m
[32m[0m
[32mexport type BuiltInSubsystemPlan = {[0m
[32m  id: string;[0m
[32m  name: string;[0m
[32m  featureGates: string[];[0m
[32m  configKnobs: string[];[0m
[32m  triggers: BuiltInSubsystemTriggerPlan[];[0m
[32m  requiredCapabilities: BuiltInSubsystemCapabilityPlan[];[0m
[32m  mobileSafeFallback: string;[0m
[32m  privacyNotes: string[];[0m
[32m};[0m
[32m[0m
[32mapply_patch(auto_approved=true) exited 0 in 303ms:[0m
[2mSuccess. Updated the following files:[0m
[2mA src/core/agents/builtins/plans.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/plans.ts b/src/core/agents/builtins/plans.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0c99b1e6e5833f600c7822749e0d240578640fbe
--- /dev/null
+++ b/src/core/agents/builtins/plans.ts
@@ -0,0 +1,23 @@
+import type { HostCapabilities } from "../../types/host.js";
+
+export type BuiltInSubsystemTriggerPlan =
+  | { kind: "time"; intervalMs: number; note?: string }
+  | { kind: "event"; event: string; note?: string };
+
+export type BuiltInSubsystemCapabilityPlan = {
+  key: keyof HostCapabilities;
+  optional?: boolean;
+  note?: string;
+};
+
+export type BuiltInSubsystemPlan = {
+  id: string;
+  name: string;
+  featureGates: string[];
+  configKnobs: string[];
+  triggers: BuiltInSubsystemTriggerPlan[];
+  requiredCapabilities: BuiltInSubsystemCapabilityPlan[];
+  mobileSafeFallback: string;
+  privacyNotes: string[];
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8945ddfcc6b42147ca9ddb8329366bd7830ddbf
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,275 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+  private lastUserInputAtMonoMs: number | null = null;
+
+  private readonly backgroundLimiterName = "agents_background";
+  private readonly backgroundMaxConcurrent: number;
+  private readonly userActiveWindowMs: number;
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: {
+    host: HostCapabilities;
+    idSource: IdSource;
+    clock: MonotonicClock;
+    runtime: RuntimeKernel;
+    bus: EventBus;
+    backgroundBudget?: { maxConcurrentBackgroundAgents?: number; userActiveWindowMs?: number };
+  }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+    this.backgroundMaxConcurrent = Math.max(1, options.backgroundBudget?.maxConcurrentBackgroundAgents ?? 2);
+    this.userActiveWindowMs = Math.max(0, options.backgroundBudget?.userActiveWindowMs ?? 5_000);
+    this.runtime.defineLimiter(this.backgroundLimiterName, this.backgroundMaxConcurrent);
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/user-input") this.lastUserInputAtMonoMs = now;
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lifecycle.memoryPressure === "high") {
+      this.noteWarnOnce(`agent_mem_high:${id}`, `Skipping background agent '${inst.def.name}' due to high memory pressure`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lastUserInputAtMonoMs !== null && this.clock.nowMs() - this.lastUserInputAtMonoMs <= this.userActiveWindowMs) {
+      this.noteWarnOnce(`agent_overload:${id}`, `Deferring background agent '${inst.def.name}' while user is active`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const releases: Array<() => void> = [];
+        try {
+          if (inst.def.kind === "background") {
+            const release = await this.runtime.acquireLimiter(this.backgroundLimiterName, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+          if (inst.def.budget?.maxConcurrent !== undefined) {
+            const limiter = `agent:${inst.def.id}`;
+            this.runtime.defineLimiter(limiter, Math.max(1, inst.def.budget.maxConcurrent));
+            const release = await this.runtime.acquireLimiter(limiter, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+        } finally {
+          for (const release of releases) release();
+        }
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0de6a25dd099d64eb9e10df4ea8c630295abbff6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      kind: initial?.kind ?? "custom",
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..7bc74dee431ae197fe22b4060dbb49166e049cd0
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,5 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
+export * from "./supervision.js";
diff --git a/src/core/runtime/supervision.ts b/src/core/runtime/supervision.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2d31c2757d6e689c0e976a2ec9784b37fe45481a
--- /dev/null
+++ b/src/core/runtime/supervision.ts
@@ -0,0 +1,51 @@
+import type { RuntimeSnapshot, TaskId, TaskScopeId, TaskScopeSnapshot } from "../types/runtime.js";
+
+export type SupervisionNode = {
+  scope: TaskScopeSnapshot;
+  children: SupervisionNode[];
+};
+
+export function buildSupervisionForest(snapshot: RuntimeSnapshot): SupervisionNode[] {
+  const scopesById = new Map<TaskScopeId, TaskScopeSnapshot>();
+  for (const s of snapshot.scopes) scopesById.set(s.id, s);
+
+  const childrenByParent = new Map<TaskScopeId, TaskScopeSnapshot[]>();
+  const roots: TaskScopeSnapshot[] = [];
+
+  for (const scope of snapshot.scopes) {
+    const parent = scope.parentScopeId;
+    if (!parent) {
+      roots.push(scope);
+      continue;
+    }
+    const list = childrenByParent.get(parent) ?? [];
+    list.push(scope);
+    childrenByParent.set(parent, list);
+  }
+
+  for (const list of childrenByParent.values()) list.sort((a, b) => a.id.localeCompare(b.id));
+  roots.sort((a, b) => a.id.localeCompare(b.id));
+
+  const visit = (scope: TaskScopeSnapshot): SupervisionNode => {
+    const kids = childrenByParent.get(scope.id) ?? [];
+    return { scope, children: kids.map(visit) };
+  };
+
+  void scopesById;
+  return roots.map(visit);
+}
+
+export function detectLeakedTasks(snapshot: RuntimeSnapshot, options: { endedScopeIds: readonly TaskScopeId[] }): TaskId[] {
+  const ended = new Set<TaskScopeId>(options.endedScopeIds);
+  const leaked: TaskId[] = [];
+  for (const task of snapshot.tasks) {
+    const scopeId = task.scopeId;
+    if (!scopeId) continue;
+    if (!ended.has(scopeId)) continue;
+    if (task.state === "completed") continue;
+    leaked.push(task.id);
+  }
+  leaked.sort((a, b) => a.localeCompare(b));
+  return leaked;
+}
+
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fcf367c1a22ba8038c625399340439ecf6d991a6
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,104 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskKindV1 = "background_agent" | "remote_agent_task" | "local_bash" | "tool_run" | "custom";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  kind: LongRunningTaskKindV1;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  nextAction?: string;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6f81ff12bd3218e1d48b5d3fadfd4e1070f20c5
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/plans.ts b/src/core/agents/builtins/plans.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0c99b1e6e5833f600c7822749e0d240578640fbe
--- /dev/null
+++ b/src/core/agents/builtins/plans.ts
@@ -0,0 +1,23 @@
+import type { HostCapabilities } from "../../types/host.js";
+
+export type BuiltInSubsystemTriggerPlan =
+  | { kind: "time"; intervalMs: number; note?: string }
+  | { kind: "event"; event: string; note?: string };
+
+export type BuiltInSubsystemCapabilityPlan = {
+  key: keyof HostCapabilities;
+  optional?: boolean;
+  note?: string;
+};
+
+export type BuiltInSubsystemPlan = {
+  id: string;
+  name: string;
+  featureGates: string[];
+  configKnobs: string[];
+  triggers: BuiltInSubsystemTriggerPlan[];
+  requiredCapabilities: BuiltInSubsystemCapabilityPlan[];
+  mobileSafeFallback: string;
+  privacyNotes: string[];
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8945ddfcc6b42147ca9ddb8329366bd7830ddbf
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,275 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+  private lastUserInputAtMonoMs: number | null = null;
+
+  private readonly backgroundLimiterName = "agents_background";
+  private readonly backgroundMaxConcurrent: number;
+  private readonly userActiveWindowMs: number;
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: {
+    host: HostCapabilities;
+    idSource: IdSource;
+    clock: MonotonicClock;
+    runtime: RuntimeKernel;
+    bus: EventBus;
+    backgroundBudget?: { maxConcurrentBackgroundAgents?: number; userActiveWindowMs?: number };
+  }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+    this.backgroundMaxConcurrent = Math.max(1, options.backgroundBudget?.maxConcurrentBackgroundAgents ?? 2);
+    this.userActiveWindowMs = Math.max(0, options.backgroundBudget?.userActiveWindowMs ?? 5_000);
+    this.runtime.defineLimiter(this.backgroundLimiterName, this.backgroundMaxConcurrent);
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/user-input") this.lastUserInputAtMonoMs = now;
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lifecycle.memoryPressure === "high") {
+      this.noteWarnOnce(`agent_mem_high:${id}`, `Skipping background agent '${inst.def.name}' due to high memory pressure`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lastUserInputAtMonoMs !== null && this.clock.nowMs() - this.lastUserInputAtMonoMs <= this.userActiveWindowMs) {
+      this.noteWarnOnce(`agent_overload:${id}`, `Deferring background agent '${inst.def.name}' while user is active`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const releases: Array<() => void> = [];
+        try {
+          if (inst.def.kind === "background") {
+            const release = await this.runtime.acquireLimiter(this.backgroundLimiterName, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+          if (inst.def.budget?.maxConcurrent !== undefined) {
+            const limiter = `agent:${inst.def.id}`;
+            this.runtime.defineLimiter(limiter, Math.max(1, inst.def.budget.maxConcurrent));
+            const release = await this.runtime.acquireLimiter(limiter, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+        } finally {
+          for (const release of releases) release();
+        }
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0de6a25dd099d64eb9e10df4ea8c630295abbff6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      kind: initial?.kind ?? "custom",
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..7bc74dee431ae197fe22b4060dbb49166e049cd0
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,5 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
+export * from "./supervision.js";
diff --git a/src/core/runtime/supervision.ts b/src/core/runtime/supervision.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2d31c2757d6e689c0e976a2ec9784b37fe45481a
--- /dev/null
+++ b/src/core/runtime/supervision.ts
@@ -0,0 +1,51 @@
+import type { RuntimeSnapshot, TaskId, TaskScopeId, TaskScopeSnapshot } from "../types/runtime.js";
+
+export type SupervisionNode = {
+  scope: TaskScopeSnapshot;
+  children: SupervisionNode[];
+};
+
+export function buildSupervisionForest(snapshot: RuntimeSnapshot): SupervisionNode[] {
+  const scopesById = new Map<TaskScopeId, TaskScopeSnapshot>();
+  for (const s of snapshot.scopes) scopesById.set(s.id, s);
+
+  const childrenByParent = new Map<TaskScopeId, TaskScopeSnapshot[]>();
+  const roots: TaskScopeSnapshot[] = [];
+
+  for (const scope of snapshot.scopes) {
+    const parent = scope.parentScopeId;
+    if (!parent) {
+      roots.push(scope);
+      continue;
+    }
+    const list = childrenByParent.get(parent) ?? [];
+    list.push(scope);
+    childrenByParent.set(parent, list);
+  }
+
+  for (const list of childrenByParent.values()) list.sort((a, b) => a.id.localeCompare(b.id));
+  roots.sort((a, b) => a.id.localeCompare(b.id));
+
+  const visit = (scope: TaskScopeSnapshot): SupervisionNode => {
+    const kids = childrenByParent.get(scope.id) ?? [];
+    return { scope, children: kids.map(visit) };
+  };
+
+  void scopesById;
+  return roots.map(visit);
+}
+
+export function detectLeakedTasks(snapshot: RuntimeSnapshot, options: { endedScopeIds: readonly TaskScopeId[] }): TaskId[] {
+  const ended = new Set<TaskScopeId>(options.endedScopeIds);
+  const leaked: TaskId[] = [];
+  for (const task of snapshot.tasks) {
+    const scopeId = task.scopeId;
+    if (!scopeId) continue;
+    if (!ended.has(scopeId)) continue;
+    if (task.state === "completed") continue;
+    leaked.push(task.id);
+  }
+  leaked.sort((a, b) => a.localeCompare(b));
+  return leaked;
+}
+
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fcf367c1a22ba8038c625399340439ecf6d991a6
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,104 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskKindV1 = "background_agent" | "remote_agent_task" | "local_bash" | "tool_run" | "custom";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  kind: LongRunningTaskKindV1;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  nextAction?: string;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/builtins/index.ts[0m
@@ -4,2 +4,2 @@
 export * from "./classifier.js";
[31m-[0m
[32m+export * from "./plans.js";[0m
[32mapply_patch(auto_approved=true) exited 0 in 177ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/agents/builtins/index.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..876f6aa22e0f1cbea4d1d382893bc930bd1e2907
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+export * from "./plans.js";
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/plans.ts b/src/core/agents/builtins/plans.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0c99b1e6e5833f600c7822749e0d240578640fbe
--- /dev/null
+++ b/src/core/agents/builtins/plans.ts
@@ -0,0 +1,23 @@
+import type { HostCapabilities } from "../../types/host.js";
+
+export type BuiltInSubsystemTriggerPlan =
+  | { kind: "time"; intervalMs: number; note?: string }
+  | { kind: "event"; event: string; note?: string };
+
+export type BuiltInSubsystemCapabilityPlan = {
+  key: keyof HostCapabilities;
+  optional?: boolean;
+  note?: string;
+};
+
+export type BuiltInSubsystemPlan = {
+  id: string;
+  name: string;
+  featureGates: string[];
+  configKnobs: string[];
+  triggers: BuiltInSubsystemTriggerPlan[];
+  requiredCapabilities: BuiltInSubsystemCapabilityPlan[];
+  mobileSafeFallback: string;
+  privacyNotes: string[];
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8945ddfcc6b42147ca9ddb8329366bd7830ddbf
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,275 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+  private lastUserInputAtMonoMs: number | null = null;
+
+  private readonly backgroundLimiterName = "agents_background";
+  private readonly backgroundMaxConcurrent: number;
+  private readonly userActiveWindowMs: number;
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: {
+    host: HostCapabilities;
+    idSource: IdSource;
+    clock: MonotonicClock;
+    runtime: RuntimeKernel;
+    bus: EventBus;
+    backgroundBudget?: { maxConcurrentBackgroundAgents?: number; userActiveWindowMs?: number };
+  }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+    this.backgroundMaxConcurrent = Math.max(1, options.backgroundBudget?.maxConcurrentBackgroundAgents ?? 2);
+    this.userActiveWindowMs = Math.max(0, options.backgroundBudget?.userActiveWindowMs ?? 5_000);
+    this.runtime.defineLimiter(this.backgroundLimiterName, this.backgroundMaxConcurrent);
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/user-input") this.lastUserInputAtMonoMs = now;
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lifecycle.memoryPressure === "high") {
+      this.noteWarnOnce(`agent_mem_high:${id}`, `Skipping background agent '${inst.def.name}' due to high memory pressure`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lastUserInputAtMonoMs !== null && this.clock.nowMs() - this.lastUserInputAtMonoMs <= this.userActiveWindowMs) {
+      this.noteWarnOnce(`agent_overload:${id}`, `Deferring background agent '${inst.def.name}' while user is active`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const releases: Array<() => void> = [];
+        try {
+          if (inst.def.kind === "background") {
+            const release = await this.runtime.acquireLimiter(this.backgroundLimiterName, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+          if (inst.def.budget?.maxConcurrent !== undefined) {
+            const limiter = `agent:${inst.def.id}`;
+            this.runtime.defineLimiter(limiter, Math.max(1, inst.def.budget.maxConcurrent));
+            const release = await this.runtime.acquireLimiter(limiter, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+        } finally {
+          for (const release of releases) release();
+        }
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0de6a25dd099d64eb9e10df4ea8c630295abbff6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      kind: initial?.kind ?? "custom",
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..7bc74dee431ae197fe22b4060dbb49166e049cd0
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,5 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
+export * from "./supervision.js";
diff --git a/src/core/runtime/supervision.ts b/src/core/runtime/supervision.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2d31c2757d6e689c0e976a2ec9784b37fe45481a
--- /dev/null
+++ b/src/core/runtime/supervision.ts
@@ -0,0 +1,51 @@
+import type { RuntimeSnapshot, TaskId, TaskScopeId, TaskScopeSnapshot } from "../types/runtime.js";
+
+export type SupervisionNode = {
+  scope: TaskScopeSnapshot;
+  children: SupervisionNode[];
+};
+
+export function buildSupervisionForest(snapshot: RuntimeSnapshot): SupervisionNode[] {
+  const scopesById = new Map<TaskScopeId, TaskScopeSnapshot>();
+  for (const s of snapshot.scopes) scopesById.set(s.id, s);
+
+  const childrenByParent = new Map<TaskScopeId, TaskScopeSnapshot[]>();
+  const roots: TaskScopeSnapshot[] = [];
+
+  for (const scope of snapshot.scopes) {
+    const parent = scope.parentScopeId;
+    if (!parent) {
+      roots.push(scope);
+      continue;
+    }
+    const list = childrenByParent.get(parent) ?? [];
+    list.push(scope);
+    childrenByParent.set(parent, list);
+  }
+
+  for (const list of childrenByParent.values()) list.sort((a, b) => a.id.localeCompare(b.id));
+  roots.sort((a, b) => a.id.localeCompare(b.id));
+
+  const visit = (scope: TaskScopeSnapshot): SupervisionNode => {
+    const kids = childrenByParent.get(scope.id) ?? [];
+    return { scope, children: kids.map(visit) };
+  };
+
+  void scopesById;
+  return roots.map(visit);
+}
+
+export function detectLeakedTasks(snapshot: RuntimeSnapshot, options: { endedScopeIds: readonly TaskScopeId[] }): TaskId[] {
+  const ended = new Set<TaskScopeId>(options.endedScopeIds);
+  const leaked: TaskId[] = [];
+  for (const task of snapshot.tasks) {
+    const scopeId = task.scopeId;
+    if (!scopeId) continue;
+    if (!ended.has(scopeId)) continue;
+    if (task.state === "completed") continue;
+    leaked.push(task.id);
+  }
+  leaked.sort((a, b) => a.localeCompare(b));
+  return leaked;
+}
+
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fcf367c1a22ba8038c625399340439ecf6d991a6
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,104 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskKindV1 = "background_agent" | "remote_agent_task" | "local_bash" | "tool_run" | "custom";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  kind: LongRunningTaskKindV1;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  nextAction?: string;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..876f6aa22e0f1cbea4d1d382893bc930bd1e2907
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+export * from "./plans.js";
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/plans.ts b/src/core/agents/builtins/plans.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0c99b1e6e5833f600c7822749e0d240578640fbe
--- /dev/null
+++ b/src/core/agents/builtins/plans.ts
@@ -0,0 +1,23 @@
+import type { HostCapabilities } from "../../types/host.js";
+
+export type BuiltInSubsystemTriggerPlan =
+  | { kind: "time"; intervalMs: number; note?: string }
+  | { kind: "event"; event: string; note?: string };
+
+export type BuiltInSubsystemCapabilityPlan = {
+  key: keyof HostCapabilities;
+  optional?: boolean;
+  note?: string;
+};
+
+export type BuiltInSubsystemPlan = {
+  id: string;
+  name: string;
+  featureGates: string[];
+  configKnobs: string[];
+  triggers: BuiltInSubsystemTriggerPlan[];
+  requiredCapabilities: BuiltInSubsystemCapabilityPlan[];
+  mobileSafeFallback: string;
+  privacyNotes: string[];
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0d904b4c0e88f1d756bd6bd1169656aa3aff2bdb
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,38 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8945ddfcc6b42147ca9ddb8329366bd7830ddbf
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,275 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+  private lastUserInputAtMonoMs: number | null = null;
+
+  private readonly backgroundLimiterName = "agents_background";
+  private readonly backgroundMaxConcurrent: number;
+  private readonly userActiveWindowMs: number;
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: {
+    host: HostCapabilities;
+    idSource: IdSource;
+    clock: MonotonicClock;
+    runtime: RuntimeKernel;
+    bus: EventBus;
+    backgroundBudget?: { maxConcurrentBackgroundAgents?: number; userActiveWindowMs?: number };
+  }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+    this.backgroundMaxConcurrent = Math.max(1, options.backgroundBudget?.maxConcurrentBackgroundAgents ?? 2);
+    this.userActiveWindowMs = Math.max(0, options.backgroundBudget?.userActiveWindowMs ?? 5_000);
+    this.runtime.defineLimiter(this.backgroundLimiterName, this.backgroundMaxConcurrent);
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/user-input") this.lastUserInputAtMonoMs = now;
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lifecycle.memoryPressure === "high") {
+      this.noteWarnOnce(`agent_mem_high:${id}`, `Skipping background agent '${inst.def.name}' due to high memory pressure`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lastUserInputAtMonoMs !== null && this.clock.nowMs() - this.lastUserInputAtMonoMs <= this.userActiveWindowMs) {
+      this.noteWarnOnce(`agent_overload:${id}`, `Deferring background agent '${inst.def.name}' while user is active`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const releases: Array<() => void> = [];
+        try {
+          if (inst.def.kind === "background") {
+            const release = await this.runtime.acquireLimiter(this.backgroundLimiterName, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+          if (inst.def.budget?.maxConcurrent !== undefined) {
+            const limiter = `agent:${inst.def.id}`;
+            this.runtime.defineLimiter(limiter, Math.max(1, inst.def.budget.maxConcurrent));
+            const release = await this.runtime.acquireLimiter(limiter, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+        } finally {
+          for (const release of releases) release();
+        }
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0de6a25dd099d64eb9e10df4ea8c630295abbff6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      kind: initial?.kind ?? "custom",
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..7bc74dee431ae197fe22b4060dbb49166e049cd0
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,5 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
+export * from "./supervision.js";
diff --git a/src/core/runtime/supervision.ts b/src/core/runtime/supervision.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2d31c2757d6e689c0e976a2ec9784b37fe45481a
--- /dev/null
+++ b/src/core/runtime/supervision.ts
@@ -0,0 +1,51 @@
+import type { RuntimeSnapshot, TaskId, TaskScopeId, TaskScopeSnapshot } from "../types/runtime.js";
+
+export type SupervisionNode = {
+  scope: TaskScopeSnapshot;
+  children: SupervisionNode[];
+};
+
+export function buildSupervisionForest(snapshot: RuntimeSnapshot): SupervisionNode[] {
+  const scopesById = new Map<TaskScopeId, TaskScopeSnapshot>();
+  for (const s of snapshot.scopes) scopesById.set(s.id, s);
+
+  const childrenByParent = new Map<TaskScopeId, TaskScopeSnapshot[]>();
+  const roots: TaskScopeSnapshot[] = [];
+
+  for (const scope of snapshot.scopes) {
+    const parent = scope.parentScopeId;
+    if (!parent) {
+      roots.push(scope);
+      continue;
+    }
+    const list = childrenByParent.get(parent) ?? [];
+    list.push(scope);
+    childrenByParent.set(parent, list);
+  }
+
+  for (const list of childrenByParent.values()) list.sort((a, b) => a.id.localeCompare(b.id));
+  roots.sort((a, b) => a.id.localeCompare(b.id));
+
+  const visit = (scope: TaskScopeSnapshot): SupervisionNode => {
+    const kids = childrenByParent.get(scope.id) ?? [];
+    return { scope, children: kids.map(visit) };
+  };
+
+  void scopesById;
+  return roots.map(visit);
+}
+
+export function detectLeakedTasks(snapshot: RuntimeSnapshot, options: { endedScopeIds: readonly TaskScopeId[] }): TaskId[] {
+  const ended = new Set<TaskScopeId>(options.endedScopeIds);
+  const leaked: TaskId[] = [];
+  for (const task of snapshot.tasks) {
+    const scopeId = task.scopeId;
+    if (!scopeId) continue;
+    if (!ended.has(scopeId)) continue;
+    if (task.state === "completed") continue;
+    leaked.push(task.id);
+  }
+  leaked.sort((a, b) => a.localeCompare(b));
+  return leaked;
+}
+
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fcf367c1a22ba8038c625399340439ecf6d991a6
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,104 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskKindV1 = "background_agent" | "remote_agent_task" | "local_bash" | "tool_run" | "custom";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  kind: LongRunningTaskKindV1;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  nextAction?: string;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/builtins/promptSuggestion.ts[0m
@@ -2,2 +2,3 @@
 import { createBuiltInAgentId } from "../manager.js";
[32m+import type { BuiltInSubsystemPlan } from "./plans.js";[0m
 
@@ -25,2 +26,26 @@
 
[32m+export function shouldOfferPromptSuggestion(options: {[0m
[32m+  nowMonoMs: number;[0m
[32m+  lastShownAtMonoMs: number | null;[0m
[32m+  lastUserPromptAtMonoMs: number | null;[0m
[32m+  minIntervalMs?: number;[0m
[32m+}): boolean {[0m
[32m+  const minIntervalMs = options.minIntervalMs ?? 60_000;[0m
[32m+  if (options.lastUserPromptAtMonoMs === null) return false;[0m
[32m+  if (options.lastShownAtMonoMs !== null && options.nowMonoMs - options.lastShownAtMonoMs < minIntervalMs) return false;[0m
[32m+  if (options.nowMonoMs < options.lastUserPromptAtMonoMs) return false;[0m
[32m+  return true;[0m
[32m+}[0m
[32m+[0m
[32m+export const PROMPT_SUGGESTION_PLAN: BuiltInSubsystemPlan = {[0m
[32m+  id: "prompt_suggestion",[0m
[32m+  name: "Prompt suggestion",[0m
[32m+  featureGates: ["tengu_prompt_suggestion", "CLAUDE_CODE_ENABLE_PROMPT_SUGGESTION"],[0m
[32m+  configKnobs: ["promptSuggestion.minIntervalMs", "promptSuggestion.maxChars"],[0m
[32m+  triggers: [{ kind: "event", event: "post_turn_idle", note: "Legacy runs from main UI loop when idle; v3 should schedule via agent manager." }],[0m
[32m+  requiredCapabilities: [{ key: "storage", note: "Stores last-shown timestamps and suppression state." }],[0m
[32m+  mobileSafeFallback: "If storage is unavailable, do not generate suggestions; suppress silently.",[0m
[32m+  privacyNotes: ["Never store raw model thoughts; store only the displayed suggestion string (or a hash) and timestamps."][0m
[32m+};[0m
[32m+[0m
 export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
@@ -30,2 +55,3 @@
   budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
[32m+  persistence: { kind: "none" },[0m
   requiredCapabilities: ["storage"],
@@ -37,2 +63 @@
 };
[31m-[0m
[32mapply_patch(auto_approved=true) exited 0 in 133ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/agents/builtins/promptSuggestion.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..876f6aa22e0f1cbea4d1d382893bc930bd1e2907
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+export * from "./plans.js";
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/plans.ts b/src/core/agents/builtins/plans.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0c99b1e6e5833f600c7822749e0d240578640fbe
--- /dev/null
+++ b/src/core/agents/builtins/plans.ts
@@ -0,0 +1,23 @@
+import type { HostCapabilities } from "../../types/host.js";
+
+export type BuiltInSubsystemTriggerPlan =
+  | { kind: "time"; intervalMs: number; note?: string }
+  | { kind: "event"; event: string; note?: string };
+
+export type BuiltInSubsystemCapabilityPlan = {
+  key: keyof HostCapabilities;
+  optional?: boolean;
+  note?: string;
+};
+
+export type BuiltInSubsystemPlan = {
+  id: string;
+  name: string;
+  featureGates: string[];
+  configKnobs: string[];
+  triggers: BuiltInSubsystemTriggerPlan[];
+  requiredCapabilities: BuiltInSubsystemCapabilityPlan[];
+  mobileSafeFallback: string;
+  privacyNotes: string[];
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e41aec8f752ad97edb16d222011b54d770a3e150
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,63 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import type { BuiltInSubsystemPlan } from "./plans.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export function shouldOfferPromptSuggestion(options: {
+  nowMonoMs: number;
+  lastShownAtMonoMs: number | null;
+  lastUserPromptAtMonoMs: number | null;
+  minIntervalMs?: number;
+}): boolean {
+  const minIntervalMs = options.minIntervalMs ?? 60_000;
+  if (options.lastUserPromptAtMonoMs === null) return false;
+  if (options.lastShownAtMonoMs !== null && options.nowMonoMs - options.lastShownAtMonoMs < minIntervalMs) return false;
+  if (options.nowMonoMs < options.lastUserPromptAtMonoMs) return false;
+  return true;
+}
+
+export const PROMPT_SUGGESTION_PLAN: BuiltInSubsystemPlan = {
+  id: "prompt_suggestion",
+  name: "Prompt suggestion",
+  featureGates: ["tengu_prompt_suggestion", "CLAUDE_CODE_ENABLE_PROMPT_SUGGESTION"],
+  configKnobs: ["promptSuggestion.minIntervalMs", "promptSuggestion.maxChars"],
+  triggers: [{ kind: "event", event: "post_turn_idle", note: "Legacy runs from main UI loop when idle; v3 should schedule via agent manager." }],
+  requiredCapabilities: [{ key: "storage", note: "Stores last-shown timestamps and suppression state." }],
+  mobileSafeFallback: "If storage is unavailable, do not generate suggestions; suppress silently.",
+  privacyNotes: ["Never store raw model thoughts; store only the displayed suggestion string (or a hash) and timestamps."]
+};
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  persistence: { kind: "none" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8945ddfcc6b42147ca9ddb8329366bd7830ddbf
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,275 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+  private lastUserInputAtMonoMs: number | null = null;
+
+  private readonly backgroundLimiterName = "agents_background";
+  private readonly backgroundMaxConcurrent: number;
+  private readonly userActiveWindowMs: number;
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: {
+    host: HostCapabilities;
+    idSource: IdSource;
+    clock: MonotonicClock;
+    runtime: RuntimeKernel;
+    bus: EventBus;
+    backgroundBudget?: { maxConcurrentBackgroundAgents?: number; userActiveWindowMs?: number };
+  }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+    this.backgroundMaxConcurrent = Math.max(1, options.backgroundBudget?.maxConcurrentBackgroundAgents ?? 2);
+    this.userActiveWindowMs = Math.max(0, options.backgroundBudget?.userActiveWindowMs ?? 5_000);
+    this.runtime.defineLimiter(this.backgroundLimiterName, this.backgroundMaxConcurrent);
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/user-input") this.lastUserInputAtMonoMs = now;
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lifecycle.memoryPressure === "high") {
+      this.noteWarnOnce(`agent_mem_high:${id}`, `Skipping background agent '${inst.def.name}' due to high memory pressure`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lastUserInputAtMonoMs !== null && this.clock.nowMs() - this.lastUserInputAtMonoMs <= this.userActiveWindowMs) {
+      this.noteWarnOnce(`agent_overload:${id}`, `Deferring background agent '${inst.def.name}' while user is active`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const releases: Array<() => void> = [];
+        try {
+          if (inst.def.kind === "background") {
+            const release = await this.runtime.acquireLimiter(this.backgroundLimiterName, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+          if (inst.def.budget?.maxConcurrent !== undefined) {
+            const limiter = `agent:${inst.def.id}`;
+            this.runtime.defineLimiter(limiter, Math.max(1, inst.def.budget.maxConcurrent));
+            const release = await this.runtime.acquireLimiter(limiter, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+        } finally {
+          for (const release of releases) release();
+        }
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0de6a25dd099d64eb9e10df4ea8c630295abbff6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      kind: initial?.kind ?? "custom",
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..7bc74dee431ae197fe22b4060dbb49166e049cd0
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,5 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
+export * from "./supervision.js";
diff --git a/src/core/runtime/supervision.ts b/src/core/runtime/supervision.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2d31c2757d6e689c0e976a2ec9784b37fe45481a
--- /dev/null
+++ b/src/core/runtime/supervision.ts
@@ -0,0 +1,51 @@
+import type { RuntimeSnapshot, TaskId, TaskScopeId, TaskScopeSnapshot } from "../types/runtime.js";
+
+export type SupervisionNode = {
+  scope: TaskScopeSnapshot;
+  children: SupervisionNode[];
+};
+
+export function buildSupervisionForest(snapshot: RuntimeSnapshot): SupervisionNode[] {
+  const scopesById = new Map<TaskScopeId, TaskScopeSnapshot>();
+  for (const s of snapshot.scopes) scopesById.set(s.id, s);
+
+  const childrenByParent = new Map<TaskScopeId, TaskScopeSnapshot[]>();
+  const roots: TaskScopeSnapshot[] = [];
+
+  for (const scope of snapshot.scopes) {
+    const parent = scope.parentScopeId;
+    if (!parent) {
+      roots.push(scope);
+      continue;
+    }
+    const list = childrenByParent.get(parent) ?? [];
+    list.push(scope);
+    childrenByParent.set(parent, list);
+  }
+
+  for (const list of childrenByParent.values()) list.sort((a, b) => a.id.localeCompare(b.id));
+  roots.sort((a, b) => a.id.localeCompare(b.id));
+
+  const visit = (scope: TaskScopeSnapshot): SupervisionNode => {
+    const kids = childrenByParent.get(scope.id) ?? [];
+    return { scope, children: kids.map(visit) };
+  };
+
+  void scopesById;
+  return roots.map(visit);
+}
+
+export function detectLeakedTasks(snapshot: RuntimeSnapshot, options: { endedScopeIds: readonly TaskScopeId[] }): TaskId[] {
+  const ended = new Set<TaskScopeId>(options.endedScopeIds);
+  const leaked: TaskId[] = [];
+  for (const task of snapshot.tasks) {
+    const scopeId = task.scopeId;
+    if (!scopeId) continue;
+    if (!ended.has(scopeId)) continue;
+    if (task.state === "completed") continue;
+    leaked.push(task.id);
+  }
+  leaked.sort((a, b) => a.localeCompare(b));
+  return leaked;
+}
+
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fcf367c1a22ba8038c625399340439ecf6d991a6
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,104 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskKindV1 = "background_agent" | "remote_agent_task" | "local_bash" | "tool_run" | "custom";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  kind: LongRunningTaskKindV1;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  nextAction?: string;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..876f6aa22e0f1cbea4d1d382893bc930bd1e2907
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+export * from "./plans.js";
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b9ebdde51b451ed0d5b67826eba981afb88c0a2c
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,42 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/plans.ts b/src/core/agents/builtins/plans.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0c99b1e6e5833f600c7822749e0d240578640fbe
--- /dev/null
+++ b/src/core/agents/builtins/plans.ts
@@ -0,0 +1,23 @@
+import type { HostCapabilities } from "../../types/host.js";
+
+export type BuiltInSubsystemTriggerPlan =
+  | { kind: "time"; intervalMs: number; note?: string }
+  | { kind: "event"; event: string; note?: string };
+
+export type BuiltInSubsystemCapabilityPlan = {
+  key: keyof HostCapabilities;
+  optional?: boolean;
+  note?: string;
+};
+
+export type BuiltInSubsystemPlan = {
+  id: string;
+  name: string;
+  featureGates: string[];
+  configKnobs: string[];
+  triggers: BuiltInSubsystemTriggerPlan[];
+  requiredCapabilities: BuiltInSubsystemCapabilityPlan[];
+  mobileSafeFallback: string;
+  privacyNotes: string[];
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e41aec8f752ad97edb16d222011b54d770a3e150
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,63 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import type { BuiltInSubsystemPlan } from "./plans.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export function shouldOfferPromptSuggestion(options: {
+  nowMonoMs: number;
+  lastShownAtMonoMs: number | null;
+  lastUserPromptAtMonoMs: number | null;
+  minIntervalMs?: number;
+}): boolean {
+  const minIntervalMs = options.minIntervalMs ?? 60_000;
+  if (options.lastUserPromptAtMonoMs === null) return false;
+  if (options.lastShownAtMonoMs !== null && options.nowMonoMs - options.lastShownAtMonoMs < minIntervalMs) return false;
+  if (options.nowMonoMs < options.lastUserPromptAtMonoMs) return false;
+  return true;
+}
+
+export const PROMPT_SUGGESTION_PLAN: BuiltInSubsystemPlan = {
+  id: "prompt_suggestion",
+  name: "Prompt suggestion",
+  featureGates: ["tengu_prompt_suggestion", "CLAUDE_CODE_ENABLE_PROMPT_SUGGESTION"],
+  configKnobs: ["promptSuggestion.minIntervalMs", "promptSuggestion.maxChars"],
+  triggers: [{ kind: "event", event: "post_turn_idle", note: "Legacy runs from main UI loop when idle; v3 should schedule via agent manager." }],
+  requiredCapabilities: [{ key: "storage", note: "Stores last-shown timestamps and suppression state." }],
+  mobileSafeFallback: "If storage is unavailable, do not generate suggestions; suppress silently.",
+  privacyNotes: ["Never store raw model thoughts; store only the displayed suggestion string (or a hash) and timestamps."]
+};
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  persistence: { kind: "none" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8945ddfcc6b42147ca9ddb8329366bd7830ddbf
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,275 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+  private lastUserInputAtMonoMs: number | null = null;
+
+  private readonly backgroundLimiterName = "agents_background";
+  private readonly backgroundMaxConcurrent: number;
+  private readonly userActiveWindowMs: number;
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: {
+    host: HostCapabilities;
+    idSource: IdSource;
+    clock: MonotonicClock;
+    runtime: RuntimeKernel;
+    bus: EventBus;
+    backgroundBudget?: { maxConcurrentBackgroundAgents?: number; userActiveWindowMs?: number };
+  }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+    this.backgroundMaxConcurrent = Math.max(1, options.backgroundBudget?.maxConcurrentBackgroundAgents ?? 2);
+    this.userActiveWindowMs = Math.max(0, options.backgroundBudget?.userActiveWindowMs ?? 5_000);
+    this.runtime.defineLimiter(this.backgroundLimiterName, this.backgroundMaxConcurrent);
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/user-input") this.lastUserInputAtMonoMs = now;
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lifecycle.memoryPressure === "high") {
+      this.noteWarnOnce(`agent_mem_high:${id}`, `Skipping background agent '${inst.def.name}' due to high memory pressure`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lastUserInputAtMonoMs !== null && this.clock.nowMs() - this.lastUserInputAtMonoMs <= this.userActiveWindowMs) {
+      this.noteWarnOnce(`agent_overload:${id}`, `Deferring background agent '${inst.def.name}' while user is active`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const releases: Array<() => void> = [];
+        try {
+          if (inst.def.kind === "background") {
+            const release = await this.runtime.acquireLimiter(this.backgroundLimiterName, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+          if (inst.def.budget?.maxConcurrent !== undefined) {
+            const limiter = `agent:${inst.def.id}`;
+            this.runtime.defineLimiter(limiter, Math.max(1, inst.def.budget.maxConcurrent));
+            const release = await this.runtime.acquireLimiter(limiter, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+        } finally {
+          for (const release of releases) release();
+        }
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0de6a25dd099d64eb9e10df4ea8c630295abbff6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      kind: initial?.kind ?? "custom",
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..7bc74dee431ae197fe22b4060dbb49166e049cd0
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,5 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
+export * from "./supervision.js";
diff --git a/src/core/runtime/supervision.ts b/src/core/runtime/supervision.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2d31c2757d6e689c0e976a2ec9784b37fe45481a
--- /dev/null
+++ b/src/core/runtime/supervision.ts
@@ -0,0 +1,51 @@
+import type { RuntimeSnapshot, TaskId, TaskScopeId, TaskScopeSnapshot } from "../types/runtime.js";
+
+export type SupervisionNode = {
+  scope: TaskScopeSnapshot;
+  children: SupervisionNode[];
+};
+
+export function buildSupervisionForest(snapshot: RuntimeSnapshot): SupervisionNode[] {
+  const scopesById = new Map<TaskScopeId, TaskScopeSnapshot>();
+  for (const s of snapshot.scopes) scopesById.set(s.id, s);
+
+  const childrenByParent = new Map<TaskScopeId, TaskScopeSnapshot[]>();
+  const roots: TaskScopeSnapshot[] = [];
+
+  for (const scope of snapshot.scopes) {
+    const parent = scope.parentScopeId;
+    if (!parent) {
+      roots.push(scope);
+      continue;
+    }
+    const list = childrenByParent.get(parent) ?? [];
+    list.push(scope);
+    childrenByParent.set(parent, list);
+  }
+
+  for (const list of childrenByParent.values()) list.sort((a, b) => a.id.localeCompare(b.id));
+  roots.sort((a, b) => a.id.localeCompare(b.id));
+
+  const visit = (scope: TaskScopeSnapshot): SupervisionNode => {
+    const kids = childrenByParent.get(scope.id) ?? [];
+    return { scope, children: kids.map(visit) };
+  };
+
+  void scopesById;
+  return roots.map(visit);
+}
+
+export function detectLeakedTasks(snapshot: RuntimeSnapshot, options: { endedScopeIds: readonly TaskScopeId[] }): TaskId[] {
+  const ended = new Set<TaskScopeId>(options.endedScopeIds);
+  const leaked: TaskId[] = [];
+  for (const task of snapshot.tasks) {
+    const scopeId = task.scopeId;
+    if (!scopeId) continue;
+    if (!ended.has(scopeId)) continue;
+    if (task.state === "completed") continue;
+    leaked.push(task.id);
+  }
+  leaked.sort((a, b) => a.localeCompare(b));
+  return leaked;
+}
+
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fcf367c1a22ba8038c625399340439ecf6d991a6
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,104 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskKindV1 = "background_agent" | "remote_agent_task" | "local_bash" | "tool_run" | "custom";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  kind: LongRunningTaskKindV1;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  nextAction?: string;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/builtins/magicDocs.ts[0m
@@ -2,2 +2,3 @@
 import { createBuiltInAgentId } from "../manager.js";
[32m+import type { BuiltInSubsystemPlan } from "./plans.js";[0m
 
@@ -30,2 +31,19 @@
 
[32m+export const MAGIC_DOCS_PLAN: BuiltInSubsystemPlan = {[0m
[32m+  id: "magic_docs",[0m
[32m+  name: "Magic Docs",[0m
[32m+  featureGates: ["tengu_magic_docs", "CLAUDE_CODE_ENABLE_MAGIC_DOCS"],[0m
[32m+  configKnobs: ["magicDocs.promptTemplatePath", "magicDocs.concurrency", "magicDocs.globRoots"],[0m
[32m+  triggers: [[0m
[32m+    { kind: "event", event: "repl_main_thread_turn_end", note: "Legacy gating checks querySource and tool_use presence." },[0m
[32m+    { kind: "time", intervalMs: 60_000, note: "Optional periodic rescan; must be cancellable on mobile." }[0m
[32m+  ],[0m
[32m+  requiredCapabilities: [[0m
[32m+    { key: "filesystem", optional: true, note: "File discovery is capability-gated; absent on mobile/web." },[0m
[32m+    { key: "storage", note: "Stores registry of Magic Doc refs + last-updated metadata." }[0m
[32m+  ],[0m
[32m+  mobileSafeFallback: "If filesystem is unavailable, keep the registry empty and skip updates; never attempt network-only work.",[0m
[32m+  privacyNotes: ["Edit-only enforcement must be applied as a hard tool gate; never allow Read/Exec for other paths."][0m
[32m+};[0m
[32m+[0m
 export const MAGIC_DOCS_AGENT: AgentDefinition = {
@@ -35,2 +53,3 @@
   budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
[32m+  persistence: { kind: "summary", sensitivity: "internal" },[0m
   requiredCapabilities: ["storage"],
@@ -41,2 +60 @@
 };
[31m-[0m
[32mapply_patch(auto_approved=true) exited 0 in 122ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/agents/builtins/magicDocs.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..876f6aa22e0f1cbea4d1d382893bc930bd1e2907
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+export * from "./plans.js";
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6b909f63377b2fbf9acbd49acea50a2d318aca0
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,60 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import type { BuiltInSubsystemPlan } from "./plans.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_PLAN: BuiltInSubsystemPlan = {
+  id: "magic_docs",
+  name: "Magic Docs",
+  featureGates: ["tengu_magic_docs", "CLAUDE_CODE_ENABLE_MAGIC_DOCS"],
+  configKnobs: ["magicDocs.promptTemplatePath", "magicDocs.concurrency", "magicDocs.globRoots"],
+  triggers: [
+    { kind: "event", event: "repl_main_thread_turn_end", note: "Legacy gating checks querySource and tool_use presence." },
+    { kind: "time", intervalMs: 60_000, note: "Optional periodic rescan; must be cancellable on mobile." }
+  ],
+  requiredCapabilities: [
+    { key: "filesystem", optional: true, note: "File discovery is capability-gated; absent on mobile/web." },
+    { key: "storage", note: "Stores registry of Magic Doc refs + last-updated metadata." }
+  ],
+  mobileSafeFallback: "If filesystem is unavailable, keep the registry empty and skip updates; never attempt network-only work.",
+  privacyNotes: ["Edit-only enforcement must be applied as a hard tool gate; never allow Read/Exec for other paths."]
+};
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  persistence: { kind: "summary", sensitivity: "internal" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
diff --git a/src/core/agents/builtins/plans.ts b/src/core/agents/builtins/plans.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0c99b1e6e5833f600c7822749e0d240578640fbe
--- /dev/null
+++ b/src/core/agents/builtins/plans.ts
@@ -0,0 +1,23 @@
+import type { HostCapabilities } from "../../types/host.js";
+
+export type BuiltInSubsystemTriggerPlan =
+  | { kind: "time"; intervalMs: number; note?: string }
+  | { kind: "event"; event: string; note?: string };
+
+export type BuiltInSubsystemCapabilityPlan = {
+  key: keyof HostCapabilities;
+  optional?: boolean;
+  note?: string;
+};
+
+export type BuiltInSubsystemPlan = {
+  id: string;
+  name: string;
+  featureGates: string[];
+  configKnobs: string[];
+  triggers: BuiltInSubsystemTriggerPlan[];
+  requiredCapabilities: BuiltInSubsystemCapabilityPlan[];
+  mobileSafeFallback: string;
+  privacyNotes: string[];
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e41aec8f752ad97edb16d222011b54d770a3e150
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,63 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import type { BuiltInSubsystemPlan } from "./plans.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export function shouldOfferPromptSuggestion(options: {
+  nowMonoMs: number;
+  lastShownAtMonoMs: number | null;
+  lastUserPromptAtMonoMs: number | null;
+  minIntervalMs?: number;
+}): boolean {
+  const minIntervalMs = options.minIntervalMs ?? 60_000;
+  if (options.lastUserPromptAtMonoMs === null) return false;
+  if (options.lastShownAtMonoMs !== null && options.nowMonoMs - options.lastShownAtMonoMs < minIntervalMs) return false;
+  if (options.nowMonoMs < options.lastUserPromptAtMonoMs) return false;
+  return true;
+}
+
+export const PROMPT_SUGGESTION_PLAN: BuiltInSubsystemPlan = {
+  id: "prompt_suggestion",
+  name: "Prompt suggestion",
+  featureGates: ["tengu_prompt_suggestion", "CLAUDE_CODE_ENABLE_PROMPT_SUGGESTION"],
+  configKnobs: ["promptSuggestion.minIntervalMs", "promptSuggestion.maxChars"],
+  triggers: [{ kind: "event", event: "post_turn_idle", note: "Legacy runs from main UI loop when idle; v3 should schedule via agent manager." }],
+  requiredCapabilities: [{ key: "storage", note: "Stores last-shown timestamps and suppression state." }],
+  mobileSafeFallback: "If storage is unavailable, do not generate suggestions; suppress silently.",
+  privacyNotes: ["Never store raw model thoughts; store only the displayed suggestion string (or a hash) and timestamps."]
+};
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  persistence: { kind: "none" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8945ddfcc6b42147ca9ddb8329366bd7830ddbf
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,275 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+  private lastUserInputAtMonoMs: number | null = null;
+
+  private readonly backgroundLimiterName = "agents_background";
+  private readonly backgroundMaxConcurrent: number;
+  private readonly userActiveWindowMs: number;
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: {
+    host: HostCapabilities;
+    idSource: IdSource;
+    clock: MonotonicClock;
+    runtime: RuntimeKernel;
+    bus: EventBus;
+    backgroundBudget?: { maxConcurrentBackgroundAgents?: number; userActiveWindowMs?: number };
+  }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+    this.backgroundMaxConcurrent = Math.max(1, options.backgroundBudget?.maxConcurrentBackgroundAgents ?? 2);
+    this.userActiveWindowMs = Math.max(0, options.backgroundBudget?.userActiveWindowMs ?? 5_000);
+    this.runtime.defineLimiter(this.backgroundLimiterName, this.backgroundMaxConcurrent);
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/user-input") this.lastUserInputAtMonoMs = now;
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lifecycle.memoryPressure === "high") {
+      this.noteWarnOnce(`agent_mem_high:${id}`, `Skipping background agent '${inst.def.name}' due to high memory pressure`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lastUserInputAtMonoMs !== null && this.clock.nowMs() - this.lastUserInputAtMonoMs <= this.userActiveWindowMs) {
+      this.noteWarnOnce(`agent_overload:${id}`, `Deferring background agent '${inst.def.name}' while user is active`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const releases: Array<() => void> = [];
+        try {
+          if (inst.def.kind === "background") {
+            const release = await this.runtime.acquireLimiter(this.backgroundLimiterName, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+          if (inst.def.budget?.maxConcurrent !== undefined) {
+            const limiter = `agent:${inst.def.id}`;
+            this.runtime.defineLimiter(limiter, Math.max(1, inst.def.budget.maxConcurrent));
+            const release = await this.runtime.acquireLimiter(limiter, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+        } finally {
+          for (const release of releases) release();
+        }
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0de6a25dd099d64eb9e10df4ea8c630295abbff6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      kind: initial?.kind ?? "custom",
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..7bc74dee431ae197fe22b4060dbb49166e049cd0
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,5 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
+export * from "./supervision.js";
diff --git a/src/core/runtime/supervision.ts b/src/core/runtime/supervision.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2d31c2757d6e689c0e976a2ec9784b37fe45481a
--- /dev/null
+++ b/src/core/runtime/supervision.ts
@@ -0,0 +1,51 @@
+import type { RuntimeSnapshot, TaskId, TaskScopeId, TaskScopeSnapshot } from "../types/runtime.js";
+
+export type SupervisionNode = {
+  scope: TaskScopeSnapshot;
+  children: SupervisionNode[];
+};
+
+export function buildSupervisionForest(snapshot: RuntimeSnapshot): SupervisionNode[] {
+  const scopesById = new Map<TaskScopeId, TaskScopeSnapshot>();
+  for (const s of snapshot.scopes) scopesById.set(s.id, s);
+
+  const childrenByParent = new Map<TaskScopeId, TaskScopeSnapshot[]>();
+  const roots: TaskScopeSnapshot[] = [];
+
+  for (const scope of snapshot.scopes) {
+    const parent = scope.parentScopeId;
+    if (!parent) {
+      roots.push(scope);
+      continue;
+    }
+    const list = childrenByParent.get(parent) ?? [];
+    list.push(scope);
+    childrenByParent.set(parent, list);
+  }
+
+  for (const list of childrenByParent.values()) list.sort((a, b) => a.id.localeCompare(b.id));
+  roots.sort((a, b) => a.id.localeCompare(b.id));
+
+  const visit = (scope: TaskScopeSnapshot): SupervisionNode => {
+    const kids = childrenByParent.get(scope.id) ?? [];
+    return { scope, children: kids.map(visit) };
+  };
+
+  void scopesById;
+  return roots.map(visit);
+}
+
+export function detectLeakedTasks(snapshot: RuntimeSnapshot, options: { endedScopeIds: readonly TaskScopeId[] }): TaskId[] {
+  const ended = new Set<TaskScopeId>(options.endedScopeIds);
+  const leaked: TaskId[] = [];
+  for (const task of snapshot.tasks) {
+    const scopeId = task.scopeId;
+    if (!scopeId) continue;
+    if (!ended.has(scopeId)) continue;
+    if (task.state === "completed") continue;
+    leaked.push(task.id);
+  }
+  leaked.sort((a, b) => a.localeCompare(b));
+  return leaked;
+}
+
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fcf367c1a22ba8038c625399340439ecf6d991a6
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,104 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskKindV1 = "background_agent" | "remote_agent_task" | "local_bash" | "tool_run" | "custom";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  kind: LongRunningTaskKindV1;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  nextAction?: string;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..876f6aa22e0f1cbea4d1d382893bc930bd1e2907
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+export * from "./plans.js";
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6b909f63377b2fbf9acbd49acea50a2d318aca0
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,60 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import type { BuiltInSubsystemPlan } from "./plans.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_PLAN: BuiltInSubsystemPlan = {
+  id: "magic_docs",
+  name: "Magic Docs",
+  featureGates: ["tengu_magic_docs", "CLAUDE_CODE_ENABLE_MAGIC_DOCS"],
+  configKnobs: ["magicDocs.promptTemplatePath", "magicDocs.concurrency", "magicDocs.globRoots"],
+  triggers: [
+    { kind: "event", event: "repl_main_thread_turn_end", note: "Legacy gating checks querySource and tool_use presence." },
+    { kind: "time", intervalMs: 60_000, note: "Optional periodic rescan; must be cancellable on mobile." }
+  ],
+  requiredCapabilities: [
+    { key: "filesystem", optional: true, note: "File discovery is capability-gated; absent on mobile/web." },
+    { key: "storage", note: "Stores registry of Magic Doc refs + last-updated metadata." }
+  ],
+  mobileSafeFallback: "If filesystem is unavailable, keep the registry empty and skip updates; never attempt network-only work.",
+  privacyNotes: ["Edit-only enforcement must be applied as a hard tool gate; never allow Read/Exec for other paths."]
+};
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  persistence: { kind: "summary", sensitivity: "internal" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
diff --git a/src/core/agents/builtins/plans.ts b/src/core/agents/builtins/plans.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0c99b1e6e5833f600c7822749e0d240578640fbe
--- /dev/null
+++ b/src/core/agents/builtins/plans.ts
@@ -0,0 +1,23 @@
+import type { HostCapabilities } from "../../types/host.js";
+
+export type BuiltInSubsystemTriggerPlan =
+  | { kind: "time"; intervalMs: number; note?: string }
+  | { kind: "event"; event: string; note?: string };
+
+export type BuiltInSubsystemCapabilityPlan = {
+  key: keyof HostCapabilities;
+  optional?: boolean;
+  note?: string;
+};
+
+export type BuiltInSubsystemPlan = {
+  id: string;
+  name: string;
+  featureGates: string[];
+  configKnobs: string[];
+  triggers: BuiltInSubsystemTriggerPlan[];
+  requiredCapabilities: BuiltInSubsystemCapabilityPlan[];
+  mobileSafeFallback: string;
+  privacyNotes: string[];
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e41aec8f752ad97edb16d222011b54d770a3e150
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,63 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import type { BuiltInSubsystemPlan } from "./plans.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export function shouldOfferPromptSuggestion(options: {
+  nowMonoMs: number;
+  lastShownAtMonoMs: number | null;
+  lastUserPromptAtMonoMs: number | null;
+  minIntervalMs?: number;
+}): boolean {
+  const minIntervalMs = options.minIntervalMs ?? 60_000;
+  if (options.lastUserPromptAtMonoMs === null) return false;
+  if (options.lastShownAtMonoMs !== null && options.nowMonoMs - options.lastShownAtMonoMs < minIntervalMs) return false;
+  if (options.nowMonoMs < options.lastUserPromptAtMonoMs) return false;
+  return true;
+}
+
+export const PROMPT_SUGGESTION_PLAN: BuiltInSubsystemPlan = {
+  id: "prompt_suggestion",
+  name: "Prompt suggestion",
+  featureGates: ["tengu_prompt_suggestion", "CLAUDE_CODE_ENABLE_PROMPT_SUGGESTION"],
+  configKnobs: ["promptSuggestion.minIntervalMs", "promptSuggestion.maxChars"],
+  triggers: [{ kind: "event", event: "post_turn_idle", note: "Legacy runs from main UI loop when idle; v3 should schedule via agent manager." }],
+  requiredCapabilities: [{ key: "storage", note: "Stores last-shown timestamps and suppression state." }],
+  mobileSafeFallback: "If storage is unavailable, do not generate suggestions; suppress silently.",
+  privacyNotes: ["Never store raw model thoughts; store only the displayed suggestion string (or a hash) and timestamps."]
+};
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  persistence: { kind: "none" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..746bf52b369537a010340c97dd2e198933403e5d
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,39 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8945ddfcc6b42147ca9ddb8329366bd7830ddbf
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,275 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+  private lastUserInputAtMonoMs: number | null = null;
+
+  private readonly backgroundLimiterName = "agents_background";
+  private readonly backgroundMaxConcurrent: number;
+  private readonly userActiveWindowMs: number;
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: {
+    host: HostCapabilities;
+    idSource: IdSource;
+    clock: MonotonicClock;
+    runtime: RuntimeKernel;
+    bus: EventBus;
+    backgroundBudget?: { maxConcurrentBackgroundAgents?: number; userActiveWindowMs?: number };
+  }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+    this.backgroundMaxConcurrent = Math.max(1, options.backgroundBudget?.maxConcurrentBackgroundAgents ?? 2);
+    this.userActiveWindowMs = Math.max(0, options.backgroundBudget?.userActiveWindowMs ?? 5_000);
+    this.runtime.defineLimiter(this.backgroundLimiterName, this.backgroundMaxConcurrent);
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/user-input") this.lastUserInputAtMonoMs = now;
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lifecycle.memoryPressure === "high") {
+      this.noteWarnOnce(`agent_mem_high:${id}`, `Skipping background agent '${inst.def.name}' due to high memory pressure`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lastUserInputAtMonoMs !== null && this.clock.nowMs() - this.lastUserInputAtMonoMs <= this.userActiveWindowMs) {
+      this.noteWarnOnce(`agent_overload:${id}`, `Deferring background agent '${inst.def.name}' while user is active`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const releases: Array<() => void> = [];
+        try {
+          if (inst.def.kind === "background") {
+            const release = await this.runtime.acquireLimiter(this.backgroundLimiterName, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+          if (inst.def.budget?.maxConcurrent !== undefined) {
+            const limiter = `agent:${inst.def.id}`;
+            this.runtime.defineLimiter(limiter, Math.max(1, inst.def.budget.maxConcurrent));
+            const release = await this.runtime.acquireLimiter(limiter, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+        } finally {
+          for (const release of releases) release();
+        }
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0de6a25dd099d64eb9e10df4ea8c630295abbff6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      kind: initial?.kind ?? "custom",
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..7bc74dee431ae197fe22b4060dbb49166e049cd0
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,5 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
+export * from "./supervision.js";
diff --git a/src/core/runtime/supervision.ts b/src/core/runtime/supervision.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2d31c2757d6e689c0e976a2ec9784b37fe45481a
--- /dev/null
+++ b/src/core/runtime/supervision.ts
@@ -0,0 +1,51 @@
+import type { RuntimeSnapshot, TaskId, TaskScopeId, TaskScopeSnapshot } from "../types/runtime.js";
+
+export type SupervisionNode = {
+  scope: TaskScopeSnapshot;
+  children: SupervisionNode[];
+};
+
+export function buildSupervisionForest(snapshot: RuntimeSnapshot): SupervisionNode[] {
+  const scopesById = new Map<TaskScopeId, TaskScopeSnapshot>();
+  for (const s of snapshot.scopes) scopesById.set(s.id, s);
+
+  const childrenByParent = new Map<TaskScopeId, TaskScopeSnapshot[]>();
+  const roots: TaskScopeSnapshot[] = [];
+
+  for (const scope of snapshot.scopes) {
+    const parent = scope.parentScopeId;
+    if (!parent) {
+      roots.push(scope);
+      continue;
+    }
+    const list = childrenByParent.get(parent) ?? [];
+    list.push(scope);
+    childrenByParent.set(parent, list);
+  }
+
+  for (const list of childrenByParent.values()) list.sort((a, b) => a.id.localeCompare(b.id));
+  roots.sort((a, b) => a.id.localeCompare(b.id));
+
+  const visit = (scope: TaskScopeSnapshot): SupervisionNode => {
+    const kids = childrenByParent.get(scope.id) ?? [];
+    return { scope, children: kids.map(visit) };
+  };
+
+  void scopesById;
+  return roots.map(visit);
+}
+
+export function detectLeakedTasks(snapshot: RuntimeSnapshot, options: { endedScopeIds: readonly TaskScopeId[] }): TaskId[] {
+  const ended = new Set<TaskScopeId>(options.endedScopeIds);
+  const leaked: TaskId[] = [];
+  for (const task of snapshot.tasks) {
+    const scopeId = task.scopeId;
+    if (!scopeId) continue;
+    if (!ended.has(scopeId)) continue;
+    if (task.state === "completed") continue;
+    leaked.push(task.id);
+  }
+  leaked.sort((a, b) => a.localeCompare(b));
+  return leaked;
+}
+
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fcf367c1a22ba8038c625399340439ecf6d991a6
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,104 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskKindV1 = "background_agent" | "remote_agent_task" | "local_bash" | "tool_run" | "custom";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  kind: LongRunningTaskKindV1;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  nextAction?: string;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

[3m[35mfile update[0m[0m
[35mM /Users/ronaldeddings/ClaudeCodeTS/src/core/agents/builtins/sessionMemory.ts[0m
@@ -3,2 +3,3 @@
 import { canonicalJsonStringify } from "../../types/canonicalJson.js";
[32m+import type { BuiltInSubsystemPlan } from "./plans.js";[0m
 
@@ -13,2 +14,8 @@
 
[32m+export type SessionMemoryCheckpointV1 = {[0m
[32m+  checkpointId: string;[0m
[32m+  transcriptEventId: string;[0m
[32m+  createdAtMonoMs: number;[0m
[32m+};[0m
[32m+[0m
 export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
@@ -27,2 +34,15 @@
 
[32m+export const SESSION_MEMORY_PLAN: BuiltInSubsystemPlan = {[0m
[32m+  id: "session_memory",[0m
[32m+  name: "Session memory",[0m
[32m+  featureGates: ["tengu_session_memory", "tengu_sm_compact"],[0m
[32m+  configKnobs: ["sessionMemory.enabled", "sessionMemory.compactionPreference", "sessionMemory.checkpointIntervalTurns"],[0m
[32m+  triggers: [[0m
[32m+    { kind: "event", event: "repl_main_thread_turn_end", note: "Legacy requires querySource === repl_main_thread; v3 should mirror via host events." }[0m
[32m+  ],[0m
[32m+  requiredCapabilities: [{ key: "storage", note: "Notes and checkpoints persist via host storage; filesystem is optional." }],[0m
[32m+  mobileSafeFallback: "If storage is unavailable, disable memory updates and fall back to in-memory summarization only for the current run.",[0m
[32m+  privacyNotes: ["Notes are user-visible summaries; never persist raw prompts/responses beyond what transcript already stores."][0m
[32m+};[0m
[32m+[0m
 export const SESSION_MEMORY_AGENT: AgentDefinition = {
@@ -32,2 +52,3 @@
   budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
[32m+  persistence: { kind: "summary", sensitivity: "internal" },[0m
   requiredCapabilities: ["storage"],
@@ -38,2 +59 @@
 };
[31m-[0m
[32mapply_patch(auto_approved=true) exited 0 in 123ms:[0m
[2mSuccess. Updated the following files:[0m
[2mM src/core/agents/builtins/sessionMemory.ts[0m
[3m[35mfile update:[0m[0m
diff --git a/src/core/agents/builtins/classifier.ts b/src/core/agents/builtins/classifier.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b7ce89ab6b26be44397fc43fccd7a99290556610
--- /dev/null
+++ b/src/core/agents/builtins/classifier.ts
@@ -0,0 +1,15 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+
+export const SESSION_QUALITY_CLASSIFIER_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_quality_classifier"),
+  name: "Session quality classifier",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 5_000, priority: "low" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
+
diff --git a/src/core/agents/builtins/index.ts b/src/core/agents/builtins/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..876f6aa22e0f1cbea4d1d382893bc930bd1e2907
--- /dev/null
+++ b/src/core/agents/builtins/index.ts
@@ -0,0 +1,5 @@
+export * from "./promptSuggestion.js";
+export * from "./magicDocs.js";
+export * from "./sessionMemory.js";
+export * from "./classifier.js";
+export * from "./plans.js";
diff --git a/src/core/agents/builtins/magicDocs.ts b/src/core/agents/builtins/magicDocs.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6b909f63377b2fbf9acbd49acea50a2d318aca0
--- /dev/null
+++ b/src/core/agents/builtins/magicDocs.ts
@@ -0,0 +1,60 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import type { BuiltInSubsystemPlan } from "./plans.js";
+
+export type MagicDocHeaderParseResult = { title: string; instructions?: string };
+
+export function parseMagicDocHeader(contents: string): MagicDocHeaderParseResult | null {
+  const header = /^#\s*MAGIC\s+DOC:\s*(.+)$/gim;
+  const match = header.exec(contents);
+  if (!match) return null;
+  const title = (match[1] ?? "").trim();
+  if (title === "") return null;
+
+  const after = contents.slice(match.index + match[0].length);
+  const lines = after.split(/\r?\n/);
+  let cursor = 0;
+  while (cursor < lines.length && lines[cursor] !== undefined && lines[cursor]!.trim() === "") cursor += 1;
+  if (cursor < lines.length) {
+    const line = lines[cursor]!.trim();
+    const instr = /^[_*](.+?)[_*]\s*$/.exec(line);
+    if (instr && instr[1]) return { title, instructions: instr[1].trim() };
+  }
+  return { title };
+}
+
+export function renderMagicDocsTemplate(template: string, vars: Record<string, string>): string {
+  let out = template;
+  for (const [k, v] of Object.entries(vars)) out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
+  return out;
+}
+
+export const MAGIC_DOCS_PLAN: BuiltInSubsystemPlan = {
+  id: "magic_docs",
+  name: "Magic Docs",
+  featureGates: ["tengu_magic_docs", "CLAUDE_CODE_ENABLE_MAGIC_DOCS"],
+  configKnobs: ["magicDocs.promptTemplatePath", "magicDocs.concurrency", "magicDocs.globRoots"],
+  triggers: [
+    { kind: "event", event: "repl_main_thread_turn_end", note: "Legacy gating checks querySource and tool_use presence." },
+    { kind: "time", intervalMs: 60_000, note: "Optional periodic rescan; must be cancellable on mobile." }
+  ],
+  requiredCapabilities: [
+    { key: "filesystem", optional: true, note: "File discovery is capability-gated; absent on mobile/web." },
+    { key: "storage", note: "Stores registry of Magic Doc refs + last-updated metadata." }
+  ],
+  mobileSafeFallback: "If filesystem is unavailable, keep the registry empty and skip updates; never attempt network-only work.",
+  privacyNotes: ["Edit-only enforcement must be applied as a hard tool gate; never allow Read/Exec for other paths."]
+};
+
+export const MAGIC_DOCS_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("magic_docs"),
+  name: "Magic Docs",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  persistence: { kind: "summary", sensitivity: "internal" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
diff --git a/src/core/agents/builtins/plans.ts b/src/core/agents/builtins/plans.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0c99b1e6e5833f600c7822749e0d240578640fbe
--- /dev/null
+++ b/src/core/agents/builtins/plans.ts
@@ -0,0 +1,23 @@
+import type { HostCapabilities } from "../../types/host.js";
+
+export type BuiltInSubsystemTriggerPlan =
+  | { kind: "time"; intervalMs: number; note?: string }
+  | { kind: "event"; event: string; note?: string };
+
+export type BuiltInSubsystemCapabilityPlan = {
+  key: keyof HostCapabilities;
+  optional?: boolean;
+  note?: string;
+};
+
+export type BuiltInSubsystemPlan = {
+  id: string;
+  name: string;
+  featureGates: string[];
+  configKnobs: string[];
+  triggers: BuiltInSubsystemTriggerPlan[];
+  requiredCapabilities: BuiltInSubsystemCapabilityPlan[];
+  mobileSafeFallback: string;
+  privacyNotes: string[];
+};
+
diff --git a/src/core/agents/builtins/promptSuggestion.ts b/src/core/agents/builtins/promptSuggestion.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e41aec8f752ad97edb16d222011b54d770a3e150
--- /dev/null
+++ b/src/core/agents/builtins/promptSuggestion.ts
@@ -0,0 +1,63 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import type { BuiltInSubsystemPlan } from "./plans.js";
+
+export type PromptSuggestionSuppressionReason =
+  | "empty"
+  | "done"
+  | "too_long"
+  | "formatting"
+  | "context_limit_error"
+  | "gratitude_or_closure";
+
+export function suppressPromptSuggestion(text: string, options: { maxChars?: number } = {}): { suppressed: boolean; reason?: PromptSuggestionSuppressionReason } {
+  const maxChars = options.maxChars ?? 100;
+  const trimmed = text.trim();
+  if (trimmed.length === 0) return { suppressed: true, reason: "empty" };
+  if (trimmed.toLowerCase() === "done") return { suppressed: true, reason: "done" };
+  if (trimmed.length >= maxChars) return { suppressed: true, reason: "too_long" };
+  if (/[`*_#>\[\]\(\)]/.test(trimmed)) return { suppressed: true, reason: "formatting" };
+  if (/context\s+limit|maximum\s+context|too\s+many\s+tokens/i.test(trimmed)) return { suppressed: true, reason: "context_limit_error" };
+  if (/\b(thanks|thank you|thx|great job|good job|all set|that'?s all|no further action)\b/i.test(trimmed)) {
+    return { suppressed: true, reason: "gratitude_or_closure" };
+  }
+  return { suppressed: false };
+}
+
+export function shouldOfferPromptSuggestion(options: {
+  nowMonoMs: number;
+  lastShownAtMonoMs: number | null;
+  lastUserPromptAtMonoMs: number | null;
+  minIntervalMs?: number;
+}): boolean {
+  const minIntervalMs = options.minIntervalMs ?? 60_000;
+  if (options.lastUserPromptAtMonoMs === null) return false;
+  if (options.lastShownAtMonoMs !== null && options.nowMonoMs - options.lastShownAtMonoMs < minIntervalMs) return false;
+  if (options.nowMonoMs < options.lastUserPromptAtMonoMs) return false;
+  return true;
+}
+
+export const PROMPT_SUGGESTION_PLAN: BuiltInSubsystemPlan = {
+  id: "prompt_suggestion",
+  name: "Prompt suggestion",
+  featureGates: ["tengu_prompt_suggestion", "CLAUDE_CODE_ENABLE_PROMPT_SUGGESTION"],
+  configKnobs: ["promptSuggestion.minIntervalMs", "promptSuggestion.maxChars"],
+  triggers: [{ kind: "event", event: "post_turn_idle", note: "Legacy runs from main UI loop when idle; v3 should schedule via agent manager." }],
+  requiredCapabilities: [{ key: "storage", note: "Stores last-shown timestamps and suppression state." }],
+  mobileSafeFallback: "If storage is unavailable, do not generate suggestions; suppress silently.",
+  privacyNotes: ["Never store raw model thoughts; store only the displayed suggestion string (or a hash) and timestamps."]
+};
+
+export const PROMPT_SUGGESTION_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("prompt_suggestion"),
+  name: "Prompt suggestion",
+  kind: "background",
+  budget: { maxTurns: 1, timeoutMs: 10_000, priority: "low" },
+  persistence: { kind: "none" },
+  requiredCapabilities: ["storage"],
+  triggers: { onHostEvent: (evt) => evt.type === "host/foregrounded" },
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
diff --git a/src/core/agents/builtins/sessionMemory.ts b/src/core/agents/builtins/sessionMemory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f296a846ecb494f987ce633653c163ce36f0ba43
--- /dev/null
+++ b/src/core/agents/builtins/sessionMemory.ts
@@ -0,0 +1,59 @@
+import type { AgentDefinition } from "../types.js";
+import { createBuiltInAgentId } from "../manager.js";
+import { canonicalJsonStringify } from "../../types/canonicalJson.js";
+import type { BuiltInSubsystemPlan } from "./plans.js";
+
+export type SessionMemoryNotesV1 = {
+  schemaVersion: 1;
+  sessionId: string;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpointId?: string;
+  notes: string;
+};
+
+export type SessionMemoryCheckpointV1 = {
+  checkpointId: string;
+  transcriptEventId: string;
+  createdAtMonoMs: number;
+};
+
+export function encodeSessionMemoryNotes(notes: SessionMemoryNotesV1): string {
+  return canonicalJsonStringify(notes);
+}
+
+export function decodeSessionMemoryNotes(text: string): SessionMemoryNotesV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Session memory notes is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported session memory notes schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (typeof obj["sessionId"] !== "string") throw new Error("Session memory notes missing sessionId");
+  if (typeof obj["notes"] !== "string") throw new Error("Session memory notes missing notes");
+  return parsed as SessionMemoryNotesV1;
+}
+
+export const SESSION_MEMORY_PLAN: BuiltInSubsystemPlan = {
+  id: "session_memory",
+  name: "Session memory",
+  featureGates: ["tengu_session_memory", "tengu_sm_compact"],
+  configKnobs: ["sessionMemory.enabled", "sessionMemory.compactionPreference", "sessionMemory.checkpointIntervalTurns"],
+  triggers: [
+    { kind: "event", event: "repl_main_thread_turn_end", note: "Legacy requires querySource === repl_main_thread; v3 should mirror via host events." }
+  ],
+  requiredCapabilities: [{ key: "storage", note: "Notes and checkpoints persist via host storage; filesystem is optional." }],
+  mobileSafeFallback: "If storage is unavailable, disable memory updates and fall back to in-memory summarization only for the current run.",
+  privacyNotes: ["Notes are user-visible summaries; never persist raw prompts/responses beyond what transcript already stores."]
+};
+
+export const SESSION_MEMORY_AGENT: AgentDefinition = {
+  id: createBuiltInAgentId("session_memory"),
+  name: "Session memory",
+  kind: "background",
+  budget: { maxConcurrent: 1, timeoutMs: 60_000, priority: "low" },
+  persistence: { kind: "summary", sensitivity: "internal" },
+  requiredCapabilities: ["storage"],
+  run: async (ctx) => {
+    void ctx;
+    return { kind: "completed" };
+  }
+};
diff --git a/src/core/agents/index.ts b/src/core/agents/index.ts
index db9908ae3ef9ee4b5eef0b45f7359708682e7b36..af29cc93cfe39cbdd90eb818fff9e5d7735b9381
--- a/src/core/agents/index.ts
+++ b/src/core/agents/index.ts
@@ -1,4 +1,6 @@
-export type AgentsPlaceholder = {
-  phase: "2";
-};
+export * from "./types.js";
+export * from "./registry.js";
+export * from "./manager.js";
+export * from "./tasks.js";
+export * from "./builtins/index.js";
 
diff --git a/src/core/agents/manager.ts b/src/core/agents/manager.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8945ddfcc6b42147ca9ddb8329366bd7830ddbf
--- /dev/null
+++ b/src/core/agents/manager.ts
@@ -0,0 +1,275 @@
+import type { EventBus } from "../events/bus.js";
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { RuntimeKernel } from "../runtime/kernel.js";
+import type { TaskScope } from "../runtime/scope.js";
+import type { HostCapabilities } from "../types/host.js";
+import type { HostEvent } from "../types/events.js";
+import type { AgentId, AgentSummaryV1 } from "../types/agents.js";
+import { asAgentId } from "../types/agents.js";
+import type { CancellationReason, TaskResult } from "../types/runtime.js";
+import type { AgentDefinition, AgentInstance, AgentRunResult } from "./types.js";
+import { AgentRegistry } from "./registry.js";
+
+type LifecycleState = {
+  backgrounded: boolean;
+  network: "online" | "offline" | "unknown";
+  memoryPressure: "low" | "medium" | "high" | "unknown";
+};
+
+function initialLifecycleState(): LifecycleState {
+  return { backgrounded: false, network: "unknown", memoryPressure: "unknown" };
+}
+
+export class AgentManager {
+  private readonly host: HostCapabilities;
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly runtime: RuntimeKernel;
+  private readonly bus: EventBus;
+
+  private readonly registry = new AgentRegistry();
+  private readonly scope: TaskScope;
+  private lifecycle: LifecycleState = initialLifecycleState();
+  private lastUserInputAtMonoMs: number | null = null;
+
+  private readonly backgroundLimiterName = "agents_background";
+  private readonly backgroundMaxConcurrent: number;
+  private readonly userActiveWindowMs: number;
+
+  private readonly agents = new Map<AgentId, AgentInstance>();
+  private readonly warnOnce = new Set<string>();
+
+  constructor(options: {
+    host: HostCapabilities;
+    idSource: IdSource;
+    clock: MonotonicClock;
+    runtime: RuntimeKernel;
+    bus: EventBus;
+    backgroundBudget?: { maxConcurrentBackgroundAgents?: number; userActiveWindowMs?: number };
+  }) {
+    this.host = options.host;
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+    this.runtime = options.runtime;
+    this.bus = options.bus;
+    this.scope = this.runtime.createScope({ kind: "agent", label: "agent_manager" });
+    this.backgroundMaxConcurrent = Math.max(1, options.backgroundBudget?.maxConcurrentBackgroundAgents ?? 2);
+    this.userActiveWindowMs = Math.max(0, options.backgroundBudget?.userActiveWindowMs ?? 5_000);
+    this.runtime.defineLimiter(this.backgroundLimiterName, this.backgroundMaxConcurrent);
+  }
+
+  getRegistry(): AgentRegistry {
+    return this.registry;
+  }
+
+  register(def: AgentDefinition): void {
+    this.registry.register(def);
+    const now = this.clock.nowMs();
+    const summary: AgentSummaryV1 = {
+      id: def.id,
+      kind: def.kind,
+      name: def.name,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(def.persistence ? { persistence: def.persistence } : {})
+    };
+    const agentScope = this.runtime.createScope({ kind: "agent", label: `agent:${def.name}`, parentScopeId: this.scope.id });
+    this.agents.set(def.id, { def, summary, scope: agentScope, taskId: null, turnsUsed: 0 });
+    void this.bus.emit({ type: "agent/updated", agent: summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  getAgent(id: AgentId): AgentSummaryV1 | null {
+    return this.agents.get(id)?.summary ?? null;
+  }
+
+  listAgents(): AgentSummaryV1[] {
+    return [...this.agents.values()]
+      .map((a) => a.summary)
+      .sort((a, b) => a.name.localeCompare(b.name));
+  }
+
+  async handleHostEvent(event: HostEvent): Promise<void> {
+    const now = this.clock.nowMs();
+    if (event.type === "host/user-input") this.lastUserInputAtMonoMs = now;
+    if (event.type === "host/backgrounded") this.lifecycle = { ...this.lifecycle, backgrounded: true };
+    if (event.type === "host/foregrounded") this.lifecycle = { ...this.lifecycle, backgrounded: false };
+    if (event.type === "host/network-state") this.lifecycle = { ...this.lifecycle, network: event.state };
+    if (event.type === "host/memory-pressure") this.lifecycle = { ...this.lifecycle, memoryPressure: event.level };
+
+    for (const inst of this.agents.values()) inst.lastHostEventAtMonoMs = now;
+
+    for (const inst of this.agents.values()) {
+      const shouldRun = inst.def.triggers?.onHostEvent ? inst.def.triggers.onHostEvent(event) : false;
+      if (shouldRun) await this.startAgent(inst.def.id);
+    }
+
+    if (event.type === "host/backgrounded") {
+      for (const inst of this.agents.values()) {
+        if (inst.def.kind !== "background") continue;
+        if (inst.summary.state === "running" || inst.summary.state === "awaiting_input") {
+          await this.cancelAgent(inst.def.id, { kind: "host_lifecycle", event: "backgrounded", message: "host backgrounded" });
+        }
+      }
+    }
+  }
+
+  async startAgent(id: AgentId): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) throw new Error(`Unknown agent: ${id}`);
+    if (inst.summary.state === "running") return;
+    if (inst.def.kind === "background" && this.lifecycle.backgrounded) {
+      this.noteWarnOnce(`agent_backgrounded:${id}`, `Skipping background agent '${inst.def.name}' while backgrounded`);
+      return;
+    }
+    if (inst.def.requiredCapabilities?.includes("network") && this.lifecycle.network === "offline") {
+      this.noteWarnOnce(`agent_offline:${id}`, `Skipping agent '${inst.def.name}' while offline`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lifecycle.memoryPressure === "high") {
+      this.noteWarnOnce(`agent_mem_high:${id}`, `Skipping background agent '${inst.def.name}' due to high memory pressure`);
+      return;
+    }
+    if (inst.def.kind === "background" && this.lastUserInputAtMonoMs !== null && this.clock.nowMs() - this.lastUserInputAtMonoMs <= this.userActiveWindowMs) {
+      this.noteWarnOnce(`agent_overload:${id}`, `Deferring background agent '${inst.def.name}' while user is active`);
+      return;
+    }
+
+    const now = this.clock.nowMs();
+    inst.turnsUsed += 1;
+    if (inst.def.budget?.maxTurns !== undefined && inst.turnsUsed > inst.def.budget.maxTurns) {
+      const next = { ...inst.summary, state: "completed" as const, updatedAtMonoMs: now, endedAtMonoMs: now };
+      inst.summary = next;
+      await this.bus.emit({ type: "agent/updated", agent: next }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      return;
+    }
+
+    const nextRunning: AgentSummaryV1 = { ...inst.summary, state: "running", updatedAtMonoMs: now, ...(inst.summary.startedAtMonoMs ? {} : { startedAtMonoMs: now }) };
+    inst.summary = nextRunning;
+    await this.bus.emit({ type: "agent/updated", agent: nextRunning }, { channel: "debug", severity: "info", sensitivity: "internal" });
+
+    const taskHandle = inst.scope.spawn(
+      async (task) => {
+        const releases: Array<() => void> = [];
+        try {
+          if (inst.def.kind === "background") {
+            const release = await this.runtime.acquireLimiter(this.backgroundLimiterName, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+          if (inst.def.budget?.maxConcurrent !== undefined) {
+            const limiter = `agent:${inst.def.id}`;
+            this.runtime.defineLimiter(limiter, Math.max(1, inst.def.budget.maxConcurrent));
+            const release = await this.runtime.acquireLimiter(limiter, { ownerTaskId: task.taskId, signal: task.signal });
+            releases.push(release);
+          }
+
+        const emit = async (evt: import("./types.js").AgentEvent) => {
+          if (evt.type === "agent/state") await this.bus.emit({ type: "agent/updated", agent: evt.agent }, { channel: "debug", severity: "info" });
+          if (evt.type === "agent/progress") {
+            await this.bus.emit(
+              { type: "agent/progress", agentId: evt.agentId, progress: evt.progress },
+              { channel: "debug", severity: "info", sensitivity: evt.sensitivity }
+            );
+          }
+          if (evt.type === "agent/result") {
+            await this.bus.emit(
+              { type: "agent/result", agentId: evt.agentId, result: evt.result },
+              { channel: "debug", severity: evt.result.kind === "failed" ? "error" : "info", sensitivity: evt.sensitivity }
+            );
+          }
+        };
+
+        const ctx: import("./types.js").AgentContext = {
+          agentId: inst.def.id,
+          signal: task.signal,
+          host: this.host,
+          task,
+          scope: inst.scope,
+          emit,
+          nowMonoMs: () => this.clock.nowMs(),
+          getLifecycle: () => ({ ...this.lifecycle })
+        };
+
+        const result: AgentRunResult = await inst.def.run(ctx);
+        void emit({ type: "agent/result", agentId: inst.def.id, result, sensitivity: "internal" });
+        return result;
+        } finally {
+          for (const release of releases) release();
+        }
+      },
+      {
+        label: `agent_run:${inst.def.name}`,
+        priority: inst.def.budget?.priority ?? "low",
+        ...(inst.def.budget?.timeoutMs !== undefined ? { timeoutMs: inst.def.budget.timeoutMs } : {})
+      }
+    );
+
+    inst.taskId = taskHandle.id;
+    void taskHandle.done.then(
+      async (res: TaskResult) => {
+        const now2 = this.clock.nowMs();
+        const agentResult: AgentRunResult =
+          res.kind === "success"
+            ? (res.value as AgentRunResult)
+            : res.kind === "cancelled" || res.kind === "timeout"
+              ? { kind: "cancelled", reason: res.reason }
+              : res.kind === "error"
+                ? { kind: "failed", error: res.error.message }
+                : { kind: "failed", error: "unknown task outcome" };
+        const final = this.finalizeFromResult(inst, agentResult);
+        inst.summary = { ...final, updatedAtMonoMs: now2, endedAtMonoMs: now2 };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+      },
+      async () => {
+        const now2 = this.clock.nowMs();
+        inst.summary = { ...inst.summary, state: "failed", updatedAtMonoMs: now2, endedAtMonoMs: now2, error: "agent task promise rejected" };
+        inst.taskId = null;
+        await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "error", sensitivity: "internal" });
+      }
+    );
+  }
+
+  async cancelAgent(id: AgentId, reason: CancellationReason): Promise<void> {
+    const inst = this.agents.get(id);
+    if (!inst) return;
+    const now = this.clock.nowMs();
+    if (inst.summary.state === "cancelled" || inst.summary.state === "completed" || inst.summary.state === "failed") return;
+    inst.summary = { ...inst.summary, state: "cancelled", updatedAtMonoMs: now, endedAtMonoMs: now, cancelled: reason };
+    inst.scope.close(reason).catch(() => {});
+    await this.bus.emit({ type: "agent/updated", agent: inst.summary }, { channel: "debug", severity: "info", sensitivity: "internal" });
+  }
+
+  async stop(options: { timeoutMs?: number; maxTicks?: number } = {}): Promise<void> {
+    const reason = { kind: "stop_request", message: "agent manager stopped" } as const;
+    await this.scope.close(reason);
+
+    const maxTicks = options.maxTicks ?? 10_000;
+    const deadline = this.clock.nowMs() + (options.timeoutMs ?? 10_000);
+    while (this.clock.nowMs() < deadline) {
+      await this.runtime.getScheduler().tick({ maxRunnables: 1000 });
+      const running = [...this.agents.values()].some((a) => a.summary.state === "running" || a.summary.state === "awaiting_input");
+      if (!running) return;
+      if (this.runtime.getScheduler().currentTick > maxTicks) break;
+    }
+  }
+
+  private finalizeFromResult(inst: AgentInstance, result: AgentRunResult): AgentSummaryV1 {
+    const base = inst.summary;
+    if (result.kind === "completed") return { ...base, state: "completed" };
+    if (result.kind === "cancelled") return { ...base, state: "cancelled", cancelled: result.reason };
+    if (result.kind === "failed") return { ...base, state: "failed", error: result.error };
+    return { ...base, state: "failed", error: "unknown agent result" };
+  }
+
+  private noteWarnOnce(key: string, message: string): void {
+    if (this.warnOnce.has(key)) return;
+    this.warnOnce.add(key);
+    void this.bus.emit({ type: "diag/log", level: "warn", message }, { channel: "diagnostic", severity: "warn", sensitivity: "internal" });
+  }
+}
+
+export function createBuiltInAgentId(name: string): AgentId {
+  return asAgentId(`agent:${name}`);
+}
diff --git a/src/core/agents/registry.ts b/src/core/agents/registry.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8714b935504179ffcb3e645bfd9e12d5e8732796
--- /dev/null
+++ b/src/core/agents/registry.ts
@@ -0,0 +1,21 @@
+import type { AgentDefinition } from "./types.js";
+import type { AgentId } from "../types/agents.js";
+
+export class AgentRegistry {
+  private readonly byId = new Map<AgentId, AgentDefinition>();
+
+  register(def: AgentDefinition): void {
+    const existing = this.byId.get(def.id);
+    if (existing) throw new Error(`Agent already registered: ${def.id}`);
+    this.byId.set(def.id, def);
+  }
+
+  get(id: AgentId): AgentDefinition | null {
+    return this.byId.get(id) ?? null;
+  }
+
+  list(): AgentDefinition[] {
+    return [...this.byId.values()].sort((a, b) => a.name.localeCompare(b.name));
+  }
+}
+
diff --git a/src/core/agents/tasks.ts b/src/core/agents/tasks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0de6a25dd099d64eb9e10df4ea8c630295abbff6
--- /dev/null
+++ b/src/core/agents/tasks.ts
@@ -0,0 +1,97 @@
+import type { MonotonicClock } from "../runtime/clock.js";
+import type { IdSource } from "../runtime/ids.js";
+import type { LongRunningTaskEntityV1, DurableTaskRecordV1 } from "../types/agents.js";
+import { canonicalJsonStringify } from "../types/canonicalJson.js";
+import type { HostStorage, StorageNamespace } from "../types/host.js";
+
+export const DURABLE_TASKS_STORAGE_KEY = "tasks/durable_tasks_v1";
+
+export type DurableTasksDocumentV1 = {
+  schemaVersion: 1;
+  tasks: Record<string, DurableTaskRecordV1>;
+};
+
+export function encodeDurableTasksDocument(doc: DurableTasksDocumentV1): string {
+  return canonicalJsonStringify(doc);
+}
+
+export function decodeDurableTasksDocument(text: string): DurableTasksDocumentV1 {
+  const parsed = JSON.parse(text) as unknown;
+  if (!parsed || typeof parsed !== "object") throw new Error("Durable tasks document is not an object");
+  const obj = parsed as Record<string, unknown>;
+  if (obj["schemaVersion"] !== 1) throw new Error(`Unsupported durable tasks schemaVersion: ${String(obj["schemaVersion"])}`);
+  if (!("tasks" in obj)) throw new Error("Durable tasks document missing tasks");
+  return parsed as DurableTasksDocumentV1;
+}
+
+export async function loadDurableTasks(storage: HostStorage, namespace: StorageNamespace, key = DURABLE_TASKS_STORAGE_KEY): Promise<DurableTasksDocumentV1 | null> {
+  const found = await storage.get(namespace, key);
+  if (!found) return null;
+  return decodeDurableTasksDocument(found.value);
+}
+
+export async function saveDurableTasks(
+  storage: HostStorage,
+  namespace: StorageNamespace,
+  doc: DurableTasksDocumentV1,
+  key = DURABLE_TASKS_STORAGE_KEY,
+  options?: { expectedVersion?: string | null }
+): Promise<{ version: string }> {
+  const encoded = encodeDurableTasksDocument(doc);
+  return await storage.set(namespace, key, encoded, options);
+}
+
+export type TaskRegistrySnapshot = {
+  tasks: Record<string, LongRunningTaskEntityV1>;
+};
+
+export class TaskRegistry {
+  private readonly idSource: IdSource;
+  private readonly clock: MonotonicClock;
+  private readonly tasks = new Map<string, LongRunningTaskEntityV1>();
+
+  constructor(options: { idSource: IdSource; clock: MonotonicClock }) {
+    this.idSource = options.idSource;
+    this.clock = options.clock;
+  }
+
+  snapshot(): TaskRegistrySnapshot {
+    return { tasks: Object.fromEntries([...this.tasks.entries()].sort((a, b) => a[0].localeCompare(b[0]))) };
+  }
+
+  create(label: string, initial?: Partial<LongRunningTaskEntityV1>): LongRunningTaskEntityV1 {
+    const id = this.idSource.nextId("lrt");
+    const now = this.clock.nowMs();
+    const task: LongRunningTaskEntityV1 = {
+      id,
+      kind: initial?.kind ?? "custom",
+      label,
+      state: "scheduled",
+      createdAtMonoMs: now,
+      updatedAtMonoMs: now,
+      ...(initial ?? {})
+    };
+    this.tasks.set(id, task);
+    return task;
+  }
+
+  upsert(task: LongRunningTaskEntityV1): void {
+    this.tasks.set(task.id, task);
+  }
+
+  get(id: string): LongRunningTaskEntityV1 | null {
+    return this.tasks.get(id) ?? null;
+  }
+
+  update(id: string, updater: (prev: LongRunningTaskEntityV1) => LongRunningTaskEntityV1): LongRunningTaskEntityV1 | null {
+    const prev = this.tasks.get(id);
+    if (!prev) return null;
+    const next = updater(prev);
+    this.tasks.set(id, next);
+    return next;
+  }
+
+  remove(id: string): void {
+    this.tasks.delete(id);
+  }
+}
diff --git a/src/core/agents/types.ts b/src/core/agents/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d64b575daf7892facbbbd24ebcaaba4af01ace4c
--- /dev/null
+++ b/src/core/agents/types.ts
@@ -0,0 +1,73 @@
+import type { HostCapabilities } from "../types/host.js";
+import type { EngineEventSensitivity, HostEvent } from "../types/events.js";
+import type {
+  AgentBudgetV1,
+  AgentId,
+  AgentKindV1,
+  AgentLifecycleStateV1,
+  AgentPersistencePolicyV1,
+  AgentProgressV1,
+  AgentRunResultV1,
+  AgentSummaryV1
+} from "../types/agents.js";
+import type { TaskExecutionContext, TaskScope } from "../runtime/scope.js";
+import type { CancellationReason } from "../types/runtime.js";
+
+export type BackgroundAgentQualification = {
+  kind: AgentKindV1;
+  rationale: string;
+};
+
+export function qualifyAgentRun(input: { kind: AgentKindV1; invokedFrom: "user_prompt" | "event" | "timer" | "startup" }): BackgroundAgentQualification {
+  if (input.kind === "foreground") return { kind: "foreground", rationale: "Explicitly user-invoked work bound to a prompt/command." };
+  return {
+    kind: "background",
+    rationale:
+      input.invokedFrom === "user_prompt"
+        ? "Agent marked background but invoked from a prompt; treat as background with explicit UI surfacing."
+        : "Non-blocking work that must be lifecycle-aware and cooperatively scheduled."
+  };
+}
+
+export type AgentRunResult = AgentRunResultV1;
+
+export type AgentEvent =
+  | { type: "agent/state"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1; sensitivity: EngineEventSensitivity }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResult; sensitivity: EngineEventSensitivity };
+
+export type AgentEventSink = (event: AgentEvent) => Promise<void>;
+
+export type AgentContext = {
+  agentId: AgentId;
+  signal: AbortSignal;
+  host: HostCapabilities;
+  task: TaskExecutionContext;
+  scope: TaskScope;
+  emit: AgentEventSink;
+  nowMonoMs: () => number;
+  getLifecycle: () => { backgrounded: boolean; network: "online" | "offline" | "unknown"; memoryPressure: "low" | "medium" | "high" | "unknown" };
+};
+
+export type AgentDefinition = {
+  id: AgentId;
+  name: string;
+  kind: AgentKindV1;
+  budget?: AgentBudgetV1;
+  persistence?: AgentPersistencePolicyV1;
+  requiredCapabilities?: Array<keyof HostCapabilities>;
+  triggers?: {
+    onHostEvent?: (event: HostEvent) => boolean;
+    intervalMs?: number;
+  };
+  run: (ctx: AgentContext) => Promise<AgentRunResult>;
+};
+
+export type AgentInstance = {
+  def: AgentDefinition;
+  summary: AgentSummaryV1;
+  scope: TaskScope;
+  taskId: string | null;
+  turnsUsed: number;
+  lastHostEventAtMonoMs?: number;
+};
diff --git a/src/core/runtime/index.ts b/src/core/runtime/index.ts
index 97e6eb69401dc45e14e8fc460565055648d6d344..7bc74dee431ae197fe22b4060dbb49166e049cd0
--- a/src/core/runtime/index.ts
+++ b/src/core/runtime/index.ts
@@ -11,3 +11,5 @@
 export * from "./replay.js";
 export * from "./replayDiff.js";
 export * from "./seededRandom.js";
+export * from "./worker.js";
+export * from "./supervision.js";
diff --git a/src/core/runtime/supervision.ts b/src/core/runtime/supervision.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2d31c2757d6e689c0e976a2ec9784b37fe45481a
--- /dev/null
+++ b/src/core/runtime/supervision.ts
@@ -0,0 +1,51 @@
+import type { RuntimeSnapshot, TaskId, TaskScopeId, TaskScopeSnapshot } from "../types/runtime.js";
+
+export type SupervisionNode = {
+  scope: TaskScopeSnapshot;
+  children: SupervisionNode[];
+};
+
+export function buildSupervisionForest(snapshot: RuntimeSnapshot): SupervisionNode[] {
+  const scopesById = new Map<TaskScopeId, TaskScopeSnapshot>();
+  for (const s of snapshot.scopes) scopesById.set(s.id, s);
+
+  const childrenByParent = new Map<TaskScopeId, TaskScopeSnapshot[]>();
+  const roots: TaskScopeSnapshot[] = [];
+
+  for (const scope of snapshot.scopes) {
+    const parent = scope.parentScopeId;
+    if (!parent) {
+      roots.push(scope);
+      continue;
+    }
+    const list = childrenByParent.get(parent) ?? [];
+    list.push(scope);
+    childrenByParent.set(parent, list);
+  }
+
+  for (const list of childrenByParent.values()) list.sort((a, b) => a.id.localeCompare(b.id));
+  roots.sort((a, b) => a.id.localeCompare(b.id));
+
+  const visit = (scope: TaskScopeSnapshot): SupervisionNode => {
+    const kids = childrenByParent.get(scope.id) ?? [];
+    return { scope, children: kids.map(visit) };
+  };
+
+  void scopesById;
+  return roots.map(visit);
+}
+
+export function detectLeakedTasks(snapshot: RuntimeSnapshot, options: { endedScopeIds: readonly TaskScopeId[] }): TaskId[] {
+  const ended = new Set<TaskScopeId>(options.endedScopeIds);
+  const leaked: TaskId[] = [];
+  for (const task of snapshot.tasks) {
+    const scopeId = task.scopeId;
+    if (!scopeId) continue;
+    if (!ended.has(scopeId)) continue;
+    if (task.state === "completed") continue;
+    leaked.push(task.id);
+  }
+  leaked.sort((a, b) => a.localeCompare(b));
+  return leaked;
+}
+
diff --git a/src/core/runtime/worker.ts b/src/core/runtime/worker.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ab5849c7130aabe5790e78a53a3376e63e237
--- /dev/null
+++ b/src/core/runtime/worker.ts
@@ -0,0 +1,122 @@
+import type { CancellationReason } from "../types/runtime.js";
+import type { Capability, HostCapabilities } from "../types/host.js";
+import { unavailableCapability } from "../types/host.js";
+import { createCapabilityView } from "../capabilities/view.js";
+
+export type JsonSerializable =
+  | null
+  | boolean
+  | number
+  | string
+  | JsonSerializable[]
+  | { [k: string]: JsonSerializable };
+
+export type WorkerRequest = {
+  id: string;
+  type: string;
+  payload: JsonSerializable;
+};
+
+export type WorkerResponse =
+  | { id: string; ok: true; payload: JsonSerializable }
+  | { id: string; ok: false; error: string };
+
+export type WorkerPort = {
+  post: (msg: WorkerRequest) => Promise<void>;
+  onMessage: (handler: (msg: WorkerResponse) => void) => () => void;
+  close?: () => Promise<void>;
+};
+
+export type WorkerHandler = (req: WorkerRequest, ctx: { signal?: AbortSignal }) => Promise<WorkerResponse>;
+
+export function assertJsonSerializable(value: unknown): asserts value is JsonSerializable {
+  try {
+    JSON.stringify(value);
+  } catch (e) {
+    throw new Error(`Value is not JSON-serializable: ${e instanceof Error ? e.message : String(e)}`);
+  }
+}
+
+export function createInMemoryWorkerPair(handler: WorkerHandler): { main: WorkerPort; worker: WorkerPort } {
+  const mainHandlers = new Set<(msg: WorkerResponse) => void>();
+  const workerHandlers = new Set<(msg: WorkerResponse) => void>();
+
+  const deliver = async (handlers: Set<(msg: WorkerResponse) => void>, msg: WorkerResponse) => {
+    for (const h of handlers) h(msg);
+  };
+
+  const mkPort = (direction: "main_to_worker" | "worker_to_main"): WorkerPort => {
+    const isMain = direction === "main_to_worker";
+    return {
+      post: async (req) => {
+        assertJsonSerializable(req.payload);
+        if (isMain) {
+          const res = await handler(req, {});
+          await deliver(mainHandlers, res);
+        } else {
+          await deliver(workerHandlers, { id: req.id, ok: true, payload: req.payload });
+        }
+      },
+      onMessage: (cb) => {
+        const set = isMain ? mainHandlers : workerHandlers;
+        set.add(cb);
+        return () => set.delete(cb);
+      }
+    };
+  };
+
+  return { main: mkPort("main_to_worker"), worker: mkPort("worker_to_main") };
+}
+
+export async function callWorker(port: WorkerPort, request: WorkerRequest, options: { signal?: AbortSignal; timeoutMs?: number } = {}): Promise<WorkerResponse> {
+  if (options.signal?.aborted) throw options.signal.reason ?? new Error("aborted");
+  const controller = new AbortController();
+  if (options.signal) options.signal.addEventListener("abort", () => controller.abort(options.signal!.reason), { once: true });
+
+  return await new Promise<WorkerResponse>((resolve, reject) => {
+    const timeout = options.timeoutMs
+      ? setTimeout(() => {
+          controller.abort({ kind: "timeout", message: "worker call timeout" } satisfies CancellationReason);
+        }, options.timeoutMs)
+      : null;
+
+    const unsub = port.onMessage((msg) => {
+      if (msg.id !== request.id) return;
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      resolve(msg);
+    });
+
+    const onAbort = () => {
+      if (timeout) clearTimeout(timeout);
+      unsub();
+      reject(controller.signal.reason ?? new Error("aborted"));
+    };
+    controller.signal.addEventListener("abort", onAbort, { once: true });
+
+    port
+      .post(request)
+      .catch((err) => {
+        if (timeout) clearTimeout(timeout);
+        unsub();
+        reject(err);
+      })
+      .finally(() => {
+        controller.signal.removeEventListener("abort", onAbort);
+      });
+  });
+}
+
+export function filterHostCapabilitiesForWorker(
+  host: HostCapabilities,
+  allowed: readonly (keyof HostCapabilities)[],
+  options?: { policyId?: string }
+): HostCapabilities {
+  const filtered = createCapabilityView(host, allowed, { policyId: options?.policyId ?? "worker" });
+  const deny: Partial<Record<keyof HostCapabilities, Capability<any>>> = {
+    secrets: unavailableCapability({ kind: "disabled", message: "secrets not available in worker" }),
+    ipc: unavailableCapability({ kind: "disabled", message: "ipc not available in worker" })
+  };
+  return { ...filtered, ...deny } as HostCapabilities;
+}
+
diff --git a/src/core/state/state.ts b/src/core/state/state.ts
index 7cef45fd8d39ae795694312986be82c6e2f617f1..91371ad90cc09ff5e65e2eaefa4039a476040ba9
--- a/src/core/state/state.ts
+++ b/src/core/state/state.ts
@@ -15,6 +15,7 @@
   type TranscriptEventV1,
   type TranscriptLogV1
 } from "../types/state.js";
+import type { LongRunningTaskEntityV1 } from "../types/agents.js";
 import { SCHEMA_VERSION } from "../types/schema.js";
 import type { CancellationReason } from "../types/runtime.js";
 import type { HostEvent } from "../types/events.js";
@@ -99,6 +100,8 @@
   | { type: "app/restore-persisted"; persisted: PersistedAppStateV1 }
   | { type: "app/session-created"; session: PersistedSessionStateV1 }
   | { type: "app/session-lifecycle-set"; sessionId: SessionId; lifecycle: SessionLifecycleState; tsMonoMs: number; error?: string }
+  | { type: "app/task/upsert"; task: LongRunningTaskEntityV1; tsMonoMs: number }
+  | { type: "app/task/remove"; taskId: string; tsMonoMs: number }
   | { type: "session/transcript/append-event"; sessionId: SessionId; event: TranscriptEventV1; tsMonoMs: number }
   | { type: "session/transcript/set-bounded"; sessionId: SessionId; bounded: TranscriptLogV1["bounded"]; tsMonoMs: number }
   | { type: "session/attachment/upsert"; sessionId: SessionId; attachment: AttachmentRefV1; tsMonoMs: number }
@@ -164,7 +167,8 @@
     appId: asAppId(options.idSource.nextId("app")),
     createdAtMonoMs: now,
     updatedAtMonoMs: now,
-    sessions: {}
+    sessions: {},
+    tasks: {}
   };
 }
 
@@ -219,7 +223,10 @@
     };
   }
 
-  return { persisted: { ...persisted, sessions: nextSessions, updatedAtMonoMs: nowMonoMs }, report };
+  return {
+    persisted: { ...persisted, sessions: nextSessions, tasks: persisted.tasks ?? {}, updatedAtMonoMs: nowMonoMs },
+    report
+  };
 }
 
 function updatePersistedSession(
@@ -291,6 +298,18 @@
       if (action.lifecycle === "active") nextPersisted.activeSessionId = action.sessionId;
       return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
     }
+    case "app/task/upsert": {
+      const tasks = { ...(state.persisted.tasks ?? {}), [action.task.id]: action.task };
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
+    case "app/task/remove": {
+      const existing = state.persisted.tasks ?? {};
+      if (!(action.taskId in existing)) return { state, effects: [], events: [] };
+      const { [action.taskId]: _removed, ...rest } = existing;
+      const nextPersisted: PersistedAppStateV1 = { ...state.persisted, tasks: rest, updatedAtMonoMs: Math.max(state.persisted.updatedAtMonoMs, action.tsMonoMs) };
+      return { state: { ...state, persisted: nextPersisted }, effects: [], events: [{ type: "ui/state-changed", actionType: action.type }] };
+    }
     case "session/transcript/append-event": {
       const nextPersisted = updatePersistedSession(state.persisted, action.sessionId, action.tsMonoMs, (sess) => ({
         ...sess,
diff --git a/src/core/types/agents.ts b/src/core/types/agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fcf367c1a22ba8038c625399340439ecf6d991a6
--- /dev/null
+++ b/src/core/types/agents.ts
@@ -0,0 +1,104 @@
+import type { EngineEventSensitivity } from "./events.js";
+import type { CancellationReason, TaskPriority } from "./runtime.js";
+
+export type AgentId = string & { readonly __brand: "AgentId" };
+export function asAgentId(value: string): AgentId {
+  return value as AgentId;
+}
+
+export type AgentKindV1 = "background" | "foreground";
+
+export type AgentLifecycleStateV1 =
+  | "scheduled"
+  | "running"
+  | "awaiting_input"
+  | "paused"
+  | "completed"
+  | "failed"
+  | "cancelled";
+
+export type AgentBudgetV1 = {
+  timeoutMs?: number;
+  maxTurns?: number;
+  maxConcurrent?: number;
+  priority?: TaskPriority;
+};
+
+export type AgentPersistencePolicyV1 =
+  | { kind: "none" }
+  | { kind: "summary"; sensitivity?: EngineEventSensitivity }
+  | { kind: "full_trace"; sensitivity?: EngineEventSensitivity };
+
+export type AgentProgressV1 = {
+  tsMonoMs: number;
+  message?: string;
+  percent?: number;
+  details?: unknown;
+};
+
+export type AgentSummaryV1 = {
+  id: AgentId;
+  kind: AgentKindV1;
+  name: string;
+  state: AgentLifecycleStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  lastProgress?: AgentProgressV1;
+  error?: string;
+  cancelled?: CancellationReason;
+  persistence?: AgentPersistencePolicyV1;
+};
+
+export type AgentRunResultV1 =
+  | { kind: "completed"; summary?: string }
+  | { kind: "failed"; error: string }
+  | { kind: "cancelled"; reason: CancellationReason };
+
+export type DurableTaskCheckpointV1 = {
+  cursor: string;
+  tsMonoMs: number;
+  summary?: string;
+};
+
+export type DurableTaskRetryStateV1 = {
+  attempt: number;
+  nextDelayMs?: number;
+  lastError?: string;
+};
+
+export type DurableTaskRecordV1 = {
+  schemaVersion: 1;
+  id: string;
+  label?: string;
+  scope: "app" | "workspace" | "session";
+  sessionId?: string;
+  workspaceId?: string;
+  requiredCapabilities?: string[];
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  lastCheckpoint?: DurableTaskCheckpointV1;
+  retry?: DurableTaskRetryStateV1;
+};
+
+export type LongRunningTaskStateV1 = "scheduled" | "running" | "paused" | "completed" | "failed" | "cancelled";
+
+export type LongRunningTaskKindV1 = "background_agent" | "remote_agent_task" | "local_bash" | "tool_run" | "custom";
+
+export type LongRunningTaskEntityV1 = {
+  id: string;
+  kind: LongRunningTaskKindV1;
+  label: string;
+  state: LongRunningTaskStateV1;
+  createdAtMonoMs: number;
+  updatedAtMonoMs: number;
+  startedAtMonoMs?: number;
+  endedAtMonoMs?: number;
+  priority?: TaskPriority;
+  progress?: AgentProgressV1;
+  nextAction?: string;
+  error?: string;
+  cancelled?: CancellationReason;
+  durable?: DurableTaskRecordV1;
+};
diff --git a/src/core/types/events.ts b/src/core/types/events.ts
index 43abcf8d53b74d4f8b7d542bd7e2e65b48866e1e..55163643a244760f2844125a70c3c75d5e12b35d
--- a/src/core/types/events.ts
+++ b/src/core/types/events.ts
@@ -2,6 +2,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import type { RuntimeShutdownSummary, RuntimeSnapshot, TaskId } from "./runtime.js";
 import type { StateSnapshotV1 } from "./state.js";
+import type { AgentId, AgentProgressV1, AgentRunResultV1, AgentSummaryV1 } from "./agents.js";
 
 export type EngineEventChannel = "ui" | "diagnostic" | "telemetry" | "transcript" | "debug";
 export type EngineEventSeverity = "debug" | "info" | "warn" | "error";
@@ -32,6 +33,9 @@
   | { type: "settings/snapshot"; settings: unknown }
   | { type: "ui/notification"; message: string; title?: string; kind?: string }
   | { type: "ui/prompt"; promptId: string; message: string }
+  | { type: "agent/updated"; agent: AgentSummaryV1 }
+  | { type: "agent/progress"; agentId: AgentId; progress: AgentProgressV1 }
+  | { type: "agent/result"; agentId: AgentId; result: AgentRunResultV1 }
   | {
       type: "ui/approval-request";
       requestId: string;
@@ -60,4 +64,6 @@
   | { type: "host/cancel"; requestId?: string }
   | { type: "host/stop" }
   | { type: "host/backgrounded" }
-  | { type: "host/foregrounded" };
+  | { type: "host/foregrounded" }
+  | { type: "host/network-state"; state: "online" | "offline" | "unknown" }
+  | { type: "host/memory-pressure"; level: "low" | "medium" | "high" | "unknown" };
diff --git a/src/core/types/index.ts b/src/core/types/index.ts
index 5e76720643cda173a645ca4d6a363fa82d3ff9d7..b0acfbf69dc6602327793d823e0d0a25c2f7e882
--- a/src/core/types/index.ts
+++ b/src/core/types/index.ts
@@ -7,4 +7,5 @@
 export * from "./workspace.js";
 export * from "./engine.js";
 export * from "./runtime.js";
+export * from "./agents.js";
 export * from "./state.js";
diff --git a/src/core/types/runtime.ts b/src/core/types/runtime.ts
index 91e061628a09673f87f41a6f671622bfc0855b4b..c305b040b87a8d4e19a21793d58c42bed77e1548
--- a/src/core/types/runtime.ts
+++ b/src/core/types/runtime.ts
@@ -43,6 +43,7 @@
   | "tool_run"
   | "hook_run"
   | "mcp_connection"
+  | "agent"
   | "custom";
 
 export type TaskScopeSnapshot = {
diff --git a/src/core/types/state.ts b/src/core/types/state.ts
index d1cef9520204aa7065e3b3d575f8031b78a022f7..0516fa5c0428d5ffdf23e8dcde62e22d1a68e902
--- a/src/core/types/state.ts
+++ b/src/core/types/state.ts
@@ -1,6 +1,7 @@
 import type { VersionedEnvelopeBase } from "./schema.js";
 import { SCHEMA_VERSION } from "./schema.js";
 import type { CancellationReason } from "./runtime.js";
+import type { LongRunningTaskEntityV1 } from "./agents.js";
 
 export type AppId = string & { readonly __brand: "AppId" };
 export type SessionId = string & { readonly __brand: "SessionId" };
@@ -174,6 +175,7 @@
   updatedAtMonoMs: number;
   activeSessionId?: SessionId;
   sessions: Record<string, PersistedSessionStateV1>;
+  tasks?: Record<string, LongRunningTaskEntityV1>;
 };
 
 export type StateSnapshotV1 = VersionedEnvelopeBase & {
diff --git a/tests/phase11-agents.test.ts b/tests/phase11-agents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4c5fa4926796b8fc3fe3c97689bcc47c3ad4bc
--- /dev/null
+++ b/tests/phase11-agents.test.ts
@@ -0,0 +1,116 @@
+import { describe, expect, test } from "bun:test";
+import { availableCapability, unavailableCapability } from "../src/core/types/host.js";
+import { TestClock } from "../src/core/runtime/clock.js";
+import { createMonotonicIdSource } from "../src/core/runtime/ids.js";
+import { RuntimeKernel } from "../src/core/runtime/kernel.js";
+import { EventBus } from "../src/core/events/bus.js";
+import { AgentManager, createBuiltInAgentId } from "../src/core/agents/manager.js";
+import type { AgentDefinition } from "../src/core/agents/types.js";
+import { suppressPromptSuggestion } from "../src/core/agents/builtins/promptSuggestion.js";
+import { parseMagicDocHeader, renderMagicDocsTemplate } from "../src/core/agents/builtins/magicDocs.js";
+import { filterHostCapabilitiesForWorker } from "../src/core/runtime/worker.js";
+import { decodeDurableTasksDocument, encodeDurableTasksDocument } from "../src/core/agents/tasks.js";
+
+describe("Phase 11: background agents + long-running tasks", () => {
+  test("prompt suggestion suppression heuristics are stable", () => {
+    expect(suppressPromptSuggestion("")).toEqual({ suppressed: true, reason: "empty" });
+    expect(suppressPromptSuggestion("done")).toEqual({ suppressed: true, reason: "done" });
+    expect(suppressPromptSuggestion("**formatting**")).toEqual({ suppressed: true, reason: "formatting" });
+    expect(suppressPromptSuggestion("We hit the context limit.")).toEqual({ suppressed: true, reason: "context_limit_error" });
+    expect(suppressPromptSuggestion("Next: run tests and ship")).toEqual({ suppressed: false });
+  });
+
+  test("magic docs parsing and template rendering match legacy behavior", () => {
+    const contents = `# MAGIC DOC: My Doc\n\n*Keep it short*\n\nrest`;
+    expect(parseMagicDocHeader(contents)).toEqual({ title: "My Doc", instructions: "Keep it short" });
+
+    const contents2 = `# magic doc: Title Only\n\nrest`;
+    expect(parseMagicDocHeader(contents2)).toEqual({ title: "Title Only" });
+
+    expect(renderMagicDocsTemplate("Hello {{name}} {{name}}", { name: "World" })).toBe("Hello World World");
+  });
+
+  test("agent manager cancels background agents on host backgrounded", async () => {
+    const clock = new TestClock(0);
+    const idSource = createMonotonicIdSource();
+
+    const host = {
+      clock: availableCapability({ nowMs: () => clock.nowMs() }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: unavailableCapability({ kind: "not-provided" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: unavailableCapability({ kind: "not-provided" }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const runtime = new RuntimeKernel({ clock, idSource });
+    const bus = new EventBus({ idSource, clock });
+    const mgr = new AgentManager({ host, idSource, clock, runtime, bus });
+
+    const agentId = createBuiltInAgentId("test_background");
+    const def: AgentDefinition = {
+      id: agentId,
+      name: "Test background agent",
+      kind: "background",
+      budget: { timeoutMs: 1_000, priority: "low" },
+      run: async (ctx) => {
+        await ctx.task.yield("low");
+        return { kind: "completed" };
+      }
+    };
+    mgr.register(def);
+
+    await mgr.startAgent(agentId);
+    await mgr.handleHostEvent({ type: "host/backgrounded" });
+    await runtime.getScheduler().runUntilIdle();
+
+    const summary = mgr.getAgent(agentId);
+    expect(summary?.state).toBe("cancelled");
+  });
+
+  test("worker capability filtering never exposes secrets/ipc", () => {
+    const host = {
+      clock: availableCapability({ nowMs: () => 1 }),
+      random: unavailableCapability({ kind: "not-provided" }),
+      crypto: unavailableCapability({ kind: "not-provided" }),
+      secrets: availableCapability({ getSecret: async () => "x" }),
+      storage: unavailableCapability({ kind: "not-provided" }),
+      filesystem: unavailableCapability({ kind: "not-provided" }),
+      network: unavailableCapability({ kind: "not-provided" }),
+      lifecycle: unavailableCapability({ kind: "not-provided" }),
+      background: unavailableCapability({ kind: "not-provided" }),
+      fileTransfer: unavailableCapability({ kind: "not-provided" }),
+      shell: unavailableCapability({ kind: "not-provided" }),
+      localEndpoint: unavailableCapability({ kind: "not-provided" }),
+      ipc: availableCapability({ send: async () => {}, onMessage: () => () => {} }),
+      process: unavailableCapability({ kind: "not-provided" }),
+      clipboard: unavailableCapability({ kind: "not-provided" }),
+      notifications: unavailableCapability({ kind: "not-provided" }),
+      haptics: unavailableCapability({ kind: "not-provided" })
+    };
+
+    const filtered = filterHostCapabilitiesForWorker(host, ["clock", "secrets", "ipc"]);
+    expect(filtered.clock.kind).toBe("available");
+    expect(filtered.secrets.kind).toBe("unavailable");
+    expect(filtered.ipc.kind).toBe("unavailable");
+  });
+
+  test("durable task document is stable via canonical JSON and decodes", () => {
+    const encoded = encodeDurableTasksDocument({ schemaVersion: 1, tasks: { t1: { schemaVersion: 1, id: "t1", scope: "app", createdAtMonoMs: 1, updatedAtMonoMs: 2 } } });
+    const decoded = decodeDurableTasksDocument(encoded);
+    expect(decoded.schemaVersion).toBe(1);
+    expect(decoded.tasks.t1?.id).toBe("t1");
+  });
+});
+

